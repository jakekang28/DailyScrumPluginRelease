// node_modules/tslib/tslib.es6.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@supabase/functions-js/dist/module/helper.js
var resolveFetch = (customFetch) => {
  if (customFetch) {
    return (...args) => customFetch(...args);
  }
  return (...args) => fetch(...args);
};

// node_modules/@supabase/functions-js/dist/module/types.js
var FunctionsError = class extends Error {
  constructor(message, name = "FunctionsError", context) {
    super(message);
    this.name = name;
    this.context = context;
  }
};
var FunctionsFetchError = class extends FunctionsError {
  constructor(context) {
    super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
  }
};
var FunctionsRelayError = class extends FunctionsError {
  constructor(context) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
  }
};
var FunctionsHttpError = class extends FunctionsError {
  constructor(context) {
    super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
  }
};
var FunctionRegion;
(function(FunctionRegion2) {
  FunctionRegion2["Any"] = "any";
  FunctionRegion2["ApNortheast1"] = "ap-northeast-1";
  FunctionRegion2["ApNortheast2"] = "ap-northeast-2";
  FunctionRegion2["ApSouth1"] = "ap-south-1";
  FunctionRegion2["ApSoutheast1"] = "ap-southeast-1";
  FunctionRegion2["ApSoutheast2"] = "ap-southeast-2";
  FunctionRegion2["CaCentral1"] = "ca-central-1";
  FunctionRegion2["EuCentral1"] = "eu-central-1";
  FunctionRegion2["EuWest1"] = "eu-west-1";
  FunctionRegion2["EuWest2"] = "eu-west-2";
  FunctionRegion2["EuWest3"] = "eu-west-3";
  FunctionRegion2["SaEast1"] = "sa-east-1";
  FunctionRegion2["UsEast1"] = "us-east-1";
  FunctionRegion2["UsWest1"] = "us-west-1";
  FunctionRegion2["UsWest2"] = "us-west-2";
})(FunctionRegion || (FunctionRegion = {}));

// node_modules/@supabase/functions-js/dist/module/FunctionsClient.js
var FunctionsClient = class {
  /**
   * Creates a new Functions client bound to an Edge Functions URL.
   *
   * @example
   * ```ts
   * import { FunctionsClient, FunctionRegion } from '@supabase/functions-js'
   *
   * const functions = new FunctionsClient('https://xyzcompany.supabase.co/functions/v1', {
   *   headers: { apikey: 'public-anon-key' },
   *   region: FunctionRegion.UsEast1,
   * })
   * ```
   */
  constructor(url, { headers = {}, customFetch, region = FunctionRegion.Any } = {}) {
    this.url = url;
    this.headers = headers;
    this.region = region;
    this.fetch = resolveFetch(customFetch);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   * @example
   * ```ts
   * functions.setAuth(session.access_token)
   * ```
   */
  setAuth(token) {
    this.headers.Authorization = `Bearer ${token}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   * @example
   * ```ts
   * const { data, error } = await functions.invoke('hello-world', {
   *   body: { name: 'Ada' },
   * })
   * ```
   */
  invoke(functionName_1) {
    return __awaiter(this, arguments, void 0, function* (functionName, options = {}) {
      var _a;
      let timeoutId;
      let timeoutController;
      try {
        const { headers, method, body: functionArgs, signal, timeout } = options;
        let _headers = {};
        let { region } = options;
        if (!region) {
          region = this.region;
        }
        const url = new URL(`${this.url}/${functionName}`);
        if (region && region !== "any") {
          _headers["x-region"] = region;
          url.searchParams.set("forceFunctionRegion", region);
        }
        let body;
        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers)) {
          if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
            _headers["Content-Type"] = "application/octet-stream";
            body = functionArgs;
          } else if (typeof functionArgs === "string") {
            _headers["Content-Type"] = "text/plain";
            body = functionArgs;
          } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) {
            body = functionArgs;
          } else {
            _headers["Content-Type"] = "application/json";
            body = JSON.stringify(functionArgs);
          }
        } else {
          if (functionArgs && typeof functionArgs !== "string" && !(typeof Blob !== "undefined" && functionArgs instanceof Blob) && !(functionArgs instanceof ArrayBuffer) && !(typeof FormData !== "undefined" && functionArgs instanceof FormData)) {
            body = JSON.stringify(functionArgs);
          } else {
            body = functionArgs;
          }
        }
        let effectiveSignal = signal;
        if (timeout) {
          timeoutController = new AbortController();
          timeoutId = setTimeout(() => timeoutController.abort(), timeout);
          if (signal) {
            effectiveSignal = timeoutController.signal;
            signal.addEventListener("abort", () => timeoutController.abort());
          } else {
            effectiveSignal = timeoutController.signal;
          }
        }
        const response = yield this.fetch(url.toString(), {
          method: method || "POST",
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
          body,
          signal: effectiveSignal
        }).catch((fetchError) => {
          throw new FunctionsFetchError(fetchError);
        });
        const isRelayError = response.headers.get("x-relay-error");
        if (isRelayError && isRelayError === "true") {
          throw new FunctionsRelayError(response);
        }
        if (!response.ok) {
          throw new FunctionsHttpError(response);
        }
        let responseType = ((_a = response.headers.get("Content-Type")) !== null && _a !== void 0 ? _a : "text/plain").split(";")[0].trim();
        let data;
        if (responseType === "application/json") {
          data = yield response.json();
        } else if (responseType === "application/octet-stream" || responseType === "application/pdf") {
          data = yield response.blob();
        } else if (responseType === "text/event-stream") {
          data = response;
        } else if (responseType === "multipart/form-data") {
          data = yield response.formData();
        } else {
          data = yield response.text();
        }
        return { data, error: null, response };
      } catch (error) {
        return {
          data: null,
          error,
          response: error instanceof FunctionsHttpError || error instanceof FunctionsRelayError ? error.context : void 0
        };
      } finally {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
      }
    });
  }
};

// node_modules/@supabase/postgrest-js/dist/index.mjs
var PostgrestError = class extends Error {
  /**
  * @example
  * ```ts
  * import PostgrestError from '@supabase/postgrest-js'
  *
  * throw new PostgrestError({
  *   message: 'Row level security prevented the request',
  *   details: 'RLS denied the insert',
  *   hint: 'Check your policies',
  *   code: 'PGRST301',
  * })
  * ```
  */
  constructor(context) {
    super(context.message);
    this.name = "PostgrestError";
    this.details = context.details;
    this.hint = context.hint;
    this.code = context.code;
  }
};
var PostgrestBuilder = class {
  /**
  * Creates a builder configured for a specific PostgREST request.
  *
  * @example
  * ```ts
  * import PostgrestQueryBuilder from '@supabase/postgrest-js'
  *
  * const builder = new PostgrestQueryBuilder(
  *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),
  *   { headers: new Headers({ apikey: 'public-anon-key' }) }
  * )
  * ```
  */
  constructor(builder) {
    var _builder$shouldThrowO, _builder$isMaybeSingl;
    this.shouldThrowOnError = false;
    this.method = builder.method;
    this.url = builder.url;
    this.headers = new Headers(builder.headers);
    this.schema = builder.schema;
    this.body = builder.body;
    this.shouldThrowOnError = (_builder$shouldThrowO = builder.shouldThrowOnError) !== null && _builder$shouldThrowO !== void 0 ? _builder$shouldThrowO : false;
    this.signal = builder.signal;
    this.isMaybeSingle = (_builder$isMaybeSingl = builder.isMaybeSingle) !== null && _builder$isMaybeSingl !== void 0 ? _builder$isMaybeSingl : false;
    if (builder.fetch) this.fetch = builder.fetch;
    else this.fetch = fetch;
  }
  /**
  * If there's an error with the query, throwOnError will reject the promise by
  * throwing the error instead of returning it as part of a successful response.
  *
  * {@link https://github.com/supabase/supabase-js/issues/92}
  */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
  * Set an HTTP header for the request.
  */
  setHeader(name, value) {
    this.headers = new Headers(this.headers);
    this.headers.set(name, value);
    return this;
  }
  then(onfulfilled, onrejected) {
    var _this = this;
    if (this.schema === void 0) {
    } else if (["GET", "HEAD"].includes(this.method)) this.headers.set("Accept-Profile", this.schema);
    else this.headers.set("Content-Profile", this.schema);
    if (this.method !== "GET" && this.method !== "HEAD") this.headers.set("Content-Type", "application/json");
    const _fetch = this.fetch;
    let res = _fetch(this.url.toString(), {
      method: this.method,
      headers: this.headers,
      body: JSON.stringify(this.body),
      signal: this.signal
    }).then(async (res$1) => {
      let error = null;
      let data = null;
      let count = null;
      let status = res$1.status;
      let statusText = res$1.statusText;
      if (res$1.ok) {
        var _this$headers$get2, _res$headers$get;
        if (_this.method !== "HEAD") {
          var _this$headers$get;
          const body = await res$1.text();
          if (body === "") {
          } else if (_this.headers.get("Accept") === "text/csv") data = body;
          else if (_this.headers.get("Accept") && ((_this$headers$get = _this.headers.get("Accept")) === null || _this$headers$get === void 0 ? void 0 : _this$headers$get.includes("application/vnd.pgrst.plan+text"))) data = body;
          else data = JSON.parse(body);
        }
        const countHeader = (_this$headers$get2 = _this.headers.get("Prefer")) === null || _this$headers$get2 === void 0 ? void 0 : _this$headers$get2.match(/count=(exact|planned|estimated)/);
        const contentRange = (_res$headers$get = res$1.headers.get("content-range")) === null || _res$headers$get === void 0 ? void 0 : _res$headers$get.split("/");
        if (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);
        if (_this.isMaybeSingle && _this.method === "GET" && Array.isArray(data)) if (data.length > 1) {
          error = {
            code: "PGRST116",
            details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
            hint: null,
            message: "JSON object requested, multiple (or no) rows returned"
          };
          data = null;
          count = null;
          status = 406;
          statusText = "Not Acceptable";
        } else if (data.length === 1) data = data[0];
        else data = null;
      } else {
        var _error$details;
        const body = await res$1.text();
        try {
          error = JSON.parse(body);
          if (Array.isArray(error) && res$1.status === 404) {
            data = [];
            error = null;
            status = 200;
            statusText = "OK";
          }
        } catch (_unused) {
          if (res$1.status === 404 && body === "") {
            status = 204;
            statusText = "No Content";
          } else error = { message: body };
        }
        if (error && _this.isMaybeSingle && (error === null || error === void 0 || (_error$details = error.details) === null || _error$details === void 0 ? void 0 : _error$details.includes("0 rows"))) {
          error = null;
          status = 200;
          statusText = "OK";
        }
        if (error && _this.shouldThrowOnError) throw new PostgrestError(error);
      }
      return {
        error,
        data,
        count,
        status,
        statusText
      };
    });
    if (!this.shouldThrowOnError) res = res.catch((fetchError) => {
      var _fetchError$name2;
      let errorDetails = "";
      const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;
      if (cause) {
        var _cause$message, _cause$code, _fetchError$name, _cause$name;
        const causeMessage = (_cause$message = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _cause$message !== void 0 ? _cause$message : "";
        const causeCode = (_cause$code = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _cause$code !== void 0 ? _cause$code : "";
        errorDetails = `${(_fetchError$name = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name !== void 0 ? _fetchError$name : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;
        errorDetails += `

Caused by: ${(_cause$name = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _cause$name !== void 0 ? _cause$name : "Error"}: ${causeMessage}`;
        if (causeCode) errorDetails += ` (${causeCode})`;
        if (cause === null || cause === void 0 ? void 0 : cause.stack) errorDetails += `
${cause.stack}`;
      } else {
        var _fetchError$stack;
        errorDetails = (_fetchError$stack = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _fetchError$stack !== void 0 ? _fetchError$stack : "";
      }
      return {
        error: {
          message: `${(_fetchError$name2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name2 !== void 0 ? _fetchError$name2 : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
          details: errorDetails,
          hint: "",
          code: ""
        },
        data: null,
        count: null,
        status: 0,
        statusText: ""
      };
    });
    return res.then(onfulfilled, onrejected);
  }
  /**
  * Override the type of the returned `data`.
  *
  * @typeParam NewResult - The new result type to override with
  * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
  */
  returns() {
    return this;
  }
  /**
  * Override the type of the returned `data` field in the response.
  *
  * @typeParam NewResult - The new type to cast the response data to
  * @typeParam Options - Optional type configuration (defaults to { merge: true })
  * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)
  * @example
  * ```typescript
  * // Merge with existing types (default behavior)
  * const query = supabase
  *   .from('users')
  *   .select()
  *   .overrideTypes<{ custom_field: string }>()
  *
  * // Replace existing types completely
  * const replaceQuery = supabase
  *   .from('users')
  *   .select()
  *   .overrideTypes<{ id: number; name: string }, { merge: false }>()
  * ```
  * @returns A PostgrestBuilder instance with the new type
  */
  overrideTypes() {
    return this;
  }
};
var PostgrestTransformBuilder = class extends PostgrestBuilder {
  /**
  * Perform a SELECT on the query result.
  *
  * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
  * return modified rows. By calling this method, modified rows are returned in
  * `data`.
  *
  * @param columns - The columns to retrieve, separated by commas
  */
  select(columns) {
    let quoted = false;
    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
      if (/\s/.test(c) && !quoted) return "";
      if (c === '"') quoted = !quoted;
      return c;
    }).join("");
    this.url.searchParams.set("select", cleanedColumns);
    this.headers.append("Prefer", "return=representation");
    return this;
  }
  /**
  * Order the query result by `column`.
  *
  * You can call this method multiple times to order by multiple columns.
  *
  * You can order referenced tables, but it only affects the ordering of the
  * parent table if you use `!inner` in the query.
  *
  * @param column - The column to order by
  * @param options - Named parameters
  * @param options.ascending - If `true`, the result will be in ascending order
  * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
  * `null`s appear last.
  * @param options.referencedTable - Set this to order a referenced table by
  * its columns
  * @param options.foreignTable - Deprecated, use `options.referencedTable`
  * instead
  */
  order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
    const key = referencedTable ? `${referencedTable}.order` : "order";
    const existingOrder = this.url.searchParams.get(key);
    this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column}.${ascending ? "asc" : "desc"}${nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
    return this;
  }
  /**
  * Limit the query result by `count`.
  *
  * @param count - The maximum number of rows to return
  * @param options - Named parameters
  * @param options.referencedTable - Set this to limit rows of referenced
  * tables instead of the parent table
  * @param options.foreignTable - Deprecated, use `options.referencedTable`
  * instead
  */
  limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
    const key = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
    this.url.searchParams.set(key, `${count}`);
    return this;
  }
  /**
  * Limit the query result by starting at an offset `from` and ending at the offset `to`.
  * Only records within this range are returned.
  * This respects the query order and if there is no order clause the range could behave unexpectedly.
  * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
  * and fourth rows of the query.
  *
  * @param from - The starting index from which to limit the result
  * @param to - The last index to which to limit the result
  * @param options - Named parameters
  * @param options.referencedTable - Set this to limit rows of referenced
  * tables instead of the parent table
  * @param options.foreignTable - Deprecated, use `options.referencedTable`
  * instead
  */
  range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {
    const keyOffset = typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`;
    const keyLimit = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
    this.url.searchParams.set(keyOffset, `${from}`);
    this.url.searchParams.set(keyLimit, `${to - from + 1}`);
    return this;
  }
  /**
  * Set the AbortSignal for the fetch request.
  *
  * @param signal - The AbortSignal to use for the fetch request
  */
  abortSignal(signal) {
    this.signal = signal;
    return this;
  }
  /**
  * Return `data` as a single object instead of an array of objects.
  *
  * Query result must be one row (e.g. using `.limit(1)`), otherwise this
  * returns an error.
  */
  single() {
    this.headers.set("Accept", "application/vnd.pgrst.object+json");
    return this;
  }
  /**
  * Return `data` as a single object instead of an array of objects.
  *
  * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
  * this returns an error.
  */
  maybeSingle() {
    if (this.method === "GET") this.headers.set("Accept", "application/json");
    else this.headers.set("Accept", "application/vnd.pgrst.object+json");
    this.isMaybeSingle = true;
    return this;
  }
  /**
  * Return `data` as a string in CSV format.
  */
  csv() {
    this.headers.set("Accept", "text/csv");
    return this;
  }
  /**
  * Return `data` as an object in [GeoJSON](https://geojson.org) format.
  */
  geojson() {
    this.headers.set("Accept", "application/geo+json");
    return this;
  }
  /**
  * Return `data` as the EXPLAIN plan for the query.
  *
  * You need to enable the
  * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
  * setting before using this method.
  *
  * @param options - Named parameters
  *
  * @param options.analyze - If `true`, the query will be executed and the
  * actual run time will be returned
  *
  * @param options.verbose - If `true`, the query identifier will be returned
  * and `data` will include the output columns of the query
  *
  * @param options.settings - If `true`, include information on configuration
  * parameters that affect query planning
  *
  * @param options.buffers - If `true`, include information on buffer usage
  *
  * @param options.wal - If `true`, include information on WAL record generation
  *
  * @param options.format - The format of the output, can be `"text"` (default)
  * or `"json"`
  */
  explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
    var _this$headers$get;
    const options = [
      analyze ? "analyze" : null,
      verbose ? "verbose" : null,
      settings ? "settings" : null,
      buffers ? "buffers" : null,
      wal ? "wal" : null
    ].filter(Boolean).join("|");
    const forMediatype = (_this$headers$get = this.headers.get("Accept")) !== null && _this$headers$get !== void 0 ? _this$headers$get : "application/json";
    this.headers.set("Accept", `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`);
    if (format === "json") return this;
    else return this;
  }
  /**
  * Rollback the query.
  *
  * `data` will still be returned, but the query is not committed.
  */
  rollback() {
    this.headers.append("Prefer", "tx=rollback");
    return this;
  }
  /**
  * Override the type of the returned `data`.
  *
  * @typeParam NewResult - The new result type to override with
  * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
  */
  returns() {
    return this;
  }
  /**
  * Set the maximum number of rows that can be affected by the query.
  * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.
  *
  * @param value - The maximum number of rows that can be affected
  */
  maxAffected(value) {
    this.headers.append("Prefer", "handling=strict");
    this.headers.append("Prefer", `max-affected=${value}`);
    return this;
  }
};
var PostgrestReservedCharsRegexp = /* @__PURE__ */ new RegExp("[,()]");
var PostgrestFilterBuilder = class extends PostgrestTransformBuilder {
  /**
  * Match only rows where `column` is equal to `value`.
  *
  * To check if the value of `column` is NULL, you should use `.is()` instead.
  *
  * @param column - The column to filter on
  * @param value - The value to filter with
  */
  eq(column, value) {
    this.url.searchParams.append(column, `eq.${value}`);
    return this;
  }
  /**
  * Match only rows where `column` is not equal to `value`.
  *
  * @param column - The column to filter on
  * @param value - The value to filter with
  */
  neq(column, value) {
    this.url.searchParams.append(column, `neq.${value}`);
    return this;
  }
  /**
  * Match only rows where `column` is greater than `value`.
  *
  * @param column - The column to filter on
  * @param value - The value to filter with
  */
  gt(column, value) {
    this.url.searchParams.append(column, `gt.${value}`);
    return this;
  }
  /**
  * Match only rows where `column` is greater than or equal to `value`.
  *
  * @param column - The column to filter on
  * @param value - The value to filter with
  */
  gte(column, value) {
    this.url.searchParams.append(column, `gte.${value}`);
    return this;
  }
  /**
  * Match only rows where `column` is less than `value`.
  *
  * @param column - The column to filter on
  * @param value - The value to filter with
  */
  lt(column, value) {
    this.url.searchParams.append(column, `lt.${value}`);
    return this;
  }
  /**
  * Match only rows where `column` is less than or equal to `value`.
  *
  * @param column - The column to filter on
  * @param value - The value to filter with
  */
  lte(column, value) {
    this.url.searchParams.append(column, `lte.${value}`);
    return this;
  }
  /**
  * Match only rows where `column` matches `pattern` case-sensitively.
  *
  * @param column - The column to filter on
  * @param pattern - The pattern to match with
  */
  like(column, pattern) {
    this.url.searchParams.append(column, `like.${pattern}`);
    return this;
  }
  /**
  * Match only rows where `column` matches all of `patterns` case-sensitively.
  *
  * @param column - The column to filter on
  * @param patterns - The patterns to match with
  */
  likeAllOf(column, patterns) {
    this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
    return this;
  }
  /**
  * Match only rows where `column` matches any of `patterns` case-sensitively.
  *
  * @param column - The column to filter on
  * @param patterns - The patterns to match with
  */
  likeAnyOf(column, patterns) {
    this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
    return this;
  }
  /**
  * Match only rows where `column` matches `pattern` case-insensitively.
  *
  * @param column - The column to filter on
  * @param pattern - The pattern to match with
  */
  ilike(column, pattern) {
    this.url.searchParams.append(column, `ilike.${pattern}`);
    return this;
  }
  /**
  * Match only rows where `column` matches all of `patterns` case-insensitively.
  *
  * @param column - The column to filter on
  * @param patterns - The patterns to match with
  */
  ilikeAllOf(column, patterns) {
    this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
    return this;
  }
  /**
  * Match only rows where `column` matches any of `patterns` case-insensitively.
  *
  * @param column - The column to filter on
  * @param patterns - The patterns to match with
  */
  ilikeAnyOf(column, patterns) {
    this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
    return this;
  }
  /**
  * Match only rows where `column` matches the PostgreSQL regex `pattern`
  * case-sensitively (using the `~` operator).
  *
  * @param column - The column to filter on
  * @param pattern - The PostgreSQL regular expression pattern to match with
  */
  regexMatch(column, pattern) {
    this.url.searchParams.append(column, `match.${pattern}`);
    return this;
  }
  /**
  * Match only rows where `column` matches the PostgreSQL regex `pattern`
  * case-insensitively (using the `~*` operator).
  *
  * @param column - The column to filter on
  * @param pattern - The PostgreSQL regular expression pattern to match with
  */
  regexIMatch(column, pattern) {
    this.url.searchParams.append(column, `imatch.${pattern}`);
    return this;
  }
  /**
  * Match only rows where `column` IS `value`.
  *
  * For non-boolean columns, this is only relevant for checking if the value of
  * `column` is NULL by setting `value` to `null`.
  *
  * For boolean columns, you can also set `value` to `true` or `false` and it
  * will behave the same way as `.eq()`.
  *
  * @param column - The column to filter on
  * @param value - The value to filter with
  */
  is(column, value) {
    this.url.searchParams.append(column, `is.${value}`);
    return this;
  }
  /**
  * Match only rows where `column` IS DISTINCT FROM `value`.
  *
  * Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values
  * are considered equal (not distinct), and comparing `NULL` with any non-NULL
  * value returns true (distinct).
  *
  * @param column - The column to filter on
  * @param value - The value to filter with
  */
  isDistinct(column, value) {
    this.url.searchParams.append(column, `isdistinct.${value}`);
    return this;
  }
  /**
  * Match only rows where `column` is included in the `values` array.
  *
  * @param column - The column to filter on
  * @param values - The values array to filter with
  */
  in(column, values) {
    const cleanedValues = Array.from(new Set(values)).map((s) => {
      if (typeof s === "string" && PostgrestReservedCharsRegexp.test(s)) return `"${s}"`;
      else return `${s}`;
    }).join(",");
    this.url.searchParams.append(column, `in.(${cleanedValues})`);
    return this;
  }
  /**
  * Match only rows where `column` is NOT included in the `values` array.
  *
  * @param column - The column to filter on
  * @param values - The values array to filter with
  */
  notIn(column, values) {
    const cleanedValues = Array.from(new Set(values)).map((s) => {
      if (typeof s === "string" && PostgrestReservedCharsRegexp.test(s)) return `"${s}"`;
      else return `${s}`;
    }).join(",");
    this.url.searchParams.append(column, `not.in.(${cleanedValues})`);
    return this;
  }
  /**
  * Only relevant for jsonb, array, and range columns. Match only rows where
  * `column` contains every element appearing in `value`.
  *
  * @param column - The jsonb, array, or range column to filter on
  * @param value - The jsonb, array, or range value to filter with
  */
  contains(column, value) {
    if (typeof value === "string") this.url.searchParams.append(column, `cs.${value}`);
    else if (Array.isArray(value)) this.url.searchParams.append(column, `cs.{${value.join(",")}}`);
    else this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
    return this;
  }
  /**
  * Only relevant for jsonb, array, and range columns. Match only rows where
  * every element appearing in `column` is contained by `value`.
  *
  * @param column - The jsonb, array, or range column to filter on
  * @param value - The jsonb, array, or range value to filter with
  */
  containedBy(column, value) {
    if (typeof value === "string") this.url.searchParams.append(column, `cd.${value}`);
    else if (Array.isArray(value)) this.url.searchParams.append(column, `cd.{${value.join(",")}}`);
    else this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
    return this;
  }
  /**
  * Only relevant for range columns. Match only rows where every element in
  * `column` is greater than any element in `range`.
  *
  * @param column - The range column to filter on
  * @param range - The range to filter with
  */
  rangeGt(column, range) {
    this.url.searchParams.append(column, `sr.${range}`);
    return this;
  }
  /**
  * Only relevant for range columns. Match only rows where every element in
  * `column` is either contained in `range` or greater than any element in
  * `range`.
  *
  * @param column - The range column to filter on
  * @param range - The range to filter with
  */
  rangeGte(column, range) {
    this.url.searchParams.append(column, `nxl.${range}`);
    return this;
  }
  /**
  * Only relevant for range columns. Match only rows where every element in
  * `column` is less than any element in `range`.
  *
  * @param column - The range column to filter on
  * @param range - The range to filter with
  */
  rangeLt(column, range) {
    this.url.searchParams.append(column, `sl.${range}`);
    return this;
  }
  /**
  * Only relevant for range columns. Match only rows where every element in
  * `column` is either contained in `range` or less than any element in
  * `range`.
  *
  * @param column - The range column to filter on
  * @param range - The range to filter with
  */
  rangeLte(column, range) {
    this.url.searchParams.append(column, `nxr.${range}`);
    return this;
  }
  /**
  * Only relevant for range columns. Match only rows where `column` is
  * mutually exclusive to `range` and there can be no element between the two
  * ranges.
  *
  * @param column - The range column to filter on
  * @param range - The range to filter with
  */
  rangeAdjacent(column, range) {
    this.url.searchParams.append(column, `adj.${range}`);
    return this;
  }
  /**
  * Only relevant for array and range columns. Match only rows where
  * `column` and `value` have an element in common.
  *
  * @param column - The array or range column to filter on
  * @param value - The array or range value to filter with
  */
  overlaps(column, value) {
    if (typeof value === "string") this.url.searchParams.append(column, `ov.${value}`);
    else this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
    return this;
  }
  /**
  * Only relevant for text and tsvector columns. Match only rows where
  * `column` matches the query string in `query`.
  *
  * @param column - The text or tsvector column to filter on
  * @param query - The query text to match with
  * @param options - Named parameters
  * @param options.config - The text search configuration to use
  * @param options.type - Change how the `query` text is interpreted
  */
  textSearch(column, query, { config, type } = {}) {
    let typePart = "";
    if (type === "plain") typePart = "pl";
    else if (type === "phrase") typePart = "ph";
    else if (type === "websearch") typePart = "w";
    const configPart = config === void 0 ? "" : `(${config})`;
    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
    return this;
  }
  /**
  * Match only rows where each column in `query` keys is equal to its
  * associated value. Shorthand for multiple `.eq()`s.
  *
  * @param query - The object to filter with, with column names as keys mapped
  * to their filter values
  */
  match(query) {
    Object.entries(query).forEach(([column, value]) => {
      this.url.searchParams.append(column, `eq.${value}`);
    });
    return this;
  }
  /**
  * Match only rows which doesn't satisfy the filter.
  *
  * Unlike most filters, `opearator` and `value` are used as-is and need to
  * follow [PostgREST
  * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
  * to make sure they are properly sanitized.
  *
  * @param column - The column to filter on
  * @param operator - The operator to be negated to filter with, following
  * PostgREST syntax
  * @param value - The value to filter with, following PostgREST syntax
  */
  not(column, operator, value) {
    this.url.searchParams.append(column, `not.${operator}.${value}`);
    return this;
  }
  /**
  * Match only rows which satisfy at least one of the filters.
  *
  * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
  * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
  * to make sure it's properly sanitized.
  *
  * It's currently not possible to do an `.or()` filter across multiple tables.
  *
  * @param filters - The filters to use, following PostgREST syntax
  * @param options - Named parameters
  * @param options.referencedTable - Set this to filter on referenced tables
  * instead of the parent table
  * @param options.foreignTable - Deprecated, use `referencedTable` instead
  */
  or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
    const key = referencedTable ? `${referencedTable}.or` : "or";
    this.url.searchParams.append(key, `(${filters})`);
    return this;
  }
  /**
  * Match only rows which satisfy the filter. This is an escape hatch - you
  * should use the specific filter methods wherever possible.
  *
  * Unlike most filters, `opearator` and `value` are used as-is and need to
  * follow [PostgREST
  * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
  * to make sure they are properly sanitized.
  *
  * @param column - The column to filter on
  * @param operator - The operator to filter with, following PostgREST syntax
  * @param value - The value to filter with, following PostgREST syntax
  */
  filter(column, operator, value) {
    this.url.searchParams.append(column, `${operator}.${value}`);
    return this;
  }
};
var PostgrestQueryBuilder = class {
  /**
  * Creates a query builder scoped to a Postgres table or view.
  *
  * @example
  * ```ts
  * import PostgrestQueryBuilder from '@supabase/postgrest-js'
  *
  * const query = new PostgrestQueryBuilder(
  *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),
  *   { headers: { apikey: 'public-anon-key' } }
  * )
  * ```
  */
  constructor(url, { headers = {}, schema, fetch: fetch$1 }) {
    this.url = url;
    this.headers = new Headers(headers);
    this.schema = schema;
    this.fetch = fetch$1;
  }
  /**
  * Clone URL and headers to prevent shared state between operations.
  */
  cloneRequestState() {
    return {
      url: new URL(this.url.toString()),
      headers: new Headers(this.headers)
    };
  }
  /**
  * Perform a SELECT query on the table or view.
  *
  * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
  *
  * @param options - Named parameters
  *
  * @param options.head - When set to `true`, `data` will not be returned.
  * Useful if you only need the count.
  *
  * @param options.count - Count algorithm to use to count rows in the table or view.
  *
  * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
  * hood.
  *
  * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
  * statistics under the hood.
  *
  * `"estimated"`: Uses exact count for low numbers and planned count for high
  * numbers.
  *
  * @remarks
  * When using `count` with `.range()` or `.limit()`, the returned `count` is the total number of rows
  * that match your filters, not the number of rows in the current page. Use this to build pagination UI.
  */
  select(columns, options) {
    const { head: head2 = false, count } = options !== null && options !== void 0 ? options : {};
    const method = head2 ? "HEAD" : "GET";
    let quoted = false;
    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
      if (/\s/.test(c) && !quoted) return "";
      if (c === '"') quoted = !quoted;
      return c;
    }).join("");
    const { url, headers } = this.cloneRequestState();
    url.searchParams.set("select", cleanedColumns);
    if (count) headers.append("Prefer", `count=${count}`);
    return new PostgrestFilterBuilder({
      method,
      url,
      headers,
      schema: this.schema,
      fetch: this.fetch
    });
  }
  /**
  * Perform an INSERT into the table or view.
  *
  * By default, inserted rows are not returned. To return it, chain the call
  * with `.select()`.
  *
  * @param values - The values to insert. Pass an object to insert a single row
  * or an array to insert multiple rows.
  *
  * @param options - Named parameters
  *
  * @param options.count - Count algorithm to use to count inserted rows.
  *
  * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
  * hood.
  *
  * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
  * statistics under the hood.
  *
  * `"estimated"`: Uses exact count for low numbers and planned count for high
  * numbers.
  *
  * @param options.defaultToNull - Make missing fields default to `null`.
  * Otherwise, use the default value for the column. Only applies for bulk
  * inserts.
  */
  insert(values, { count, defaultToNull = true } = {}) {
    var _this$fetch;
    const method = "POST";
    const { url, headers } = this.cloneRequestState();
    if (count) headers.append("Prefer", `count=${count}`);
    if (!defaultToNull) headers.append("Prefer", `missing=default`);
    if (Array.isArray(values)) {
      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
      if (columns.length > 0) {
        const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
        url.searchParams.set("columns", uniqueColumns.join(","));
      }
    }
    return new PostgrestFilterBuilder({
      method,
      url,
      headers,
      schema: this.schema,
      body: values,
      fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch
    });
  }
  /**
  * Perform an UPSERT on the table or view. Depending on the column(s) passed
  * to `onConflict`, `.upsert()` allows you to perform the equivalent of
  * `.insert()` if a row with the corresponding `onConflict` columns doesn't
  * exist, or if it does exist, perform an alternative action depending on
  * `ignoreDuplicates`.
  *
  * By default, upserted rows are not returned. To return it, chain the call
  * with `.select()`.
  *
  * @param values - The values to upsert with. Pass an object to upsert a
  * single row or an array to upsert multiple rows.
  *
  * @param options - Named parameters
  *
  * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
  * duplicate rows are determined. Two rows are duplicates if all the
  * `onConflict` columns are equal.
  *
  * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
  * `false`, duplicate rows are merged with existing rows.
  *
  * @param options.count - Count algorithm to use to count upserted rows.
  *
  * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
  * hood.
  *
  * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
  * statistics under the hood.
  *
  * `"estimated"`: Uses exact count for low numbers and planned count for high
  * numbers.
  *
  * @param options.defaultToNull - Make missing fields default to `null`.
  * Otherwise, use the default value for the column. This only applies when
  * inserting new rows, not when merging with existing rows under
  * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
  *
  * @example Upsert a single row using a unique key
  * ```ts
  * // Upserting a single row, overwriting based on the 'username' unique column
  * const { data, error } = await supabase
  *   .from('users')
  *   .upsert({ username: 'supabot' }, { onConflict: 'username' })
  *
  * // Example response:
  * // {
  * //   data: [
  * //     { id: 4, message: 'bar', username: 'supabot' }
  * //   ],
  * //   error: null
  * // }
  * ```
  *
  * @example Upsert with conflict resolution and exact row counting
  * ```ts
  * // Upserting and returning exact count
  * const { data, error, count } = await supabase
  *   .from('users')
  *   .upsert(
  *     {
  *       id: 3,
  *       message: 'foo',
  *       username: 'supabot'
  *     },
  *     {
  *       onConflict: 'username',
  *       count: 'exact'
  *     }
  *   )
  *
  * // Example response:
  * // {
  * //   data: [
  * //     {
  * //       id: 42,
  * //       handle: "saoirse",
  * //       display_name: "Saoirse"
  * //     }
  * //   ],
  * //   count: 1,
  * //   error: null
  * // }
  * ```
  */
  upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
    var _this$fetch2;
    const method = "POST";
    const { url, headers } = this.cloneRequestState();
    headers.append("Prefer", `resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`);
    if (onConflict !== void 0) url.searchParams.set("on_conflict", onConflict);
    if (count) headers.append("Prefer", `count=${count}`);
    if (!defaultToNull) headers.append("Prefer", "missing=default");
    if (Array.isArray(values)) {
      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
      if (columns.length > 0) {
        const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
        url.searchParams.set("columns", uniqueColumns.join(","));
      }
    }
    return new PostgrestFilterBuilder({
      method,
      url,
      headers,
      schema: this.schema,
      body: values,
      fetch: (_this$fetch2 = this.fetch) !== null && _this$fetch2 !== void 0 ? _this$fetch2 : fetch
    });
  }
  /**
  * Perform an UPDATE on the table or view.
  *
  * By default, updated rows are not returned. To return it, chain the call
  * with `.select()` after filters.
  *
  * @param values - The values to update with
  *
  * @param options - Named parameters
  *
  * @param options.count - Count algorithm to use to count updated rows.
  *
  * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
  * hood.
  *
  * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
  * statistics under the hood.
  *
  * `"estimated"`: Uses exact count for low numbers and planned count for high
  * numbers.
  */
  update(values, { count } = {}) {
    var _this$fetch3;
    const method = "PATCH";
    const { url, headers } = this.cloneRequestState();
    if (count) headers.append("Prefer", `count=${count}`);
    return new PostgrestFilterBuilder({
      method,
      url,
      headers,
      schema: this.schema,
      body: values,
      fetch: (_this$fetch3 = this.fetch) !== null && _this$fetch3 !== void 0 ? _this$fetch3 : fetch
    });
  }
  /**
  * Perform a DELETE on the table or view.
  *
  * By default, deleted rows are not returned. To return it, chain the call
  * with `.select()` after filters.
  *
  * @param options - Named parameters
  *
  * @param options.count - Count algorithm to use to count deleted rows.
  *
  * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
  * hood.
  *
  * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
  * statistics under the hood.
  *
  * `"estimated"`: Uses exact count for low numbers and planned count for high
  * numbers.
  */
  delete({ count } = {}) {
    var _this$fetch4;
    const method = "DELETE";
    const { url, headers } = this.cloneRequestState();
    if (count) headers.append("Prefer", `count=${count}`);
    return new PostgrestFilterBuilder({
      method,
      url,
      headers,
      schema: this.schema,
      fetch: (_this$fetch4 = this.fetch) !== null && _this$fetch4 !== void 0 ? _this$fetch4 : fetch
    });
  }
};
var PostgrestClient = class PostgrestClient2 {
  /**
  * Creates a PostgREST client.
  *
  * @param url - URL of the PostgREST endpoint
  * @param options - Named parameters
  * @param options.headers - Custom headers
  * @param options.schema - Postgres schema to switch to
  * @param options.fetch - Custom fetch
  * @example
  * ```ts
  * import PostgrestClient from '@supabase/postgrest-js'
  *
  * const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {
  *   headers: { apikey: 'public-anon-key' },
  *   schema: 'public',
  * })
  * ```
  */
  constructor(url, { headers = {}, schema, fetch: fetch$1 } = {}) {
    this.url = url;
    this.headers = new Headers(headers);
    this.schemaName = schema;
    this.fetch = fetch$1;
  }
  /**
  * Perform a query on a table or a view.
  *
  * @param relation - The table or view name to query
  */
  from(relation) {
    if (!relation || typeof relation !== "string" || relation.trim() === "") throw new Error("Invalid relation name: relation must be a non-empty string.");
    return new PostgrestQueryBuilder(new URL(`${this.url}/${relation}`), {
      headers: new Headers(this.headers),
      schema: this.schemaName,
      fetch: this.fetch
    });
  }
  /**
  * Select a schema to query or perform an function (rpc) call.
  *
  * The schema needs to be on the list of exposed schemas inside Supabase.
  *
  * @param schema - The schema to query
  */
  schema(schema) {
    return new PostgrestClient2(this.url, {
      headers: this.headers,
      schema,
      fetch: this.fetch
    });
  }
  /**
  * Perform a function call.
  *
  * @param fn - The function name to call
  * @param args - The arguments to pass to the function call
  * @param options - Named parameters
  * @param options.head - When set to `true`, `data` will not be returned.
  * Useful if you only need the count.
  * @param options.get - When set to `true`, the function will be called with
  * read-only access mode.
  * @param options.count - Count algorithm to use to count rows returned by the
  * function. Only applicable for [set-returning
  * functions](https://www.postgresql.org/docs/current/functions-srf.html).
  *
  * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
  * hood.
  *
  * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
  * statistics under the hood.
  *
  * `"estimated"`: Uses exact count for low numbers and planned count for high
  * numbers.
  *
  * @example
  * ```ts
  * // For cross-schema functions where type inference fails, use overrideTypes:
  * const { data } = await supabase
  *   .schema('schema_b')
  *   .rpc('function_a', {})
  *   .overrideTypes<{ id: string; user_id: string }[]>()
  * ```
  */
  rpc(fn, args = {}, { head: head2 = false, get: get2 = false, count } = {}) {
    var _this$fetch;
    let method;
    const url = new URL(`${this.url}/rpc/${fn}`);
    let body;
    const _isObject = (v) => v !== null && typeof v === "object" && (!Array.isArray(v) || v.some(_isObject));
    const _hasObjectArg = head2 && Object.values(args).some(_isObject);
    if (_hasObjectArg) {
      method = "POST";
      body = args;
    } else if (head2 || get2) {
      method = head2 ? "HEAD" : "GET";
      Object.entries(args).filter(([_, value]) => value !== void 0).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(",")}}` : `${value}`]).forEach(([name, value]) => {
        url.searchParams.append(name, value);
      });
    } else {
      method = "POST";
      body = args;
    }
    const headers = new Headers(this.headers);
    if (_hasObjectArg) headers.set("Prefer", count ? `count=${count},return=minimal` : "return=minimal");
    else if (count) headers.set("Prefer", `count=${count}`);
    return new PostgrestFilterBuilder({
      method,
      url,
      headers,
      schema: this.schemaName,
      body,
      fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch
    });
  }
};

// node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js
var WebSocketFactory = class {
  /**
   * Static-only utility  prevent instantiation.
   */
  constructor() {
  }
  static detectEnvironment() {
    var _a;
    if (typeof WebSocket !== "undefined") {
      return { type: "native", constructor: WebSocket };
    }
    if (typeof globalThis !== "undefined" && typeof globalThis.WebSocket !== "undefined") {
      return { type: "native", constructor: globalThis.WebSocket };
    }
    if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
      return { type: "native", constructor: global.WebSocket };
    }
    if (typeof globalThis !== "undefined" && typeof globalThis.WebSocketPair !== "undefined" && typeof globalThis.WebSocket === "undefined") {
      return {
        type: "cloudflare",
        error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
        workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
      };
    }
    if (typeof globalThis !== "undefined" && globalThis.EdgeRuntime || typeof navigator !== "undefined" && ((_a = navigator.userAgent) === null || _a === void 0 ? void 0 : _a.includes("Vercel-Edge"))) {
      return {
        type: "unsupported",
        error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
        workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
      };
    }
    const _process = globalThis["process"];
    if (_process) {
      const processVersions = _process["versions"];
      if (processVersions && processVersions["node"]) {
        const versionString = processVersions["node"];
        const nodeVersion = parseInt(versionString.replace(/^v/, "").split(".")[0]);
        if (nodeVersion >= 22) {
          if (typeof globalThis.WebSocket !== "undefined") {
            return { type: "native", constructor: globalThis.WebSocket };
          }
          return {
            type: "unsupported",
            error: `Node.js ${nodeVersion} detected but native WebSocket not found.`,
            workaround: "Provide a WebSocket implementation via the transport option."
          };
        }
        return {
          type: "unsupported",
          error: `Node.js ${nodeVersion} detected without native WebSocket support.`,
          workaround: 'For Node.js < 22, install "ws" package and provide it via the transport option:\nimport ws from "ws"\nnew RealtimeClient(url, { transport: ws })'
        };
      }
    }
    return {
      type: "unsupported",
      error: "Unknown JavaScript runtime without WebSocket support.",
      workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
    };
  }
  /**
   * Returns the best available WebSocket constructor for the current runtime.
   *
   * @example
   * ```ts
   * const WS = WebSocketFactory.getWebSocketConstructor()
   * const socket = new WS('wss://realtime.supabase.co/socket')
   * ```
   */
  static getWebSocketConstructor() {
    const env = this.detectEnvironment();
    if (env.constructor) {
      return env.constructor;
    }
    let errorMessage2 = env.error || "WebSocket not supported in this environment.";
    if (env.workaround) {
      errorMessage2 += `

Suggested solution: ${env.workaround}`;
    }
    throw new Error(errorMessage2);
  }
  /**
   * Creates a WebSocket using the detected constructor.
   *
   * @example
   * ```ts
   * const socket = WebSocketFactory.createWebSocket('wss://realtime.supabase.co/socket')
   * ```
   */
  static createWebSocket(url, protocols) {
    const WS = this.getWebSocketConstructor();
    return new WS(url, protocols);
  }
  /**
   * Detects whether the runtime can establish WebSocket connections.
   *
   * @example
   * ```ts
   * if (!WebSocketFactory.isWebSocketSupported()) {
   *   console.warn('Falling back to long polling')
   * }
   * ```
   */
  static isWebSocketSupported() {
    try {
      const env = this.detectEnvironment();
      return env.type === "native" || env.type === "ws";
    } catch (_a) {
      return false;
    }
  }
};
var websocket_factory_default = WebSocketFactory;

// node_modules/@supabase/realtime-js/dist/module/lib/version.js
var version = "2.93.3";

// node_modules/@supabase/realtime-js/dist/module/lib/constants.js
var DEFAULT_VERSION = `realtime-js/${version}`;
var VSN_1_0_0 = "1.0.0";
var VSN_2_0_0 = "2.0.0";
var DEFAULT_VSN = VSN_2_0_0;
var DEFAULT_TIMEOUT = 1e4;
var WS_CLOSE_NORMAL = 1e3;
var MAX_PUSH_BUFFER_SIZE = 100;
var SOCKET_STATES;
(function(SOCKET_STATES2) {
  SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
  SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
  SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
  SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function(CHANNEL_STATES2) {
  CHANNEL_STATES2["closed"] = "closed";
  CHANNEL_STATES2["errored"] = "errored";
  CHANNEL_STATES2["joined"] = "joined";
  CHANNEL_STATES2["joining"] = "joining";
  CHANNEL_STATES2["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function(CHANNEL_EVENTS2) {
  CHANNEL_EVENTS2["close"] = "phx_close";
  CHANNEL_EVENTS2["error"] = "phx_error";
  CHANNEL_EVENTS2["join"] = "phx_join";
  CHANNEL_EVENTS2["reply"] = "phx_reply";
  CHANNEL_EVENTS2["leave"] = "phx_leave";
  CHANNEL_EVENTS2["access_token"] = "access_token";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function(TRANSPORTS2) {
  TRANSPORTS2["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));
var CONNECTION_STATE;
(function(CONNECTION_STATE2) {
  CONNECTION_STATE2["Connecting"] = "connecting";
  CONNECTION_STATE2["Open"] = "open";
  CONNECTION_STATE2["Closing"] = "closing";
  CONNECTION_STATE2["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {}));

// node_modules/@supabase/realtime-js/dist/module/lib/serializer.js
var Serializer = class {
  constructor(allowedMetadataKeys) {
    this.HEADER_LENGTH = 1;
    this.USER_BROADCAST_PUSH_META_LENGTH = 6;
    this.KINDS = { userBroadcastPush: 3, userBroadcast: 4 };
    this.BINARY_ENCODING = 0;
    this.JSON_ENCODING = 1;
    this.BROADCAST_EVENT = "broadcast";
    this.allowedMetadataKeys = [];
    this.allowedMetadataKeys = allowedMetadataKeys !== null && allowedMetadataKeys !== void 0 ? allowedMetadataKeys : [];
  }
  encode(msg, callback) {
    if (msg.event === this.BROADCAST_EVENT && !(msg.payload instanceof ArrayBuffer) && typeof msg.payload.event === "string") {
      return callback(this._binaryEncodeUserBroadcastPush(msg));
    }
    let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
    return callback(JSON.stringify(payload));
  }
  _binaryEncodeUserBroadcastPush(message) {
    var _a;
    if (this._isArrayBuffer((_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload)) {
      return this._encodeBinaryUserBroadcastPush(message);
    } else {
      return this._encodeJsonUserBroadcastPush(message);
    }
  }
  _encodeBinaryUserBroadcastPush(message) {
    var _a, _b;
    const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : new ArrayBuffer(0);
    return this._encodeUserBroadcastPush(message, this.BINARY_ENCODING, userPayload);
  }
  _encodeJsonUserBroadcastPush(message) {
    var _a, _b;
    const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : {};
    const encoder = new TextEncoder();
    const encodedUserPayload = encoder.encode(JSON.stringify(userPayload)).buffer;
    return this._encodeUserBroadcastPush(message, this.JSON_ENCODING, encodedUserPayload);
  }
  _encodeUserBroadcastPush(message, encodingType, encodedPayload) {
    var _a, _b;
    const topic = message.topic;
    const ref = (_a = message.ref) !== null && _a !== void 0 ? _a : "";
    const joinRef = (_b = message.join_ref) !== null && _b !== void 0 ? _b : "";
    const userEvent = message.payload.event;
    const rest = this.allowedMetadataKeys ? this._pick(message.payload, this.allowedMetadataKeys) : {};
    const metadata = Object.keys(rest).length === 0 ? "" : JSON.stringify(rest);
    if (joinRef.length > 255) {
      throw new Error(`joinRef length ${joinRef.length} exceeds maximum of 255`);
    }
    if (ref.length > 255) {
      throw new Error(`ref length ${ref.length} exceeds maximum of 255`);
    }
    if (topic.length > 255) {
      throw new Error(`topic length ${topic.length} exceeds maximum of 255`);
    }
    if (userEvent.length > 255) {
      throw new Error(`userEvent length ${userEvent.length} exceeds maximum of 255`);
    }
    if (metadata.length > 255) {
      throw new Error(`metadata length ${metadata.length} exceeds maximum of 255`);
    }
    const metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length + metadata.length;
    const header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
    let view = new DataView(header);
    let offset = 0;
    view.setUint8(offset++, this.KINDS.userBroadcastPush);
    view.setUint8(offset++, joinRef.length);
    view.setUint8(offset++, ref.length);
    view.setUint8(offset++, topic.length);
    view.setUint8(offset++, userEvent.length);
    view.setUint8(offset++, metadata.length);
    view.setUint8(offset++, encodingType);
    Array.from(joinRef, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(userEvent, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(metadata, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    var combined = new Uint8Array(header.byteLength + encodedPayload.byteLength);
    combined.set(new Uint8Array(header), 0);
    combined.set(new Uint8Array(encodedPayload), header.byteLength);
    return combined.buffer;
  }
  decode(rawPayload, callback) {
    if (this._isArrayBuffer(rawPayload)) {
      let result = this._binaryDecode(rawPayload);
      return callback(result);
    }
    if (typeof rawPayload === "string") {
      const jsonPayload = JSON.parse(rawPayload);
      const [join_ref, ref, topic, event, payload] = jsonPayload;
      return callback({ join_ref, ref, topic, event, payload });
    }
    return callback({});
  }
  _binaryDecode(buffer) {
    const view = new DataView(buffer);
    const kind = view.getUint8(0);
    const decoder = new TextDecoder();
    switch (kind) {
      case this.KINDS.userBroadcast:
        return this._decodeUserBroadcast(buffer, view, decoder);
    }
  }
  _decodeUserBroadcast(buffer, view, decoder) {
    const topicSize = view.getUint8(1);
    const userEventSize = view.getUint8(2);
    const metadataSize = view.getUint8(3);
    const payloadEncoding = view.getUint8(4);
    let offset = this.HEADER_LENGTH + 4;
    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    const userEvent = decoder.decode(buffer.slice(offset, offset + userEventSize));
    offset = offset + userEventSize;
    const metadata = decoder.decode(buffer.slice(offset, offset + metadataSize));
    offset = offset + metadataSize;
    const payload = buffer.slice(offset, buffer.byteLength);
    const parsedPayload = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(payload)) : payload;
    const data = {
      type: this.BROADCAST_EVENT,
      event: userEvent,
      payload: parsedPayload
    };
    if (metadataSize > 0) {
      data["meta"] = JSON.parse(metadata);
    }
    return { join_ref: null, ref: null, topic, event: this.BROADCAST_EVENT, payload: data };
  }
  _isArrayBuffer(buffer) {
    var _a;
    return buffer instanceof ArrayBuffer || ((_a = buffer === null || buffer === void 0 ? void 0 : buffer.constructor) === null || _a === void 0 ? void 0 : _a.name) === "ArrayBuffer";
  }
  _pick(obj, keys) {
    if (!obj || typeof obj !== "object") {
      return {};
    }
    return Object.fromEntries(Object.entries(obj).filter(([key]) => keys.includes(key)));
  }
};

// node_modules/@supabase/realtime-js/dist/module/lib/timer.js
var Timer = class {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = void 0;
    this.tries = 0;
    this.callback = callback;
    this.timerCalc = timerCalc;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
    this.timer = void 0;
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
};

// node_modules/@supabase/realtime-js/dist/module/lib/transformers.js
var PostgresTypes;
(function(PostgresTypes2) {
  PostgresTypes2["abstime"] = "abstime";
  PostgresTypes2["bool"] = "bool";
  PostgresTypes2["date"] = "date";
  PostgresTypes2["daterange"] = "daterange";
  PostgresTypes2["float4"] = "float4";
  PostgresTypes2["float8"] = "float8";
  PostgresTypes2["int2"] = "int2";
  PostgresTypes2["int4"] = "int4";
  PostgresTypes2["int4range"] = "int4range";
  PostgresTypes2["int8"] = "int8";
  PostgresTypes2["int8range"] = "int8range";
  PostgresTypes2["json"] = "json";
  PostgresTypes2["jsonb"] = "jsonb";
  PostgresTypes2["money"] = "money";
  PostgresTypes2["numeric"] = "numeric";
  PostgresTypes2["oid"] = "oid";
  PostgresTypes2["reltime"] = "reltime";
  PostgresTypes2["text"] = "text";
  PostgresTypes2["time"] = "time";
  PostgresTypes2["timestamp"] = "timestamp";
  PostgresTypes2["timestamptz"] = "timestamptz";
  PostgresTypes2["timetz"] = "timetz";
  PostgresTypes2["tsrange"] = "tsrange";
  PostgresTypes2["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
var convertChangeData = (columns, record, options = {}) => {
  var _a;
  const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];
  if (!record) {
    return {};
  }
  return Object.keys(record).reduce((acc, rec_key) => {
    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
    return acc;
  }, {});
};
var convertColumn = (columnName, columns, record, skipTypes) => {
  const column = columns.find((x) => x.name === columnName);
  const colType = column === null || column === void 0 ? void 0 : column.type;
  const value = record[columnName];
  if (colType && !skipTypes.includes(colType)) {
    return convertCell(colType, value);
  }
  return noop(value);
};
var convertCell = (type, value) => {
  if (type.charAt(0) === "_") {
    const dataType = type.slice(1, type.length);
    return toArray(value, dataType);
  }
  switch (type) {
    case PostgresTypes.bool:
      return toBoolean(value);
    case PostgresTypes.float4:
    case PostgresTypes.float8:
    case PostgresTypes.int2:
    case PostgresTypes.int4:
    case PostgresTypes.int8:
    case PostgresTypes.numeric:
    case PostgresTypes.oid:
      return toNumber(value);
    case PostgresTypes.json:
    case PostgresTypes.jsonb:
      return toJson(value);
    case PostgresTypes.timestamp:
      return toTimestampString(value);
    // Format to be consistent with PostgREST
    case PostgresTypes.abstime:
    // To allow users to cast it based on Timezone
    case PostgresTypes.date:
    // To allow users to cast it based on Timezone
    case PostgresTypes.daterange:
    case PostgresTypes.int4range:
    case PostgresTypes.int8range:
    case PostgresTypes.money:
    case PostgresTypes.reltime:
    // To allow users to cast it based on Timezone
    case PostgresTypes.text:
    case PostgresTypes.time:
    // To allow users to cast it based on Timezone
    case PostgresTypes.timestamptz:
    // To allow users to cast it based on Timezone
    case PostgresTypes.timetz:
    // To allow users to cast it based on Timezone
    case PostgresTypes.tsrange:
    case PostgresTypes.tstzrange:
      return noop(value);
    default:
      return noop(value);
  }
};
var noop = (value) => {
  return value;
};
var toBoolean = (value) => {
  switch (value) {
    case "t":
      return true;
    case "f":
      return false;
    default:
      return value;
  }
};
var toNumber = (value) => {
  if (typeof value === "string") {
    const parsedValue = parseFloat(value);
    if (!Number.isNaN(parsedValue)) {
      return parsedValue;
    }
  }
  return value;
};
var toJson = (value) => {
  if (typeof value === "string") {
    try {
      return JSON.parse(value);
    } catch (_a) {
      return value;
    }
  }
  return value;
};
var toArray = (value, type) => {
  if (typeof value !== "string") {
    return value;
  }
  const lastIdx = value.length - 1;
  const closeBrace = value[lastIdx];
  const openBrace = value[0];
  if (openBrace === "{" && closeBrace === "}") {
    let arr;
    const valTrim = value.slice(1, lastIdx);
    try {
      arr = JSON.parse("[" + valTrim + "]");
    } catch (_) {
      arr = valTrim ? valTrim.split(",") : [];
    }
    return arr.map((val) => convertCell(type, val));
  }
  return value;
};
var toTimestampString = (value) => {
  if (typeof value === "string") {
    return value.replace(" ", "T");
  }
  return value;
};
var httpEndpointURL = (socketUrl) => {
  const wsUrl = new URL(socketUrl);
  wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, "http");
  wsUrl.pathname = wsUrl.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, "");
  if (wsUrl.pathname === "" || wsUrl.pathname === "/") {
    wsUrl.pathname = "/api/broadcast";
  } else {
    wsUrl.pathname = wsUrl.pathname + "/api/broadcast";
  }
  return wsUrl.href;
};

// node_modules/@supabase/realtime-js/dist/module/lib/push.js
var Push = class {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {
    this.channel = channel;
    this.event = event;
    this.payload = payload;
    this.timeout = timeout;
    this.sent = false;
    this.timeoutTimer = void 0;
    this.ref = "";
    this.receivedResp = null;
    this.recHooks = [];
    this.refEvent = null;
  }
  resend(timeout) {
    this.timeout = timeout;
    this._cancelRefEvent();
    this.ref = "";
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
    this.send();
  }
  send() {
    if (this._hasReceived("timeout")) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    });
  }
  updatePayload(payload) {
    this.payload = Object.assign(Object.assign({}, this.payload), payload);
  }
  receive(status, callback) {
    var _a;
    if (this._hasReceived(status)) {
      callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);
    }
    this.recHooks.push({ status, callback });
    return this;
  }
  startTimeout() {
    if (this.timeoutTimer) {
      return;
    }
    this.ref = this.channel.socket._makeRef();
    this.refEvent = this.channel._replyEventName(this.ref);
    const callback = (payload) => {
      this._cancelRefEvent();
      this._cancelTimeout();
      this.receivedResp = payload;
      this._matchReceive(payload);
    };
    this.channel._on(this.refEvent, {}, callback);
    this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  trigger(status, response) {
    if (this.refEvent)
      this.channel._trigger(this.refEvent, { status, response });
  }
  destroy() {
    this._cancelRefEvent();
    this._cancelTimeout();
  }
  _cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = void 0;
  }
  _matchReceive({ status, response }) {
    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
  }
  _hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function(REALTIME_PRESENCE_LISTEN_EVENTS2) {
  REALTIME_PRESENCE_LISTEN_EVENTS2["SYNC"] = "sync";
  REALTIME_PRESENCE_LISTEN_EVENTS2["JOIN"] = "join";
  REALTIME_PRESENCE_LISTEN_EVENTS2["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
var RealtimePresence = class _RealtimePresence {
  /**
   * Creates a Presence helper that keeps the local presence state in sync with the server.
   *
   * @param channel - The realtime channel to bind to.
   * @param opts - Optional custom event names, e.g. `{ events: { state: 'state', diff: 'diff' } }`.
   *
   * @example
   * ```ts
   * const presence = new RealtimePresence(channel)
   *
   * channel.on('presence', ({ event, key }) => {
   *   console.log(`Presence ${event} on ${key}`)
   * })
   * ```
   */
  constructor(channel, opts) {
    this.channel = channel;
    this.state = {};
    this.pendingDiffs = [];
    this.joinRef = null;
    this.enabled = false;
    this.caller = {
      onJoin: () => {
      },
      onLeave: () => {
      },
      onSync: () => {
      }
    };
    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
      state: "presence_state",
      diff: "presence_diff"
    };
    this.channel._on(events.state, {}, (newState) => {
      const { onJoin, onLeave, onSync } = this.caller;
      this.joinRef = this.channel._joinRef();
      this.state = _RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach((diff) => {
        this.state = _RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel._on(events.diff, {}, (diff) => {
      const { onJoin, onLeave, onSync } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = _RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
    this.onJoin((key, currentPresences, newPresences) => {
      this.channel._trigger("presence", {
        event: "join",
        key,
        currentPresences,
        newPresences
      });
    });
    this.onLeave((key, currentPresences, leftPresences) => {
      this.channel._trigger("presence", {
        event: "leave",
        key,
        currentPresences,
        leftPresences
      });
    });
    this.onSync(() => {
      this.channel._trigger("presence", { event: "sync" });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(currentState, newState, onJoin, onLeave) {
    const state = this.cloneDeep(currentState);
    const transformedState = this.transformState(newState);
    const joins = {};
    const leaves = {};
    this.map(state, (key, presences) => {
      if (!transformedState[key]) {
        leaves[key] = presences;
      }
    });
    this.map(transformedState, (key, newPresences) => {
      const currentPresences = state[key];
      if (currentPresences) {
        const newPresenceRefs = newPresences.map((m) => m.presence_ref);
        const curPresenceRefs = currentPresences.map((m) => m.presence_ref);
        const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);
        const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);
        if (joinedPresences.length > 0) {
          joins[key] = joinedPresences;
        }
        if (leftPresences.length > 0) {
          leaves[key] = leftPresences;
        }
      } else {
        joins[key] = newPresences;
      }
    });
    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(state, diff, onJoin, onLeave) {
    const { joins, leaves } = {
      joins: this.transformState(diff.joins),
      leaves: this.transformState(diff.leaves)
    };
    if (!onJoin) {
      onJoin = () => {
      };
    }
    if (!onLeave) {
      onLeave = () => {
      };
    }
    this.map(joins, (key, newPresences) => {
      var _a;
      const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];
      state[key] = this.cloneDeep(newPresences);
      if (currentPresences.length > 0) {
        const joinedPresenceRefs = state[key].map((m) => m.presence_ref);
        const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);
        state[key].unshift(...curPresences);
      }
      onJoin(key, currentPresences, newPresences);
    });
    this.map(leaves, (key, leftPresences) => {
      let currentPresences = state[key];
      if (!currentPresences)
        return;
      const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);
      currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);
      state[key] = currentPresences;
      onLeave(key, currentPresences, leftPresences);
      if (currentPresences.length === 0)
        delete state[key];
    });
    return state;
  }
  /** @internal */
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(state) {
    state = this.cloneDeep(state);
    return Object.getOwnPropertyNames(state).reduce((newState, key) => {
      const presences = state[key];
      if ("metas" in presences) {
        newState[key] = presences.metas.map((presence) => {
          presence["presence_ref"] = presence["phx_ref"];
          delete presence["phx_ref"];
          delete presence["phx_ref_prev"];
          return presence;
        });
      } else {
        newState[key] = presences;
      }
      return newState;
    }, {});
  }
  /** @internal */
  static cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /** @internal */
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  /** @internal */
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  /** @internal */
  onSync(callback) {
    this.caller.onSync = callback;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["ALL"] = "*";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["INSERT"] = "INSERT";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["UPDATE"] = "UPDATE";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function(REALTIME_LISTEN_TYPES2) {
  REALTIME_LISTEN_TYPES2["BROADCAST"] = "broadcast";
  REALTIME_LISTEN_TYPES2["PRESENCE"] = "presence";
  REALTIME_LISTEN_TYPES2["POSTGRES_CHANGES"] = "postgres_changes";
  REALTIME_LISTEN_TYPES2["SYSTEM"] = "system";
})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function(REALTIME_SUBSCRIBE_STATES2) {
  REALTIME_SUBSCRIBE_STATES2["SUBSCRIBED"] = "SUBSCRIBED";
  REALTIME_SUBSCRIBE_STATES2["TIMED_OUT"] = "TIMED_OUT";
  REALTIME_SUBSCRIBE_STATES2["CLOSED"] = "CLOSED";
  REALTIME_SUBSCRIBE_STATES2["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
var RealtimeChannel = class _RealtimeChannel {
  /**
   * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.
   *
   * The topic determines which realtime stream you are subscribing to. Config options let you
   * enable acknowledgement for broadcasts, presence tracking, or private channels.
   *
   * @example
   * ```ts
   * import RealtimeClient from '@supabase/realtime-js'
   *
   * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {
   *   params: { apikey: 'public-anon-key' },
   * })
   * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)
   * ```
   */
  constructor(topic, params = { config: {} }, socket) {
    var _a, _b;
    this.topic = topic;
    this.params = params;
    this.socket = socket;
    this.bindings = {};
    this.state = CHANNEL_STATES.closed;
    this.joinedOnce = false;
    this.pushBuffer = [];
    this.subTopic = topic.replace(/^realtime:/i, "");
    this.params.config = Object.assign({
      broadcast: { ack: false, self: false },
      presence: { key: "", enabled: false },
      private: false
    }, params.config);
    this.timeout = this.socket.timeout;
    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
    this.joinPush.receive("ok", () => {
      this.state = CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach((pushEvent) => pushEvent.send());
      this.pushBuffer = [];
    });
    this._onClose(() => {
      this.rejoinTimer.reset();
      this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
      this.state = CHANNEL_STATES.closed;
      this.socket._remove(this);
    });
    this._onError((reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("timeout", () => {
      if (!this._isJoining()) {
        return;
      }
      this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("error", (reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {
      this._trigger(this._replyEventName(ref), payload);
    });
    this.presence = new RealtimePresence(this);
    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint);
    this.private = this.params.config.private || false;
    if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {
      throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;
    }
  }
  /** Subscribe registers your client with the server */
  subscribe(callback, timeout = this.timeout) {
    var _a, _b, _c;
    if (!this.socket.isConnected()) {
      this.socket.connect();
    }
    if (this.state == CHANNEL_STATES.closed) {
      const { config: { broadcast, presence, private: isPrivate } } = this.params;
      const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [];
      const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;
      const accessTokenPayload = {};
      const config = {
        broadcast,
        presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),
        postgres_changes,
        private: isPrivate
      };
      if (this.socket.accessTokenValue) {
        accessTokenPayload.access_token = this.socket.accessTokenValue;
      }
      this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));
      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
      this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));
      this.joinedOnce = true;
      this._rejoin(timeout);
      this.joinPush.receive("ok", async ({ postgres_changes: postgres_changes2 }) => {
        var _a2;
        if (!this.socket._isManualToken()) {
          this.socket.setAuth();
        }
        if (postgres_changes2 === void 0) {
          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        } else {
          const clientPostgresBindings = this.bindings.postgres_changes;
          const bindingsLen = (_a2 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a2 !== void 0 ? _a2 : 0;
          const newPostgresBindings = [];
          for (let i = 0; i < bindingsLen; i++) {
            const clientPostgresBinding = clientPostgresBindings[i];
            const { filter: { event, schema, table, filter } } = clientPostgresBinding;
            const serverPostgresFilter = postgres_changes2 && postgres_changes2[i];
            if (serverPostgresFilter && serverPostgresFilter.event === event && _RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) && _RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) && _RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {
              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));
            } else {
              this.unsubscribe();
              this.state = CHANNEL_STATES.errored;
              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
              return;
            }
          }
          this.bindings.postgres_changes = newPostgresBindings;
          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        }
      }).receive("error", (error) => {
        this.state = CHANNEL_STATES.errored;
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(", ") || "error")));
        return;
      }).receive("timeout", () => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
        return;
      });
    }
    return this;
  }
  /**
   * Returns the current presence state for this channel.
   *
   * The shape is a map keyed by presence key (for example a user id) where each entry contains the
   * tracked metadata for that user.
   */
  presenceState() {
    return this.presence.state;
  }
  /**
   * Sends the supplied payload to the presence tracker so other subscribers can see that this
   * client is online. Use `untrack` to stop broadcasting presence for the same key.
   */
  async track(payload, opts = {}) {
    return await this.send({
      type: "presence",
      event: "track",
      payload
    }, opts.timeout || this.timeout);
  }
  /**
   * Removes the current presence state for this client.
   */
  async untrack(opts = {}) {
    return await this.send({
      type: "presence",
      event: "untrack"
    }, opts);
  }
  on(type, filter, callback) {
    if (this.state === CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {
      this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);
      this.unsubscribe().then(async () => await this.subscribe());
    }
    return this._on(type, filter, callback);
  }
  /**
   * Sends a broadcast message explicitly via REST API.
   *
   * This method always uses the REST API endpoint regardless of WebSocket connection state.
   * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.
   *
   * @param event The name of the broadcast event
   * @param payload Payload to be sent (required)
   * @param opts Options including timeout
   * @returns Promise resolving to object with success status, and error details if failed
   */
  async httpSend(event, payload, opts = {}) {
    var _a;
    if (payload === void 0 || payload === null) {
      return Promise.reject("Payload is required for httpSend()");
    }
    const headers = {
      apikey: this.socket.apiKey ? this.socket.apiKey : "",
      "Content-Type": "application/json"
    };
    if (this.socket.accessTokenValue) {
      headers["Authorization"] = `Bearer ${this.socket.accessTokenValue}`;
    }
    const options = {
      method: "POST",
      headers,
      body: JSON.stringify({
        messages: [
          {
            topic: this.subTopic,
            event,
            payload,
            private: this.private
          }
        ]
      })
    };
    const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);
    if (response.status === 202) {
      return { success: true };
    }
    let errorMessage2 = response.statusText;
    try {
      const errorBody = await response.json();
      errorMessage2 = errorBody.error || errorBody.message || errorMessage2;
    } catch (_b) {
    }
    return Promise.reject(new Error(errorMessage2));
  }
  /**
   * Sends a message into the channel.
   *
   * @param args Arguments to send to channel
   * @param args.type The type of event to send
   * @param args.event The name of the event being sent
   * @param args.payload Payload to be sent
   * @param opts Options to be used during the send process
   */
  async send(args, opts = {}) {
    var _a, _b;
    if (!this._canPush() && args.type === "broadcast") {
      console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
      const { event, payload: endpoint_payload } = args;
      const headers = {
        apikey: this.socket.apiKey ? this.socket.apiKey : "",
        "Content-Type": "application/json"
      };
      if (this.socket.accessTokenValue) {
        headers["Authorization"] = `Bearer ${this.socket.accessTokenValue}`;
      }
      const options = {
        method: "POST",
        headers,
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event,
              payload: endpoint_payload,
              private: this.private
            }
          ]
        })
      };
      try {
        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);
        await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());
        return response.ok ? "ok" : "error";
      } catch (error) {
        if (error.name === "AbortError") {
          return "timed out";
        } else {
          return "error";
        }
      }
    } else {
      return new Promise((resolve) => {
        var _a2, _b2, _c;
        const push = this._push(args.type, args, opts.timeout || this.timeout);
        if (args.type === "broadcast" && !((_c = (_b2 = (_a2 = this.params) === null || _a2 === void 0 ? void 0 : _a2.config) === null || _b2 === void 0 ? void 0 : _b2.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
          resolve("ok");
        }
        push.receive("ok", () => resolve("ok"));
        push.receive("error", () => resolve("error"));
        push.receive("timeout", () => resolve("timed out"));
      });
    }
  }
  /**
   * Updates the payload that will be sent the next time the channel joins (reconnects).
   * Useful for rotating access tokens or updating config without re-creating the channel.
   */
  updateJoinPayload(payload) {
    this.joinPush.updatePayload(payload);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(timeout = this.timeout) {
    this.state = CHANNEL_STATES.leaving;
    const onClose = () => {
      this.socket.log("channel", `leave ${this.topic}`);
      this._trigger(CHANNEL_EVENTS.close, "leave", this._joinRef());
    };
    this.joinPush.destroy();
    let leavePush = null;
    return new Promise((resolve) => {
      leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);
      leavePush.receive("ok", () => {
        onClose();
        resolve("ok");
      }).receive("timeout", () => {
        onClose();
        resolve("timed out");
      }).receive("error", () => {
        resolve("error");
      });
      leavePush.send();
      if (!this._canPush()) {
        leavePush.trigger("ok", {});
      }
    }).finally(() => {
      leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();
    });
  }
  /**
   * Teardown the channel.
   *
   * Destroys and stops related timers.
   */
  teardown() {
    this.pushBuffer.forEach((push) => push.destroy());
    this.pushBuffer = [];
    this.rejoinTimer.reset();
    this.joinPush.destroy();
    this.state = CHANNEL_STATES.closed;
    this.bindings = {};
  }
  /** @internal */
  async _fetchWithTimeout(url, options, timeout) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));
    clearTimeout(id);
    return response;
  }
  /** @internal */
  _push(event, payload, timeout = this.timeout) {
    if (!this.joinedOnce) {
      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    }
    let pushEvent = new Push(this, event, payload, timeout);
    if (this._canPush()) {
      pushEvent.send();
    } else {
      this._addToPushBuffer(pushEvent);
    }
    return pushEvent;
  }
  /** @internal */
  _addToPushBuffer(pushEvent) {
    pushEvent.startTimeout();
    this.pushBuffer.push(pushEvent);
    if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {
      const removedPush = this.pushBuffer.shift();
      if (removedPush) {
        removedPush.destroy();
        this.socket.log("channel", `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);
      }
    }
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(_event, payload, _ref) {
    return payload;
  }
  /** @internal */
  _isMember(topic) {
    return this.topic === topic;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(type, payload, ref) {
    var _a, _b;
    const typeLower = type.toLocaleLowerCase();
    const { close, error, leave, join } = CHANNEL_EVENTS;
    const events = [close, error, leave, join];
    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
      return;
    }
    let handledPayload = this._onMessage(typeLower, payload, ref);
    if (payload && !handledPayload) {
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    }
    if (["insert", "update", "delete"].includes(typeLower)) {
      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {
        var _a2, _b2, _c;
        return ((_a2 = bind.filter) === null || _a2 === void 0 ? void 0 : _a2.event) === "*" || ((_c = (_b2 = bind.filter) === null || _b2 === void 0 ? void 0 : _b2.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
      }).map((bind) => bind.callback(handledPayload, ref));
    } else {
      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {
        var _a2, _b2, _c, _d, _e, _f;
        if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
          if ("id" in bind) {
            const bindId = bind.id;
            const bindEvent = (_a2 = bind.filter) === null || _a2 === void 0 ? void 0 : _a2.event;
            return bindId && ((_b2 = payload.ids) === null || _b2 === void 0 ? void 0 : _b2.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
          } else {
            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
            return bindEvent === "*" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
          }
        } else {
          return bind.type.toLocaleLowerCase() === typeLower;
        }
      }).map((bind) => {
        if (typeof handledPayload === "object" && "ids" in handledPayload) {
          const postgresChanges = handledPayload.data;
          const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;
          const enrichedPayload = {
            schema,
            table,
            commit_timestamp,
            eventType: type2,
            new: {},
            old: {},
            errors
          };
          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
        }
        bind.callback(handledPayload, ref);
      });
    }
  }
  /** @internal */
  _isClosed() {
    return this.state === CHANNEL_STATES.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === CHANNEL_STATES.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === CHANNEL_STATES.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === CHANNEL_STATES.leaving;
  }
  /** @internal */
  _replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  /** @internal */
  _on(type, filter, callback) {
    const typeLower = type.toLocaleLowerCase();
    const binding = {
      type: typeLower,
      filter,
      callback
    };
    if (this.bindings[typeLower]) {
      this.bindings[typeLower].push(binding);
    } else {
      this.bindings[typeLower] = [binding];
    }
    return this;
  }
  /** @internal */
  _off(type, filter) {
    const typeLower = type.toLocaleLowerCase();
    if (this.bindings[typeLower]) {
      this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {
        var _a;
        return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && _RealtimeChannel.isEqual(bind.filter, filter));
      });
    }
    return this;
  }
  /** @internal */
  static isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length) {
      return false;
    }
    for (const k in obj1) {
      if (obj1[k] !== obj2[k]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Compares two optional filter values for equality.
   * Treats undefined, null, and empty string as equivalent empty values.
   * @internal
   */
  static isFilterValueEqual(serverValue, clientValue) {
    const normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : void 0;
    const normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : void 0;
    return normalizedServer === normalizedClient;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout();
    if (this.socket.isConnected()) {
      this._rejoin();
    }
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(callback) {
    this._on(CHANNEL_EVENTS.close, {}, callback);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(callback) {
    this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(timeout = this.timeout) {
    if (this._isLeaving()) {
      return;
    }
    this.socket._leaveOpenTopic(this.topic);
    this.state = CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  /** @internal */
  _getPayloadRecords(payload) {
    const records = {
      new: {},
      old: {}
    };
    if (payload.type === "INSERT" || payload.type === "UPDATE") {
      records.new = convertChangeData(payload.columns, payload.record);
    }
    if (payload.type === "UPDATE" || payload.type === "DELETE") {
      records.old = convertChangeData(payload.columns, payload.old_record);
    }
    return records;
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js
var noop2 = () => {
};
var CONNECTION_TIMEOUTS = {
  HEARTBEAT_INTERVAL: 25e3,
  RECONNECT_DELAY: 10,
  HEARTBEAT_TIMEOUT_FALLBACK: 100
};
var RECONNECT_INTERVALS = [1e3, 2e3, 5e3, 1e4];
var DEFAULT_RECONNECT_FALLBACK = 1e4;
var WORKER_SCRIPT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
var RealtimeClient = class {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.logLevel Sets the log level for Realtime
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   * @param options.worker Use Web Worker to set a side flow. Defaults to false.
   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
   * @param options.vsn The protocol version to use when connecting. Supported versions are "1.0.0" and "2.0.0". Defaults to "2.0.0".
   * @example
   * ```ts
   * import RealtimeClient from '@supabase/realtime-js'
   *
   * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {
   *   params: { apikey: 'public-anon-key' },
   * })
   * client.connect()
   * ```
   */
  constructor(endPoint, options) {
    var _a;
    this.accessTokenValue = null;
    this.apiKey = null;
    this._manuallySetToken = false;
    this.channels = new Array();
    this.endPoint = "";
    this.httpEndpoint = "";
    this.headers = {};
    this.params = {};
    this.timeout = DEFAULT_TIMEOUT;
    this.transport = null;
    this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
    this.heartbeatTimer = void 0;
    this.pendingHeartbeatRef = null;
    this.heartbeatCallback = noop2;
    this.ref = 0;
    this.reconnectTimer = null;
    this.vsn = DEFAULT_VSN;
    this.logger = noop2;
    this.conn = null;
    this.sendBuffer = [];
    this.serializer = new Serializer();
    this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    };
    this.accessToken = null;
    this._connectionState = "disconnected";
    this._wasManualDisconnect = false;
    this._authPromise = null;
    this._heartbeatSentAt = null;
    this._resolveFetch = (customFetch) => {
      if (customFetch) {
        return (...args) => customFetch(...args);
      }
      return (...args) => fetch(...args);
    };
    if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {
      throw new Error("API key is required to connect to Realtime");
    }
    this.apiKey = options.params.apikey;
    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
    this.httpEndpoint = httpEndpointURL(endPoint);
    this._initializeOptions(options);
    this._setupReconnectionTimer();
    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {
      return;
    }
    this._setConnectionState("connecting");
    if (this.accessToken && !this._authPromise) {
      this._setAuthSafely("connect");
    }
    if (this.transport) {
      this.conn = new this.transport(this.endpointURL());
    } else {
      try {
        this.conn = websocket_factory_default.createWebSocket(this.endpointURL());
      } catch (error) {
        this._setConnectionState("disconnected");
        const errorMessage2 = error.message;
        if (errorMessage2.includes("Node.js")) {
          throw new Error(`${errorMessage2}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`);
        }
        throw new Error(`WebSocket not available: ${errorMessage2}`);
      }
    }
    this._setupConnectionHandlers();
  }
  /**
   * Returns the URL of the websocket.
   * @returns string The URL of the websocket.
   */
  endpointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: this.vsn }));
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(code, reason) {
    if (this.isDisconnecting()) {
      return;
    }
    this._setConnectionState("disconnecting", true);
    if (this.conn) {
      const fallbackTimer = setTimeout(() => {
        this._setConnectionState("disconnected");
      }, 100);
      this.conn.onclose = () => {
        clearTimeout(fallbackTimer);
        this._setConnectionState("disconnected");
      };
      if (typeof this.conn.close === "function") {
        if (code) {
          this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
        } else {
          this.conn.close();
        }
      }
      this._teardownConnection();
    } else {
      this._setConnectionState("disconnected");
    }
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  async removeChannel(channel) {
    const status = await channel.unsubscribe();
    if (this.channels.length === 0) {
      this.disconnect();
    }
    return status;
  }
  /**
   * Unsubscribes and removes all channels
   */
  async removeAllChannels() {
    const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));
    this.channels = [];
    this.disconnect();
    return values_1;
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(kind, msg, data) {
    this.logger(kind, msg, data);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return CONNECTION_STATE.Connecting;
      case SOCKET_STATES.open:
        return CONNECTION_STATE.Open;
      case SOCKET_STATES.closing:
        return CONNECTION_STATE.Closing;
      default:
        return CONNECTION_STATE.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === CONNECTION_STATE.Open;
  }
  /**
   * Returns `true` if the connection is currently connecting.
   */
  isConnecting() {
    return this._connectionState === "connecting";
  }
  /**
   * Returns `true` if the connection is currently disconnecting.
   */
  isDisconnecting() {
    return this._connectionState === "disconnecting";
  }
  /**
   * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.
   *
   * Topics are automatically prefixed with `realtime:` to match the Realtime service.
   * If a channel with the same topic already exists it will be returned instead of creating
   * a duplicate connection.
   */
  channel(topic, params = { config: {} }) {
    const realtimeTopic = `realtime:${topic}`;
    const exists = this.getChannels().find((c) => c.topic === realtimeTopic);
    if (!exists) {
      const chan = new RealtimeChannel(`realtime:${topic}`, params, this);
      this.channels.push(chan);
      return chan;
    } else {
      return exists;
    }
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(data) {
    const { topic, event, payload, ref } = data;
    const callback = () => {
      this.encode(data, (result) => {
        var _a;
        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);
      });
    };
    this.log("push", `${topic} ${event} (${ref})`, payload);
    if (this.isConnected()) {
      callback();
    } else {
      this.sendBuffer.push(callback);
    }
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * If param is null it will use the `accessToken` callback function or the token set on the client.
   *
   * On callback used, it will set the value of the token internal to the client.
   *
   * When a token is explicitly provided, it will be preserved across channel operations
   * (including removeChannel and resubscribe). The `accessToken` callback will not be
   * invoked until `setAuth()` is called without arguments.
   *
   * @param token A JWT string to override the token set on the client.
   *
   * @example
   * // Use a manual token (preserved across resubscribes, ignores accessToken callback)
   * client.realtime.setAuth('my-custom-jwt')
   *
   * // Switch back to using the accessToken callback
   * client.realtime.setAuth()
   */
  async setAuth(token = null) {
    this._authPromise = this._performAuth(token);
    try {
      await this._authPromise;
    } finally {
      this._authPromise = null;
    }
  }
  /**
   * Returns true if the current access token was explicitly set via setAuth(token),
   * false if it was obtained via the accessToken callback.
   * @internal
   */
  _isManualToken() {
    return this._manuallySetToken;
  }
  /**
   * Sends a heartbeat message if the socket is connected.
   */
  async sendHeartbeat() {
    var _a;
    if (!this.isConnected()) {
      try {
        this.heartbeatCallback("disconnected");
      } catch (e) {
        this.log("error", "error in heartbeat callback", e);
      }
      return;
    }
    if (this.pendingHeartbeatRef) {
      this.pendingHeartbeatRef = null;
      this._heartbeatSentAt = null;
      this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
      try {
        this.heartbeatCallback("timeout");
      } catch (e) {
        this.log("error", "error in heartbeat callback", e);
      }
      this._wasManualDisconnect = false;
      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, "heartbeat timeout");
      setTimeout(() => {
        var _a2;
        if (!this.isConnected()) {
          (_a2 = this.reconnectTimer) === null || _a2 === void 0 ? void 0 : _a2.scheduleTimeout();
        }
      }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);
      return;
    }
    this._heartbeatSentAt = Date.now();
    this.pendingHeartbeatRef = this._makeRef();
    this.push({
      topic: "phoenix",
      event: "heartbeat",
      payload: {},
      ref: this.pendingHeartbeatRef
    });
    try {
      this.heartbeatCallback("sent");
    } catch (e) {
      this.log("error", "error in heartbeat callback", e);
    }
    this._setAuthSafely("heartbeat");
  }
  /**
   * Sets a callback that receives lifecycle events for internal heartbeat messages.
   * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).
   */
  onHeartbeat(callback) {
    this.heartbeatCallback = callback;
  }
  /**
   * Flushes send buffer
   */
  flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach((callback) => callback());
      this.sendBuffer = [];
    }
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(topic) {
    let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));
    if (dupChannel) {
      this.log("transport", `leaving duplicate topic "${topic}"`);
      dupChannel.unsubscribe();
    }
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(channel) {
    this.channels = this.channels.filter((c) => c.topic !== channel.topic);
  }
  /** @internal */
  _onConnMessage(rawMessage) {
    this.decode(rawMessage.data, (msg) => {
      if (msg.topic === "phoenix" && msg.event === "phx_reply" && msg.ref && msg.ref === this.pendingHeartbeatRef) {
        const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : void 0;
        try {
          this.heartbeatCallback(msg.payload.status === "ok" ? "ok" : "error", latency);
        } catch (e) {
          this.log("error", "error in heartbeat callback", e);
        }
        this._heartbeatSentAt = null;
        this.pendingHeartbeatRef = null;
      }
      const { topic, event, payload, ref } = msg;
      const refString = ref ? `(${ref})` : "";
      const status = payload.status || "";
      this.log("receive", `${status} ${topic} ${event} ${refString}`.trim(), payload);
      this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));
      this._triggerStateCallbacks("message", msg);
    });
  }
  /**
   * Clear specific timer
   * @internal
   */
  _clearTimer(timer) {
    var _a;
    if (timer === "heartbeat" && this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = void 0;
    } else if (timer === "reconnect") {
      (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();
    }
  }
  /**
   * Clear all timers
   * @internal
   */
  _clearAllTimers() {
    this._clearTimer("heartbeat");
    this._clearTimer("reconnect");
  }
  /**
   * Setup connection handlers for WebSocket events
   * @internal
   */
  _setupConnectionHandlers() {
    if (!this.conn)
      return;
    if ("binaryType" in this.conn) {
      ;
      this.conn.binaryType = "arraybuffer";
    }
    this.conn.onopen = () => this._onConnOpen();
    this.conn.onerror = (error) => this._onConnError(error);
    this.conn.onmessage = (event) => this._onConnMessage(event);
    this.conn.onclose = (event) => this._onConnClose(event);
    if (this.conn.readyState === SOCKET_STATES.open) {
      this._onConnOpen();
    }
  }
  /**
   * Teardown connection and cleanup resources
   * @internal
   */
  _teardownConnection() {
    if (this.conn) {
      if (this.conn.readyState === SOCKET_STATES.open || this.conn.readyState === SOCKET_STATES.connecting) {
        try {
          this.conn.close();
        } catch (e) {
          this.log("error", "Error closing connection", e);
        }
      }
      this.conn.onopen = null;
      this.conn.onerror = null;
      this.conn.onmessage = null;
      this.conn.onclose = null;
      this.conn = null;
    }
    this._clearAllTimers();
    this._terminateWorker();
    this.channels.forEach((channel) => channel.teardown());
  }
  /** @internal */
  _onConnOpen() {
    this._setConnectionState("connected");
    this.log("transport", `connected to ${this.endpointURL()}`);
    const authPromise = this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());
    authPromise.then(() => {
      this.flushSendBuffer();
    }).catch((e) => {
      this.log("error", "error waiting for auth on connect", e);
      this.flushSendBuffer();
    });
    this._clearTimer("reconnect");
    if (!this.worker) {
      this._startHeartbeat();
    } else {
      if (!this.workerRef) {
        this._startWorkerHeartbeat();
      }
    }
    this._triggerStateCallbacks("open");
  }
  /** @internal */
  _startHeartbeat() {
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
  }
  /** @internal */
  _startWorkerHeartbeat() {
    if (this.workerUrl) {
      this.log("worker", `starting worker for from ${this.workerUrl}`);
    } else {
      this.log("worker", `starting default worker`);
    }
    const objectUrl = this._workerObjectUrl(this.workerUrl);
    this.workerRef = new Worker(objectUrl);
    this.workerRef.onerror = (error) => {
      this.log("worker", "worker error", error.message);
      this._terminateWorker();
    };
    this.workerRef.onmessage = (event) => {
      if (event.data.event === "keepAlive") {
        this.sendHeartbeat();
      }
    };
    this.workerRef.postMessage({
      event: "start",
      interval: this.heartbeatIntervalMs
    });
  }
  /**
   * Terminate the Web Worker and clear the reference
   * @internal
   */
  _terminateWorker() {
    if (this.workerRef) {
      this.log("worker", "terminating worker");
      this.workerRef.terminate();
      this.workerRef = void 0;
    }
  }
  /** @internal */
  _onConnClose(event) {
    var _a;
    this._setConnectionState("disconnected");
    this.log("transport", "close", event);
    this._triggerChanError();
    this._clearTimer("heartbeat");
    if (!this._wasManualDisconnect) {
      (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();
    }
    this._triggerStateCallbacks("close", event);
  }
  /** @internal */
  _onConnError(error) {
    this._setConnectionState("disconnected");
    this.log("transport", `${error}`);
    this._triggerChanError();
    this._triggerStateCallbacks("error", error);
    try {
      this.heartbeatCallback("error");
    } catch (e) {
      this.log("error", "error in heartbeat callback", e);
    }
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));
  }
  /** @internal */
  _appendParams(url, params) {
    if (Object.keys(params).length === 0) {
      return url;
    }
    const prefix = url.match(/\?/) ? "&" : "?";
    const query = new URLSearchParams(params);
    return `${url}${prefix}${query}`;
  }
  _workerObjectUrl(url) {
    let result_url;
    if (url) {
      result_url = url;
    } else {
      const blob = new Blob([WORKER_SCRIPT], { type: "application/javascript" });
      result_url = URL.createObjectURL(blob);
    }
    return result_url;
  }
  /**
   * Set connection state with proper state management
   * @internal
   */
  _setConnectionState(state, manual = false) {
    this._connectionState = state;
    if (state === "connecting") {
      this._wasManualDisconnect = false;
    } else if (state === "disconnecting") {
      this._wasManualDisconnect = manual;
    }
  }
  /**
   * Perform the actual auth operation
   * @internal
   */
  async _performAuth(token = null) {
    let tokenToSend;
    let isManualToken = false;
    if (token) {
      tokenToSend = token;
      isManualToken = true;
    } else if (this.accessToken) {
      try {
        tokenToSend = await this.accessToken();
      } catch (e) {
        this.log("error", "Error fetching access token from callback", e);
        tokenToSend = this.accessTokenValue;
      }
    } else {
      tokenToSend = this.accessTokenValue;
    }
    if (isManualToken) {
      this._manuallySetToken = true;
    } else if (this.accessToken) {
      this._manuallySetToken = false;
    }
    if (this.accessTokenValue != tokenToSend) {
      this.accessTokenValue = tokenToSend;
      this.channels.forEach((channel) => {
        const payload = {
          access_token: tokenToSend,
          version: DEFAULT_VERSION
        };
        tokenToSend && channel.updateJoinPayload(payload);
        if (channel.joinedOnce && channel._isJoined()) {
          channel._push(CHANNEL_EVENTS.access_token, {
            access_token: tokenToSend
          });
        }
      });
    }
  }
  /**
   * Wait for any in-flight auth operations to complete
   * @internal
   */
  async _waitForAuthIfNeeded() {
    if (this._authPromise) {
      await this._authPromise;
    }
  }
  /**
   * Safely call setAuth with standardized error handling
   * @internal
   */
  _setAuthSafely(context = "general") {
    if (!this._isManualToken()) {
      this.setAuth().catch((e) => {
        this.log("error", `Error setting auth in ${context}`, e);
      });
    }
  }
  /**
   * Trigger state change callbacks with proper error handling
   * @internal
   */
  _triggerStateCallbacks(event, data) {
    try {
      this.stateChangeCallbacks[event].forEach((callback) => {
        try {
          callback(data);
        } catch (e) {
          this.log("error", `error in ${event} callback`, e);
        }
      });
    } catch (e) {
      this.log("error", `error triggering ${event} callbacks`, e);
    }
  }
  /**
   * Setup reconnection timer with proper configuration
   * @internal
   */
  _setupReconnectionTimer() {
    this.reconnectTimer = new Timer(async () => {
      setTimeout(async () => {
        await this._waitForAuthIfNeeded();
        if (!this.isConnected()) {
          this.connect();
        }
      }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);
    }, this.reconnectAfterMs);
  }
  /**
   * Initialize client options with defaults
   * @internal
   */
  _initializeOptions(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;
    this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : DEFAULT_TIMEOUT;
    this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
    this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;
    this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;
    this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop2;
    this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : DEFAULT_VSN;
    if (options === null || options === void 0 ? void 0 : options.params)
      this.params = options.params;
    if (options === null || options === void 0 ? void 0 : options.logger)
      this.logger = options.logger;
    if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {
      this.logLevel = options.logLevel || options.log_level;
      this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });
    }
    this.reconnectAfterMs = (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : ((tries) => {
      return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;
    });
    switch (this.vsn) {
      case VSN_1_0_0:
        this.encode = (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : ((payload, callback) => {
          return callback(JSON.stringify(payload));
        });
        this.decode = (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : ((payload, callback) => {
          return callback(JSON.parse(payload));
        });
        break;
      case VSN_2_0_0:
        this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);
        this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);
        break;
      default:
        throw new Error(`Unsupported serializer version: ${this.vsn}`);
    }
    if (this.worker) {
      if (typeof window !== "undefined" && !window.Worker) {
        throw new Error("Web Worker is not supported");
      }
      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
    }
  }
};

// node_modules/iceberg-js/dist/index.mjs
var IcebergError = class extends Error {
  constructor(message, opts) {
    super(message);
    this.name = "IcebergError";
    this.status = opts.status;
    this.icebergType = opts.icebergType;
    this.icebergCode = opts.icebergCode;
    this.details = opts.details;
    this.isCommitStateUnknown = opts.icebergType === "CommitStateUnknownException" || [500, 502, 504].includes(opts.status) && opts.icebergType?.includes("CommitState") === true;
  }
  /**
   * Returns true if the error is a 404 Not Found error.
   */
  isNotFound() {
    return this.status === 404;
  }
  /**
   * Returns true if the error is a 409 Conflict error.
   */
  isConflict() {
    return this.status === 409;
  }
  /**
   * Returns true if the error is a 419 Authentication Timeout error.
   */
  isAuthenticationTimeout() {
    return this.status === 419;
  }
};
function buildUrl(baseUrl, path, query) {
  const url = new URL(path, baseUrl);
  if (query) {
    for (const [key, value] of Object.entries(query)) {
      if (value !== void 0) {
        url.searchParams.set(key, value);
      }
    }
  }
  return url.toString();
}
async function buildAuthHeaders(auth) {
  if (!auth || auth.type === "none") {
    return {};
  }
  if (auth.type === "bearer") {
    return { Authorization: `Bearer ${auth.token}` };
  }
  if (auth.type === "header") {
    return { [auth.name]: auth.value };
  }
  if (auth.type === "custom") {
    return await auth.getHeaders();
  }
  return {};
}
function createFetchClient(options) {
  const fetchFn = options.fetchImpl ?? globalThis.fetch;
  return {
    async request({
      method,
      path,
      query,
      body,
      headers
    }) {
      const url = buildUrl(options.baseUrl, path, query);
      const authHeaders = await buildAuthHeaders(options.auth);
      const res = await fetchFn(url, {
        method,
        headers: {
          ...body ? { "Content-Type": "application/json" } : {},
          ...authHeaders,
          ...headers
        },
        body: body ? JSON.stringify(body) : void 0
      });
      const text = await res.text();
      const isJson = (res.headers.get("content-type") || "").includes("application/json");
      const data = isJson && text ? JSON.parse(text) : text;
      if (!res.ok) {
        const errBody = isJson ? data : void 0;
        const errorDetail = errBody?.error;
        throw new IcebergError(
          errorDetail?.message ?? `Request failed with status ${res.status}`,
          {
            status: res.status,
            icebergType: errorDetail?.type,
            icebergCode: errorDetail?.code,
            details: errBody
          }
        );
      }
      return { status: res.status, headers: res.headers, data };
    }
  };
}
function namespaceToPath(namespace) {
  return namespace.join("");
}
var NamespaceOperations = class {
  constructor(client, prefix = "") {
    this.client = client;
    this.prefix = prefix;
  }
  async listNamespaces(parent) {
    const query = parent ? { parent: namespaceToPath(parent.namespace) } : void 0;
    const response = await this.client.request({
      method: "GET",
      path: `${this.prefix}/namespaces`,
      query
    });
    return response.data.namespaces.map((ns) => ({ namespace: ns }));
  }
  async createNamespace(id, metadata) {
    const request = {
      namespace: id.namespace,
      properties: metadata?.properties
    };
    const response = await this.client.request({
      method: "POST",
      path: `${this.prefix}/namespaces`,
      body: request
    });
    return response.data;
  }
  async dropNamespace(id) {
    await this.client.request({
      method: "DELETE",
      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`
    });
  }
  async loadNamespaceMetadata(id) {
    const response = await this.client.request({
      method: "GET",
      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`
    });
    return {
      properties: response.data.properties
    };
  }
  async namespaceExists(id) {
    try {
      await this.client.request({
        method: "HEAD",
        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`
      });
      return true;
    } catch (error) {
      if (error instanceof IcebergError && error.status === 404) {
        return false;
      }
      throw error;
    }
  }
  async createNamespaceIfNotExists(id, metadata) {
    try {
      return await this.createNamespace(id, metadata);
    } catch (error) {
      if (error instanceof IcebergError && error.status === 409) {
        return;
      }
      throw error;
    }
  }
};
function namespaceToPath2(namespace) {
  return namespace.join("");
}
var TableOperations = class {
  constructor(client, prefix = "", accessDelegation) {
    this.client = client;
    this.prefix = prefix;
    this.accessDelegation = accessDelegation;
  }
  async listTables(namespace) {
    const response = await this.client.request({
      method: "GET",
      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`
    });
    return response.data.identifiers;
  }
  async createTable(namespace, request) {
    const headers = {};
    if (this.accessDelegation) {
      headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
    }
    const response = await this.client.request({
      method: "POST",
      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,
      body: request,
      headers
    });
    return response.data.metadata;
  }
  async updateTable(id, request) {
    const response = await this.client.request({
      method: "POST",
      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
      body: request
    });
    return {
      "metadata-location": response.data["metadata-location"],
      metadata: response.data.metadata
    };
  }
  async dropTable(id, options) {
    await this.client.request({
      method: "DELETE",
      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
      query: { purgeRequested: String(options?.purge ?? false) }
    });
  }
  async loadTable(id) {
    const headers = {};
    if (this.accessDelegation) {
      headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
    }
    const response = await this.client.request({
      method: "GET",
      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
      headers
    });
    return response.data.metadata;
  }
  async tableExists(id) {
    const headers = {};
    if (this.accessDelegation) {
      headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
    }
    try {
      await this.client.request({
        method: "HEAD",
        path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
        headers
      });
      return true;
    } catch (error) {
      if (error instanceof IcebergError && error.status === 404) {
        return false;
      }
      throw error;
    }
  }
  async createTableIfNotExists(namespace, request) {
    try {
      return await this.createTable(namespace, request);
    } catch (error) {
      if (error instanceof IcebergError && error.status === 409) {
        return await this.loadTable({ namespace: namespace.namespace, name: request.name });
      }
      throw error;
    }
  }
};
var IcebergRestCatalog = class {
  /**
   * Creates a new Iceberg REST Catalog client.
   *
   * @param options - Configuration options for the catalog client
   */
  constructor(options) {
    let prefix = "v1";
    if (options.catalogName) {
      prefix += `/${options.catalogName}`;
    }
    const baseUrl = options.baseUrl.endsWith("/") ? options.baseUrl : `${options.baseUrl}/`;
    this.client = createFetchClient({
      baseUrl,
      auth: options.auth,
      fetchImpl: options.fetch
    });
    this.accessDelegation = options.accessDelegation?.join(",");
    this.namespaceOps = new NamespaceOperations(this.client, prefix);
    this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);
  }
  /**
   * Lists all namespaces in the catalog.
   *
   * @param parent - Optional parent namespace to list children under
   * @returns Array of namespace identifiers
   *
   * @example
   * ```typescript
   * // List all top-level namespaces
   * const namespaces = await catalog.listNamespaces();
   *
   * // List namespaces under a parent
   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });
   * ```
   */
  async listNamespaces(parent) {
    return this.namespaceOps.listNamespaces(parent);
  }
  /**
   * Creates a new namespace in the catalog.
   *
   * @param id - Namespace identifier to create
   * @param metadata - Optional metadata properties for the namespace
   * @returns Response containing the created namespace and its properties
   *
   * @example
   * ```typescript
   * const response = await catalog.createNamespace(
   *   { namespace: ['analytics'] },
   *   { properties: { owner: 'data-team' } }
   * );
   * console.log(response.namespace); // ['analytics']
   * console.log(response.properties); // { owner: 'data-team', ... }
   * ```
   */
  async createNamespace(id, metadata) {
    return this.namespaceOps.createNamespace(id, metadata);
  }
  /**
   * Drops a namespace from the catalog.
   *
   * The namespace must be empty (contain no tables) before it can be dropped.
   *
   * @param id - Namespace identifier to drop
   *
   * @example
   * ```typescript
   * await catalog.dropNamespace({ namespace: ['analytics'] });
   * ```
   */
  async dropNamespace(id) {
    await this.namespaceOps.dropNamespace(id);
  }
  /**
   * Loads metadata for a namespace.
   *
   * @param id - Namespace identifier to load
   * @returns Namespace metadata including properties
   *
   * @example
   * ```typescript
   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });
   * console.log(metadata.properties);
   * ```
   */
  async loadNamespaceMetadata(id) {
    return this.namespaceOps.loadNamespaceMetadata(id);
  }
  /**
   * Lists all tables in a namespace.
   *
   * @param namespace - Namespace identifier to list tables from
   * @returns Array of table identifiers
   *
   * @example
   * ```typescript
   * const tables = await catalog.listTables({ namespace: ['analytics'] });
   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]
   * ```
   */
  async listTables(namespace) {
    return this.tableOps.listTables(namespace);
  }
  /**
   * Creates a new table in the catalog.
   *
   * @param namespace - Namespace to create the table in
   * @param request - Table creation request including name, schema, partition spec, etc.
   * @returns Table metadata for the created table
   *
   * @example
   * ```typescript
   * const metadata = await catalog.createTable(
   *   { namespace: ['analytics'] },
   *   {
   *     name: 'events',
   *     schema: {
   *       type: 'struct',
   *       fields: [
   *         { id: 1, name: 'id', type: 'long', required: true },
   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }
   *       ],
   *       'schema-id': 0
   *     },
   *     'partition-spec': {
   *       'spec-id': 0,
   *       fields: [
   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }
   *       ]
   *     }
   *   }
   * );
   * ```
   */
  async createTable(namespace, request) {
    return this.tableOps.createTable(namespace, request);
  }
  /**
   * Updates an existing table's metadata.
   *
   * Can update the schema, partition spec, or properties of a table.
   *
   * @param id - Table identifier to update
   * @param request - Update request with fields to modify
   * @returns Response containing the metadata location and updated table metadata
   *
   * @example
   * ```typescript
   * const response = await catalog.updateTable(
   *   { namespace: ['analytics'], name: 'events' },
   *   {
   *     properties: { 'read.split.target-size': '134217728' }
   *   }
   * );
   * console.log(response['metadata-location']); // s3://...
   * console.log(response.metadata); // TableMetadata object
   * ```
   */
  async updateTable(id, request) {
    return this.tableOps.updateTable(id, request);
  }
  /**
   * Drops a table from the catalog.
   *
   * @param id - Table identifier to drop
   *
   * @example
   * ```typescript
   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });
   * ```
   */
  async dropTable(id, options) {
    await this.tableOps.dropTable(id, options);
  }
  /**
   * Loads metadata for a table.
   *
   * @param id - Table identifier to load
   * @returns Table metadata including schema, partition spec, location, etc.
   *
   * @example
   * ```typescript
   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });
   * console.log(metadata.schema);
   * console.log(metadata.location);
   * ```
   */
  async loadTable(id) {
    return this.tableOps.loadTable(id);
  }
  /**
   * Checks if a namespace exists in the catalog.
   *
   * @param id - Namespace identifier to check
   * @returns True if the namespace exists, false otherwise
   *
   * @example
   * ```typescript
   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });
   * console.log(exists); // true or false
   * ```
   */
  async namespaceExists(id) {
    return this.namespaceOps.namespaceExists(id);
  }
  /**
   * Checks if a table exists in the catalog.
   *
   * @param id - Table identifier to check
   * @returns True if the table exists, false otherwise
   *
   * @example
   * ```typescript
   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });
   * console.log(exists); // true or false
   * ```
   */
  async tableExists(id) {
    return this.tableOps.tableExists(id);
  }
  /**
   * Creates a namespace if it does not exist.
   *
   * If the namespace already exists, returns void. If created, returns the response.
   *
   * @param id - Namespace identifier to create
   * @param metadata - Optional metadata properties for the namespace
   * @returns Response containing the created namespace and its properties, or void if it already exists
   *
   * @example
   * ```typescript
   * const response = await catalog.createNamespaceIfNotExists(
   *   { namespace: ['analytics'] },
   *   { properties: { owner: 'data-team' } }
   * );
   * if (response) {
   *   console.log('Created:', response.namespace);
   * } else {
   *   console.log('Already exists');
   * }
   * ```
   */
  async createNamespaceIfNotExists(id, metadata) {
    return this.namespaceOps.createNamespaceIfNotExists(id, metadata);
  }
  /**
   * Creates a table if it does not exist.
   *
   * If the table already exists, returns its metadata instead.
   *
   * @param namespace - Namespace to create the table in
   * @param request - Table creation request including name, schema, partition spec, etc.
   * @returns Table metadata for the created or existing table
   *
   * @example
   * ```typescript
   * const metadata = await catalog.createTableIfNotExists(
   *   { namespace: ['analytics'] },
   *   {
   *     name: 'events',
   *     schema: {
   *       type: 'struct',
   *       fields: [
   *         { id: 1, name: 'id', type: 'long', required: true },
   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }
   *       ],
   *       'schema-id': 0
   *     }
   *   }
   * );
   * ```
   */
  async createTableIfNotExists(namespace, request) {
    return this.tableOps.createTableIfNotExists(namespace, request);
  }
};

// node_modules/@supabase/storage-js/dist/index.mjs
var StorageError = class extends Error {
  constructor(message, namespace = "storage", status, statusCode) {
    super(message);
    this.__isStorageError = true;
    this.namespace = namespace;
    this.name = namespace === "vectors" ? "StorageVectorsError" : "StorageError";
    this.status = status;
    this.statusCode = statusCode;
  }
};
function isStorageError(error) {
  return typeof error === "object" && error !== null && "__isStorageError" in error;
}
var StorageApiError = class extends StorageError {
  constructor(message, status, statusCode, namespace = "storage") {
    super(message, namespace, status, statusCode);
    this.name = namespace === "vectors" ? "StorageVectorsApiError" : "StorageApiError";
    this.status = status;
    this.statusCode = statusCode;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode
    };
  }
};
var StorageUnknownError = class extends StorageError {
  constructor(message, originalError, namespace = "storage") {
    super(message, namespace);
    this.name = namespace === "vectors" ? "StorageVectorsUnknownError" : "StorageUnknownError";
    this.originalError = originalError;
  }
};
var resolveFetch2 = (customFetch) => {
  if (customFetch) return (...args) => customFetch(...args);
  return (...args) => fetch(...args);
};
var isPlainObject = (value) => {
  if (typeof value !== "object" || value === null) return false;
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
var recursiveToCamel = (item) => {
  if (Array.isArray(item)) return item.map((el) => recursiveToCamel(el));
  else if (typeof item === "function" || item !== Object(item)) return item;
  const result = {};
  Object.entries(item).forEach(([key, value]) => {
    const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ""));
    result[newKey] = recursiveToCamel(value);
  });
  return result;
};
var isValidBucketName = (bucketName) => {
  if (!bucketName || typeof bucketName !== "string") return false;
  if (bucketName.length === 0 || bucketName.length > 100) return false;
  if (bucketName.trim() !== bucketName) return false;
  if (bucketName.includes("/") || bucketName.includes("\\")) return false;
  return /^[\w!.\*'() &$@=;:+,?-]+$/.test(bucketName);
};
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
    return typeof o$1;
  } : function(o$1) {
    return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
  }, _typeof(o);
}
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r$1) {
      return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r$1) {
      _defineProperty(e, r$1, t[r$1]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {
      Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
    });
  }
  return e;
}
var _getErrorMessage = (err) => {
  var _err$error;
  return err.msg || err.message || err.error_description || (typeof err.error === "string" ? err.error : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.message) || JSON.stringify(err);
};
var handleError = async (error, reject, options, namespace) => {
  if (error && typeof error === "object" && "status" in error && "ok" in error && typeof error.status === "number" && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
    const responseError = error;
    const status = responseError.status || 500;
    if (typeof responseError.json === "function") responseError.json().then((err) => {
      const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + "";
      reject(new StorageApiError(_getErrorMessage(err), status, statusCode, namespace));
    }).catch(() => {
      if (namespace === "vectors") {
        const statusCode = status + "";
        reject(new StorageApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode, namespace));
      } else {
        const statusCode = status + "";
        reject(new StorageApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode, namespace));
      }
    });
    else {
      const statusCode = status + "";
      reject(new StorageApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode, namespace));
    }
  } else reject(new StorageUnknownError(_getErrorMessage(error), error, namespace));
};
var _getRequestParams = (method, options, parameters, body) => {
  const params = {
    method,
    headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
  };
  if (method === "GET" || method === "HEAD" || !body) return _objectSpread2(_objectSpread2({}, params), parameters);
  if (isPlainObject(body)) {
    params.headers = _objectSpread2({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
    params.body = JSON.stringify(body);
  } else params.body = body;
  if (options === null || options === void 0 ? void 0 : options.duplex) params.duplex = options.duplex;
  return _objectSpread2(_objectSpread2({}, params), parameters);
};
async function _handleRequest(fetcher, method, url, options, parameters, body, namespace) {
  return new Promise((resolve, reject) => {
    fetcher(url, _getRequestParams(method, options, parameters, body)).then((result) => {
      if (!result.ok) throw result;
      if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;
      if (namespace === "vectors") {
        const contentType = result.headers.get("content-type");
        if (result.headers.get("content-length") === "0" || result.status === 204) return {};
        if (!contentType || !contentType.includes("application/json")) return {};
      }
      return result.json();
    }).then((data) => resolve(data)).catch((error) => handleError(error, reject, options, namespace));
  });
}
function createFetchApi(namespace = "storage") {
  return {
    get: async (fetcher, url, options, parameters) => {
      return _handleRequest(fetcher, "GET", url, options, parameters, void 0, namespace);
    },
    post: async (fetcher, url, body, options, parameters) => {
      return _handleRequest(fetcher, "POST", url, options, parameters, body, namespace);
    },
    put: async (fetcher, url, body, options, parameters) => {
      return _handleRequest(fetcher, "PUT", url, options, parameters, body, namespace);
    },
    head: async (fetcher, url, options, parameters) => {
      return _handleRequest(fetcher, "HEAD", url, _objectSpread2(_objectSpread2({}, options), {}, { noResolveJson: true }), parameters, void 0, namespace);
    },
    remove: async (fetcher, url, body, options, parameters) => {
      return _handleRequest(fetcher, "DELETE", url, options, parameters, body, namespace);
    }
  };
}
var defaultApi = createFetchApi("storage");
var { get, post, put, head, remove } = defaultApi;
var vectorsApi = createFetchApi("vectors");
var BaseApiClient = class {
  /**
  * Creates a new BaseApiClient instance
  * @param url - Base URL for API requests
  * @param headers - Default headers for API requests
  * @param fetch - Optional custom fetch implementation
  * @param namespace - Error namespace ('storage' or 'vectors')
  */
  constructor(url, headers = {}, fetch$1, namespace = "storage") {
    this.shouldThrowOnError = false;
    this.url = url;
    this.headers = headers;
    this.fetch = resolveFetch2(fetch$1);
    this.namespace = namespace;
  }
  /**
  * Enable throwing errors instead of returning them.
  * When enabled, errors are thrown instead of returned in { data, error } format.
  *
  * @returns this - For method chaining
  */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
  * Handles API operation with standardized error handling
  * Eliminates repetitive try-catch blocks across all API methods
  *
  * This wrapper:
  * 1. Executes the operation
  * 2. Returns { data, error: null } on success
  * 3. Returns { data: null, error } on failure (if shouldThrowOnError is false)
  * 4. Throws error on failure (if shouldThrowOnError is true)
  *
  * @typeParam T - The expected data type from the operation
  * @param operation - Async function that performs the API call
  * @returns Promise with { data, error } tuple
  *
  * @example
  * ```typescript
  * async listBuckets() {
  *   return this.handleOperation(async () => {
  *     return await get(this.fetch, `${this.url}/bucket`, {
  *       headers: this.headers,
  *     })
  *   })
  * }
  * ```
  */
  async handleOperation(operation) {
    var _this = this;
    try {
      return {
        data: await operation(),
        error: null
      };
    } catch (error) {
      if (_this.shouldThrowOnError) throw error;
      if (isStorageError(error)) return {
        data: null,
        error
      };
      throw error;
    }
  }
};
var StreamDownloadBuilder = class {
  constructor(downloadFn, shouldThrowOnError) {
    this.downloadFn = downloadFn;
    this.shouldThrowOnError = shouldThrowOnError;
  }
  then(onfulfilled, onrejected) {
    return this.execute().then(onfulfilled, onrejected);
  }
  async execute() {
    var _this = this;
    try {
      return {
        data: (await _this.downloadFn()).body,
        error: null
      };
    } catch (error) {
      if (_this.shouldThrowOnError) throw error;
      if (isStorageError(error)) return {
        data: null,
        error
      };
      throw error;
    }
  }
};
var _Symbol$toStringTag;
_Symbol$toStringTag = Symbol.toStringTag;
var BlobDownloadBuilder = class {
  constructor(downloadFn, shouldThrowOnError) {
    this.downloadFn = downloadFn;
    this.shouldThrowOnError = shouldThrowOnError;
    this[_Symbol$toStringTag] = "BlobDownloadBuilder";
    this.promise = null;
  }
  asStream() {
    return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);
  }
  then(onfulfilled, onrejected) {
    return this.getPromise().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.getPromise().catch(onrejected);
  }
  finally(onfinally) {
    return this.getPromise().finally(onfinally);
  }
  getPromise() {
    if (!this.promise) this.promise = this.execute();
    return this.promise;
  }
  async execute() {
    var _this = this;
    try {
      return {
        data: await (await _this.downloadFn()).blob(),
        error: null
      };
    } catch (error) {
      if (_this.shouldThrowOnError) throw error;
      if (isStorageError(error)) return {
        data: null,
        error
      };
      throw error;
    }
  }
};
var DEFAULT_SEARCH_OPTIONS = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: "name",
    order: "asc"
  }
};
var DEFAULT_FILE_OPTIONS = {
  cacheControl: "3600",
  contentType: "text/plain;charset=UTF-8",
  upsert: false
};
var StorageFileApi = class extends BaseApiClient {
  constructor(url, headers = {}, bucketId, fetch$1) {
    super(url, headers, fetch$1, "storage");
    this.bucketId = bucketId;
  }
  /**
  * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
  *
  * @param method HTTP method.
  * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
  * @param fileBody The body of the file to be stored in the bucket.
  */
  async uploadOrUpdate(method, path, fileBody, fileOptions) {
    var _this = this;
    return _this.handleOperation(async () => {
      let body;
      const options = _objectSpread2(_objectSpread2({}, DEFAULT_FILE_OPTIONS), fileOptions);
      let headers = _objectSpread2(_objectSpread2({}, _this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
      const metadata = options.metadata;
      if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
        body = new FormData();
        body.append("cacheControl", options.cacheControl);
        if (metadata) body.append("metadata", _this.encodeMetadata(metadata));
        body.append("", fileBody);
      } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
        body = fileBody;
        if (!body.has("cacheControl")) body.append("cacheControl", options.cacheControl);
        if (metadata && !body.has("metadata")) body.append("metadata", _this.encodeMetadata(metadata));
      } else {
        body = fileBody;
        headers["cache-control"] = `max-age=${options.cacheControl}`;
        headers["content-type"] = options.contentType;
        if (metadata) headers["x-metadata"] = _this.toBase64(_this.encodeMetadata(metadata));
        if ((typeof ReadableStream !== "undefined" && body instanceof ReadableStream || body && typeof body === "object" && "pipe" in body && typeof body.pipe === "function") && !options.duplex) options.duplex = "half";
      }
      if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) headers = _objectSpread2(_objectSpread2({}, headers), fileOptions.headers);
      const cleanPath = _this._removeEmptyFolders(path);
      const _path = _this._getFinalPath(cleanPath);
      const data = await (method == "PUT" ? put : post)(_this.fetch, `${_this.url}/object/${_path}`, body, _objectSpread2({ headers }, (options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {}));
      return {
        path: cleanPath,
        id: data.Id,
        fullPath: data.Key
      };
    });
  }
  /**
  * Uploads a file to an existing bucket.
  *
  * @category File Buckets
  * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
  * @param fileBody The body of the file to be stored in the bucket.
  * @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.
  * @returns Promise with response containing file path, id, and fullPath or error
  *
  * @example Upload file
  * ```js
  * const avatarFile = event.target.files[0]
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .upload('public/avatar1.png', avatarFile, {
  *     cacheControl: '3600',
  *     upsert: false
  *   })
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "path": "public/avatar1.png",
  *     "fullPath": "avatars/public/avatar1.png"
  *   },
  *   "error": null
  * }
  * ```
  *
  * @example Upload file using `ArrayBuffer` from base64 file data
  * ```js
  * import { decode } from 'base64-arraybuffer'
  *
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .upload('public/avatar1.png', decode('base64FileData'), {
  *     contentType: 'image/png'
  *   })
  * ```
  */
  async upload(path, fileBody, fileOptions) {
    return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
  }
  /**
  * Upload a file with a token generated from `createSignedUploadUrl`.
  *
  * @category File Buckets
  * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
  * @param token The token generated from `createSignedUploadUrl`
  * @param fileBody The body of the file to be stored in the bucket.
  * @param fileOptions HTTP headers (cacheControl, contentType, etc.).
  * **Note:** The `upsert` option has no effect here. To enable upsert behavior,
  * pass `{ upsert: true }` when calling `createSignedUploadUrl()` instead.
  * @returns Promise with response containing file path and fullPath or error
  *
  * @example Upload to a signed URL
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "path": "folder/cat.jpg",
  *     "fullPath": "avatars/folder/cat.jpg"
  *   },
  *   "error": null
  * }
  * ```
  */
  async uploadToSignedUrl(path, token, fileBody, fileOptions) {
    var _this3 = this;
    const cleanPath = _this3._removeEmptyFolders(path);
    const _path = _this3._getFinalPath(cleanPath);
    const url = new URL(_this3.url + `/object/upload/sign/${_path}`);
    url.searchParams.set("token", token);
    return _this3.handleOperation(async () => {
      let body;
      const options = _objectSpread2({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);
      const headers = _objectSpread2(_objectSpread2({}, _this3.headers), { "x-upsert": String(options.upsert) });
      if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
        body = new FormData();
        body.append("cacheControl", options.cacheControl);
        body.append("", fileBody);
      } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
        body = fileBody;
        body.append("cacheControl", options.cacheControl);
      } else {
        body = fileBody;
        headers["cache-control"] = `max-age=${options.cacheControl}`;
        headers["content-type"] = options.contentType;
      }
      return {
        path: cleanPath,
        fullPath: (await put(_this3.fetch, url.toString(), body, { headers })).Key
      };
    });
  }
  /**
  * Creates a signed upload URL.
  * Signed upload URLs can be used to upload files to the bucket without further authentication.
  * They are valid for 2 hours.
  *
  * @category File Buckets
  * @param path The file path, including the current file name. For example `folder/image.png`.
  * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
  * @returns Promise with response containing signed upload URL, token, and path or error
  *
  * @example Create Signed Upload URL
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .createSignedUploadUrl('folder/cat.jpg')
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "signedUrl": "https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>",
  *     "path": "folder/cat.jpg",
  *     "token": "<TOKEN>"
  *   },
  *   "error": null
  * }
  * ```
  */
  async createSignedUploadUrl(path, options) {
    var _this4 = this;
    return _this4.handleOperation(async () => {
      let _path = _this4._getFinalPath(path);
      const headers = _objectSpread2({}, _this4.headers);
      if (options === null || options === void 0 ? void 0 : options.upsert) headers["x-upsert"] = "true";
      const data = await post(_this4.fetch, `${_this4.url}/object/upload/sign/${_path}`, {}, { headers });
      const url = new URL(_this4.url + data.url);
      const token = url.searchParams.get("token");
      if (!token) throw new StorageError("No token returned by API");
      return {
        signedUrl: url.toString(),
        path,
        token
      };
    });
  }
  /**
  * Replaces an existing file at the specified path with a new one.
  *
  * @category File Buckets
  * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
  * @param fileBody The body of the file to be stored in the bucket.
  * @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.
  * @returns Promise with response containing file path, id, and fullPath or error
  *
  * @example Update file
  * ```js
  * const avatarFile = event.target.files[0]
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .update('public/avatar1.png', avatarFile, {
  *     cacheControl: '3600',
  *     upsert: true
  *   })
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "path": "public/avatar1.png",
  *     "fullPath": "avatars/public/avatar1.png"
  *   },
  *   "error": null
  * }
  * ```
  *
  * @example Update file using `ArrayBuffer` from base64 file data
  * ```js
  * import {decode} from 'base64-arraybuffer'
  *
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .update('public/avatar1.png', decode('base64FileData'), {
  *     contentType: 'image/png'
  *   })
  * ```
  */
  async update(path, fileBody, fileOptions) {
    return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
  }
  /**
  * Moves an existing file to a new path in the same bucket.
  *
  * @category File Buckets
  * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
  * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
  * @param options The destination options.
  * @returns Promise with response containing success message or error
  *
  * @example Move file
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .move('public/avatar1.png', 'private/avatar2.png')
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "message": "Successfully moved"
  *   },
  *   "error": null
  * }
  * ```
  */
  async move(fromPath, toPath, options) {
    var _this6 = this;
    return _this6.handleOperation(async () => {
      return await post(_this6.fetch, `${_this6.url}/object/move`, {
        bucketId: _this6.bucketId,
        sourceKey: fromPath,
        destinationKey: toPath,
        destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
      }, { headers: _this6.headers });
    });
  }
  /**
  * Copies an existing file to a new path in the same bucket.
  *
  * @category File Buckets
  * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
  * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
  * @param options The destination options.
  * @returns Promise with response containing copied file path or error
  *
  * @example Copy file
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .copy('public/avatar1.png', 'private/avatar2.png')
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "path": "avatars/private/avatar2.png"
  *   },
  *   "error": null
  * }
  * ```
  */
  async copy(fromPath, toPath, options) {
    var _this7 = this;
    return _this7.handleOperation(async () => {
      return { path: (await post(_this7.fetch, `${_this7.url}/object/copy`, {
        bucketId: _this7.bucketId,
        sourceKey: fromPath,
        destinationKey: toPath,
        destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
      }, { headers: _this7.headers })).Key };
    });
  }
  /**
  * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
  *
  * @category File Buckets
  * @param path The file path, including the current file name. For example `folder/image.png`.
  * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
  * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
  * @param options.transform Transform the asset before serving it to the client.
  * @returns Promise with response containing signed URL or error
  *
  * @example Create Signed URL
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .createSignedUrl('folder/avatar1.png', 60)
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>"
  *   },
  *   "error": null
  * }
  * ```
  *
  * @example Create a signed URL for an asset with transformations
  * ```js
  * const { data } = await supabase
  *   .storage
  *   .from('avatars')
  *   .createSignedUrl('folder/avatar1.png', 60, {
  *     transform: {
  *       width: 100,
  *       height: 100,
  *     }
  *   })
  * ```
  *
  * @example Create a signed URL which triggers the download of the asset
  * ```js
  * const { data } = await supabase
  *   .storage
  *   .from('avatars')
  *   .createSignedUrl('folder/avatar1.png', 60, {
  *     download: true,
  *   })
  * ```
  */
  async createSignedUrl(path, expiresIn, options) {
    var _this8 = this;
    return _this8.handleOperation(async () => {
      let _path = _this8._getFinalPath(path);
      let data = await post(_this8.fetch, `${_this8.url}/object/sign/${_path}`, _objectSpread2({ expiresIn }, (options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {}), { headers: _this8.headers });
      const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
      return { signedUrl: encodeURI(`${_this8.url}${data.signedURL}${downloadQueryParam}`) };
    });
  }
  /**
  * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
  *
  * @category File Buckets
  * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
  * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
  * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
  * @returns Promise with response containing array of objects with signedUrl, path, and error or error
  *
  * @example Create Signed URLs
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": [
  *     {
  *       "error": null,
  *       "path": "folder/avatar1.png",
  *       "signedURL": "/object/sign/avatars/folder/avatar1.png?token=<TOKEN>",
  *       "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>"
  *     },
  *     {
  *       "error": null,
  *       "path": "folder/avatar2.png",
  *       "signedURL": "/object/sign/avatars/folder/avatar2.png?token=<TOKEN>",
  *       "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>"
  *     }
  *   ],
  *   "error": null
  * }
  * ```
  */
  async createSignedUrls(paths, expiresIn, options) {
    var _this9 = this;
    return _this9.handleOperation(async () => {
      const data = await post(_this9.fetch, `${_this9.url}/object/sign/${_this9.bucketId}`, {
        expiresIn,
        paths
      }, { headers: _this9.headers });
      const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
      return data.map((datum) => _objectSpread2(_objectSpread2({}, datum), {}, { signedUrl: datum.signedURL ? encodeURI(`${_this9.url}${datum.signedURL}${downloadQueryParam}`) : null }));
    });
  }
  /**
  * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
  *
  * @category File Buckets
  * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
  * @param options.transform Transform the asset before serving it to the client.
  * @returns BlobDownloadBuilder instance for downloading the file
  *
  * @example Download file
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .download('folder/avatar1.png')
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": <BLOB>,
  *   "error": null
  * }
  * ```
  *
  * @example Download file with transformations
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .download('folder/avatar1.png', {
  *     transform: {
  *       width: 100,
  *       height: 100,
  *       quality: 80
  *     }
  *   })
  * ```
  */
  download(path, options) {
    const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined" ? "render/image/authenticated" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    const queryString = transformationQuery ? `?${transformationQuery}` : "";
    const _path = this._getFinalPath(path);
    const downloadFn = () => get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
      headers: this.headers,
      noResolveJson: true
    });
    return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);
  }
  /**
  * Retrieves the details of an existing file.
  *
  * @category File Buckets
  * @param path The file path, including the file name. For example `folder/image.png`.
  * @returns Promise with response containing file metadata or error
  *
  * @example Get file info
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .info('folder/avatar1.png')
  * ```
  */
  async info(path) {
    var _this10 = this;
    const _path = _this10._getFinalPath(path);
    return _this10.handleOperation(async () => {
      return recursiveToCamel(await get(_this10.fetch, `${_this10.url}/object/info/${_path}`, { headers: _this10.headers }));
    });
  }
  /**
  * Checks the existence of a file.
  *
  * @category File Buckets
  * @param path The file path, including the file name. For example `folder/image.png`.
  * @returns Promise with response containing boolean indicating file existence or error
  *
  * @example Check file existence
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .exists('folder/avatar1.png')
  * ```
  */
  async exists(path) {
    var _this11 = this;
    const _path = _this11._getFinalPath(path);
    try {
      await head(_this11.fetch, `${_this11.url}/object/${_path}`, { headers: _this11.headers });
      return {
        data: true,
        error: null
      };
    } catch (error) {
      if (_this11.shouldThrowOnError) throw error;
      if (isStorageError(error) && error instanceof StorageUnknownError) {
        const originalError = error.originalError;
        if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) return {
          data: false,
          error
        };
      }
      throw error;
    }
  }
  /**
  * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
  * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
  *
  * @category File Buckets
  * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
  * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
  * @param options.transform Transform the asset before serving it to the client.
  * @returns Object with public URL
  *
  * @example Returns the URL for an asset in a public bucket
  * ```js
  * const { data } = supabase
  *   .storage
  *   .from('public-bucket')
  *   .getPublicUrl('folder/avatar1.png')
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "publicUrl": "https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png"
  *   }
  * }
  * ```
  *
  * @example Returns the URL for an asset in a public bucket with transformations
  * ```js
  * const { data } = supabase
  *   .storage
  *   .from('public-bucket')
  *   .getPublicUrl('folder/avatar1.png', {
  *     transform: {
  *       width: 100,
  *       height: 100,
  *     }
  *   })
  * ```
  *
  * @example Returns the URL which triggers the download of an asset in a public bucket
  * ```js
  * const { data } = supabase
  *   .storage
  *   .from('public-bucket')
  *   .getPublicUrl('folder/avatar1.png', {
  *     download: true,
  *   })
  * ```
  */
  getPublicUrl(path, options) {
    const _path = this._getFinalPath(path);
    const _queryString = [];
    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
    if (downloadQueryParam !== "") _queryString.push(downloadQueryParam);
    const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined" ? "render/image" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    if (transformationQuery !== "") _queryString.push(transformationQuery);
    let queryString = _queryString.join("&");
    if (queryString !== "") queryString = `?${queryString}`;
    return { data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) } };
  }
  /**
  * Deletes files within the same bucket
  *
  * @category File Buckets
  * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
  * @returns Promise with response containing array of deleted file objects or error
  *
  * @example Delete file
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .remove(['folder/avatar1.png'])
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": [],
  *   "error": null
  * }
  * ```
  */
  async remove(paths) {
    var _this12 = this;
    return _this12.handleOperation(async () => {
      return await remove(_this12.fetch, `${_this12.url}/object/${_this12.bucketId}`, { prefixes: paths }, { headers: _this12.headers });
    });
  }
  /**
  * Get file metadata
  * @param id the file id to retrieve metadata
  */
  /**
  * Update file metadata
  * @param id the file id to update metadata
  * @param meta the new file metadata
  */
  /**
  * Lists all the files and folders within a path of the bucket.
  *
  * @category File Buckets
  * @param path The folder path.
  * @param options Search options including limit (defaults to 100), offset, sortBy, and search
  * @param parameters Optional fetch parameters including signal for cancellation
  * @returns Promise with response containing array of files or error
  *
  * @example List files in a bucket
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .list('folder', {
  *     limit: 100,
  *     offset: 0,
  *     sortBy: { column: 'name', order: 'asc' },
  *   })
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": [
  *     {
  *       "name": "avatar1.png",
  *       "id": "e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2",
  *       "updated_at": "2024-05-22T23:06:05.580Z",
  *       "created_at": "2024-05-22T23:04:34.443Z",
  *       "last_accessed_at": "2024-05-22T23:04:34.443Z",
  *       "metadata": {
  *         "eTag": "\"c5e8c553235d9af30ef4f6e280790b92\"",
  *         "size": 32175,
  *         "mimetype": "image/png",
  *         "cacheControl": "max-age=3600",
  *         "lastModified": "2024-05-22T23:06:05.574Z",
  *         "contentLength": 32175,
  *         "httpStatusCode": 200
  *       }
  *     }
  *   ],
  *   "error": null
  * }
  * ```
  *
  * @example Search files in a bucket
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .from('avatars')
  *   .list('folder', {
  *     limit: 100,
  *     offset: 0,
  *     sortBy: { column: 'name', order: 'asc' },
  *     search: 'jon'
  *   })
  * ```
  */
  async list(path, options, parameters) {
    var _this13 = this;
    return _this13.handleOperation(async () => {
      const body = _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_SEARCH_OPTIONS), options), {}, { prefix: path || "" });
      return await post(_this13.fetch, `${_this13.url}/object/list/${_this13.bucketId}`, body, { headers: _this13.headers }, parameters);
    });
  }
  /**
  * @experimental this method signature might change in the future
  *
  * @category File Buckets
  * @param options search options
  * @param parameters
  */
  async listV2(options, parameters) {
    var _this14 = this;
    return _this14.handleOperation(async () => {
      const body = _objectSpread2({}, options);
      return await post(_this14.fetch, `${_this14.url}/object/list-v2/${_this14.bucketId}`, body, { headers: _this14.headers }, parameters);
    });
  }
  encodeMetadata(metadata) {
    return JSON.stringify(metadata);
  }
  toBase64(data) {
    if (typeof Buffer !== "undefined") return Buffer.from(data).toString("base64");
    return btoa(data);
  }
  _getFinalPath(path) {
    return `${this.bucketId}/${path.replace(/^\/+/, "")}`;
  }
  _removeEmptyFolders(path) {
    return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(transform) {
    const params = [];
    if (transform.width) params.push(`width=${transform.width}`);
    if (transform.height) params.push(`height=${transform.height}`);
    if (transform.resize) params.push(`resize=${transform.resize}`);
    if (transform.format) params.push(`format=${transform.format}`);
    if (transform.quality) params.push(`quality=${transform.quality}`);
    return params.join("&");
  }
};
var version2 = "2.93.3";
var DEFAULT_HEADERS = { "X-Client-Info": `storage-js/${version2}` };
var StorageBucketApi = class extends BaseApiClient {
  constructor(url, headers = {}, fetch$1, opts) {
    const baseUrl = new URL(url);
    if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {
      if (/supabase\.(co|in|red)$/.test(baseUrl.hostname) && !baseUrl.hostname.includes("storage.supabase.")) baseUrl.hostname = baseUrl.hostname.replace("supabase.", "storage.supabase.");
    }
    const finalUrl = baseUrl.href.replace(/\/$/, "");
    const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);
    super(finalUrl, finalHeaders, fetch$1, "storage");
  }
  /**
  * Retrieves the details of all Storage buckets within an existing project.
  *
  * @category File Buckets
  * @param options Query parameters for listing buckets
  * @param options.limit Maximum number of buckets to return
  * @param options.offset Number of buckets to skip
  * @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')
  * @param options.sortOrder Sort order ('asc' or 'desc')
  * @param options.search Search term to filter bucket names
  * @returns Promise with response containing array of buckets or error
  *
  * @example List buckets
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .listBuckets()
  * ```
  *
  * @example List buckets with options
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .listBuckets({
  *     limit: 10,
  *     offset: 0,
  *     sortColumn: 'created_at',
  *     sortOrder: 'desc',
  *     search: 'prod'
  *   })
  * ```
  */
  async listBuckets(options) {
    var _this = this;
    return _this.handleOperation(async () => {
      const queryString = _this.listBucketOptionsToQueryString(options);
      return await get(_this.fetch, `${_this.url}/bucket${queryString}`, { headers: _this.headers });
    });
  }
  /**
  * Retrieves the details of an existing Storage bucket.
  *
  * @category File Buckets
  * @param id The unique identifier of the bucket you would like to retrieve.
  * @returns Promise with response containing bucket details or error
  *
  * @example Get bucket
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .getBucket('avatars')
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "id": "avatars",
  *     "name": "avatars",
  *     "owner": "",
  *     "public": false,
  *     "file_size_limit": 1024,
  *     "allowed_mime_types": [
  *       "image/png"
  *     ],
  *     "created_at": "2024-05-22T22:26:05.100Z",
  *     "updated_at": "2024-05-22T22:26:05.100Z"
  *   },
  *   "error": null
  * }
  * ```
  */
  async getBucket(id) {
    var _this2 = this;
    return _this2.handleOperation(async () => {
      return await get(_this2.fetch, `${_this2.url}/bucket/${id}`, { headers: _this2.headers });
    });
  }
  /**
  * Creates a new Storage bucket
  *
  * @category File Buckets
  * @param id A unique identifier for the bucket you are creating.
  * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
  * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
  * The global file size limit takes precedence over this value.
  * The default value is null, which doesn't set a per bucket file size limit.
  * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
  * The default value is null, which allows files with all mime types to be uploaded.
  * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
  * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.
  *   - default bucket type is `STANDARD`
  * @returns Promise with response containing newly created bucket name or error
  *
  * @example Create bucket
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .createBucket('avatars', {
  *     public: false,
  *     allowedMimeTypes: ['image/png'],
  *     fileSizeLimit: 1024
  *   })
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "name": "avatars"
  *   },
  *   "error": null
  * }
  * ```
  */
  async createBucket(id, options = { public: false }) {
    var _this3 = this;
    return _this3.handleOperation(async () => {
      return await post(_this3.fetch, `${_this3.url}/bucket`, {
        id,
        name: id,
        type: options.type,
        public: options.public,
        file_size_limit: options.fileSizeLimit,
        allowed_mime_types: options.allowedMimeTypes
      }, { headers: _this3.headers });
    });
  }
  /**
  * Updates a Storage bucket
  *
  * @category File Buckets
  * @param id A unique identifier for the bucket you are updating.
  * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
  * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
  * The global file size limit takes precedence over this value.
  * The default value is null, which doesn't set a per bucket file size limit.
  * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
  * The default value is null, which allows files with all mime types to be uploaded.
  * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
  * @returns Promise with response containing success message or error
  *
  * @example Update bucket
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .updateBucket('avatars', {
  *     public: false,
  *     allowedMimeTypes: ['image/png'],
  *     fileSizeLimit: 1024
  *   })
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "message": "Successfully updated"
  *   },
  *   "error": null
  * }
  * ```
  */
  async updateBucket(id, options) {
    var _this4 = this;
    return _this4.handleOperation(async () => {
      return await put(_this4.fetch, `${_this4.url}/bucket/${id}`, {
        id,
        name: id,
        public: options.public,
        file_size_limit: options.fileSizeLimit,
        allowed_mime_types: options.allowedMimeTypes
      }, { headers: _this4.headers });
    });
  }
  /**
  * Removes all objects inside a single bucket.
  *
  * @category File Buckets
  * @param id The unique identifier of the bucket you would like to empty.
  * @returns Promise with success message or error
  *
  * @example Empty bucket
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .emptyBucket('avatars')
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "message": "Successfully emptied"
  *   },
  *   "error": null
  * }
  * ```
  */
  async emptyBucket(id) {
    var _this5 = this;
    return _this5.handleOperation(async () => {
      return await post(_this5.fetch, `${_this5.url}/bucket/${id}/empty`, {}, { headers: _this5.headers });
    });
  }
  /**
  * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
  * You must first `empty()` the bucket.
  *
  * @category File Buckets
  * @param id The unique identifier of the bucket you would like to delete.
  * @returns Promise with success message or error
  *
  * @example Delete bucket
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .deleteBucket('avatars')
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "message": "Successfully deleted"
  *   },
  *   "error": null
  * }
  * ```
  */
  async deleteBucket(id) {
    var _this6 = this;
    return _this6.handleOperation(async () => {
      return await remove(_this6.fetch, `${_this6.url}/bucket/${id}`, {}, { headers: _this6.headers });
    });
  }
  listBucketOptionsToQueryString(options) {
    const params = {};
    if (options) {
      if ("limit" in options) params.limit = String(options.limit);
      if ("offset" in options) params.offset = String(options.offset);
      if (options.search) params.search = options.search;
      if (options.sortColumn) params.sortColumn = options.sortColumn;
      if (options.sortOrder) params.sortOrder = options.sortOrder;
    }
    return Object.keys(params).length > 0 ? "?" + new URLSearchParams(params).toString() : "";
  }
};
var StorageAnalyticsClient = class extends BaseApiClient {
  /**
  * @alpha
  *
  * Creates a new StorageAnalyticsClient instance
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Analytics Buckets
  * @param url - The base URL for the storage API
  * @param headers - HTTP headers to include in requests
  * @param fetch - Optional custom fetch implementation
  *
  * @example
  * ```typescript
  * const client = new StorageAnalyticsClient(url, headers)
  * ```
  */
  constructor(url, headers = {}, fetch$1) {
    const finalUrl = url.replace(/\/$/, "");
    const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);
    super(finalUrl, finalHeaders, fetch$1, "storage");
  }
  /**
  * @alpha
  *
  * Creates a new analytics bucket using Iceberg tables
  * Analytics buckets are optimized for analytical queries and data processing
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Analytics Buckets
  * @param name A unique name for the bucket you are creating
  * @returns Promise with response containing newly created analytics bucket or error
  *
  * @example Create analytics bucket
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .analytics
  *   .createBucket('analytics-data')
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "name": "analytics-data",
  *     "type": "ANALYTICS",
  *     "format": "iceberg",
  *     "created_at": "2024-05-22T22:26:05.100Z",
  *     "updated_at": "2024-05-22T22:26:05.100Z"
  *   },
  *   "error": null
  * }
  * ```
  */
  async createBucket(name) {
    var _this = this;
    return _this.handleOperation(async () => {
      return await post(_this.fetch, `${_this.url}/bucket`, { name }, { headers: _this.headers });
    });
  }
  /**
  * @alpha
  *
  * Retrieves the details of all Analytics Storage buckets within an existing project
  * Only returns buckets of type 'ANALYTICS'
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Analytics Buckets
  * @param options Query parameters for listing buckets
  * @param options.limit Maximum number of buckets to return
  * @param options.offset Number of buckets to skip
  * @param options.sortColumn Column to sort by ('name', 'created_at', 'updated_at')
  * @param options.sortOrder Sort order ('asc' or 'desc')
  * @param options.search Search term to filter bucket names
  * @returns Promise with response containing array of analytics buckets or error
  *
  * @example List analytics buckets
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .analytics
  *   .listBuckets({
  *     limit: 10,
  *     offset: 0,
  *     sortColumn: 'created_at',
  *     sortOrder: 'desc'
  *   })
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": [
  *     {
  *       "name": "analytics-data",
  *       "type": "ANALYTICS",
  *       "format": "iceberg",
  *       "created_at": "2024-05-22T22:26:05.100Z",
  *       "updated_at": "2024-05-22T22:26:05.100Z"
  *     }
  *   ],
  *   "error": null
  * }
  * ```
  */
  async listBuckets(options) {
    var _this2 = this;
    return _this2.handleOperation(async () => {
      const queryParams = new URLSearchParams();
      if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0) queryParams.set("limit", options.limit.toString());
      if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0) queryParams.set("offset", options.offset.toString());
      if (options === null || options === void 0 ? void 0 : options.sortColumn) queryParams.set("sortColumn", options.sortColumn);
      if (options === null || options === void 0 ? void 0 : options.sortOrder) queryParams.set("sortOrder", options.sortOrder);
      if (options === null || options === void 0 ? void 0 : options.search) queryParams.set("search", options.search);
      const queryString = queryParams.toString();
      const url = queryString ? `${_this2.url}/bucket?${queryString}` : `${_this2.url}/bucket`;
      return await get(_this2.fetch, url, { headers: _this2.headers });
    });
  }
  /**
  * @alpha
  *
  * Deletes an existing analytics bucket
  * A bucket can't be deleted with existing objects inside it
  * You must first empty the bucket before deletion
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Analytics Buckets
  * @param bucketName The unique identifier of the bucket you would like to delete
  * @returns Promise with response containing success message or error
  *
  * @example Delete analytics bucket
  * ```js
  * const { data, error } = await supabase
  *   .storage
  *   .analytics
  *   .deleteBucket('analytics-data')
  * ```
  *
  * Response:
  * ```json
  * {
  *   "data": {
  *     "message": "Successfully deleted"
  *   },
  *   "error": null
  * }
  * ```
  */
  async deleteBucket(bucketName) {
    var _this3 = this;
    return _this3.handleOperation(async () => {
      return await remove(_this3.fetch, `${_this3.url}/bucket/${bucketName}`, {}, { headers: _this3.headers });
    });
  }
  /**
  * @alpha
  *
  * Get an Iceberg REST Catalog client configured for a specific analytics bucket
  * Use this to perform advanced table and namespace operations within the bucket
  * The returned client provides full access to the Apache Iceberg REST Catalog API
  * with the Supabase `{ data, error }` pattern for consistent error handling on all operations.
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Analytics Buckets
  * @param bucketName - The name of the analytics bucket (warehouse) to connect to
  * @returns The wrapped Iceberg catalog client
  * @throws {StorageError} If the bucket name is invalid
  *
  * @example Get catalog and create table
  * ```js
  * // First, create an analytics bucket
  * const { data: bucket, error: bucketError } = await supabase
  *   .storage
  *   .analytics
  *   .createBucket('analytics-data')
  *
  * // Get the Iceberg catalog for that bucket
  * const catalog = supabase.storage.analytics.from('analytics-data')
  *
  * // Create a namespace
  * const { error: nsError } = await catalog.createNamespace({ namespace: ['default'] })
  *
  * // Create a table with schema
  * const { data: tableMetadata, error: tableError } = await catalog.createTable(
  *   { namespace: ['default'] },
  *   {
  *     name: 'events',
  *     schema: {
  *       type: 'struct',
  *       fields: [
  *         { id: 1, name: 'id', type: 'long', required: true },
  *         { id: 2, name: 'timestamp', type: 'timestamp', required: true },
  *         { id: 3, name: 'user_id', type: 'string', required: false }
  *       ],
  *       'schema-id': 0,
  *       'identifier-field-ids': [1]
  *     },
  *     'partition-spec': {
  *       'spec-id': 0,
  *       fields: []
  *     },
  *     'write-order': {
  *       'order-id': 0,
  *       fields: []
  *     },
  *     properties: {
  *       'write.format.default': 'parquet'
  *     }
  *   }
  * )
  * ```
  *
  * @example List tables in namespace
  * ```js
  * const catalog = supabase.storage.analytics.from('analytics-data')
  *
  * // List all tables in the default namespace
  * const { data: tables, error: listError } = await catalog.listTables({ namespace: ['default'] })
  * if (listError) {
  *   if (listError.isNotFound()) {
  *     console.log('Namespace not found')
  *   }
  *   return
  * }
  * console.log(tables) // [{ namespace: ['default'], name: 'events' }]
  * ```
  *
  * @example Working with namespaces
  * ```js
  * const catalog = supabase.storage.analytics.from('analytics-data')
  *
  * // List all namespaces
  * const { data: namespaces } = await catalog.listNamespaces()
  *
  * // Create namespace with properties
  * await catalog.createNamespace(
  *   { namespace: ['production'] },
  *   { properties: { owner: 'data-team', env: 'prod' } }
  * )
  * ```
  *
  * @example Cleanup operations
  * ```js
  * const catalog = supabase.storage.analytics.from('analytics-data')
  *
  * // Drop table with purge option (removes all data)
  * const { error: dropError } = await catalog.dropTable(
  *   { namespace: ['default'], name: 'events' },
  *   { purge: true }
  * )
  *
  * if (dropError?.isNotFound()) {
  *   console.log('Table does not exist')
  * }
  *
  * // Drop namespace (must be empty)
  * await catalog.dropNamespace({ namespace: ['default'] })
  * ```
  *
  * @remarks
  * This method provides a bridge between Supabase's bucket management and the standard
  * Apache Iceberg REST Catalog API. The bucket name maps to the Iceberg warehouse parameter.
  * All authentication and configuration is handled automatically using your Supabase credentials.
  *
  * **Error Handling**: Invalid bucket names throw immediately. All catalog
  * operations return `{ data, error }` where errors are `IcebergError` instances from iceberg-js.
  * Use helper methods like `error.isNotFound()` or check `error.status` for specific error handling.
  * Use `.throwOnError()` on the analytics client if you prefer exceptions for catalog operations.
  *
  * **Cleanup Operations**: When using `dropTable`, the `purge: true` option permanently
  * deletes all table data. Without it, the table is marked as deleted but data remains.
  *
  * **Library Dependency**: The returned catalog wraps `IcebergRestCatalog` from iceberg-js.
  * For complete API documentation and advanced usage, refer to the
  * [iceberg-js documentation](https://supabase.github.io/iceberg-js/).
  */
  from(bucketName) {
    var _this4 = this;
    if (!isValidBucketName(bucketName)) throw new StorageError("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");
    const catalog = new IcebergRestCatalog({
      baseUrl: this.url,
      catalogName: bucketName,
      auth: {
        type: "custom",
        getHeaders: async () => _this4.headers
      },
      fetch: this.fetch
    });
    const shouldThrowOnError = this.shouldThrowOnError;
    return new Proxy(catalog, { get(target, prop) {
      const value = target[prop];
      if (typeof value !== "function") return value;
      return async (...args) => {
        try {
          return {
            data: await value.apply(target, args),
            error: null
          };
        } catch (error) {
          if (shouldThrowOnError) throw error;
          return {
            data: null,
            error
          };
        }
      };
    } });
  }
};
var VectorIndexApi = class extends BaseApiClient {
  /** Creates a new VectorIndexApi instance */
  constructor(url, headers = {}, fetch$1) {
    const finalUrl = url.replace(/\/$/, "");
    const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), {}, { "Content-Type": "application/json" }, headers);
    super(finalUrl, finalHeaders, fetch$1, "vectors");
  }
  /** Creates a new vector index within a bucket */
  async createIndex(options) {
    var _this = this;
    return _this.handleOperation(async () => {
      return await vectorsApi.post(_this.fetch, `${_this.url}/CreateIndex`, options, { headers: _this.headers }) || {};
    });
  }
  /** Retrieves metadata for a specific vector index */
  async getIndex(vectorBucketName, indexName) {
    var _this2 = this;
    return _this2.handleOperation(async () => {
      return await vectorsApi.post(_this2.fetch, `${_this2.url}/GetIndex`, {
        vectorBucketName,
        indexName
      }, { headers: _this2.headers });
    });
  }
  /** Lists vector indexes within a bucket with optional filtering and pagination */
  async listIndexes(options) {
    var _this3 = this;
    return _this3.handleOperation(async () => {
      return await vectorsApi.post(_this3.fetch, `${_this3.url}/ListIndexes`, options, { headers: _this3.headers });
    });
  }
  /** Deletes a vector index and all its data */
  async deleteIndex(vectorBucketName, indexName) {
    var _this4 = this;
    return _this4.handleOperation(async () => {
      return await vectorsApi.post(_this4.fetch, `${_this4.url}/DeleteIndex`, {
        vectorBucketName,
        indexName
      }, { headers: _this4.headers }) || {};
    });
  }
};
var VectorDataApi = class extends BaseApiClient {
  /** Creates a new VectorDataApi instance */
  constructor(url, headers = {}, fetch$1) {
    const finalUrl = url.replace(/\/$/, "");
    const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), {}, { "Content-Type": "application/json" }, headers);
    super(finalUrl, finalHeaders, fetch$1, "vectors");
  }
  /** Inserts or updates vectors in batch (1-500 per request) */
  async putVectors(options) {
    var _this = this;
    if (options.vectors.length < 1 || options.vectors.length > 500) throw new Error("Vector batch size must be between 1 and 500 items");
    return _this.handleOperation(async () => {
      return await vectorsApi.post(_this.fetch, `${_this.url}/PutVectors`, options, { headers: _this.headers }) || {};
    });
  }
  /** Retrieves vectors by their keys in batch */
  async getVectors(options) {
    var _this2 = this;
    return _this2.handleOperation(async () => {
      return await vectorsApi.post(_this2.fetch, `${_this2.url}/GetVectors`, options, { headers: _this2.headers });
    });
  }
  /** Lists vectors in an index with pagination */
  async listVectors(options) {
    var _this3 = this;
    if (options.segmentCount !== void 0) {
      if (options.segmentCount < 1 || options.segmentCount > 16) throw new Error("segmentCount must be between 1 and 16");
      if (options.segmentIndex !== void 0) {
        if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);
      }
    }
    return _this3.handleOperation(async () => {
      return await vectorsApi.post(_this3.fetch, `${_this3.url}/ListVectors`, options, { headers: _this3.headers });
    });
  }
  /** Queries for similar vectors using approximate nearest neighbor search */
  async queryVectors(options) {
    var _this4 = this;
    return _this4.handleOperation(async () => {
      return await vectorsApi.post(_this4.fetch, `${_this4.url}/QueryVectors`, options, { headers: _this4.headers });
    });
  }
  /** Deletes vectors by their keys in batch (1-500 per request) */
  async deleteVectors(options) {
    var _this5 = this;
    if (options.keys.length < 1 || options.keys.length > 500) throw new Error("Keys batch size must be between 1 and 500 items");
    return _this5.handleOperation(async () => {
      return await vectorsApi.post(_this5.fetch, `${_this5.url}/DeleteVectors`, options, { headers: _this5.headers }) || {};
    });
  }
};
var VectorBucketApi = class extends BaseApiClient {
  /** Creates a new VectorBucketApi instance */
  constructor(url, headers = {}, fetch$1) {
    const finalUrl = url.replace(/\/$/, "");
    const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), {}, { "Content-Type": "application/json" }, headers);
    super(finalUrl, finalHeaders, fetch$1, "vectors");
  }
  /** Creates a new vector bucket */
  async createBucket(vectorBucketName) {
    var _this = this;
    return _this.handleOperation(async () => {
      return await vectorsApi.post(_this.fetch, `${_this.url}/CreateVectorBucket`, { vectorBucketName }, { headers: _this.headers }) || {};
    });
  }
  /** Retrieves metadata for a specific vector bucket */
  async getBucket(vectorBucketName) {
    var _this2 = this;
    return _this2.handleOperation(async () => {
      return await vectorsApi.post(_this2.fetch, `${_this2.url}/GetVectorBucket`, { vectorBucketName }, { headers: _this2.headers });
    });
  }
  /** Lists vector buckets with optional filtering and pagination */
  async listBuckets(options = {}) {
    var _this3 = this;
    return _this3.handleOperation(async () => {
      return await vectorsApi.post(_this3.fetch, `${_this3.url}/ListVectorBuckets`, options, { headers: _this3.headers });
    });
  }
  /** Deletes a vector bucket (must be empty first) */
  async deleteBucket(vectorBucketName) {
    var _this4 = this;
    return _this4.handleOperation(async () => {
      return await vectorsApi.post(_this4.fetch, `${_this4.url}/DeleteVectorBucket`, { vectorBucketName }, { headers: _this4.headers }) || {};
    });
  }
};
var StorageVectorsClient = class extends VectorBucketApi {
  /**
  * @alpha
  *
  * Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param url - Base URL of the Storage Vectors REST API.
  * @param options.headers - Optional headers (for example `Authorization`) applied to every request.
  * @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.
  *
  * @example
  * ```typescript
  * const client = new StorageVectorsClient(url, options)
  * ```
  */
  constructor(url, options = {}) {
    super(url, options.headers || {}, options.fetch);
  }
  /**
  *
  * @alpha
  *
  * Access operations for a specific vector bucket
  * Returns a scoped client for index and vector operations within the bucket
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param vectorBucketName - Name of the vector bucket
  * @returns Bucket-scoped client with index and vector operations
  *
  * @example
  * ```typescript
  * const bucket = supabase.storage.vectors.from('embeddings-prod')
  * ```
  */
  from(vectorBucketName) {
    return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);
  }
  /**
  *
  * @alpha
  *
  * Creates a new vector bucket
  * Vector buckets are containers for vector indexes and their data
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param vectorBucketName - Unique name for the vector bucket
  * @returns Promise with empty response on success or error
  *
  * @example
  * ```typescript
  * const { data, error } = await supabase
  *   .storage
  *   .vectors
  *   .createBucket('embeddings-prod')
  * ```
  */
  async createBucket(vectorBucketName) {
    var _superprop_getCreateBucket = () => super.createBucket, _this = this;
    return _superprop_getCreateBucket().call(_this, vectorBucketName);
  }
  /**
  *
  * @alpha
  *
  * Retrieves metadata for a specific vector bucket
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param vectorBucketName - Name of the vector bucket
  * @returns Promise with bucket metadata or error
  *
  * @example
  * ```typescript
  * const { data, error } = await supabase
  *   .storage
  *   .vectors
  *   .getBucket('embeddings-prod')
  *
  * console.log('Bucket created:', data?.vectorBucket.creationTime)
  * ```
  */
  async getBucket(vectorBucketName) {
    var _superprop_getGetBucket = () => super.getBucket, _this2 = this;
    return _superprop_getGetBucket().call(_this2, vectorBucketName);
  }
  /**
  *
  * @alpha
  *
  * Lists all vector buckets with optional filtering and pagination
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param options - Optional filters (prefix, maxResults, nextToken)
  * @returns Promise with list of buckets or error
  *
  * @example
  * ```typescript
  * const { data, error } = await supabase
  *   .storage
  *   .vectors
  *   .listBuckets({ prefix: 'embeddings-' })
  *
  * data?.vectorBuckets.forEach(bucket => {
  *   console.log(bucket.vectorBucketName)
  * })
  * ```
  */
  async listBuckets(options = {}) {
    var _superprop_getListBuckets = () => super.listBuckets, _this3 = this;
    return _superprop_getListBuckets().call(_this3, options);
  }
  /**
  *
  * @alpha
  *
  * Deletes a vector bucket (bucket must be empty)
  * All indexes must be deleted before deleting the bucket
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param vectorBucketName - Name of the vector bucket to delete
  * @returns Promise with empty response on success or error
  *
  * @example
  * ```typescript
  * const { data, error } = await supabase
  *   .storage
  *   .vectors
  *   .deleteBucket('embeddings-old')
  * ```
  */
  async deleteBucket(vectorBucketName) {
    var _superprop_getDeleteBucket = () => super.deleteBucket, _this4 = this;
    return _superprop_getDeleteBucket().call(_this4, vectorBucketName);
  }
};
var VectorBucketScope = class extends VectorIndexApi {
  /**
  * @alpha
  *
  * Creates a helper that automatically scopes all index operations to the provided bucket.
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @example
  * ```typescript
  * const bucket = supabase.storage.vectors.from('embeddings-prod')
  * ```
  */
  constructor(url, headers, vectorBucketName, fetch$1) {
    super(url, headers, fetch$1);
    this.vectorBucketName = vectorBucketName;
  }
  /**
  *
  * @alpha
  *
  * Creates a new vector index in this bucket
  * Convenience method that automatically includes the bucket name
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param options - Index configuration (vectorBucketName is automatically set)
  * @returns Promise with empty response on success or error
  *
  * @example
  * ```typescript
  * const bucket = supabase.storage.vectors.from('embeddings-prod')
  * await bucket.createIndex({
  *   indexName: 'documents-openai',
  *   dataType: 'float32',
  *   dimension: 1536,
  *   distanceMetric: 'cosine',
  *   metadataConfiguration: {
  *     nonFilterableMetadataKeys: ['raw_text']
  *   }
  * })
  * ```
  */
  async createIndex(options) {
    var _superprop_getCreateIndex = () => super.createIndex, _this5 = this;
    return _superprop_getCreateIndex().call(_this5, _objectSpread2(_objectSpread2({}, options), {}, { vectorBucketName: _this5.vectorBucketName }));
  }
  /**
  *
  * @alpha
  *
  * Lists indexes in this bucket
  * Convenience method that automatically includes the bucket name
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param options - Listing options (vectorBucketName is automatically set)
  * @returns Promise with response containing indexes array and pagination token or error
  *
  * @example
  * ```typescript
  * const bucket = supabase.storage.vectors.from('embeddings-prod')
  * const { data } = await bucket.listIndexes({ prefix: 'documents-' })
  * ```
  */
  async listIndexes(options = {}) {
    var _superprop_getListIndexes = () => super.listIndexes, _this6 = this;
    return _superprop_getListIndexes().call(_this6, _objectSpread2(_objectSpread2({}, options), {}, { vectorBucketName: _this6.vectorBucketName }));
  }
  /**
  *
  * @alpha
  *
  * Retrieves metadata for a specific index in this bucket
  * Convenience method that automatically includes the bucket name
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param indexName - Name of the index to retrieve
  * @returns Promise with index metadata or error
  *
  * @example
  * ```typescript
  * const bucket = supabase.storage.vectors.from('embeddings-prod')
  * const { data } = await bucket.getIndex('documents-openai')
  * console.log('Dimension:', data?.index.dimension)
  * ```
  */
  async getIndex(indexName) {
    var _superprop_getGetIndex = () => super.getIndex, _this7 = this;
    return _superprop_getGetIndex().call(_this7, _this7.vectorBucketName, indexName);
  }
  /**
  *
  * @alpha
  *
  * Deletes an index from this bucket
  * Convenience method that automatically includes the bucket name
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param indexName - Name of the index to delete
  * @returns Promise with empty response on success or error
  *
  * @example
  * ```typescript
  * const bucket = supabase.storage.vectors.from('embeddings-prod')
  * await bucket.deleteIndex('old-index')
  * ```
  */
  async deleteIndex(indexName) {
    var _superprop_getDeleteIndex = () => super.deleteIndex, _this8 = this;
    return _superprop_getDeleteIndex().call(_this8, _this8.vectorBucketName, indexName);
  }
  /**
  *
  * @alpha
  *
  * Access operations for a specific index within this bucket
  * Returns a scoped client for vector data operations
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param indexName - Name of the index
  * @returns Index-scoped client with vector data operations
  *
  * @example
  * ```typescript
  * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
  *
  * // Insert vectors
  * await index.putVectors({
  *   vectors: [
  *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }
  *   ]
  * })
  *
  * // Query similar vectors
  * const { data } = await index.queryVectors({
  *   queryVector: { float32: [...] },
  *   topK: 5
  * })
  * ```
  */
  index(indexName) {
    return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);
  }
};
var VectorIndexScope = class extends VectorDataApi {
  /**
  *
  * @alpha
  *
  * Creates a helper that automatically scopes all vector operations to the provided bucket/index names.
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @example
  * ```typescript
  * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
  * ```
  */
  constructor(url, headers, vectorBucketName, indexName, fetch$1) {
    super(url, headers, fetch$1);
    this.vectorBucketName = vectorBucketName;
    this.indexName = indexName;
  }
  /**
  *
  * @alpha
  *
  * Inserts or updates vectors in this index
  * Convenience method that automatically includes bucket and index names
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param options - Vector insertion options (bucket and index names automatically set)
  * @returns Promise with empty response on success or error
  *
  * @example
  * ```typescript
  * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
  * await index.putVectors({
  *   vectors: [
  *     {
  *       key: 'doc-1',
  *       data: { float32: [0.1, 0.2, ...] },
  *       metadata: { title: 'Introduction', page: 1 }
  *     }
  *   ]
  * })
  * ```
  */
  async putVectors(options) {
    var _superprop_getPutVectors = () => super.putVectors, _this9 = this;
    return _superprop_getPutVectors().call(_this9, _objectSpread2(_objectSpread2({}, options), {}, {
      vectorBucketName: _this9.vectorBucketName,
      indexName: _this9.indexName
    }));
  }
  /**
  *
  * @alpha
  *
  * Retrieves vectors by keys from this index
  * Convenience method that automatically includes bucket and index names
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param options - Vector retrieval options (bucket and index names automatically set)
  * @returns Promise with response containing vectors array or error
  *
  * @example
  * ```typescript
  * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
  * const { data } = await index.getVectors({
  *   keys: ['doc-1', 'doc-2'],
  *   returnMetadata: true
  * })
  * ```
  */
  async getVectors(options) {
    var _superprop_getGetVectors = () => super.getVectors, _this10 = this;
    return _superprop_getGetVectors().call(_this10, _objectSpread2(_objectSpread2({}, options), {}, {
      vectorBucketName: _this10.vectorBucketName,
      indexName: _this10.indexName
    }));
  }
  /**
  *
  * @alpha
  *
  * Lists vectors in this index with pagination
  * Convenience method that automatically includes bucket and index names
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param options - Listing options (bucket and index names automatically set)
  * @returns Promise with response containing vectors array and pagination token or error
  *
  * @example
  * ```typescript
  * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
  * const { data } = await index.listVectors({
  *   maxResults: 500,
  *   returnMetadata: true
  * })
  * ```
  */
  async listVectors(options = {}) {
    var _superprop_getListVectors = () => super.listVectors, _this11 = this;
    return _superprop_getListVectors().call(_this11, _objectSpread2(_objectSpread2({}, options), {}, {
      vectorBucketName: _this11.vectorBucketName,
      indexName: _this11.indexName
    }));
  }
  /**
  *
  * @alpha
  *
  * Queries for similar vectors in this index
  * Convenience method that automatically includes bucket and index names
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param options - Query options (bucket and index names automatically set)
  * @returns Promise with response containing matches array of similar vectors ordered by distance or error
  *
  * @example
  * ```typescript
  * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
  * const { data } = await index.queryVectors({
  *   queryVector: { float32: [0.1, 0.2, ...] },
  *   topK: 5,
  *   filter: { category: 'technical' },
  *   returnDistance: true,
  *   returnMetadata: true
  * })
  * ```
  */
  async queryVectors(options) {
    var _superprop_getQueryVectors = () => super.queryVectors, _this12 = this;
    return _superprop_getQueryVectors().call(_this12, _objectSpread2(_objectSpread2({}, options), {}, {
      vectorBucketName: _this12.vectorBucketName,
      indexName: _this12.indexName
    }));
  }
  /**
  *
  * @alpha
  *
  * Deletes vectors by keys from this index
  * Convenience method that automatically includes bucket and index names
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @param options - Deletion options (bucket and index names automatically set)
  * @returns Promise with empty response on success or error
  *
  * @example
  * ```typescript
  * const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')
  * await index.deleteVectors({
  *   keys: ['doc-1', 'doc-2', 'doc-3']
  * })
  * ```
  */
  async deleteVectors(options) {
    var _superprop_getDeleteVectors = () => super.deleteVectors, _this13 = this;
    return _superprop_getDeleteVectors().call(_this13, _objectSpread2(_objectSpread2({}, options), {}, {
      vectorBucketName: _this13.vectorBucketName,
      indexName: _this13.indexName
    }));
  }
};
var StorageClient = class extends StorageBucketApi {
  /**
  * Creates a client for Storage buckets, files, analytics, and vectors.
  *
  * @category File Buckets
  * @example
  * ```ts
  * import { StorageClient } from '@supabase/storage-js'
  *
  * const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {
  *   apikey: 'public-anon-key',
  * })
  * const avatars = storage.from('avatars')
  * ```
  */
  constructor(url, headers = {}, fetch$1, opts) {
    super(url, headers, fetch$1, opts);
  }
  /**
  * Perform file operation in a bucket.
  *
  * @category File Buckets
  * @param id The bucket id to operate on.
  *
  * @example
  * ```typescript
  * const avatars = supabase.storage.from('avatars')
  * ```
  */
  from(id) {
    return new StorageFileApi(this.url, this.headers, id, this.fetch);
  }
  /**
  *
  * @alpha
  *
  * Access vector storage operations.
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Vector Buckets
  * @returns A StorageVectorsClient instance configured with the current storage settings.
  */
  get vectors() {
    return new StorageVectorsClient(this.url + "/vector", {
      headers: this.headers,
      fetch: this.fetch
    });
  }
  /**
  *
  * @alpha
  *
  * Access analytics storage operations using Iceberg tables.
  *
  * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
  *
  * @category Analytics Buckets
  * @returns A StorageAnalyticsClient instance configured with the current storage settings.
  */
  get analytics() {
    return new StorageAnalyticsClient(this.url + "/iceberg", this.headers, this.fetch);
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/version.js
var version3 = "2.93.3";

// node_modules/@supabase/auth-js/dist/module/lib/constants.js
var AUTO_REFRESH_TICK_DURATION_MS = 30 * 1e3;
var AUTO_REFRESH_TICK_THRESHOLD = 3;
var EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;
var GOTRUE_URL = "http://localhost:9999";
var STORAGE_KEY = "supabase.auth.token";
var DEFAULT_HEADERS2 = { "X-Client-Info": `gotrue-js/${version3}` };
var API_VERSION_HEADER_NAME = "X-Supabase-Api-Version";
var API_VERSIONS = {
  "2024-01-01": {
    timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
    name: "2024-01-01"
  }
};
var BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;
var JWKS_TTL = 10 * 60 * 1e3;

// node_modules/@supabase/auth-js/dist/module/lib/errors.js
var AuthError = class extends Error {
  constructor(message, status, code) {
    super(message);
    this.__isAuthError = true;
    this.name = "AuthError";
    this.status = status;
    this.code = code;
  }
};
function isAuthError(error) {
  return typeof error === "object" && error !== null && "__isAuthError" in error;
}
var AuthApiError = class extends AuthError {
  constructor(message, status, code) {
    super(message, status, code);
    this.name = "AuthApiError";
    this.status = status;
    this.code = code;
  }
};
function isAuthApiError(error) {
  return isAuthError(error) && error.name === "AuthApiError";
}
var AuthUnknownError = class extends AuthError {
  constructor(message, originalError) {
    super(message);
    this.name = "AuthUnknownError";
    this.originalError = originalError;
  }
};
var CustomAuthError = class extends AuthError {
  constructor(message, name, status, code) {
    super(message, status, code);
    this.name = name;
    this.status = status;
  }
};
var AuthSessionMissingError = class extends CustomAuthError {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
};
function isAuthSessionMissingError(error) {
  return isAuthError(error) && error.name === "AuthSessionMissingError";
}
var AuthInvalidTokenResponseError = class extends CustomAuthError {
  constructor() {
    super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0);
  }
};
var AuthInvalidCredentialsError = class extends CustomAuthError {
  constructor(message) {
    super(message, "AuthInvalidCredentialsError", 400, void 0);
  }
};
var AuthImplicitGrantRedirectError = class extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthImplicitGrantRedirectError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
};
function isAuthImplicitGrantRedirectError(error) {
  return isAuthError(error) && error.name === "AuthImplicitGrantRedirectError";
}
var AuthPKCEGrantCodeExchangeError = class extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthPKCEGrantCodeExchangeError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
};
var AuthPKCECodeVerifierMissingError = class extends CustomAuthError {
  constructor() {
    super("PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.", "AuthPKCECodeVerifierMissingError", 400, "pkce_code_verifier_not_found");
  }
};
var AuthRetryableFetchError = class extends CustomAuthError {
  constructor(message, status) {
    super(message, "AuthRetryableFetchError", status, void 0);
  }
};
function isAuthRetryableFetchError(error) {
  return isAuthError(error) && error.name === "AuthRetryableFetchError";
}
var AuthWeakPasswordError = class extends CustomAuthError {
  constructor(message, status, reasons) {
    super(message, "AuthWeakPasswordError", status, "weak_password");
    this.reasons = reasons;
  }
};
var AuthInvalidJwtError = class extends CustomAuthError {
  constructor(message) {
    super(message, "AuthInvalidJwtError", 400, "invalid_jwt");
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/base64url.js
var TO_BASE64URL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("");
var IGNORE_BASE64URL = " 	\n\r=".split("");
var FROM_BASE64URL = (() => {
  const charMap = new Array(128);
  for (let i = 0; i < charMap.length; i += 1) {
    charMap[i] = -1;
  }
  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {
    charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;
  }
  for (let i = 0; i < TO_BASE64URL.length; i += 1) {
    charMap[TO_BASE64URL[i].charCodeAt(0)] = i;
  }
  return charMap;
})();
function byteToBase64URL(byte, state, emit) {
  if (byte !== null) {
    state.queue = state.queue << 8 | byte;
    state.queuedBits += 8;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  } else if (state.queuedBits > 0) {
    state.queue = state.queue << 6 - state.queuedBits;
    state.queuedBits = 6;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  }
}
function byteFromBase64URL(charCode, state, emit) {
  const bits = FROM_BASE64URL[charCode];
  if (bits > -1) {
    state.queue = state.queue << 6 | bits;
    state.queuedBits += 6;
    while (state.queuedBits >= 8) {
      emit(state.queue >> state.queuedBits - 8 & 255);
      state.queuedBits -= 8;
    }
  } else if (bits === -2) {
    return;
  } else {
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`);
  }
}
function stringFromBase64URL(str) {
  const conv = [];
  const utf8Emit = (codepoint) => {
    conv.push(String.fromCodePoint(codepoint));
  };
  const utf8State = {
    utf8seq: 0,
    codepoint: 0
  };
  const b64State = { queue: 0, queuedBits: 0 };
  const byteEmit = (byte) => {
    stringFromUTF8(byte, utf8State, utf8Emit);
  };
  for (let i = 0; i < str.length; i += 1) {
    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);
  }
  return conv.join("");
}
function codepointToUTF8(codepoint, emit) {
  if (codepoint <= 127) {
    emit(codepoint);
    return;
  } else if (codepoint <= 2047) {
    emit(192 | codepoint >> 6);
    emit(128 | codepoint & 63);
    return;
  } else if (codepoint <= 65535) {
    emit(224 | codepoint >> 12);
    emit(128 | codepoint >> 6 & 63);
    emit(128 | codepoint & 63);
    return;
  } else if (codepoint <= 1114111) {
    emit(240 | codepoint >> 18);
    emit(128 | codepoint >> 12 & 63);
    emit(128 | codepoint >> 6 & 63);
    emit(128 | codepoint & 63);
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);
}
function stringToUTF8(str, emit) {
  for (let i = 0; i < str.length; i += 1) {
    let codepoint = str.charCodeAt(i);
    if (codepoint > 55295 && codepoint <= 56319) {
      const highSurrogate = (codepoint - 55296) * 1024 & 65535;
      const lowSurrogate = str.charCodeAt(i + 1) - 56320 & 65535;
      codepoint = (lowSurrogate | highSurrogate) + 65536;
      i += 1;
    }
    codepointToUTF8(codepoint, emit);
  }
}
function stringFromUTF8(byte, state, emit) {
  if (state.utf8seq === 0) {
    if (byte <= 127) {
      emit(byte);
      return;
    }
    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {
      if ((byte >> 7 - leadingBit & 1) === 0) {
        state.utf8seq = leadingBit;
        break;
      }
    }
    if (state.utf8seq === 2) {
      state.codepoint = byte & 31;
    } else if (state.utf8seq === 3) {
      state.codepoint = byte & 15;
    } else if (state.utf8seq === 4) {
      state.codepoint = byte & 7;
    } else {
      throw new Error("Invalid UTF-8 sequence");
    }
    state.utf8seq -= 1;
  } else if (state.utf8seq > 0) {
    if (byte <= 127) {
      throw new Error("Invalid UTF-8 sequence");
    }
    state.codepoint = state.codepoint << 6 | byte & 63;
    state.utf8seq -= 1;
    if (state.utf8seq === 0) {
      emit(state.codepoint);
    }
  }
}
function base64UrlToUint8Array(str) {
  const result = [];
  const state = { queue: 0, queuedBits: 0 };
  const onByte = (byte) => {
    result.push(byte);
  };
  for (let i = 0; i < str.length; i += 1) {
    byteFromBase64URL(str.charCodeAt(i), state, onByte);
  }
  return new Uint8Array(result);
}
function stringToUint8Array(str) {
  const result = [];
  stringToUTF8(str, (byte) => result.push(byte));
  return new Uint8Array(result);
}
function bytesToBase64URL(bytes) {
  const result = [];
  const state = { queue: 0, queuedBits: 0 };
  const onChar = (char) => {
    result.push(char);
  };
  bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));
  byteToBase64URL(null, state, onChar);
  return result.join("");
}

// node_modules/@supabase/auth-js/dist/module/lib/helpers.js
function expiresAt(expiresIn) {
  const timeNow = Math.round(Date.now() / 1e3);
  return timeNow + expiresIn;
}
function generateCallbackId() {
  return /* @__PURE__ */ Symbol("auth-callback");
}
var isBrowser = () => typeof window !== "undefined" && typeof document !== "undefined";
var localStorageWriteTests = {
  tested: false,
  writable: false
};
var supportsLocalStorage = () => {
  if (!isBrowser()) {
    return false;
  }
  try {
    if (typeof globalThis.localStorage !== "object") {
      return false;
    }
  } catch (e) {
    return false;
  }
  if (localStorageWriteTests.tested) {
    return localStorageWriteTests.writable;
  }
  const randomKey = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(randomKey, randomKey);
    globalThis.localStorage.removeItem(randomKey);
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = true;
  } catch (e) {
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = false;
  }
  return localStorageWriteTests.writable;
};
function parseParametersFromURL(href) {
  const result = {};
  const url = new URL(href);
  if (url.hash && url.hash[0] === "#") {
    try {
      const hashSearchParams = new URLSearchParams(url.hash.substring(1));
      hashSearchParams.forEach((value, key) => {
        result[key] = value;
      });
    } catch (e) {
    }
  }
  url.searchParams.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
var resolveFetch3 = (customFetch) => {
  if (customFetch) {
    return (...args) => customFetch(...args);
  }
  return (...args) => fetch(...args);
};
var looksLikeFetchResponse = (maybeResponse) => {
  return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
};
var setItemAsync = async (storage, key, data) => {
  await storage.setItem(key, JSON.stringify(data));
};
var getItemAsync = async (storage, key) => {
  const value = await storage.getItem(key);
  if (!value) {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
};
var removeItemAsync = async (storage, key) => {
  await storage.removeItem(key);
};
var Deferred = class _Deferred {
  constructor() {
    ;
    this.promise = new _Deferred.promiseConstructor((res, rej) => {
      ;
      this.resolve = res;
      this.reject = rej;
    });
  }
};
Deferred.promiseConstructor = Promise;
function decodeJWT(token) {
  const parts = token.split(".");
  if (parts.length !== 3) {
    throw new AuthInvalidJwtError("Invalid JWT structure");
  }
  for (let i = 0; i < parts.length; i++) {
    if (!BASE64URL_REGEX.test(parts[i])) {
      throw new AuthInvalidJwtError("JWT not in base64url format");
    }
  }
  const data = {
    // using base64url lib
    header: JSON.parse(stringFromBase64URL(parts[0])),
    payload: JSON.parse(stringFromBase64URL(parts[1])),
    signature: base64UrlToUint8Array(parts[2]),
    raw: {
      header: parts[0],
      payload: parts[1]
    }
  };
  return data;
}
async function sleep(time) {
  return await new Promise((accept) => {
    setTimeout(() => accept(null), time);
  });
}
function retryable(fn, isRetryable) {
  const promise = new Promise((accept, reject) => {
    ;
    (async () => {
      for (let attempt = 0; attempt < Infinity; attempt++) {
        try {
          const result = await fn(attempt);
          if (!isRetryable(attempt, null, result)) {
            accept(result);
            return;
          }
        } catch (e) {
          if (!isRetryable(attempt, e)) {
            reject(e);
            return;
          }
        }
      }
    })();
  });
  return promise;
}
function dec2hex(dec) {
  return ("0" + dec.toString(16)).substr(-2);
}
function generatePKCEVerifier() {
  const verifierLength = 56;
  const array = new Uint32Array(verifierLength);
  if (typeof crypto === "undefined") {
    const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    const charSetLen = charSet.length;
    let verifier = "";
    for (let i = 0; i < verifierLength; i++) {
      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
    }
    return verifier;
  }
  crypto.getRandomValues(array);
  return Array.from(array, dec2hex).join("");
}
async function sha256(randomString) {
  const encoder = new TextEncoder();
  const encodedData = encoder.encode(randomString);
  const hash = await crypto.subtle.digest("SHA-256", encodedData);
  const bytes = new Uint8Array(hash);
  return Array.from(bytes).map((c) => String.fromCharCode(c)).join("");
}
async function generatePKCEChallenge(verifier) {
  const hasCryptoSupport = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof TextEncoder !== "undefined";
  if (!hasCryptoSupport) {
    console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
    return verifier;
  }
  const hashed = await sha256(verifier);
  return btoa(hashed).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {
  const codeVerifier = generatePKCEVerifier();
  let storedCodeVerifier = codeVerifier;
  if (isPasswordRecovery) {
    storedCodeVerifier += "/PASSWORD_RECOVERY";
  }
  await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
  const codeChallenge = await generatePKCEChallenge(codeVerifier);
  const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
  return [codeChallenge, codeChallengeMethod];
}
var API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function parseResponseAPIVersion(response) {
  const apiVersion = response.headers.get(API_VERSION_HEADER_NAME);
  if (!apiVersion) {
    return null;
  }
  if (!apiVersion.match(API_VERSION_REGEX)) {
    return null;
  }
  try {
    const date = /* @__PURE__ */ new Date(`${apiVersion}T00:00:00.0Z`);
    return date;
  } catch (e) {
    return null;
  }
}
function validateExp(exp) {
  if (!exp) {
    throw new Error("Missing exp claim");
  }
  const timeNow = Math.floor(Date.now() / 1e3);
  if (exp <= timeNow) {
    throw new Error("JWT has expired");
  }
}
function getAlgorithm(alg) {
  switch (alg) {
    case "RS256":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      };
    case "ES256":
      return {
        name: "ECDSA",
        namedCurve: "P-256",
        hash: { name: "SHA-256" }
      };
    default:
      throw new Error("Invalid alg claim");
  }
}
var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function validateUUID(str) {
  if (!UUID_REGEX.test(str)) {
    throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not");
  }
}
function userNotAvailableProxy() {
  const proxyTarget = {};
  return new Proxy(proxyTarget, {
    get: (target, prop) => {
      if (prop === "__isUserNotAvailableProxy") {
        return true;
      }
      if (typeof prop === "symbol") {
        const sProp = prop.toString();
        if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)") {
          return void 0;
        }
      }
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${prop}" property of the session object is not supported. Please use getUser() instead.`);
    },
    set: (_target, prop) => {
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    },
    deleteProperty: (_target, prop) => {
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    }
  });
}
function insecureUserWarningProxy(user, suppressWarningRef) {
  return new Proxy(user, {
    get: (target, prop, receiver) => {
      if (prop === "__isInsecureUserWarningProxy") {
        return true;
      }
      if (typeof prop === "symbol") {
        const sProp = prop.toString();
        if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)" || sProp === "Symbol(nodejs.util.inspect.custom)") {
          return Reflect.get(target, prop, receiver);
        }
      }
      if (!suppressWarningRef.value && typeof prop === "string") {
        console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.");
        suppressWarningRef.value = true;
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// node_modules/@supabase/auth-js/dist/module/lib/fetch.js
var _getErrorMessage2 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
var NETWORK_ERROR_CODES = [502, 503, 504];
async function handleError2(error) {
  var _a;
  if (!looksLikeFetchResponse(error)) {
    throw new AuthRetryableFetchError(_getErrorMessage2(error), 0);
  }
  if (NETWORK_ERROR_CODES.includes(error.status)) {
    throw new AuthRetryableFetchError(_getErrorMessage2(error), error.status);
  }
  let data;
  try {
    data = await error.json();
  } catch (e) {
    throw new AuthUnknownError(_getErrorMessage2(e), e);
  }
  let errorCode = void 0;
  const responseAPIVersion = parseResponseAPIVersion(error);
  if (responseAPIVersion && responseAPIVersion.getTime() >= API_VERSIONS["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string") {
    errorCode = data.code;
  } else if (typeof data === "object" && data && typeof data.error_code === "string") {
    errorCode = data.error_code;
  }
  if (!errorCode) {
    if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
      throw new AuthWeakPasswordError(_getErrorMessage2(data), error.status, data.weak_password.reasons);
    }
  } else if (errorCode === "weak_password") {
    throw new AuthWeakPasswordError(_getErrorMessage2(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);
  } else if (errorCode === "session_not_found") {
    throw new AuthSessionMissingError();
  }
  throw new AuthApiError(_getErrorMessage2(data), error.status || 500, errorCode);
}
var _getRequestParams2 = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
async function _request(fetcher, method, url, options) {
  var _a;
  const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
  if (!headers[API_VERSION_HEADER_NAME]) {
    headers[API_VERSION_HEADER_NAME] = API_VERSIONS["2024-01-01"].name;
  }
  if (options === null || options === void 0 ? void 0 : options.jwt) {
    headers["Authorization"] = `Bearer ${options.jwt}`;
  }
  const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};
  if (options === null || options === void 0 ? void 0 : options.redirectTo) {
    qs["redirect_to"] = options.redirectTo;
  }
  const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
  const data = await _handleRequest2(fetcher, method, url + queryString, {
    headers,
    noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
  }, {}, options === null || options === void 0 ? void 0 : options.body);
  return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };
}
async function _handleRequest2(fetcher, method, url, options, parameters, body) {
  const requestParams = _getRequestParams2(method, options, parameters, body);
  let result;
  try {
    result = await fetcher(url, Object.assign({}, requestParams));
  } catch (e) {
    console.error(e);
    throw new AuthRetryableFetchError(_getErrorMessage2(e), 0);
  }
  if (!result.ok) {
    await handleError2(result);
  }
  if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
    return result;
  }
  try {
    return await result.json();
  } catch (e) {
    await handleError2(e);
  }
}
function _sessionResponse(data) {
  var _a;
  let session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    if (!data.expires_at) {
      session.expires_at = expiresAt(data.expires_in);
    }
  }
  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
  return { data: { session, user }, error: null };
}
function _sessionResponsePassword(data) {
  const response = _sessionResponse(data);
  if (!response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
    response.data.weak_password = data.weak_password;
  }
  return response;
}
function _userResponse(data) {
  var _a;
  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
  return { data: { user }, error: null };
}
function _ssoResponse(data) {
  return { data, error: null };
}
function _generateLinkResponse(data) {
  const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  const properties = {
    action_link,
    email_otp,
    hashed_token,
    redirect_to,
    verification_type
  };
  const user = Object.assign({}, rest);
  return {
    data: {
      properties,
      user
    },
    error: null
  };
}
function _noResolveJsonResponse(data) {
  return data;
}
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}

// node_modules/@supabase/auth-js/dist/module/lib/types.js
var SIGN_OUT_SCOPES = ["global", "local", "others"];

// node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js
var GoTrueAdminApi = class {
  /**
   * Creates an admin API client that can be used to manage users and OAuth clients.
   *
   * @example
   * ```ts
   * import { GoTrueAdminApi } from '@supabase/auth-js'
   *
   * const admin = new GoTrueAdminApi({
   *   url: 'https://xyzcompany.supabase.co/auth/v1',
   *   headers: { Authorization: `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}` },
   * })
   * ```
   */
  constructor({ url = "", headers = {}, fetch: fetch2 }) {
    this.url = url;
    this.headers = headers;
    this.fetch = resolveFetch3(fetch2);
    this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
    this.oauth = {
      listClients: this._listOAuthClients.bind(this),
      createClient: this._createOAuthClient.bind(this),
      getClient: this._getOAuthClient.bind(this),
      updateClient: this._updateOAuthClient.bind(this),
      deleteClient: this._deleteOAuthClient.bind(this),
      regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  async signOut(jwt, scope = SIGN_OUT_SCOPES[0]) {
    if (SIGN_OUT_SCOPES.indexOf(scope) < 0) {
      throw new Error(`@supabase/auth-js: Parameter scope must be one of ${SIGN_OUT_SCOPES.join(", ")}`);
    }
    try {
      await _request(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
        headers: this.headers,
        jwt,
        noResolveJson: true
      });
      return { data: null, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  async inviteUserByEmail(email, options = {}) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/invite`, {
        body: { email, data: options.data },
        headers: this.headers,
        redirectTo: options.redirectTo,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  async generateLink(params) {
    try {
      const { options } = params, rest = __rest(params, ["options"]);
      const body = Object.assign(Object.assign({}, rest), options);
      if ("newEmail" in rest) {
        body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
        delete body["newEmail"];
      }
      return await _request(this.fetch, "POST", `${this.url}/admin/generate_link`, {
        body,
        headers: this.headers,
        xform: _generateLinkResponse,
        redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
      });
    } catch (error) {
      if (isAuthError(error)) {
        return {
          data: {
            properties: null,
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async createUser(attributes) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/admin/users`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  async listUsers(params) {
    var _a, _b, _c, _d, _e, _f, _g;
    try {
      const pagination = { nextPage: null, lastPage: 0, total: 0 };
      const response = await _request(this.fetch, "GET", `${this.url}/admin/users`, {
        headers: this.headers,
        noResolveJson: true,
        query: {
          page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "",
          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
        },
        xform: _noResolveJsonResponse
      });
      if (response.error)
        throw response.error;
      const users = await response.json();
      const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
      const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
      if (links.length > 0) {
        links.forEach((link) => {
          const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
          const rel = JSON.parse(link.split(";")[1].split("=")[1]);
          pagination[`${rel}Page`] = page;
        });
        pagination.total = parseInt(total);
      }
      return { data: Object.assign(Object.assign({}, users), pagination), error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { users: [] }, error };
      }
      throw error;
    }
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async getUserById(uid) {
    validateUUID(uid);
    try {
      return await _request(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Updates the user data. Changes are applied directly without confirmation flows.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async updateUserById(uid, attributes) {
    validateUUID(uid);
    try {
      return await _request(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async deleteUser(id, shouldSoftDelete = false) {
    validateUUID(id);
    try {
      return await _request(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {
        headers: this.headers,
        body: {
          should_soft_delete: shouldSoftDelete
        },
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  async _listFactors(params) {
    validateUUID(params.userId);
    try {
      const { data, error } = await _request(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {
        headers: this.headers,
        xform: (factors) => {
          return { data: { factors }, error: null };
        }
      });
      return { data, error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  async _deleteFactor(params) {
    validateUUID(params.userId);
    validateUUID(params.id);
    try {
      const data = await _request(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
        headers: this.headers
      });
      return { data, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Lists all OAuth clients with optional pagination.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _listOAuthClients(params) {
    var _a, _b, _c, _d, _e, _f, _g;
    try {
      const pagination = { nextPage: null, lastPage: 0, total: 0 };
      const response = await _request(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
        headers: this.headers,
        noResolveJson: true,
        query: {
          page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "",
          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
        },
        xform: _noResolveJsonResponse
      });
      if (response.error)
        throw response.error;
      const clients = await response.json();
      const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
      const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
      if (links.length > 0) {
        links.forEach((link) => {
          const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
          const rel = JSON.parse(link.split(";")[1].split("=")[1]);
          pagination[`${rel}Page`] = page;
        });
        pagination.total = parseInt(total);
      }
      return { data: Object.assign(Object.assign({}, clients), pagination), error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { clients: [] }, error };
      }
      throw error;
    }
  }
  /**
   * Creates a new OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _createOAuthClient(params) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
        body: params,
        headers: this.headers,
        xform: (client) => {
          return { data: client, error: null };
        }
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Gets details of a specific OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _getOAuthClient(clientId) {
    try {
      return await _request(this.fetch, "GET", `${this.url}/admin/oauth/clients/${clientId}`, {
        headers: this.headers,
        xform: (client) => {
          return { data: client, error: null };
        }
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Updates an existing OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _updateOAuthClient(clientId, params) {
    try {
      return await _request(this.fetch, "PUT", `${this.url}/admin/oauth/clients/${clientId}`, {
        body: params,
        headers: this.headers,
        xform: (client) => {
          return { data: client, error: null };
        }
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Deletes an OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _deleteOAuthClient(clientId) {
    try {
      await _request(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${clientId}`, {
        headers: this.headers,
        noResolveJson: true
      });
      return { data: null, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Regenerates the secret for an OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async _regenerateOAuthClientSecret(clientId) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {
        headers: this.headers,
        xform: (client) => {
          return { data: client, error: null };
        }
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/local-storage.js
function memoryLocalStorageAdapter(store = {}) {
  return {
    getItem: (key) => {
      return store[key] || null;
    },
    setItem: (key, value) => {
      store[key] = value;
    },
    removeItem: (key) => {
      delete store[key];
    }
  };
}

// node_modules/@supabase/auth-js/dist/module/lib/locks.js
var internals = {
  /**
   * @experimental
   */
  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
var LockAcquireTimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.isAcquireTimeout = true;
  }
};
var NavigatorLockAcquireTimeoutError = class extends LockAcquireTimeoutError {
};
async function navigatorLock(name, acquireTimeout, fn) {
  if (internals.debug) {
    console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name, acquireTimeout);
  }
  const abortController = new globalThis.AbortController();
  if (acquireTimeout > 0) {
    setTimeout(() => {
      abortController.abort();
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name);
      }
    }, acquireTimeout);
  }
  return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
    mode: "exclusive",
    ifAvailable: true
  } : {
    mode: "exclusive",
    signal: abortController.signal
  }, async (lock) => {
    if (lock) {
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock: acquired", name, lock.name);
      }
      try {
        return await fn();
      } finally {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: released", name, lock.name);
        }
      }
    } else {
      if (acquireTimeout === 0) {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name);
        }
        throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
      } else {
        if (internals.debug) {
          try {
            const result = await globalThis.navigator.locks.query();
            console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result, null, "  "));
          } catch (e) {
            console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e);
          }
        }
        console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
        return await fn();
      }
    }
  }));
}

// node_modules/@supabase/auth-js/dist/module/lib/polyfills.js
function polyfillGlobalThis() {
  if (typeof globalThis === "object")
    return;
  try {
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  } catch (e) {
    if (typeof self !== "undefined") {
      self.globalThis = self;
    }
  }
}

// node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js
function getAddress(address) {
  if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
    throw new Error(`@supabase/auth-js: Address "${address}" is invalid.`);
  }
  return address.toLowerCase();
}
function fromHex(hex) {
  return parseInt(hex, 16);
}
function toHex(value) {
  const bytes = new TextEncoder().encode(value);
  const hex = Array.from(bytes, (byte) => byte.toString(16).padStart(2, "0")).join("");
  return "0x" + hex;
}
function createSiweMessage(parameters) {
  var _a;
  const { chainId, domain, expirationTime, issuedAt = /* @__PURE__ */ new Date(), nonce, notBefore, requestId, resources, scheme, uri, version: version5 } = parameters;
  {
    if (!Number.isInteger(chainId))
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);
    if (!domain)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.`);
    if (nonce && nonce.length < 8)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${nonce}`);
    if (!uri)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.`);
    if (version5 !== "1")
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${version5}`);
    if ((_a = parameters.statement) === null || _a === void 0 ? void 0 : _a.includes("\n"))
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${parameters.statement}`);
  }
  const address = getAddress(parameters.address);
  const origin = scheme ? `${scheme}://${domain}` : domain;
  const statement = parameters.statement ? `${parameters.statement}
` : "";
  const prefix = `${origin} wants you to sign in with your Ethereum account:
${address}

${statement}`;
  let suffix = `URI: ${uri}
Version: ${version5}
Chain ID: ${chainId}${nonce ? `
Nonce: ${nonce}` : ""}
Issued At: ${issuedAt.toISOString()}`;
  if (expirationTime)
    suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
  if (notBefore)
    suffix += `
Not Before: ${notBefore.toISOString()}`;
  if (requestId)
    suffix += `
Request ID: ${requestId}`;
  if (resources) {
    let content = "\nResources:";
    for (const resource of resources) {
      if (!resource || typeof resource !== "string")
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${resource}`);
      content += `
- ${resource}`;
    }
    suffix += content;
  }
  return `${prefix}
${suffix}`;
}

// node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js
var WebAuthnError = class extends Error {
  constructor({ message, code, cause, name }) {
    var _a;
    super(message, { cause });
    this.__isWebAuthnError = true;
    this.name = (_a = name !== null && name !== void 0 ? name : cause instanceof Error ? cause.name : void 0) !== null && _a !== void 0 ? _a : "Unknown Error";
    this.code = code;
  }
};
var WebAuthnUnknownError = class extends WebAuthnError {
  constructor(message, originalError) {
    super({
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: originalError,
      message
    });
    this.name = "WebAuthnUnknownError";
    this.originalError = originalError;
  }
};
function identifyRegistrationError({ error, options }) {
  var _a, _b, _c;
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error
      });
    }
  } else if (error.name === "ConstraintError") {
    if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {
      return new WebAuthnError({
        message: "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: error
      });
    } else if (
      // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
      options.mediation === "conditional" && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === "required"
    ) {
      return new WebAuthnError({
        message: "User verification was required during automatic registration but it could not be performed",
        code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
        cause: error
      });
    } else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === "required") {
      return new WebAuthnError({
        message: "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: error
      });
    }
  } else if (error.name === "InvalidStateError") {
    return new WebAuthnError({
      message: "The authenticator was previously registered",
      code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
      cause: error
    });
  } else if (error.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error
    });
  } else if (error.name === "NotSupportedError") {
    const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === "public-key");
    if (validPubKeyCredParams.length === 0) {
      return new WebAuthnError({
        message: 'No entry in pubKeyCredParams was of type "public-key"',
        code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
        cause: error
      });
    }
    return new WebAuthnError({
      message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
      code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
      cause: error
    });
  } else if (error.name === "SecurityError") {
    const effectiveDomain = window.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error
      });
    } else if (publicKey.rp.id !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rp.id}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error
      });
    }
  } else if (error.name === "TypeError") {
    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
      return new WebAuthnError({
        message: "User ID was not between 1 and 64 characters",
        code: "ERROR_INVALID_USER_ID_LENGTH",
        cause: error
      });
    }
  } else if (error.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new credential",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error
    });
  }
  return new WebAuthnError({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: error
  });
}
function identifyAuthenticationError({ error, options }) {
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Authentication ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error
      });
    }
  } else if (error.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error
    });
  } else if (error.name === "SecurityError") {
    const effectiveDomain = window.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error
      });
    } else if (publicKey.rpId !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rpId}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error
      });
    }
  } else if (error.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error
    });
  }
  return new WebAuthnError({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: error
  });
}

// node_modules/@supabase/auth-js/dist/module/lib/webauthn.js
var WebAuthnAbortService = class {
  /**
   * Create an abort signal for a new WebAuthn operation.
   * Automatically cancels any existing operation.
   *
   * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}
   */
  createNewAbortSignal() {
    if (this.controller) {
      const abortError = new Error("Cancelling existing WebAuthn API call for new one");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
    }
    const newController = new AbortController();
    this.controller = newController;
    return newController.signal;
  }
  /**
   * Manually cancel the current WebAuthn operation.
   * Useful for cleaning up when user cancels or navigates away.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}
   */
  cancelCeremony() {
    if (this.controller) {
      const abortError = new Error("Manually cancelling existing WebAuthn API call");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
      this.controller = void 0;
    }
  }
};
var webAuthnAbortService = new WebAuthnAbortService();
function deserializeCredentialCreationOptions(options) {
  if (!options) {
    throw new Error("Credential creation options are required");
  }
  if (typeof PublicKeyCredential !== "undefined" && "parseCreationOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === "function") {
    return PublicKeyCredential.parseCreationOptionsFromJSON(
      /** we assert the options here as typescript still doesn't know about future webauthn types */
      options
    );
  }
  const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = __rest(
    options,
    ["challenge", "user", "excludeCredentials"]
  );
  const challenge = base64UrlToUint8Array(challengeStr).buffer;
  const user = Object.assign(Object.assign({}, userOpts), { id: base64UrlToUint8Array(userOpts.id).buffer });
  const result = Object.assign(Object.assign({}, restOptions), {
    challenge,
    user
  });
  if (excludeCredentials && excludeCredentials.length > 0) {
    result.excludeCredentials = new Array(excludeCredentials.length);
    for (let i = 0; i < excludeCredentials.length; i++) {
      const cred = excludeCredentials[i];
      result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {
        id: base64UrlToUint8Array(cred.id).buffer,
        type: cred.type || "public-key",
        // Cast transports to handle future transport types like "cable"
        transports: cred.transports
      });
    }
  }
  return result;
}
function deserializeCredentialRequestOptions(options) {
  if (!options) {
    throw new Error("Credential request options are required");
  }
  if (typeof PublicKeyCredential !== "undefined" && "parseRequestOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === "function") {
    return PublicKeyCredential.parseRequestOptionsFromJSON(options);
  }
  const { challenge: challengeStr, allowCredentials } = options, restOptions = __rest(
    options,
    ["challenge", "allowCredentials"]
  );
  const challenge = base64UrlToUint8Array(challengeStr).buffer;
  const result = Object.assign(Object.assign({}, restOptions), { challenge });
  if (allowCredentials && allowCredentials.length > 0) {
    result.allowCredentials = new Array(allowCredentials.length);
    for (let i = 0; i < allowCredentials.length; i++) {
      const cred = allowCredentials[i];
      result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {
        id: base64UrlToUint8Array(cred.id).buffer,
        type: cred.type || "public-key",
        // Cast transports to handle future transport types like "cable"
        transports: cred.transports
      });
    }
  }
  return result;
}
function serializeCredentialCreationResponse(credential) {
  var _a;
  if ("toJSON" in credential && typeof credential.toJSON === "function") {
    return credential.toJSON();
  }
  const credentialWithAttachment = credential;
  return {
    id: credential.id,
    rawId: credential.id,
    response: {
      attestationObject: bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),
      clientDataJSON: bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON))
    },
    type: "public-key",
    clientExtensionResults: credential.getClientExtensionResults(),
    // Convert null to undefined and cast to AuthenticatorAttachment type
    authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : void 0
  };
}
function serializeCredentialRequestResponse(credential) {
  var _a;
  if ("toJSON" in credential && typeof credential.toJSON === "function") {
    return credential.toJSON();
  }
  const credentialWithAttachment = credential;
  const clientExtensionResults = credential.getClientExtensionResults();
  const assertionResponse = credential.response;
  return {
    id: credential.id,
    rawId: credential.id,
    // W3C spec expects rawId to match id for JSON format
    response: {
      authenticatorData: bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),
      clientDataJSON: bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),
      signature: bytesToBase64URL(new Uint8Array(assertionResponse.signature)),
      userHandle: assertionResponse.userHandle ? bytesToBase64URL(new Uint8Array(assertionResponse.userHandle)) : void 0
    },
    type: "public-key",
    clientExtensionResults,
    // Convert null to undefined and cast to AuthenticatorAttachment type
    authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : void 0
  };
}
function isValidDomain(hostname) {
  return (
    // Consider localhost valid as well since it's okay wrt Secure Contexts
    hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname)
  );
}
function browserSupportsWebAuthn() {
  var _a, _b;
  return !!(isBrowser() && "PublicKeyCredential" in window && window.PublicKeyCredential && "credentials" in navigator && typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === "function" && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === "function");
}
async function createCredential(options) {
  try {
    const response = await navigator.credentials.create(
      /** we assert the type here until typescript types are updated */
      options
    );
    if (!response) {
      return {
        data: null,
        error: new WebAuthnUnknownError("Empty credential response", response)
      };
    }
    if (!(response instanceof PublicKeyCredential)) {
      return {
        data: null,
        error: new WebAuthnUnknownError("Browser returned unexpected credential type", response)
      };
    }
    return { data: response, error: null };
  } catch (err) {
    return {
      data: null,
      error: identifyRegistrationError({
        error: err,
        options
      })
    };
  }
}
async function getCredential(options) {
  try {
    const response = await navigator.credentials.get(
      /** we assert the type here until typescript types are updated */
      options
    );
    if (!response) {
      return {
        data: null,
        error: new WebAuthnUnknownError("Empty credential response", response)
      };
    }
    if (!(response instanceof PublicKeyCredential)) {
      return {
        data: null,
        error: new WebAuthnUnknownError("Browser returned unexpected credential type", response)
      };
    }
    return { data: response, error: null };
  } catch (err) {
    return {
      data: null,
      error: identifyAuthenticationError({
        error: err,
        options
      })
    };
  }
}
var DEFAULT_CREATION_OPTIONS = {
  hints: ["security-key"],
  authenticatorSelection: {
    authenticatorAttachment: "cross-platform",
    requireResidentKey: false,
    /** set to preferred because older yubikeys don't have PIN/Biometric */
    userVerification: "preferred",
    residentKey: "discouraged"
  },
  attestation: "direct"
};
var DEFAULT_REQUEST_OPTIONS = {
  /** set to preferred because older yubikeys don't have PIN/Biometric */
  userVerification: "preferred",
  hints: ["security-key"],
  attestation: "direct"
};
function deepMerge(...sources) {
  const isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);
  const result = {};
  for (const source of sources) {
    if (!source)
      continue;
    for (const key in source) {
      const value = source[key];
      if (value === void 0)
        continue;
      if (Array.isArray(value)) {
        result[key] = value;
      } else if (isArrayBufferLike(value)) {
        result[key] = value;
      } else if (isObject(value)) {
        const existing = result[key];
        if (isObject(existing)) {
          result[key] = deepMerge(existing, value);
        } else {
          result[key] = deepMerge(value);
        }
      } else {
        result[key] = value;
      }
    }
  }
  return result;
}
function mergeCredentialCreationOptions(baseOptions, overrides) {
  return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});
}
function mergeCredentialRequestOptions(baseOptions, overrides) {
  return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});
}
var WebAuthnApi = class {
  constructor(client) {
    this.client = client;
    this.enroll = this._enroll.bind(this);
    this.challenge = this._challenge.bind(this);
    this.verify = this._verify.bind(this);
    this.authenticate = this._authenticate.bind(this);
    this.register = this._register.bind(this);
  }
  /**
   * Enroll a new WebAuthn factor.
   * Creates an unverified WebAuthn factor that must be verified with a credential.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)
   * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}
   */
  async _enroll(params) {
    return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: "webauthn" }));
  }
  /**
   * Challenge for WebAuthn credential creation or authentication.
   * Combines server challenge with browser credential operations.
   * Handles both registration (create) and authentication (request) flows.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId
   * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials
   * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation
   * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request
   * @returns {Promise<RequestResult>} Challenge response with credential or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}
   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}
   */
  async _challenge({ factorId, webauthn, friendlyName, signal }, overrides) {
    var _a;
    try {
      const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({
        factorId,
        webauthn
      });
      if (!challengeResponse) {
        return { data: null, error: challengeError };
      }
      const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();
      if (challengeResponse.webauthn.type === "create") {
        const { user } = challengeResponse.webauthn.credential_options.publicKey;
        if (!user.name) {
          const nameToUse = friendlyName;
          if (!nameToUse) {
            const currentUser = await this.client.getUser();
            const userData = currentUser.data.user;
            const fallbackName = ((_a = userData === null || userData === void 0 ? void 0 : userData.user_metadata) === null || _a === void 0 ? void 0 : _a.name) || (userData === null || userData === void 0 ? void 0 : userData.email) || (userData === null || userData === void 0 ? void 0 : userData.id) || "User";
            user.name = `${user.id}:${fallbackName}`;
          } else {
            user.name = `${user.id}:${nameToUse}`;
          }
        }
        if (!user.displayName) {
          user.displayName = user.name;
        }
      }
      switch (challengeResponse.webauthn.type) {
        case "create": {
          const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);
          const { data, error } = await createCredential({
            publicKey: options,
            signal: abortSignal
          });
          if (data) {
            return {
              data: {
                factorId,
                challengeId: challengeResponse.id,
                webauthn: {
                  type: challengeResponse.webauthn.type,
                  credential_response: data
                }
              },
              error: null
            };
          }
          return { data: null, error };
        }
        case "request": {
          const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);
          const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));
          if (data) {
            return {
              data: {
                factorId,
                challengeId: challengeResponse.id,
                webauthn: {
                  type: challengeResponse.webauthn.type,
                  credential_response: data
                }
              },
              error: null
            };
          }
          return { data: null, error };
        }
      }
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      return {
        data: null,
        error: new AuthUnknownError("Unexpected error in challenge", error)
      };
    }
  }
  /**
   * Verify a WebAuthn credential with the server.
   * Completes the WebAuthn ceremony by sending the credential to the server for verification.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Verification parameters
   * @param {string} params.challengeId - ID of the challenge being verified
   * @param {string} params.factorId - ID of the WebAuthn factor
   * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response
   * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}
   * */
  async _verify({ challengeId, factorId, webauthn }) {
    return this.client.mfa.verify({
      factorId,
      challengeId,
      webauthn
    });
  }
  /**
   * Complete WebAuthn authentication flow.
   * Performs challenge and verification in a single operation for existing credentials.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Authentication parameters
   * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with
   * @param {Object} params.webauthn - WebAuthn configuration
   * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)
   * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)
   * @param {AbortSignal} params.webauthn.signal - Optional abort signal
   * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get
   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result
   * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}
   */
  async _authenticate({ factorId, webauthn: { rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal } = {} }, overrides) {
    if (!rpId) {
      return {
        data: null,
        error: new AuthError("rpId is required for WebAuthn authentication")
      };
    }
    try {
      if (!browserSupportsWebAuthn()) {
        return {
          data: null,
          error: new AuthUnknownError("Browser does not support WebAuthn", null)
        };
      }
      const { data: challengeResponse, error: challengeError } = await this.challenge({
        factorId,
        webauthn: { rpId, rpOrigins },
        signal
      }, { request: overrides });
      if (!challengeResponse) {
        return { data: null, error: challengeError };
      }
      const { webauthn } = challengeResponse;
      return this._verify({
        factorId,
        challengeId: challengeResponse.challengeId,
        webauthn: {
          type: webauthn.type,
          rpId,
          rpOrigins,
          credential_response: webauthn.credential_response
        }
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      return {
        data: null,
        error: new AuthUnknownError("Unexpected error in authenticate", error)
      };
    }
  }
  /**
   * Complete WebAuthn registration flow.
   * Performs enrollment, challenge, and verification in a single operation for new credentials.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Registration parameters
   * @param {string} params.friendlyName - User-friendly name for the credential
   * @param {string} params.rpId - Relying Party ID (defaults to current hostname)
   * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)
   * @param {AbortSignal} params.signal - Optional abort signal
   * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create
   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result
   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}
   */
  async _register({ friendlyName, webauthn: { rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal } = {} }, overrides) {
    if (!rpId) {
      return {
        data: null,
        error: new AuthError("rpId is required for WebAuthn registration")
      };
    }
    try {
      if (!browserSupportsWebAuthn()) {
        return {
          data: null,
          error: new AuthUnknownError("Browser does not support WebAuthn", null)
        };
      }
      const { data: factor, error: enrollError } = await this._enroll({
        friendlyName
      });
      if (!factor) {
        await this.client.mfa.listFactors().then((factors) => {
          var _a;
          return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v) => v.factor_type === "webauthn" && v.friendly_name === friendlyName && v.status !== "unverified");
        }).then((factor2) => factor2 ? this.client.mfa.unenroll({ factorId: factor2 === null || factor2 === void 0 ? void 0 : factor2.id }) : void 0);
        return { data: null, error: enrollError };
      }
      const { data: challengeResponse, error: challengeError } = await this._challenge({
        factorId: factor.id,
        friendlyName: factor.friendly_name,
        webauthn: { rpId, rpOrigins },
        signal
      }, {
        create: overrides
      });
      if (!challengeResponse) {
        return { data: null, error: challengeError };
      }
      return this._verify({
        factorId: factor.id,
        challengeId: challengeResponse.challengeId,
        webauthn: {
          rpId,
          rpOrigins,
          type: challengeResponse.webauthn.type,
          credential_response: challengeResponse.webauthn.credential_response
        }
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      return {
        data: null,
        error: new AuthUnknownError("Unexpected error in register", error)
      };
    }
  }
};

// node_modules/@supabase/auth-js/dist/module/GoTrueClient.js
polyfillGlobalThis();
var DEFAULT_OPTIONS = {
  url: GOTRUE_URL,
  storageKey: STORAGE_KEY,
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  headers: DEFAULT_HEADERS2,
  flowType: "implicit",
  debug: false,
  hasCustomAuthorizationHeader: false,
  throwOnError: false,
  lockAcquireTimeout: 1e4
  // 10 seconds
};
async function lockNoOp(name, acquireTimeout, fn) {
  return await fn();
}
var GLOBAL_JWKS = {};
var GoTrueClient = class _GoTrueClient {
  /**
   * The JWKS used for verifying asymmetric JWTs
   */
  get jwks() {
    var _a, _b;
    return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.jwks) !== null && _b !== void 0 ? _b : { keys: [] };
  }
  set jwks(value) {
    GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { jwks: value });
  }
  get jwks_cached_at() {
    var _a, _b;
    return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
  }
  set jwks_cached_at(value) {
    GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { cachedAt: value });
  }
  /**
   * Create a new client for use in the browser.
   *
   * @example
   * ```ts
   * import { GoTrueClient } from '@supabase/auth-js'
   *
   * const auth = new GoTrueClient({
   *   url: 'https://xyzcompany.supabase.co/auth/v1',
   *   headers: { apikey: 'public-anon-key' },
   *   storageKey: 'supabase-auth',
   * })
   * ```
   */
  constructor(options) {
    var _a, _b, _c;
    this.userStorage = null;
    this.memoryStorage = null;
    this.stateChangeEmitters = /* @__PURE__ */ new Map();
    this.autoRefreshTicker = null;
    this.autoRefreshTickTimeout = null;
    this.visibilityChangedCallback = null;
    this.refreshingDeferred = null;
    this.initializePromise = null;
    this.detectSessionInUrl = true;
    this.hasCustomAuthorizationHeader = false;
    this.suppressGetSessionWarning = false;
    this.lockAcquired = false;
    this.pendingInLock = [];
    this.broadcastChannel = null;
    this.logger = console.log;
    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    this.storageKey = settings.storageKey;
    this.instanceID = (_a = _GoTrueClient.nextInstanceID[this.storageKey]) !== null && _a !== void 0 ? _a : 0;
    _GoTrueClient.nextInstanceID[this.storageKey] = this.instanceID + 1;
    this.logDebugMessages = !!settings.debug;
    if (typeof settings.debug === "function") {
      this.logger = settings.debug;
    }
    if (this.instanceID > 0 && isBrowser()) {
      const message = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;
      console.warn(message);
      if (this.logDebugMessages) {
        console.trace(message);
      }
    }
    this.persistSession = settings.persistSession;
    this.autoRefreshToken = settings.autoRefreshToken;
    this.admin = new GoTrueAdminApi({
      url: settings.url,
      headers: settings.headers,
      fetch: settings.fetch
    });
    this.url = settings.url;
    this.headers = settings.headers;
    this.fetch = resolveFetch3(settings.fetch);
    this.lock = settings.lock || lockNoOp;
    this.detectSessionInUrl = settings.detectSessionInUrl;
    this.flowType = settings.flowType;
    this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
    this.throwOnError = settings.throwOnError;
    this.lockAcquireTimeout = settings.lockAcquireTimeout;
    if (settings.lock) {
      this.lock = settings.lock;
    } else if (this.persistSession && isBrowser() && ((_b = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _b === void 0 ? void 0 : _b.locks)) {
      this.lock = navigatorLock;
    } else {
      this.lock = lockNoOp;
    }
    if (!this.jwks) {
      this.jwks = { keys: [] };
      this.jwks_cached_at = Number.MIN_SAFE_INTEGER;
    }
    this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
      webauthn: new WebAuthnApi(this)
    };
    this.oauth = {
      getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
      approveAuthorization: this._approveAuthorization.bind(this),
      denyAuthorization: this._denyAuthorization.bind(this),
      listGrants: this._listOAuthGrants.bind(this),
      revokeGrant: this._revokeOAuthGrant.bind(this)
    };
    if (this.persistSession) {
      if (settings.storage) {
        this.storage = settings.storage;
      } else {
        if (supportsLocalStorage()) {
          this.storage = globalThis.localStorage;
        } else {
          this.memoryStorage = {};
          this.storage = memoryLocalStorageAdapter(this.memoryStorage);
        }
      }
      if (settings.userStorage) {
        this.userStorage = settings.userStorage;
      }
    } else {
      this.memoryStorage = {};
      this.storage = memoryLocalStorageAdapter(this.memoryStorage);
    }
    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (e) {
        console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e);
      }
      (_c = this.broadcastChannel) === null || _c === void 0 ? void 0 : _c.addEventListener("message", async (event) => {
        this._debug("received broadcast notification from other tab or client", event);
        try {
          await this._notifyAllSubscribers(event.data.event, event.data.session, false);
        } catch (error) {
          this._debug("#broadcastChannel", "error", error);
        }
      });
    }
    this.initialize().catch((error) => {
      this._debug("#initialize()", "error", error);
    });
  }
  /**
   * Returns whether error throwing mode is enabled for this client.
   */
  isThrowOnErrorEnabled() {
    return this.throwOnError;
  }
  /**
   * Centralizes return handling with optional error throwing. When `throwOnError` is enabled
   * and the provided result contains a non-nullish error, the error is thrown instead of
   * being returned. This ensures consistent behavior across all public API methods.
   */
  _returnResult(result) {
    if (this.throwOnError && result && result.error) {
      throw result.error;
    }
    return result;
  }
  _logPrefix() {
    return `GoTrueClient@${this.storageKey}:${this.instanceID} (${version3}) ${(/* @__PURE__ */ new Date()).toISOString()}`;
  }
  _debug(...args) {
    if (this.logDebugMessages) {
      this.logger(this._logPrefix(), ...args);
    }
    return this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  async initialize() {
    if (this.initializePromise) {
      return await this.initializePromise;
    }
    this.initializePromise = (async () => {
      return await this._acquireLock(this.lockAcquireTimeout, async () => {
        return await this._initialize();
      });
    })();
    return await this.initializePromise;
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  async _initialize() {
    var _a;
    try {
      let params = {};
      let callbackUrlType = "none";
      if (isBrowser()) {
        params = parseParametersFromURL(window.location.href);
        if (this._isImplicitGrantCallback(params)) {
          callbackUrlType = "implicit";
        } else if (await this._isPKCECallback(params)) {
          callbackUrlType = "pkce";
        }
      }
      if (isBrowser() && this.detectSessionInUrl && callbackUrlType !== "none") {
        const { data, error } = await this._getSessionFromURL(params, callbackUrlType);
        if (error) {
          this._debug("#_initialize()", "error detecting session from URL", error);
          if (isAuthImplicitGrantRedirectError(error)) {
            const errorCode = (_a = error.details) === null || _a === void 0 ? void 0 : _a.code;
            if (errorCode === "identity_already_exists" || errorCode === "identity_not_found" || errorCode === "single_identity_not_deletable") {
              return { error };
            }
          }
          return { error };
        }
        const { session, redirectType } = data;
        this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
        await this._saveSession(session);
        setTimeout(async () => {
          if (redirectType === "recovery") {
            await this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
          } else {
            await this._notifyAllSubscribers("SIGNED_IN", session);
          }
        }, 0);
        return { error: null };
      }
      await this._recoverAndRefresh();
      return { error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ error });
      }
      return this._returnResult({
        error: new AuthUnknownError("Unexpected error during initialization", error)
      });
    } finally {
      await this._handleVisibilityChange();
      this._debug("#_initialize()", "end");
    }
  }
  /**
   * Creates a new anonymous user.
   *
   * @returns A session where the is_anonymous claim in the access token JWT set to true
   */
  async signInAnonymously(credentials) {
    var _a, _b, _c;
    try {
      const res = await _request(this.fetch, "POST", `${this.url}/signup`, {
        headers: this.headers,
        body: {
          data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},
          gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error } = res;
      if (error || !data) {
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return this._returnResult({ data: { user, session }, error: null });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      throw error;
    }
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  async signUp(credentials) {
    var _a, _b, _c;
    try {
      let res;
      if ("email" in credentials) {
        const { email, password, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: {
            email,
            password,
            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          xform: _sessionResponse
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone,
            password,
            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
            channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : "sms",
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
      } else {
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
      }
      const { data, error } = res;
      if (error || !data) {
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return this._returnResult({ data: { user, session }, error: null });
    } catch (error) {
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (isAuthError(error)) {
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      throw error;
    }
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  async signInWithPassword(credentials) {
    try {
      let res;
      if ("email" in credentials) {
        const { email, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            email,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponsePassword
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            phone,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponsePassword
        });
      } else {
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
      }
      const { data, error } = res;
      if (error) {
        return this._returnResult({ data: { user: null, session: null }, error });
      } else if (!data || !data.session || !data.user) {
        const invalidTokenError = new AuthInvalidTokenResponseError();
        return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return this._returnResult({
        data: Object.assign({ user: data.user, session: data.session }, data.weak_password ? { weakPassword: data.weak_password } : null),
        error
      });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      throw error;
    }
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  async signInWithOAuth(credentials) {
    var _a, _b, _c, _d;
    return await this._handleProviderSignIn(credentials.provider, {
      redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,
      scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
      queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
      skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  async exchangeCodeForSession(authCode) {
    await this.initializePromise;
    return this._acquireLock(this.lockAcquireTimeout, async () => {
      return this._exchangeCodeForSession(authCode);
    });
  }
  /**
   * Signs in a user by verifying a message signed by the user's private key.
   * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,
   * both of which derive from the EIP-4361 standard
   * With slight variation on Solana's side.
   * @reference https://eips.ethereum.org/EIPS/eip-4361
   */
  async signInWithWeb3(credentials) {
    const { chain } = credentials;
    switch (chain) {
      case "ethereum":
        return await this.signInWithEthereum(credentials);
      case "solana":
        return await this.signInWithSolana(credentials);
      default:
        throw new Error(`@supabase/auth-js: Unsupported chain "${chain}"`);
    }
  }
  async signInWithEthereum(credentials) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    let message;
    let signature;
    if ("message" in credentials) {
      message = credentials.message;
      signature = credentials.signature;
    } else {
      const { chain, wallet, statement, options } = credentials;
      let resolvedWallet;
      if (!isBrowser()) {
        if (typeof wallet !== "object" || !(options === null || options === void 0 ? void 0 : options.url)) {
          throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
        }
        resolvedWallet = wallet;
      } else if (typeof wallet === "object") {
        resolvedWallet = wallet;
      } else {
        const windowAny = window;
        if ("ethereum" in windowAny && typeof windowAny.ethereum === "object" && "request" in windowAny.ethereum && typeof windowAny.ethereum.request === "function") {
          resolvedWallet = windowAny.ethereum;
        } else {
          throw new Error(`@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.`);
        }
      }
      const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);
      const accounts = await resolvedWallet.request({
        method: "eth_requestAccounts"
      }).then((accs) => accs).catch(() => {
        throw new Error(`@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid`);
      });
      if (!accounts || accounts.length === 0) {
        throw new Error(`@supabase/auth-js: No accounts available. Please ensure the wallet is connected.`);
      }
      const address = getAddress(accounts[0]);
      let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;
      if (!chainId) {
        const chainIdHex = await resolvedWallet.request({
          method: "eth_chainId"
        });
        chainId = fromHex(chainIdHex);
      }
      const siweMessage = {
        domain: url.host,
        address,
        statement,
        uri: url.href,
        version: "1",
        chainId,
        nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,
        issuedAt: (_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : /* @__PURE__ */ new Date(),
        expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,
        notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,
        requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,
        resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources
      };
      message = createSiweMessage(siweMessage);
      signature = await resolvedWallet.request({
        method: "personal_sign",
        params: [toHex(message), address]
      });
    }
    try {
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
        headers: this.headers,
        body: Object.assign({
          chain: "ethereum",
          message,
          signature
        }, ((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken) ? { gotrue_meta_security: { captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken } } : null),
        xform: _sessionResponse
      });
      if (error) {
        throw error;
      }
      if (!data || !data.session || !data.user) {
        const invalidTokenError = new AuthInvalidTokenResponseError();
        return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return this._returnResult({ data: Object.assign({}, data), error });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      throw error;
    }
  }
  async signInWithSolana(credentials) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    let message;
    let signature;
    if ("message" in credentials) {
      message = credentials.message;
      signature = credentials.signature;
    } else {
      const { chain, wallet, statement, options } = credentials;
      let resolvedWallet;
      if (!isBrowser()) {
        if (typeof wallet !== "object" || !(options === null || options === void 0 ? void 0 : options.url)) {
          throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
        }
        resolvedWallet = wallet;
      } else if (typeof wallet === "object") {
        resolvedWallet = wallet;
      } else {
        const windowAny = window;
        if ("solana" in windowAny && typeof windowAny.solana === "object" && ("signIn" in windowAny.solana && typeof windowAny.solana.signIn === "function" || "signMessage" in windowAny.solana && typeof windowAny.solana.signMessage === "function")) {
          resolvedWallet = windowAny.solana;
        } else {
          throw new Error(`@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`);
        }
      }
      const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);
      if ("signIn" in resolvedWallet && resolvedWallet.signIn) {
        const output = await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({ issuedAt: (/* @__PURE__ */ new Date()).toISOString() }, options === null || options === void 0 ? void 0 : options.signInWithSolana), {
          // non-overridable properties
          version: "1",
          domain: url.host,
          uri: url.href
        }), statement ? { statement } : null));
        let outputToProcess;
        if (Array.isArray(output) && output[0] && typeof output[0] === "object") {
          outputToProcess = output[0];
        } else if (output && typeof output === "object" && "signedMessage" in output && "signature" in output) {
          outputToProcess = output;
        } else {
          throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
        }
        if ("signedMessage" in outputToProcess && "signature" in outputToProcess && (typeof outputToProcess.signedMessage === "string" || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array) {
          message = typeof outputToProcess.signedMessage === "string" ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);
          signature = outputToProcess.signature;
        } else {
          throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields");
        }
      } else {
        if (!("signMessage" in resolvedWallet) || typeof resolvedWallet.signMessage !== "function" || !("publicKey" in resolvedWallet) || typeof resolvedWallet !== "object" || !resolvedWallet.publicKey || !("toBase58" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== "function") {
          throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
        }
        message = [
          `${url.host} wants you to sign in with your Solana account:`,
          resolvedWallet.publicKey.toBase58(),
          ...statement ? ["", statement, ""] : [""],
          "Version: 1",
          `URI: ${url.href}`,
          `Issued At: ${(_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : (/* @__PURE__ */ new Date()).toISOString()}`,
          ...((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore) ? [`Not Before: ${options.signInWithSolana.notBefore}`] : [],
          ...((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? void 0 : _e.expirationTime) ? [`Expiration Time: ${options.signInWithSolana.expirationTime}`] : [],
          ...((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId) ? [`Chain ID: ${options.signInWithSolana.chainId}`] : [],
          ...((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? [`Nonce: ${options.signInWithSolana.nonce}`] : [],
          ...((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId) ? [`Request ID: ${options.signInWithSolana.requestId}`] : [],
          ...((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length) ? [
            "Resources",
            ...options.signInWithSolana.resources.map((resource) => `- ${resource}`)
          ] : []
        ].join("\n");
        const maybeSignature = await resolvedWallet.signMessage(new TextEncoder().encode(message), "utf8");
        if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {
          throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
        }
        signature = maybeSignature;
      }
    }
    try {
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
        headers: this.headers,
        body: Object.assign({ chain: "solana", message, signature: bytesToBase64URL(signature) }, ((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken) ? { gotrue_meta_security: { captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken } } : null),
        xform: _sessionResponse
      });
      if (error) {
        throw error;
      }
      if (!data || !data.session || !data.user) {
        const invalidTokenError = new AuthInvalidTokenResponseError();
        return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return this._returnResult({ data: Object.assign({}, data), error });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      throw error;
    }
  }
  async _exchangeCodeForSession(authCode) {
    const storageItem = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : "").split("/");
    try {
      if (!codeVerifier && this.flowType === "pkce") {
        throw new AuthPKCECodeVerifierMissingError();
      }
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
        headers: this.headers,
        body: {
          auth_code: authCode,
          code_verifier: codeVerifier
        },
        xform: _sessionResponse
      });
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (error) {
        throw error;
      }
      if (!data || !data.session || !data.user) {
        const invalidTokenError = new AuthInvalidTokenResponseError();
        return this._returnResult({
          data: { user: null, session: null, redirectType: null },
          error: invalidTokenError
        });
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return this._returnResult({ data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null }), error });
    } catch (error) {
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (isAuthError(error)) {
        return this._returnResult({
          data: { user: null, session: null, redirectType: null },
          error
        });
      }
      throw error;
    }
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  async signInWithIdToken(credentials) {
    try {
      const { options, provider, token, access_token, nonce } = credentials;
      const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
        headers: this.headers,
        body: {
          provider,
          id_token: token,
          access_token,
          nonce,
          gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error } = res;
      if (error) {
        return this._returnResult({ data: { user: null, session: null }, error });
      } else if (!data || !data.session || !data.user) {
        const invalidTokenError = new AuthInvalidTokenResponseError();
        return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return this._returnResult({ data, error });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      throw error;
    }
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  async signInWithOtp(credentials) {
    var _a, _b, _c, _d, _e;
    try {
      if ("email" in credentials) {
        const { email, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const { error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email,
            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
            create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      if ("phone" in credentials) {
        const { phone, options } = credentials;
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            phone,
            data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
            create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : "sms"
          }
        });
        return this._returnResult({
          data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id },
          error
        });
      }
      throw new AuthInvalidCredentialsError("You must provide either an email or phone number.");
    } catch (error) {
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (isAuthError(error)) {
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      throw error;
    }
  }
  /**
   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
   */
  async verifyOtp(params) {
    var _a, _b;
    try {
      let redirectTo = void 0;
      let captchaToken = void 0;
      if ("options" in params) {
        redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;
        captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
      }
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/verify`, {
        headers: this.headers,
        body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),
        redirectTo,
        xform: _sessionResponse
      });
      if (error) {
        throw error;
      }
      if (!data) {
        const tokenVerificationError = new Error("An error occurred on token verification.");
        throw tokenVerificationError;
      }
      const session = data.session;
      const user = data.user;
      if (session === null || session === void 0 ? void 0 : session.access_token) {
        await this._saveSession(session);
        await this._notifyAllSubscribers(params.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
      }
      return this._returnResult({ data: { user, session }, error: null });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      throw error;
    }
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  async signInWithSSO(params) {
    var _a, _b, _c, _d, _e;
    try {
      let codeChallenge = null;
      let codeChallengeMethod = null;
      if (this.flowType === "pkce") {
        ;
        [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
      }
      const result = await _request(this.fetch, "POST", `${this.url}/sso`, {
        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? { provider_id: params.providerId } : null), "domain" in params ? { domain: params.domain } : null), { redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : void 0 }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
        headers: this.headers,
        xform: _ssoResponse
      });
      if (((_d = result.data) === null || _d === void 0 ? void 0 : _d.url) && isBrowser() && !((_e = params.options) === null || _e === void 0 ? void 0 : _e.skipBrowserRedirect)) {
        window.location.assign(result.data.url);
      }
      return this._returnResult(result);
    } catch (error) {
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (isAuthError(error)) {
        return this._returnResult({ data: null, error });
      }
      throw error;
    }
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  async reauthenticate() {
    await this.initializePromise;
    return await this._acquireLock(this.lockAcquireTimeout, async () => {
      return await this._reauthenticate();
    });
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError)
          throw sessionError;
        if (!session)
          throw new AuthSessionMissingError();
        const { error } = await _request(this.fetch, "GET", `${this.url}/reauthenticate`, {
          headers: this.headers,
          jwt: session.access_token
        });
        return this._returnResult({ data: { user: null, session: null }, error });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      throw error;
    }
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  async resend(credentials) {
    try {
      const endpoint = `${this.url}/resend`;
      if ("email" in credentials) {
        const { email, type, options } = credentials;
        const { error } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            email,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return this._returnResult({ data: { user: null, session: null }, error });
      } else if ("phone" in credentials) {
        const { phone, type, options } = credentials;
        const { data, error } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            phone,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          }
        });
        return this._returnResult({
          data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id },
          error
        });
      }
      throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      throw error;
    }
  }
  /**
   * Returns the session, refreshing it if necessary.
   *
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   *
   * **IMPORTANT:** This method loads values directly from the storage attached
   * to the client. If that storage is based on request cookies for example,
   * the values in it may not be authentic and therefore it's strongly advised
   * against using this method and its results in such circumstances. A warning
   * will be emitted if this is detected. Use {@link #getUser()} instead.
   */
  async getSession() {
    await this.initializePromise;
    const result = await this._acquireLock(this.lockAcquireTimeout, async () => {
      return this._useSession(async (result2) => {
        return result2;
      });
    });
    return result;
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  async _acquireLock(acquireTimeout, fn) {
    this._debug("#_acquireLock", "begin", acquireTimeout);
    try {
      if (this.lockAcquired) {
        const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
        const result = (async () => {
          await last;
          return await fn();
        })();
        this.pendingInLock.push((async () => {
          try {
            await result;
          } catch (e) {
          }
        })());
        return result;
      }
      return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {
        this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
        try {
          this.lockAcquired = true;
          const result = fn();
          this.pendingInLock.push((async () => {
            try {
              await result;
            } catch (e) {
            }
          })());
          await result;
          while (this.pendingInLock.length) {
            const waitOn = [...this.pendingInLock];
            await Promise.all(waitOn);
            this.pendingInLock.splice(0, waitOn.length);
          }
          return await result;
        } finally {
          this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
          this.lockAcquired = false;
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  async _useSession(fn) {
    this._debug("#_useSession", "begin");
    try {
      const result = await this.__loadSession();
      return await fn(result);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  async __loadSession() {
    this._debug("#__loadSession()", "begin");
    if (!this.lockAcquired) {
      this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
    }
    try {
      let currentSession = null;
      const maybeSession = await getItemAsync(this.storage, this.storageKey);
      this._debug("#getSession()", "session from storage", maybeSession);
      if (maybeSession !== null) {
        if (this._isValidSession(maybeSession)) {
          currentSession = maybeSession;
        } else {
          this._debug("#getSession()", "session from storage is not valid");
          await this._removeSession();
        }
      }
      if (!currentSession) {
        return { data: { session: null }, error: null };
      }
      const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1e3 - Date.now() < EXPIRY_MARGIN_MS : false;
      this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
      if (!hasExpired) {
        if (this.userStorage) {
          const maybeUser = await getItemAsync(this.userStorage, this.storageKey + "-user");
          if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {
            currentSession.user = maybeUser.user;
          } else {
            currentSession.user = userNotAvailableProxy();
          }
        }
        if (this.storage.isServer && currentSession.user && !currentSession.user.__isUserNotAvailableProxy) {
          const suppressWarningRef = { value: this.suppressGetSessionWarning };
          currentSession.user = insecureUserWarningProxy(currentSession.user, suppressWarningRef);
          if (suppressWarningRef.value) {
            this.suppressGetSessionWarning = true;
          }
        }
        return { data: { session: currentSession }, error: null };
      }
      const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);
      if (error) {
        return this._returnResult({ data: { session: null }, error });
      }
      return this._returnResult({ data: { session }, error: null });
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  /**
   * Gets the current user details if there is an existing session. This method
   * performs a network request to the Supabase Auth server, so the returned
   * value is authentic and can be used to base authorization rules on.
   *
   * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
   */
  async getUser(jwt) {
    if (jwt) {
      return await this._getUser(jwt);
    }
    await this.initializePromise;
    const result = await this._acquireLock(this.lockAcquireTimeout, async () => {
      return await this._getUser();
    });
    if (result.data.user) {
      this.suppressGetSessionWarning = true;
    }
    return result;
  }
  async _getUser(jwt) {
    try {
      if (jwt) {
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt,
          xform: _userResponse
        });
      }
      return await this._useSession(async (result) => {
        var _a, _b, _c;
        const { data, error } = result;
        if (error) {
          throw error;
        }
        if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) {
          return { data: { user: null }, error: new AuthSessionMissingError() };
        }
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : void 0,
          xform: _userResponse
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        if (isAuthSessionMissingError(error)) {
          await this._removeSession();
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        }
        return this._returnResult({ data: { user: null }, error });
      }
      throw error;
    }
  }
  /**
   * Updates user data for a logged in user.
   */
  async updateUser(attributes, options = {}) {
    await this.initializePromise;
    return await this._acquireLock(this.lockAcquireTimeout, async () => {
      return await this._updateUser(attributes, options);
    });
  }
  async _updateUser(attributes, options = {}) {
    try {
      return await this._useSession(async (result) => {
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          throw sessionError;
        }
        if (!sessionData.session) {
          throw new AuthSessionMissingError();
        }
        const session = sessionData.session;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce" && attributes.email != null) {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const { data, error: userError } = await _request(this.fetch, "PUT", `${this.url}/user`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
          jwt: session.access_token,
          xform: _userResponse
        });
        if (userError) {
          throw userError;
        }
        session.user = data.user;
        await this._saveSession(session);
        await this._notifyAllSubscribers("USER_UPDATED", session);
        return this._returnResult({ data: { user: session.user }, error: null });
      });
    } catch (error) {
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (isAuthError(error)) {
        return this._returnResult({ data: { user: null }, error });
      }
      throw error;
    }
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  async setSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(this.lockAcquireTimeout, async () => {
      return await this._setSession(currentSession);
    });
  }
  async _setSession(currentSession) {
    try {
      if (!currentSession.access_token || !currentSession.refresh_token) {
        throw new AuthSessionMissingError();
      }
      const timeNow = Date.now() / 1e3;
      let expiresAt2 = timeNow;
      let hasExpired = true;
      let session = null;
      const { payload } = decodeJWT(currentSession.access_token);
      if (payload.exp) {
        expiresAt2 = payload.exp;
        hasExpired = expiresAt2 <= timeNow;
      }
      if (hasExpired) {
        const { data: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        if (!refreshedSession) {
          return { data: { user: null, session: null }, error: null };
        }
        session = refreshedSession;
      } else {
        const { data, error } = await this._getUser(currentSession.access_token);
        if (error) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        session = {
          access_token: currentSession.access_token,
          refresh_token: currentSession.refresh_token,
          user: data.user,
          token_type: "bearer",
          expires_in: expiresAt2 - timeNow,
          expires_at: expiresAt2
        };
        await this._saveSession(session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return this._returnResult({ data: { user: session.user, session }, error: null });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: { session: null, user: null }, error });
      }
      throw error;
    }
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  async refreshSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(this.lockAcquireTimeout, async () => {
      return await this._refreshSession(currentSession);
    });
  }
  async _refreshSession(currentSession) {
    try {
      return await this._useSession(async (result) => {
        var _a;
        if (!currentSession) {
          const { data, error: error2 } = result;
          if (error2) {
            throw error2;
          }
          currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : void 0;
        }
        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
          throw new AuthSessionMissingError();
        }
        const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        if (!session) {
          return this._returnResult({ data: { user: null, session: null }, error: null });
        }
        return this._returnResult({ data: { user: session.user, session }, error: null });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: { user: null, session: null }, error });
      }
      throw error;
    }
  }
  /**
   * Gets the session data from a URL string
   */
  async _getSessionFromURL(params, callbackUrlType) {
    try {
      if (!isBrowser())
        throw new AuthImplicitGrantRedirectError("No browser detected.");
      if (params.error || params.error_description || params.error_code) {
        throw new AuthImplicitGrantRedirectError(params.error_description || "Error in URL with unspecified error_description", {
          error: params.error || "unspecified_error",
          code: params.error_code || "unspecified_code"
        });
      }
      switch (callbackUrlType) {
        case "implicit":
          if (this.flowType === "pkce") {
            throw new AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
          }
          break;
        case "pkce":
          if (this.flowType === "implicit") {
            throw new AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
          }
          break;
        default:
      }
      if (callbackUrlType === "pkce") {
        this._debug("#_initialize()", "begin", "is PKCE flow", true);
        if (!params.code)
          throw new AuthPKCEGrantCodeExchangeError("No code detected.");
        const { data: data2, error: error2 } = await this._exchangeCodeForSession(params.code);
        if (error2)
          throw error2;
        const url = new URL(window.location.href);
        url.searchParams.delete("code");
        window.history.replaceState(window.history.state, "", url.toString());
        return { data: { session: data2.session, redirectType: null }, error: null };
      }
      const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;
      if (!access_token || !expires_in || !refresh_token || !token_type) {
        throw new AuthImplicitGrantRedirectError("No session defined in URL");
      }
      const timeNow = Math.round(Date.now() / 1e3);
      const expiresIn = parseInt(expires_in);
      let expiresAt2 = timeNow + expiresIn;
      if (expires_at) {
        expiresAt2 = parseInt(expires_at);
      }
      const actuallyExpiresIn = expiresAt2 - timeNow;
      if (actuallyExpiresIn * 1e3 <= AUTO_REFRESH_TICK_DURATION_MS) {
        console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
      }
      const issuedAt = expiresAt2 - expiresIn;
      if (timeNow - issuedAt >= 120) {
        console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", issuedAt, expiresAt2, timeNow);
      } else if (timeNow - issuedAt < 0) {
        console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", issuedAt, expiresAt2, timeNow);
      }
      const { data, error } = await this._getUser(access_token);
      if (error)
        throw error;
      const session = {
        provider_token,
        provider_refresh_token,
        access_token,
        expires_in: expiresIn,
        expires_at: expiresAt2,
        refresh_token,
        token_type,
        user: data.user
      };
      window.location.hash = "";
      this._debug("#_getSessionFromURL()", "clearing window.location.hash");
      return this._returnResult({ data: { session, redirectType: params.type }, error: null });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: { session: null, redirectType: null }, error });
      }
      throw error;
    }
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   *
   * If `detectSessionInUrl` is a function, it will be called with the URL and params to determine
   * if the URL should be processed as a Supabase auth callback. This allows users to exclude
   * URLs from other OAuth providers (e.g., Facebook Login) that also return access_token in the fragment.
   */
  _isImplicitGrantCallback(params) {
    if (typeof this.detectSessionInUrl === "function") {
      return this.detectSessionInUrl(new URL(window.location.href), params);
    }
    return Boolean(params.access_token || params.error_description);
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  async _isPKCECallback(params) {
    const currentStorageContent = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    return !!(params.code && currentStorageContent);
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using `others` scope, no `SIGNED_OUT` event is fired!
   */
  async signOut(options = { scope: "global" }) {
    await this.initializePromise;
    return await this._acquireLock(this.lockAcquireTimeout, async () => {
      return await this._signOut(options);
    });
  }
  async _signOut({ scope } = { scope: "global" }) {
    return await this._useSession(async (result) => {
      var _a;
      const { data, error: sessionError } = result;
      if (sessionError && !isAuthSessionMissingError(sessionError)) {
        return this._returnResult({ error: sessionError });
      }
      const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;
      if (accessToken) {
        const { error } = await this.admin.signOut(accessToken, scope);
        if (error) {
          if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401 || error.status === 403) || isAuthSessionMissingError(error))) {
            return this._returnResult({ error });
          }
        }
      }
      if (scope !== "others") {
        await this._removeSession();
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      }
      return this._returnResult({ error: null });
    });
  }
  onAuthStateChange(callback) {
    const id = generateCallbackId();
    const subscription = {
      id,
      callback,
      unsubscribe: () => {
        this._debug("#unsubscribe()", "state change callback with id removed", id);
        this.stateChangeEmitters.delete(id);
      }
    };
    this._debug("#onAuthStateChange()", "registered callback with id", id);
    this.stateChangeEmitters.set(id, subscription);
    (async () => {
      await this.initializePromise;
      await this._acquireLock(this.lockAcquireTimeout, async () => {
        this._emitInitialSession(id);
      });
    })();
    return { data: { subscription } };
  }
  async _emitInitialSession(id) {
    return await this._useSession(async (result) => {
      var _a, _b;
      try {
        const { data: { session }, error } = result;
        if (error)
          throw error;
        await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback("INITIAL_SESSION", session));
        this._debug("INITIAL_SESSION", "callback id", id, "session", session);
      } catch (err) {
        await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback("INITIAL_SESSION", null));
        this._debug("INITIAL_SESSION", "callback id", id, "error", err);
        console.error(err);
      }
    });
  }
  /**
   * Sends a password reset request to an email address. This method supports the PKCE flow.
   *
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  async resetPasswordForEmail(email, options = {}) {
    let codeChallenge = null;
    let codeChallengeMethod = null;
    if (this.flowType === "pkce") {
      ;
      [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(
        this.storage,
        this.storageKey,
        true
        // isPasswordRecovery
      );
    }
    try {
      return await _request(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod,
          gotrue_meta_security: { captcha_token: options.captchaToken }
        },
        headers: this.headers,
        redirectTo: options.redirectTo
      });
    } catch (error) {
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (isAuthError(error)) {
        return this._returnResult({ data: null, error });
      }
      throw error;
    }
  }
  /**
   * Gets all the identities linked to a user.
   */
  async getUserIdentities() {
    var _a;
    try {
      const { data, error } = await this.getUser();
      if (error)
        throw error;
      return this._returnResult({ data: { identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : [] }, error: null });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: null, error });
      }
      throw error;
    }
  }
  async linkIdentity(credentials) {
    if ("token" in credentials) {
      return this.linkIdentityIdToken(credentials);
    }
    return this.linkIdentityOAuth(credentials);
  }
  async linkIdentityOAuth(credentials) {
    var _a;
    try {
      const { data, error } = await this._useSession(async (result) => {
        var _a2, _b, _c, _d, _e;
        const { data: data2, error: error2 } = result;
        if (error2)
          throw error2;
        const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
          redirectTo: (_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo,
          scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
          queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
          skipBrowserRedirect: true
        });
        return await _request(this.fetch, "GET", url, {
          headers: this.headers,
          jwt: (_e = (_d = data2.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : void 0
        });
      });
      if (error)
        throw error;
      if (isBrowser() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {
        window.location.assign(data === null || data === void 0 ? void 0 : data.url);
      }
      return this._returnResult({
        data: { provider: credentials.provider, url: data === null || data === void 0 ? void 0 : data.url },
        error: null
      });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: { provider: credentials.provider, url: null }, error });
      }
      throw error;
    }
  }
  async linkIdentityIdToken(credentials) {
    return await this._useSession(async (result) => {
      var _a;
      try {
        const { error: sessionError, data: { session } } = result;
        if (sessionError)
          throw sessionError;
        const { options, provider, token, access_token, nonce } = credentials;
        const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
          headers: this.headers,
          jwt: (_a = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a !== void 0 ? _a : void 0,
          body: {
            provider,
            id_token: token,
            access_token,
            nonce,
            link_identity: true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
        const { data, error } = res;
        if (error) {
          return this._returnResult({ data: { user: null, session: null }, error });
        } else if (!data || !data.session || !data.user) {
          return this._returnResult({
            data: { user: null, session: null },
            error: new AuthInvalidTokenResponseError()
          });
        }
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("USER_UPDATED", data.session);
        }
        return this._returnResult({ data, error });
      } catch (error) {
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    });
  }
  /**
   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
   */
  async unlinkIdentity(identity) {
    try {
      return await this._useSession(async (result) => {
        var _a, _b;
        const { data, error } = result;
        if (error) {
          throw error;
        }
        return await _request(this.fetch, "DELETE", `${this.url}/user/identities/${identity.identity_id}`, {
          headers: this.headers,
          jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : void 0
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: null, error });
      }
      throw error;
    }
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  async _refreshAccessToken(refreshToken) {
    const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      const startedAt = Date.now();
      return await retryable(async (attempt) => {
        if (attempt > 0) {
          await sleep(200 * Math.pow(2, attempt - 1));
        }
        this._debug(debugName, "refreshing attempt", attempt);
        return await _request(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
          body: { refresh_token: refreshToken },
          headers: this.headers,
          xform: _sessionResponse
        });
      }, (attempt, error) => {
        const nextBackOffInterval = 200 * Math.pow(2, attempt);
        return error && isAuthRetryableFetchError(error) && // retryable only if the request can be sent before the backoff overflows the tick duration
        Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION_MS;
      });
    } catch (error) {
      this._debug(debugName, "error", error);
      if (isAuthError(error)) {
        return this._returnResult({ data: { session: null, user: null }, error });
      }
      throw error;
    } finally {
      this._debug(debugName, "end");
    }
  }
  _isValidSession(maybeSession) {
    const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
    return isValidSession;
  }
  async _handleProviderSignIn(provider, options) {
    const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {
      redirectTo: options.redirectTo,
      scopes: options.scopes,
      queryParams: options.queryParams
    });
    this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
    if (isBrowser() && !options.skipBrowserRedirect) {
      window.location.assign(url);
    }
    return { data: { provider, url }, error: null };
  }
  /**
   * Recovers the session from LocalStorage and refreshes the token
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  async _recoverAndRefresh() {
    var _a, _b;
    const debugName = "#_recoverAndRefresh()";
    this._debug(debugName, "begin");
    try {
      const currentSession = await getItemAsync(this.storage, this.storageKey);
      if (currentSession && this.userStorage) {
        let maybeUser = await getItemAsync(this.userStorage, this.storageKey + "-user");
        if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {
          maybeUser = { user: currentSession.user };
          await setItemAsync(this.userStorage, this.storageKey + "-user", maybeUser);
        }
        currentSession.user = (_a = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a !== void 0 ? _a : userNotAvailableProxy();
      } else if (currentSession && !currentSession.user) {
        if (!currentSession.user) {
          const separateUser = await getItemAsync(this.storage, this.storageKey + "-user");
          if (separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user)) {
            currentSession.user = separateUser.user;
            await removeItemAsync(this.storage, this.storageKey + "-user");
            await setItemAsync(this.storage, this.storageKey, currentSession);
          } else {
            currentSession.user = userNotAvailableProxy();
          }
        }
      }
      this._debug(debugName, "session from storage", currentSession);
      if (!this._isValidSession(currentSession)) {
        this._debug(debugName, "session is not valid");
        if (currentSession !== null) {
          await this._removeSession();
        }
        return;
      }
      const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1e3 - Date.now() < EXPIRY_MARGIN_MS;
      this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${EXPIRY_MARGIN_MS}s`);
      if (expiresWithMargin) {
        if (this.autoRefreshToken && currentSession.refresh_token) {
          const { error } = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            console.error(error);
            if (!isAuthRetryableFetchError(error)) {
              this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error);
              await this._removeSession();
            }
          }
        }
      } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === true) {
        try {
          const { data, error: userError } = await this._getUser(currentSession.access_token);
          if (!userError && (data === null || data === void 0 ? void 0 : data.user)) {
            currentSession.user = data.user;
            await this._saveSession(currentSession);
            await this._notifyAllSubscribers("SIGNED_IN", currentSession);
          } else {
            this._debug(debugName, "could not get user data, skipping SIGNED_IN notification");
          }
        } catch (getUserError) {
          console.error("Error getting user data:", getUserError);
          this._debug(debugName, "error getting user data, skipping SIGNED_IN notification", getUserError);
        }
      } else {
        await this._notifyAllSubscribers("SIGNED_IN", currentSession);
      }
    } catch (err) {
      this._debug(debugName, "error", err);
      console.error(err);
      return;
    } finally {
      this._debug(debugName, "end");
    }
  }
  async _callRefreshToken(refreshToken) {
    var _a, _b;
    if (!refreshToken) {
      throw new AuthSessionMissingError();
    }
    if (this.refreshingDeferred) {
      return this.refreshingDeferred.promise;
    }
    const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      this.refreshingDeferred = new Deferred();
      const { data, error } = await this._refreshAccessToken(refreshToken);
      if (error)
        throw error;
      if (!data.session)
        throw new AuthSessionMissingError();
      await this._saveSession(data.session);
      await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
      const result = { data: data.session, error: null };
      this.refreshingDeferred.resolve(result);
      return result;
    } catch (error) {
      this._debug(debugName, "error", error);
      if (isAuthError(error)) {
        const result = { data: null, error };
        if (!isAuthRetryableFetchError(error)) {
          await this._removeSession();
        }
        (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);
        return result;
      }
      (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);
      throw error;
    } finally {
      this.refreshingDeferred = null;
      this._debug(debugName, "end");
    }
  }
  async _notifyAllSubscribers(event, session, broadcast = true) {
    const debugName = `#_notifyAllSubscribers(${event})`;
    this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
    try {
      if (this.broadcastChannel && broadcast) {
        this.broadcastChannel.postMessage({ event, session });
      }
      const errors = [];
      const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {
        try {
          await x.callback(event, session);
        } catch (e) {
          errors.push(e);
        }
      });
      await Promise.all(promises);
      if (errors.length > 0) {
        for (let i = 0; i < errors.length; i += 1) {
          console.error(errors[i]);
        }
        throw errors[0];
      }
    } finally {
      this._debug(debugName, "end");
    }
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  async _saveSession(session) {
    this._debug("#_saveSession()", session);
    this.suppressGetSessionWarning = true;
    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    const sessionToProcess = Object.assign({}, session);
    const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;
    if (this.userStorage) {
      if (!userIsProxy && sessionToProcess.user) {
        await setItemAsync(this.userStorage, this.storageKey + "-user", {
          user: sessionToProcess.user
        });
      } else if (userIsProxy) {
      }
      const mainSessionData = Object.assign({}, sessionToProcess);
      delete mainSessionData.user;
      const clonedMainSessionData = deepClone(mainSessionData);
      await setItemAsync(this.storage, this.storageKey, clonedMainSessionData);
    } else {
      const clonedSession = deepClone(sessionToProcess);
      await setItemAsync(this.storage, this.storageKey, clonedSession);
    }
  }
  async _removeSession() {
    this._debug("#_removeSession()");
    this.suppressGetSessionWarning = false;
    await removeItemAsync(this.storage, this.storageKey);
    await removeItemAsync(this.storage, this.storageKey + "-code-verifier");
    await removeItemAsync(this.storage, this.storageKey + "-user");
    if (this.userStorage) {
      await removeItemAsync(this.userStorage, this.storageKey + "-user");
    }
    await this._notifyAllSubscribers("SIGNED_OUT", null);
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const callback = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
        window.removeEventListener("visibilitychange", callback);
      }
    } catch (e) {
      console.error("removing visibilitychange callback failed", e);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  async _startAutoRefresh() {
    await this._stopAutoRefresh();
    this._debug("#_startAutoRefresh()");
    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION_MS);
    this.autoRefreshTicker = ticker;
    if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") {
      ticker.unref();
    } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
      Deno.unrefTimer(ticker);
    }
    const timeout = setTimeout(async () => {
      await this.initializePromise;
      await this._autoRefreshTokenTick();
    }, 0);
    this.autoRefreshTickTimeout = timeout;
    if (timeout && typeof timeout === "object" && typeof timeout.unref === "function") {
      timeout.unref();
    } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
      Deno.unrefTimer(timeout);
    }
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const ticker = this.autoRefreshTicker;
    this.autoRefreshTicker = null;
    if (ticker) {
      clearInterval(ticker);
    }
    const timeout = this.autoRefreshTickTimeout;
    this.autoRefreshTickTimeout = null;
    if (timeout) {
      clearTimeout(timeout);
    }
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._startAutoRefresh();
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._stopAutoRefresh();
  }
  /**
   * Runs the auto refresh token tick.
   */
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const now = Date.now();
          try {
            return await this._useSession(async (result) => {
              const { data: { session } } = result;
              if (!session || !session.refresh_token || !session.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const expiresInTicks = Math.floor((session.expires_at * 1e3 - now) / AUTO_REFRESH_TICK_DURATION_MS);
              this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
              if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {
                await this._callRefreshToken(session.refresh_token);
              }
            });
          } catch (e) {
            console.error("Auto refresh tick failed with error. This is likely a transient error.", e);
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof LockAcquireTimeoutError) {
        this._debug("auto refresh token tick lock not available");
      } else {
        throw e;
      }
    }
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  async _handleVisibilityChange() {
    this._debug("#_handleVisibilityChange()");
    if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
      if (this.autoRefreshToken) {
        this.startAutoRefresh();
      }
      return false;
    }
    try {
      this.visibilityChangedCallback = async () => {
        try {
          await this._onVisibilityChanged(false);
        } catch (error) {
          this._debug("#visibilityChangedCallback", "error", error);
        }
      };
      window === null || window === void 0 ? void 0 : window.addEventListener("visibilitychange", this.visibilityChangedCallback);
      await this._onVisibilityChanged(true);
    } catch (error) {
      console.error("_handleVisibilityChange", error);
    }
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  async _onVisibilityChanged(calledFromInitialize) {
    const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
    this._debug(methodName, "visibilityState", document.visibilityState);
    if (document.visibilityState === "visible") {
      if (this.autoRefreshToken) {
        this._startAutoRefresh();
      }
      if (!calledFromInitialize) {
        await this.initializePromise;
        await this._acquireLock(this.lockAcquireTimeout, async () => {
          if (document.visibilityState !== "visible") {
            this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
            return;
          }
          await this._recoverAndRefresh();
        });
      }
    } else if (document.visibilityState === "hidden") {
      if (this.autoRefreshToken) {
        this._stopAutoRefresh();
      }
    }
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  async _getUrlForProvider(url, provider, options) {
    const urlParams = [`provider=${encodeURIComponent(provider)}`];
    if (options === null || options === void 0 ? void 0 : options.redirectTo) {
      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
    }
    if (options === null || options === void 0 ? void 0 : options.scopes) {
      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
    }
    if (this.flowType === "pkce") {
      const [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
      const flowParams = new URLSearchParams({
        code_challenge: `${encodeURIComponent(codeChallenge)}`,
        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
      });
      urlParams.push(flowParams.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.queryParams) {
      const query = new URLSearchParams(options.queryParams);
      urlParams.push(query.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
      urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
    }
    return `${url}?${urlParams.join("&")}`;
  }
  async _unenroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        return await _request(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {
          headers: this.headers,
          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: null, error });
      }
      throw error;
    }
  }
  async _enroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a, _b;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        const body = Object.assign({ friendly_name: params.friendlyName, factor_type: params.factorType }, params.factorType === "phone" ? { phone: params.phone } : params.factorType === "totp" ? { issuer: params.issuer } : {});
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors`, {
          body,
          headers: this.headers,
          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
        });
        if (error) {
          return this._returnResult({ data: null, error });
        }
        if (params.factorType === "totp" && data.type === "totp" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {
          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
        }
        return this._returnResult({ data, error: null });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: null, error });
      }
      throw error;
    }
  }
  async _verify(params) {
    return this._acquireLock(this.lockAcquireTimeout, async () => {
      try {
        return await this._useSession(async (result) => {
          var _a;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          const body = Object.assign({ challenge_id: params.challengeId }, "webauthn" in params ? {
            webauthn: Object.assign(Object.assign({}, params.webauthn), { credential_response: params.webauthn.type === "create" ? serializeCredentialCreationResponse(params.webauthn.credential_response) : serializeCredentialRequestResponse(params.webauthn.credential_response) })
          } : { code: params.code });
          const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {
            body,
            headers: this.headers,
            jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
          });
          if (error) {
            return this._returnResult({ data: null, error });
          }
          await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));
          await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
          return this._returnResult({ data, error });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    });
  }
  async _challenge(params) {
    return this._acquireLock(this.lockAcquireTimeout, async () => {
      try {
        return await this._useSession(async (result) => {
          var _a;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          const response = await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {
            body: params,
            headers: this.headers,
            jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
          });
          if (response.error) {
            return response;
          }
          const { data } = response;
          if (data.type !== "webauthn") {
            return { data, error: null };
          }
          switch (data.webauthn.type) {
            case "create":
              return {
                data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: deserializeCredentialCreationOptions(data.webauthn.credential_options.publicKey) }) }) }),
                error: null
              };
            case "request":
              return {
                data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: deserializeCredentialRequestOptions(data.webauthn.credential_options.publicKey) }) }) }),
                error: null
              };
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  async _challengeAndVerify(params) {
    const { data: challengeData, error: challengeError } = await this._challenge({
      factorId: params.factorId
    });
    if (challengeError) {
      return this._returnResult({ data: null, error: challengeError });
    }
    return await this._verify({
      factorId: params.factorId,
      challengeId: challengeData.id,
      code: params.code
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  async _listFactors() {
    var _a;
    const { data: { user }, error: userError } = await this.getUser();
    if (userError) {
      return { data: null, error: userError };
    }
    const data = {
      all: [],
      phone: [],
      totp: [],
      webauthn: []
    };
    for (const factor of (_a = user === null || user === void 0 ? void 0 : user.factors) !== null && _a !== void 0 ? _a : []) {
      data.all.push(factor);
      if (factor.status === "verified") {
        ;
        data[factor.factor_type].push(factor);
      }
    }
    return {
      data,
      error: null
    };
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  async _getAuthenticatorAssuranceLevel(jwt) {
    var _a, _b, _c, _d;
    if (jwt) {
      try {
        const { payload: payload2 } = decodeJWT(jwt);
        let currentLevel2 = null;
        if (payload2.aal) {
          currentLevel2 = payload2.aal;
        }
        let nextLevel2 = currentLevel2;
        const { data: { user }, error: userError } = await this.getUser(jwt);
        if (userError) {
          return this._returnResult({ data: null, error: userError });
        }
        const verifiedFactors2 = (_b = (_a = user === null || user === void 0 ? void 0 : user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor) => factor.status === "verified")) !== null && _b !== void 0 ? _b : [];
        if (verifiedFactors2.length > 0) {
          nextLevel2 = "aal2";
        }
        const currentAuthenticationMethods2 = payload2.amr || [];
        return { data: { currentLevel: currentLevel2, nextLevel: nextLevel2, currentAuthenticationMethods: currentAuthenticationMethods2 }, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    const { data: { session }, error: sessionError } = await this.getSession();
    if (sessionError) {
      return this._returnResult({ data: null, error: sessionError });
    }
    if (!session) {
      return {
        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
        error: null
      };
    }
    const { payload } = decodeJWT(session.access_token);
    let currentLevel = null;
    if (payload.aal) {
      currentLevel = payload.aal;
    }
    let nextLevel = currentLevel;
    const verifiedFactors = (_d = (_c = session.user.factors) === null || _c === void 0 ? void 0 : _c.filter((factor) => factor.status === "verified")) !== null && _d !== void 0 ? _d : [];
    if (verifiedFactors.length > 0) {
      nextLevel = "aal2";
    }
    const currentAuthenticationMethods = payload.amr || [];
    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };
  }
  /**
   * Retrieves details about an OAuth authorization request.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * Returns authorization details including client info, scopes, and user information.
   * If the API returns a redirect_uri, it means consent was already given - the caller
   * should handle the redirect manually if needed.
   */
  async _getAuthorizationDetails(authorizationId) {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        if (!session) {
          return this._returnResult({ data: null, error: new AuthSessionMissingError() });
        }
        return await _request(this.fetch, "GET", `${this.url}/oauth/authorizations/${authorizationId}`, {
          headers: this.headers,
          jwt: session.access_token,
          xform: (data) => ({ data, error: null })
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: null, error });
      }
      throw error;
    }
  }
  /**
   * Approves an OAuth authorization request.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   */
  async _approveAuthorization(authorizationId, options) {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        if (!session) {
          return this._returnResult({ data: null, error: new AuthSessionMissingError() });
        }
        const response = await _request(this.fetch, "POST", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {
          headers: this.headers,
          jwt: session.access_token,
          body: { action: "approve" },
          xform: (data) => ({ data, error: null })
        });
        if (response.data && response.data.redirect_url) {
          if (isBrowser() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {
            window.location.assign(response.data.redirect_url);
          }
        }
        return response;
      });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: null, error });
      }
      throw error;
    }
  }
  /**
   * Denies an OAuth authorization request.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   */
  async _denyAuthorization(authorizationId, options) {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        if (!session) {
          return this._returnResult({ data: null, error: new AuthSessionMissingError() });
        }
        const response = await _request(this.fetch, "POST", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {
          headers: this.headers,
          jwt: session.access_token,
          body: { action: "deny" },
          xform: (data) => ({ data, error: null })
        });
        if (response.data && response.data.redirect_url) {
          if (isBrowser() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {
            window.location.assign(response.data.redirect_url);
          }
        }
        return response;
      });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: null, error });
      }
      throw error;
    }
  }
  /**
   * Lists all OAuth grants that the authenticated user has authorized.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   */
  async _listOAuthGrants() {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        if (!session) {
          return this._returnResult({ data: null, error: new AuthSessionMissingError() });
        }
        return await _request(this.fetch, "GET", `${this.url}/user/oauth/grants`, {
          headers: this.headers,
          jwt: session.access_token,
          xform: (data) => ({ data, error: null })
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: null, error });
      }
      throw error;
    }
  }
  /**
   * Revokes a user's OAuth grant for a specific client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   */
  async _revokeOAuthGrant(options) {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ data: null, error: sessionError });
        }
        if (!session) {
          return this._returnResult({ data: null, error: new AuthSessionMissingError() });
        }
        await _request(this.fetch, "DELETE", `${this.url}/user/oauth/grants`, {
          headers: this.headers,
          jwt: session.access_token,
          query: { client_id: options.clientId },
          noResolveJson: true
        });
        return { data: {}, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: null, error });
      }
      throw error;
    }
  }
  async fetchJwk(kid, jwks = { keys: [] }) {
    let jwk = jwks.keys.find((key) => key.kid === kid);
    if (jwk) {
      return jwk;
    }
    const now = Date.now();
    jwk = this.jwks.keys.find((key) => key.kid === kid);
    if (jwk && this.jwks_cached_at + JWKS_TTL > now) {
      return jwk;
    }
    const { data, error } = await _request(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
      headers: this.headers
    });
    if (error) {
      throw error;
    }
    if (!data.keys || data.keys.length === 0) {
      return null;
    }
    this.jwks = data;
    this.jwks_cached_at = now;
    jwk = data.keys.find((key) => key.kid === kid);
    if (!jwk) {
      return null;
    }
    return jwk;
  }
  /**
   * Extracts the JWT claims present in the access token by first verifying the
   * JWT against the server's JSON Web Key Set endpoint
   * `/.well-known/jwks.json` which is often cached, resulting in significantly
   * faster responses. Prefer this method over {@link #getUser} which always
   * sends a request to the Auth server for each JWT.
   *
   * If the project is not using an asymmetric JWT signing key (like ECC or
   * RSA) it always sends a request to the Auth server (similar to {@link
   * #getUser}) to verify the JWT.
   *
   * @param jwt An optional specific JWT you wish to verify, not the one you
   *            can obtain from {@link #getSession}.
   * @param options Various additional options that allow you to customize the
   *                behavior of this method.
   */
  async getClaims(jwt, options = {}) {
    try {
      let token = jwt;
      if (!token) {
        const { data, error } = await this.getSession();
        if (error || !data.session) {
          return this._returnResult({ data: null, error });
        }
        token = data.session.access_token;
      }
      const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = decodeJWT(token);
      if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {
        validateExp(payload.exp);
      }
      const signingKey = !header.alg || header.alg.startsWith("HS") || !header.kid || !("crypto" in globalThis && "subtle" in globalThis.crypto) ? null : await this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? { keys: options.keys } : options === null || options === void 0 ? void 0 : options.jwks);
      if (!signingKey) {
        const { error } = await this.getUser(token);
        if (error) {
          throw error;
        }
        return {
          data: {
            claims: payload,
            header,
            signature
          },
          error: null
        };
      }
      const algorithm = getAlgorithm(header.alg);
      const publicKey = await crypto.subtle.importKey("jwk", signingKey, algorithm, true, [
        "verify"
      ]);
      const isValid = await crypto.subtle.verify(algorithm, publicKey, signature, stringToUint8Array(`${rawHeader}.${rawPayload}`));
      if (!isValid) {
        throw new AuthInvalidJwtError("Invalid JWT signature");
      }
      return {
        data: {
          claims: payload,
          header,
          signature
        },
        error: null
      };
    } catch (error) {
      if (isAuthError(error)) {
        return this._returnResult({ data: null, error });
      }
      throw error;
    }
  }
};
GoTrueClient.nextInstanceID = {};
var GoTrueClient_default = GoTrueClient;

// node_modules/@supabase/auth-js/dist/module/AuthClient.js
var AuthClient = GoTrueClient_default;
var AuthClient_default = AuthClient;

// node_modules/@supabase/supabase-js/dist/index.mjs
var version4 = "2.93.3";
var JS_ENV = "";
if (typeof Deno !== "undefined") JS_ENV = "deno";
else if (typeof document !== "undefined") JS_ENV = "web";
else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") JS_ENV = "react-native";
else JS_ENV = "node";
var DEFAULT_HEADERS3 = { "X-Client-Info": `supabase-js-${JS_ENV}/${version4}` };
var DEFAULT_GLOBAL_OPTIONS = { headers: DEFAULT_HEADERS3 };
var DEFAULT_DB_OPTIONS = { schema: "public" };
var DEFAULT_AUTH_OPTIONS = {
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  flowType: "implicit"
};
var DEFAULT_REALTIME_OPTIONS = {};
function _typeof2(o) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
    return typeof o$1;
  } : function(o$1) {
    return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
  }, _typeof2(o);
}
function toPrimitive2(t, r) {
  if ("object" != _typeof2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof2(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function toPropertyKey2(t) {
  var i = toPrimitive2(t, "string");
  return "symbol" == _typeof2(i) ? i : i + "";
}
function _defineProperty2(e, r, t) {
  return (r = toPropertyKey2(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r$1) {
      return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread22(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r$1) {
      _defineProperty2(e, r$1, t[r$1]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r$1) {
      Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
    });
  }
  return e;
}
var resolveFetch4 = (customFetch) => {
  if (customFetch) return (...args) => customFetch(...args);
  return (...args) => fetch(...args);
};
var resolveHeadersConstructor = () => {
  return Headers;
};
var fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
  const fetch$1 = resolveFetch4(customFetch);
  const HeadersConstructor = resolveHeadersConstructor();
  return async (input, init) => {
    var _await$getAccessToken;
    const accessToken = (_await$getAccessToken = await getAccessToken()) !== null && _await$getAccessToken !== void 0 ? _await$getAccessToken : supabaseKey;
    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
    if (!headers.has("apikey")) headers.set("apikey", supabaseKey);
    if (!headers.has("Authorization")) headers.set("Authorization", `Bearer ${accessToken}`);
    return fetch$1(input, _objectSpread22(_objectSpread22({}, init), {}, { headers }));
  };
};
function ensureTrailingSlash(url) {
  return url.endsWith("/") ? url : url + "/";
}
function applySettingDefaults(options, defaults) {
  var _DEFAULT_GLOBAL_OPTIO, _globalOptions$header;
  const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
  const { db: DEFAULT_DB_OPTIONS$1, auth: DEFAULT_AUTH_OPTIONS$1, realtime: DEFAULT_REALTIME_OPTIONS$1, global: DEFAULT_GLOBAL_OPTIONS$1 } = defaults;
  const result = {
    db: _objectSpread22(_objectSpread22({}, DEFAULT_DB_OPTIONS$1), dbOptions),
    auth: _objectSpread22(_objectSpread22({}, DEFAULT_AUTH_OPTIONS$1), authOptions),
    realtime: _objectSpread22(_objectSpread22({}, DEFAULT_REALTIME_OPTIONS$1), realtimeOptions),
    storage: {},
    global: _objectSpread22(_objectSpread22(_objectSpread22({}, DEFAULT_GLOBAL_OPTIONS$1), globalOptions), {}, { headers: _objectSpread22(_objectSpread22({}, (_DEFAULT_GLOBAL_OPTIO = DEFAULT_GLOBAL_OPTIONS$1 === null || DEFAULT_GLOBAL_OPTIONS$1 === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS$1.headers) !== null && _DEFAULT_GLOBAL_OPTIO !== void 0 ? _DEFAULT_GLOBAL_OPTIO : {}), (_globalOptions$header = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _globalOptions$header !== void 0 ? _globalOptions$header : {}) }),
    accessToken: async () => ""
  };
  if (options.accessToken) result.accessToken = options.accessToken;
  else delete result.accessToken;
  return result;
}
function validateSupabaseUrl(supabaseUrl) {
  const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();
  if (!trimmedUrl) throw new Error("supabaseUrl is required.");
  if (!trimmedUrl.match(/^https?:\/\//i)) throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
  try {
    return new URL(ensureTrailingSlash(trimmedUrl));
  } catch (_unused) {
    throw Error("Invalid supabaseUrl: Provided URL is malformed.");
  }
}
var SupabaseAuthClient = class extends AuthClient_default {
  constructor(options) {
    super(options);
  }
};
var SupabaseClient = class {
  /**
  * Create a new client for use in the browser.
  * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
  * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
  * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
  * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
  * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
  * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
  * @param options.realtime Options passed along to realtime-js constructor.
  * @param options.storage Options passed along to the storage-js constructor.
  * @param options.global.fetch A custom fetch implementation.
  * @param options.global.headers Any additional headers to send with each network request.
  * @example
  * ```ts
  * import { createClient } from '@supabase/supabase-js'
  *
  * const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')
  * const { data } = await supabase.from('profiles').select('*')
  * ```
  */
  constructor(supabaseUrl, supabaseKey, options) {
    var _settings$auth$storag, _settings$global$head;
    this.supabaseUrl = supabaseUrl;
    this.supabaseKey = supabaseKey;
    const baseUrl = validateSupabaseUrl(supabaseUrl);
    if (!supabaseKey) throw new Error("supabaseKey is required.");
    this.realtimeUrl = new URL("realtime/v1", baseUrl);
    this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws");
    this.authUrl = new URL("auth/v1", baseUrl);
    this.storageUrl = new URL("storage/v1", baseUrl);
    this.functionsUrl = new URL("functions/v1", baseUrl);
    const defaultStorageKey = `sb-${baseUrl.hostname.split(".")[0]}-auth-token`;
    const DEFAULTS = {
      db: DEFAULT_DB_OPTIONS,
      realtime: DEFAULT_REALTIME_OPTIONS,
      auth: _objectSpread22(_objectSpread22({}, DEFAULT_AUTH_OPTIONS), {}, { storageKey: defaultStorageKey }),
      global: DEFAULT_GLOBAL_OPTIONS
    };
    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);
    this.storageKey = (_settings$auth$storag = settings.auth.storageKey) !== null && _settings$auth$storag !== void 0 ? _settings$auth$storag : "";
    this.headers = (_settings$global$head = settings.global.headers) !== null && _settings$global$head !== void 0 ? _settings$global$head : {};
    if (!settings.accessToken) {
      var _settings$auth;
      this.auth = this._initSupabaseAuthClient((_settings$auth = settings.auth) !== null && _settings$auth !== void 0 ? _settings$auth : {}, this.headers, settings.global.fetch);
    } else {
      this.accessToken = settings.accessToken;
      this.auth = new Proxy({}, { get: (_, prop) => {
        throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
      } });
    }
    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
    this.realtime = this._initRealtimeClient(_objectSpread22({
      headers: this.headers,
      accessToken: this._getAccessToken.bind(this)
    }, settings.realtime));
    if (this.accessToken) Promise.resolve(this.accessToken()).then((token) => this.realtime.setAuth(token)).catch((e) => console.warn("Failed to set initial Realtime auth token:", e));
    this.rest = new PostgrestClient(new URL("rest/v1", baseUrl).href, {
      headers: this.headers,
      schema: settings.db.schema,
      fetch: this.fetch
    });
    this.storage = new StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);
    if (!settings.accessToken) this._listenForAuthEvents();
  }
  /**
  * Supabase Functions allows you to deploy and invoke edge functions.
  */
  get functions() {
    return new FunctionsClient(this.functionsUrl.href, {
      headers: this.headers,
      customFetch: this.fetch
    });
  }
  /**
  * Perform a query on a table or a view.
  *
  * @param relation - The table or view name to query
  */
  from(relation) {
    return this.rest.from(relation);
  }
  /**
  * Select a schema to query or perform an function (rpc) call.
  *
  * The schema needs to be on the list of exposed schemas inside Supabase.
  *
  * @param schema - The schema to query
  */
  schema(schema) {
    return this.rest.schema(schema);
  }
  /**
  * Perform a function call.
  *
  * @param fn - The function name to call
  * @param args - The arguments to pass to the function call
  * @param options - Named parameters
  * @param options.head - When set to `true`, `data` will not be returned.
  * Useful if you only need the count.
  * @param options.get - When set to `true`, the function will be called with
  * read-only access mode.
  * @param options.count - Count algorithm to use to count rows returned by the
  * function. Only applicable for [set-returning
  * functions](https://www.postgresql.org/docs/current/functions-srf.html).
  *
  * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
  * hood.
  *
  * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
  * statistics under the hood.
  *
  * `"estimated"`: Uses exact count for low numbers and planned count for high
  * numbers.
  */
  rpc(fn, args = {}, options = {
    head: false,
    get: false,
    count: void 0
  }) {
    return this.rest.rpc(fn, args, options);
  }
  /**
  * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
  *
  * @param {string} name - The name of the Realtime channel.
  * @param {Object} opts - The options to pass to the Realtime channel.
  *
  */
  channel(name, opts = { config: {} }) {
    return this.realtime.channel(name, opts);
  }
  /**
  * Returns all Realtime channels.
  */
  getChannels() {
    return this.realtime.getChannels();
  }
  /**
  * Unsubscribes and removes Realtime channel from Realtime client.
  *
  * @param {RealtimeChannel} channel - The name of the Realtime channel.
  *
  */
  removeChannel(channel) {
    return this.realtime.removeChannel(channel);
  }
  /**
  * Unsubscribes and removes all Realtime channels from Realtime client.
  */
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  async _getAccessToken() {
    var _this = this;
    var _data$session$access_, _data$session;
    if (_this.accessToken) return await _this.accessToken();
    const { data } = await _this.auth.getSession();
    return (_data$session$access_ = (_data$session = data.session) === null || _data$session === void 0 ? void 0 : _data$session.access_token) !== null && _data$session$access_ !== void 0 ? _data$session$access_ : _this.supabaseKey;
  }
  _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, throwOnError }, headers, fetch$1) {
    const authHeaders = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new SupabaseAuthClient({
      url: this.authUrl.href,
      headers: _objectSpread22(_objectSpread22({}, authHeaders), headers),
      storageKey,
      autoRefreshToken,
      persistSession,
      detectSessionInUrl,
      storage,
      userStorage,
      flowType,
      lock,
      debug,
      throwOnError,
      fetch: fetch$1,
      hasCustomAuthorizationHeader: Object.keys(this.headers).some((key) => key.toLowerCase() === "authorization")
    });
  }
  _initRealtimeClient(options) {
    return new RealtimeClient(this.realtimeUrl.href, _objectSpread22(_objectSpread22({}, options), {}, { params: _objectSpread22(_objectSpread22({}, { apikey: this.supabaseKey }), options === null || options === void 0 ? void 0 : options.params) }));
  }
  _listenForAuthEvents() {
    return this.auth.onAuthStateChange((event, session) => {
      this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
    });
  }
  _handleTokenChanged(event, source, token) {
    if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
      this.changedAccessToken = token;
      this.realtime.setAuth(token);
    } else if (event === "SIGNED_OUT") {
      this.realtime.setAuth();
      if (source == "STORAGE") this.auth.signOut();
      this.changedAccessToken = void 0;
    }
  }
};
var createClient = (supabaseUrl, supabaseKey, options) => {
  return new SupabaseClient(supabaseUrl, supabaseKey, options);
};
function shouldShowDeprecationWarning() {
  if (typeof window !== "undefined") return false;
  const _process = globalThis["process"];
  if (!_process) return false;
  const processVersion = _process["version"];
  if (processVersion === void 0 || processVersion === null) return false;
  const versionMatch = processVersion.match(/^v(\d+)\./);
  if (!versionMatch) return false;
  return parseInt(versionMatch[1], 10) <= 18;
}
if (shouldShowDeprecationWarning()) console.warn("\u26A0\uFE0F  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");

// lib/config.js
var SUPABASE_URL = "https://zoqtvrcrqnaatkdwmail.supabase.co";
var SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpvcXR2cmNycW5hYXRrZHdtYWlsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk0MDg5ODksImV4cCI6MjA4NDk4NDk4OX0.j2NNC57jmWPANjGufdLZb0FPz8lhOdaq9V32Fv0zZpE";
var GOOGLE_AUTH_CLIENT_ID = import.meta.env?.VITE_GOOGLE_AUTH_CLIENT_ID || "167290902104-m31v1limo9qjec9s7f9r9k9ltu4n25b3.apps.googleusercontent.com";

// lib/supabase-client.js
var supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: {
    // chrome.storage.local   
    storage: {
      getItem: async (key) => {
        const result = await chrome.storage.local.get([key]);
        return result[key] || null;
      },
      setItem: async (key, value) => {
        await chrome.storage.local.set({ [key]: value });
      },
      removeItem: async (key) => {
        await chrome.storage.local.remove([key]);
      }
    },
    //    
    autoRefreshToken: true,
    //   (   )
    persistSession: true,
    //    (    )
    detectSessionInUrl: false
  }
});
async function getSession() {
  const { data, error } = await supabase.auth.getSession();
  if (error) {
    console.error("[Supabase] Get session failed:", error.message);
    throw error;
  }
  return {
    session: data.session,
    user: data.session?.user || null
  };
}

// scrum-viewer.js
var loadingScreen = document.getElementById("loadingScreen");
var loadingSubtext = document.getElementById("loadingSubtext");
var progressFill = document.getElementById("progressFill");
var scrumContainer = document.getElementById("scrumContainer");
var scrumDate = document.getElementById("scrumDate");
var scrumContent = document.getElementById("scrumContent");
var errorScreen = document.getElementById("errorScreen");
var errorTitle = document.getElementById("errorTitle");
var errorMessage = document.getElementById("errorMessage");
var retryBtn = document.getElementById("retryBtn");
var emptyScreen = document.getElementById("emptyScreen");
var emptyMessage = document.getElementById("emptyMessage");
var generateBtn = document.getElementById("generateBtn");
var floatingControls = document.getElementById("floatingControls");
var datePicker = document.getElementById("datePicker");
var todayBtn = document.getElementById("todayBtn");
var generateBtnMain = document.getElementById("generateBtnMain");
var syncBtn = document.getElementById("syncBtn");
var syncStatus = document.getElementById("syncStatus");
var syncProgress = document.getElementById("syncProgress");
var syncProgressFill = document.getElementById("syncProgressFill");
var currentDate = null;
var progress = 0;
var loadingInterval = null;
var pendingCount = 0;
var initialPendingCount = 0;
var processedCount = 0;
var isSyncing = false;
var expandedFlows = /* @__PURE__ */ new Set();
var loadingMessages = [
  "Analyzing your activities...",
  "Processing commits & PRs...",
  "Reviewing calendar events...",
  "Gathering insights...",
  "Preparing your scrum..."
];
document.addEventListener("DOMContentLoaded", async () => {
  const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
  datePicker.value = today;
  currentDate = today;
  setupEventListeners();
  await loadReport(currentDate);
  await checkPendingCount(currentDate);
});
function setupEventListeners() {
  datePicker.addEventListener("change", async (e) => {
    currentDate = e.target.value;
    await loadReport(currentDate);
    await checkPendingCount(currentDate);
  });
  todayBtn.addEventListener("click", async () => {
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    datePicker.value = today;
    currentDate = today;
    await loadReport(currentDate);
    await checkPendingCount(currentDate);
  });
  retryBtn.addEventListener("click", () => loadReport(currentDate));
  generateBtn.addEventListener("click", () => generateReport(currentDate));
  generateBtnMain.addEventListener("click", () => generateReport(currentDate));
  if (syncBtn) {
    syncBtn.addEventListener("click", () => syncData(currentDate));
  }
}
function showView(view) {
  loadingScreen.classList.add("hidden");
  scrumContainer.classList.remove("visible");
  errorScreen.classList.remove("visible");
  emptyScreen.classList.remove("visible");
  floatingControls.classList.remove("visible");
  switch (view) {
    case "loading":
      loadingScreen.classList.remove("hidden");
      startLoadingAnimation();
      break;
    case "report":
      scrumContainer.classList.add("visible");
      floatingControls.classList.add("visible");
      break;
    case "error":
      errorScreen.classList.add("visible");
      floatingControls.classList.add("visible");
      break;
    case "empty":
      emptyScreen.classList.add("visible");
      floatingControls.classList.add("visible");
      break;
  }
}
function startLoadingAnimation() {
  progress = 0;
  progressFill.style.width = "0%";
  loadingSubtext.textContent = loadingMessages[0];
  if (loadingInterval) clearInterval(loadingInterval);
  loadingInterval = setInterval(() => {
    progress += Math.random() * 8 + 2;
    if (progress > 95) progress = 95;
    progressFill.style.width = progress + "%";
    const msgIndex = Math.min(Math.floor(progress / 20), loadingMessages.length - 1);
    loadingSubtext.textContent = loadingMessages[msgIndex];
  }, 400);
}
function stopLoadingAnimation() {
  if (loadingInterval) {
    clearInterval(loadingInterval);
    loadingInterval = null;
  }
  progressFill.style.width = "100%";
  loadingSubtext.textContent = "Complete!";
}
async function loadReport(date) {
  try {
    showView("loading");
    const { session } = await getSession();
    if (!session) {
      throw new Error("Please log in first.");
    }
    const url = `${SUPABASE_URL}/functions/v1/get-scrum?date=${date}`;
    const response = await fetch(url, {
      method: "GET",
      headers: {
        "Authorization": `Bearer ${session.access_token}`,
        "Content-Type": "application/json"
      }
    });
    stopLoadingAnimation();
    await new Promise((resolve) => setTimeout(resolve, 300));
    if (response.status === 404) {
      emptyMessage.textContent = `${formatDate(date)}\uC5D0 \uC218\uC9D1\uB41C \uB370\uC774\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.`;
      showView("empty");
      return;
    }
    if (!response.ok) {
      const err = await response.json().catch(() => ({ error: "Unknown error" }));
      throw new Error(err.error || `HTTP ${response.status}`);
    }
    const result = await response.json();
    if (!result.success || !result.data) {
      throw new Error("Invalid response format.");
    }
    renderReport(result.data, date);
    showView("report");
  } catch (error) {
    stopLoadingAnimation();
    await new Promise((resolve) => setTimeout(resolve, 300));
    console.error("[Viewer] Load failed:", error);
    showError("\uBD88\uB7EC\uC624\uAE30 \uC2E4\uD328", error.message);
  }
}
async function checkPendingCount(date) {
  try {
    const { session } = await getSession();
    if (!session) return;
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || "Asia/Seoul";
    const url = `${SUPABASE_URL}/functions/v1/pending-count?date=${date}&timezone=${encodeURIComponent(timezone)}`;
    const response = await fetch(url, {
      method: "GET",
      headers: {
        "Authorization": `Bearer ${session.access_token}`,
        "Content-Type": "application/json"
      }
    });
    if (!response.ok) {
      console.warn("[Sync] Failed to check pending count");
      updateSyncUI(0);
      return;
    }
    const result = await response.json();
    if (result.success) {
      pendingCount = result.pending_count || 0;
      updateSyncUI(pendingCount, result.normalized_count);
    }
  } catch (error) {
    console.error("[Sync] Check pending failed:", error);
    updateSyncUI(0);
  }
}
function updateSyncUI(pending, normalized = 0) {
  if (!syncBtn || !syncStatus) return;
  if (isSyncing) {
    syncBtn.disabled = true;
    syncBtn.classList.add("syncing");
    syncStatus.textContent = "\uB3D9\uAE30\uD654 \uC911...";
    syncBtn.title = "\uB3D9\uAE30\uD654 \uC9C4\uD589 \uC911...";
    if (syncProgress) {
      syncProgress.classList.add("visible");
    }
  } else if (pending > 0) {
    syncBtn.disabled = false;
    syncBtn.classList.remove("syncing");
    syncStatus.textContent = `${pending}\uAC1C \uB300\uAE30`;
    syncBtn.title = `${pending}\uAC1C\uC758 \uBBF8\uCC98\uB9AC \uB370\uC774\uD130\uAC00 \uC788\uC2B5\uB2C8\uB2E4. \uD074\uB9AD\uD558\uC5EC \uB3D9\uAE30\uD654\uD558\uC138\uC694.`;
    if (syncProgress) {
      syncProgress.classList.remove("visible");
    }
    if (syncProgressFill) {
      syncProgressFill.style.width = "0%";
      syncProgressFill.classList.remove("complete");
    }
  } else {
    syncBtn.disabled = true;
    syncBtn.classList.remove("syncing");
    syncStatus.textContent = "\uB3D9\uAE30\uD654 \uC644\uB8CC";
    syncBtn.title = "\uCC98\uB9AC\uD560 \uB370\uC774\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.";
    if (syncProgress) {
      syncProgress.classList.remove("visible");
    }
  }
}
function updateSyncProgress(processed, total) {
  if (!syncProgressFill || total === 0) return;
  const percent = Math.min(100, Math.round(processed / total * 100));
  syncProgressFill.style.width = `${percent}%`;
  if (percent >= 100) {
    syncProgressFill.classList.add("complete");
  } else {
    syncProgressFill.classList.remove("complete");
  }
}
async function syncData(date, isInitialCall = true) {
  if (isSyncing && isInitialCall) return;
  try {
    if (isInitialCall) {
      isSyncing = true;
      initialPendingCount = pendingCount;
      processedCount = 0;
      updateSyncUI(pendingCount);
      updateSyncProgress(0, initialPendingCount);
    }
    const { session } = await getSession();
    if (!session) {
      throw new Error("Please log in first.");
    }
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || "Asia/Seoul";
    const url = `${SUPABASE_URL}/functions/v1/data-normalize`;
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${session.access_token}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ batch_size: 20, date, timezone })
    });
    if (!response.ok) {
      const err = await response.json().catch(() => ({ error: "Unknown error" }));
      throw new Error(err.error || `HTTP ${response.status}`);
    }
    const result = await response.json();
    console.log("[Sync] Result:", result);
    const normalizedThisBatch = result.normalized || 0;
    processedCount += normalizedThisBatch;
    updateSyncProgress(processedCount, initialPendingCount);
    if (syncStatus) {
      syncStatus.textContent = `${processedCount}/${initialPendingCount} \uCC98\uB9AC \uC911...`;
    }
    await checkPendingCount(date);
    if (pendingCount > 0 && normalizedThisBatch > 0) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      await syncData(date, false);
    } else {
      finishSync();
    }
  } catch (error) {
    console.error("[Sync] Failed:", error);
    if (syncStatus) {
      syncStatus.textContent = "\uB3D9\uAE30\uD654 \uC2E4\uD328";
    }
    finishSync(true);
  }
}
function finishSync(isError = false) {
  isSyncing = false;
  if (!isError) {
    updateSyncProgress(initialPendingCount, initialPendingCount);
    if (syncStatus) {
      if (processedCount > 0) {
        syncStatus.textContent = `${processedCount}\uAC1C \uC644\uB8CC!`;
      } else {
        syncStatus.textContent = "\uCC98\uB9AC\uD560 \uB370\uC774\uD130 \uC5C6\uC74C";
      }
    }
    setTimeout(() => {
      updateSyncUI(pendingCount);
    }, 2e3);
  } else {
    updateSyncUI(pendingCount);
  }
}
async function generateReport(date) {
  try {
    generateBtn.disabled = true;
    generateBtnMain.disabled = true;
    showView("loading");
    const { session } = await getSession();
    if (!session) {
      throw new Error("Please log in first.");
    }
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || "Asia/Seoul";
    const url = `${SUPABASE_URL}/functions/v1/generate-scrum`;
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${session.access_token}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ target_date: date, timezone })
    });
    if (!response.ok) {
      const err = await response.json().catch(() => ({ error: "Unknown error" }));
      throw new Error(err.error || `HTTP ${response.status}`);
    }
    const result = await response.json();
    if (!result.success) {
      throw new Error(result.error || "Generation failed.");
    }
    await loadReport(date);
  } catch (error) {
    stopLoadingAnimation();
    await new Promise((resolve) => setTimeout(resolve, 300));
    console.error("[Viewer] Generate failed:", error);
    showError("\uC0DD\uC131 \uC2E4\uD328", error.message);
  } finally {
    generateBtn.disabled = false;
    generateBtnMain.disabled = false;
  }
}
function showError(title, message) {
  errorTitle.textContent = title;
  errorMessage.textContent = message;
  showView("error");
}
function renderReport(report, date) {
  scrumDate.textContent = formatDate(date);
  scrumContent.innerHTML = "";
  const structured = report.core_agendas ? report : (
    // New format: core_agendas at root
    report.source_citations?.structured_output || (report.cognitive_reasoning?.core_agendas ? report.cognitive_reasoning : null)
  );
  if (structured && structured.core_agendas) {
    renderStructuredReport(structured);
  } else if (report.cognitive_reasoning?.content) {
    renderMarkdownReport(report.cognitive_reasoning.content);
  } else if (report.raw_summary || report.summary) {
    renderMarkdownReport(report.raw_summary || report.summary);
  } else {
    scrumContent.innerHTML = '<p class="empty-content">\uB0B4\uC6A9\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.</p>';
  }
}
function renderStructuredReport(structured) {
  const icons = ["\u{1F4CB}", "\u{1F3AF}", "\u{1F4A1}", "\u{1F4CA}", "\u{1F527}"];
  structured.core_agendas.forEach((agenda, i) => {
    const icon = icons[i % icons.length];
    const agendaId = `agenda-${i}`;
    const section = createSection(agenda.title, icon, agenda.tasks, agendaId, agenda.cognitive_flow);
    scrumContent.appendChild(section);
    if (i < structured.core_agendas.length - 1) {
      scrumContent.appendChild(createDivider());
    }
  });
  if (structured.summary) {
    scrumContent.appendChild(createDivider());
    const summarySection = createSection("\uC694\uC57D", "\u{1F4DD}", [structured.summary]);
    scrumContent.appendChild(summarySection);
  }
  if (structured.standalone_tasks && structured.standalone_tasks.length > 0) {
    scrumContent.appendChild(createDivider());
    const section = createSection(
      "\uAE30\uD0C0 \uD65C\uB3D9",
      "\u{1F4DD}",
      structured.standalone_tasks.map((t) => t.title + (t.summary ? ": " + t.summary : ""))
    );
    scrumContent.appendChild(section);
  }
  if (structured.data_gaps && structured.data_gaps.length > 0) {
    scrumContent.appendChild(createDivider());
    const section = createSection("\uB370\uC774\uD130 \uB204\uB77D", "\u26A0\uFE0F", structured.data_gaps);
    scrumContent.appendChild(section);
  }
  if (structured.unresolved && structured.unresolved.length > 0) {
    scrumContent.appendChild(createDivider());
    const section = createSection("\uBBF8\uD574\uACB0 \uD56D\uBAA9", "\u2753", structured.unresolved);
    scrumContent.appendChild(section);
  }
}
function renderMarkdownReport(content) {
  const lines = content.split("\n").filter((l) => l.trim());
  const section = createSection("Report", "\u{1F4C4}", lines);
  scrumContent.appendChild(section);
}
function createSection(title, icon, tasks, agendaId = null, cognitiveFlow = null) {
  const section = document.createElement("div");
  section.className = "scrum-section";
  const hasCognitiveFlow = cognitiveFlow && cognitiveFlow.points && cognitiveFlow.points.length > 0;
  const isExpanded = expandedFlows.has(agendaId);
  let headerHtml = `
        <div class="section-header">
            <span class="section-icon">${icon}</span>
            <h2 class="section-title">${escapeHtml(title)}</h2>
    `;
  if (hasCognitiveFlow) {
    headerHtml += `
            <button class="cognitive-flow-btn ${isExpanded ? "active" : ""}" data-agenda-id="${agendaId}">
                <span class="cf-icon">\u{1F9E0}</span>
                <span class="cf-text">Cognitive Flow</span>
            </button>
        `;
  }
  headerHtml += `</div>`;
  section.innerHTML = headerHtml;
  const contentWrapper = document.createElement("div");
  contentWrapper.className = "section-content-wrapper" + (isExpanded ? " expanded" : "");
  section.appendChild(contentWrapper);
  const content = document.createElement("div");
  content.className = "section-content";
  contentWrapper.appendChild(content);
  const isNewFormat = tasks.length > 0 && typeof tasks[0] === "object" && tasks[0] !== null;
  if (tasks.length === 0) {
    const empty = document.createElement("div");
    empty.className = "scrum-item";
    empty.textContent = "\uD56D\uBAA9 \uC5C6\uC74C";
    empty.style.color = "var(--text-tertiary)";
    empty.style.fontStyle = "italic";
    content.appendChild(empty);
  } else if (isNewFormat) {
    tasks.forEach((task, index) => {
      const row = document.createElement("div");
      row.className = "task-row";
      row.style.animationDelay = index * 0.08 + "s";
      const factDiv = document.createElement("div");
      factDiv.className = "task-fact";
      const importance = task.importance === "high" ? "\u2B50 " : "";
      factDiv.textContent = importance + (task.fact || task.title || "");
      row.appendChild(factDiv);
      const reasoningDiv = document.createElement("div");
      reasoningDiv.className = "task-reasoning";
      reasoningDiv.textContent = task.reasoning || task.summary?.join(", ") || "";
      row.appendChild(reasoningDiv);
      content.appendChild(row);
    });
  } else {
    tasks.forEach((item, index) => {
      const div = document.createElement("div");
      div.className = "scrum-item";
      div.textContent = item;
      div.style.animationDelay = index * 0.08 + "s";
      content.appendChild(div);
    });
  }
  if (hasCognitiveFlow) {
    const flowPanel = createCognitiveFlowPanel(cognitiveFlow, agendaId);
    contentWrapper.appendChild(flowPanel);
    const btn = section.querySelector(".cognitive-flow-btn");
    if (btn) {
      btn.addEventListener("click", () => {
        toggleCognitiveFlow(agendaId, btn, flowPanel, contentWrapper);
      });
    }
  }
  return section;
}
function createCognitiveFlowPanel(flow, agendaId) {
  const panel = document.createElement("div");
  panel.className = "cognitive-flow-panel";
  panel.id = `cf-panel-${agendaId}`;
  if (expandedFlows.has(agendaId)) {
    panel.classList.add("visible");
  }
  let diagramHtml = "";
  if (flow.flow_diagram && flow.flow_diagram.length > 0) {
    const flowArrows = flow.flow_diagram.map(
      (domain) => `<span class="flow-domain">${escapeHtml(domain)}</span>`
    ).join('<span class="flow-arrow">\u2192</span>');
    diagramHtml = `<div class="flow-diagram">${flowArrows}</div>`;
  }
  let pointsHtml = "";
  if (flow.points && flow.points.length > 0) {
    pointsHtml = flow.points.map((point) => {
      let pointContent = `
                <div class="flow-point">
                    <div class="point-main">
                        <span class="point-domain">[${escapeHtml(point.domain)}]</span>
                        <span class="point-thought">${escapeHtml(point.thought_process)}</span>
                    </div>
            `;
      if (point.insight) {
        pointContent += `
                    <div class="point-insight">
                        <span class="insight-icon">\u{1F4A1}</span>
                        <span class="insight-text">${escapeHtml(point.insight)}</span>
                    </div>
                `;
      }
      pointContent += "</div>";
      return pointContent;
    }).join("");
  }
  panel.innerHTML = `
        <div class="cf-header">
            <span class="cf-title-icon">\u{1F9E0}</span>
            <span class="cf-title">Cognitive Flow</span>
        </div>
        ${diagramHtml}
        <div class="flow-points">${pointsHtml}</div>
    `;
  return panel;
}
function toggleCognitiveFlow(agendaId, btn, panel, contentWrapper) {
  const isExpanded = expandedFlows.has(agendaId);
  if (isExpanded) {
    expandedFlows.delete(agendaId);
    panel.classList.remove("visible");
    btn.classList.remove("active");
    if (contentWrapper) contentWrapper.classList.remove("expanded");
  } else {
    expandedFlows.add(agendaId);
    panel.classList.add("visible");
    btn.classList.add("active");
    if (contentWrapper) contentWrapper.classList.add("expanded");
  }
}
function createDivider() {
  const div = document.createElement("div");
  div.className = "divider";
  return div;
}
function formatDate(dateStr) {
  const date = /* @__PURE__ */ new Date(dateStr + "T00:00:00");
  return date.toLocaleDateString("ko-KR", {
    year: "numeric",
    month: "long",
    day: "numeric",
    weekday: "long"
  });
}
function escapeHtml(text) {
  const div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvc3JjL2hlbHBlci50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9zcmMvdHlwZXMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvc3JjL0Z1bmN0aW9uc0NsaWVudC50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9zcmMvUG9zdGdyZXN0RXJyb3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdEJ1aWxkZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlci50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9zcmMvUG9zdGdyZXN0Q2xpZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9pbmRleC50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvd2Vic29ja2V0LWZhY3RvcnkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL2NvbnN0YW50cy50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvc2VyaWFsaXplci50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvdGltZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL3RyYW5zZm9ybWVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvcHVzaC50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9SZWFsdGltZVByZXNlbmNlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvc3JjL1JlYWx0aW1lQ2hhbm5lbC50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9SZWFsdGltZUNsaWVudC50cyIsICIuLi9ub2RlX21vZHVsZXMvaWNlYmVyZy1qcy9zcmMvZXJyb3JzL0ljZWJlcmdFcnJvci50cyIsICIuLi9ub2RlX21vZHVsZXMvaWNlYmVyZy1qcy9zcmMvdXRpbHMvdXJsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9pY2ViZXJnLWpzL3NyYy9odHRwL2NyZWF0ZUZldGNoQ2xpZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9pY2ViZXJnLWpzL3NyYy9jYXRhbG9nL25hbWVzcGFjZXMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2ljZWJlcmctanMvc3JjL2NhdGFsb2cvdGFibGVzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9pY2ViZXJnLWpzL3NyYy9jYXRhbG9nL0ljZWJlcmdSZXN0Q2F0YWxvZy50cyIsICIuLi9ub2RlX21vZHVsZXMvaWNlYmVyZy1qcy9zcmMvY2F0YWxvZy90eXBlcy50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi9jb21tb24vZXJyb3JzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvbGliL2NvbW1vbi9oZWxwZXJzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvbGliL2NvbW1vbi9mZXRjaC50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi9jb21tb24vQmFzZUFwaUNsaWVudC50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL3BhY2thZ2VzL1N0cmVhbURvd25sb2FkQnVpbGRlci50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL3BhY2thZ2VzL0Jsb2JEb3dubG9hZEJ1aWxkZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9wYWNrYWdlcy9TdG9yYWdlRmlsZUFwaS50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi92ZXJzaW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvbGliL2NvbnN0YW50cy50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL3BhY2thZ2VzL1N0b3JhZ2VCdWNrZXRBcGkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9wYWNrYWdlcy9TdG9yYWdlQW5hbHl0aWNzQ2xpZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvcGFja2FnZXMvVmVjdG9ySW5kZXhBcGkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9wYWNrYWdlcy9WZWN0b3JEYXRhQXBpLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvcGFja2FnZXMvVmVjdG9yQnVja2V0QXBpLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvcGFja2FnZXMvU3RvcmFnZVZlY3RvcnNDbGllbnQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9TdG9yYWdlQ2xpZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvY29uc3RhbnRzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL2Vycm9ycy50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9iYXNlNjR1cmwudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvaGVscGVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9mZXRjaC50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi90eXBlcy50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL0dvVHJ1ZUFkbWluQXBpLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL2xvY2FsLXN0b3JhZ2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvbG9ja3MudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvcG9seWZpbGxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL3dlYjMvZXRoZXJldW0udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvd2ViYXV0aG4uZXJyb3JzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL3dlYmF1dGhuLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvR29UcnVlQ2xpZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvQXV0aENsaWVudC50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9saWIvdmVyc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9saWIvY29uc3RhbnRzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvc3JjL2xpYi9mZXRjaC50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9saWIvaGVscGVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9saWIvU3VwYWJhc2VBdXRoQ2xpZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvc3JjL1N1cGFiYXNlQ2xpZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvc3JjL2luZGV4LnRzIiwgIi4uL2xpYi9jb25maWcuanMiLCAiLi4vbGliL3N1cGFiYXNlLWNsaWVudC5qcyIsICIuLi9zY3J1bS12aWV3ZXIuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICB9XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2VzRGVjb3JhdGUoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgfVxuICB9XG4gIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgZG9uZSA9IHRydWU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgfVxuICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Byb3BLZXkoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEl0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKTtcbiAgcmV0dXJuIGcubmV4dCA9IHZlcmIoMCksIGdbXCJ0aHJvd1wiXSA9IHZlcmIoMSksIGdbXCJyZXR1cm5cIl0gPSB2ZXJiKDIpLCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gIH1cbn1cblxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gIGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICB9XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgcltrXSA9IGFbal07XG4gIHJldHVybiByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcbiAgdmFyIGksIHA7XG4gIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gIHJldHVybiBjb29rZWQ7XG59O1xuXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59O1xuXG52YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIGFyID0gW107XG4gICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICByZXR1cm4gYXI7XG4gIH07XG4gIHJldHVybiBvd25LZXlzKG8pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XG4gIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52LCB2YWx1ZSwgYXN5bmMpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkLlwiKTtcbiAgICB2YXIgZGlzcG9zZSwgaW5uZXI7XG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICB9XG4gICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKCFTeW1ib2wuZGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5kaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuZGlzcG9zZV07XG4gICAgICBpZiAoYXN5bmMpIGlubmVyID0gZGlzcG9zZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qgbm90IGRpc3Bvc2FibGUuXCIpO1xuICAgIGlmIChpbm5lcikgZGlzcG9zZSA9IGZ1bmN0aW9uKCkgeyB0cnkgeyBpbm5lci5jYWxsKHRoaXMpOyB9IGNhdGNoIChlKSB7IHJldHVybiBQcm9taXNlLnJlamVjdChlKTsgfSB9O1xuICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gIH1cbiAgZWxzZSBpZiAoYXN5bmMpIHtcbiAgICBlbnYuc3RhY2sucHVzaCh7IGFzeW5jOiB0cnVlIH0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIF9TdXBwcmVzc2VkRXJyb3IgPSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19kaXNwb3NlUmVzb3VyY2VzKGVudikge1xuICBmdW5jdGlvbiBmYWlsKGUpIHtcbiAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgX1N1cHByZXNzZWRFcnJvcihlLCBlbnYuZXJyb3IsIFwiQW4gZXJyb3Igd2FzIHN1cHByZXNzZWQgZHVyaW5nIGRpc3Bvc2FsLlwiKSA6IGU7XG4gICAgZW52Lmhhc0Vycm9yID0gdHJ1ZTtcbiAgfVxuICB2YXIgciwgcyA9IDA7XG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgd2hpbGUgKHIgPSBlbnYuc3RhY2sucG9wKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghci5hc3luYyAmJiBzID09PSAxKSByZXR1cm4gcyA9IDAsIGVudi5zdGFjay5wdXNoKHIpLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKG5leHQpO1xuICAgICAgICBpZiAoci5kaXNwb3NlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHIuZGlzcG9zZS5jYWxsKHIudmFsdWUpO1xuICAgICAgICAgIGlmIChyLmFzeW5jKSByZXR1cm4gcyB8PSAyLCBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgcmV0dXJuIG5leHQoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBzIHw9IDE7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBmYWlsKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocyA9PT0gMSkgcmV0dXJuIGVudi5oYXNFcnJvciA/IFByb21pc2UucmVqZWN0KGVudi5lcnJvcikgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XG4gIH1cbiAgcmV0dXJuIG5leHQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmV3cml0ZVJlbGF0aXZlSW1wb3J0RXh0ZW5zaW9uKHBhdGgsIHByZXNlcnZlSnN4KSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAvXlxcLlxcLj9cXC8vLnRlc3QocGF0aCkpIHtcbiAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcLih0c3gpJHwoKD86XFwuZCk/KSgoPzpcXC5bXi4vXSs/KT8pXFwuKFtjbV0/KXRzJC9pLCBmdW5jdGlvbiAobSwgdHN4LCBkLCBleHQsIGNtKSB7XG4gICAgICAgICAgcmV0dXJuIHRzeCA/IHByZXNlcnZlSnN4ID8gXCIuanN4XCIgOiBcIi5qc1wiIDogZCAmJiAoIWV4dCB8fCAhY20pID8gbSA6IChkICsgZXh0ICsgXCIuXCIgKyBjbS50b0xvd2VyQ2FzZSgpICsgXCJqc1wiKTtcbiAgICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZXh0ZW5kcyxcbiAgX19hc3NpZ24sXG4gIF9fcmVzdCxcbiAgX19kZWNvcmF0ZSxcbiAgX19wYXJhbSxcbiAgX19lc0RlY29yYXRlLFxuICBfX3J1bkluaXRpYWxpemVycyxcbiAgX19wcm9wS2V5LFxuICBfX3NldEZ1bmN0aW9uTmFtZSxcbiAgX19tZXRhZGF0YSxcbiAgX19hd2FpdGVyLFxuICBfX2dlbmVyYXRvcixcbiAgX19jcmVhdGVCaW5kaW5nLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fdmFsdWVzLFxuICBfX3JlYWQsXG4gIF9fc3ByZWFkLFxuICBfX3NwcmVhZEFycmF5cyxcbiAgX19zcHJlYWRBcnJheSxcbiAgX19hd2FpdCxcbiAgX19hc3luY0dlbmVyYXRvcixcbiAgX19hc3luY0RlbGVnYXRvcixcbiAgX19hc3luY1ZhbHVlcyxcbiAgX19tYWtlVGVtcGxhdGVPYmplY3QsXG4gIF9faW1wb3J0U3RhcixcbiAgX19pbXBvcnREZWZhdWx0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXG4gIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlLFxuICBfX2Rpc3Bvc2VSZXNvdXJjZXMsXG4gIF9fcmV3cml0ZVJlbGF0aXZlSW1wb3J0RXh0ZW5zaW9uLFxufTtcbiIsICJpbXBvcnQgeyBGZXRjaCB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBjdXN0b21GZXRjaCguLi5hcmdzKVxuICB9XG4gIHJldHVybiAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncylcbn1cbiIsICJleHBvcnQgdHlwZSBGZXRjaCA9IHR5cGVvZiBmZXRjaFxuXG4vKipcbiAqIFJlc3BvbnNlIGZvcm1hdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uc1Jlc3BvbnNlU3VjY2VzczxUPiB7XG4gIGRhdGE6IFRcbiAgZXJyb3I6IG51bGxcbiAgcmVzcG9uc2U/OiBSZXNwb25zZVxufVxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbnNSZXNwb25zZUZhaWx1cmUge1xuICBkYXRhOiBudWxsXG4gIGVycm9yOiBhbnlcbiAgcmVzcG9uc2U/OiBSZXNwb25zZVxufVxuZXhwb3J0IHR5cGUgRnVuY3Rpb25zUmVzcG9uc2U8VD4gPSBGdW5jdGlvbnNSZXNwb25zZVN1Y2Nlc3M8VD4gfCBGdW5jdGlvbnNSZXNwb25zZUZhaWx1cmVcblxuLyoqXG4gKiBCYXNlIGVycm9yIGZvciBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uIGludm9jYXRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRnVuY3Rpb25zRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuICpcbiAqIHRocm93IG5ldyBGdW5jdGlvbnNFcnJvcignVW5leHBlY3RlZCBlcnJvciBpbnZva2luZyBmdW5jdGlvbicsICdGdW5jdGlvbnNFcnJvcicsIHtcbiAqICAgcmVxdWVzdElkOiAnYWJjMTIzJyxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb250ZXh0OiBhbnlcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBuYW1lID0gJ0Z1bmN0aW9uc0Vycm9yJywgY29udGV4dD86IGFueSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxufVxuXG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBuZXR3b3JrIHJlcXVlc3QgdG8gYW4gRWRnZSBGdW5jdGlvbiBmYWlscy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEZ1bmN0aW9uc0ZldGNoRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuICpcbiAqIHRocm93IG5ldyBGdW5jdGlvbnNGZXRjaEVycm9yKHsgcmVxdWVzdElkOiAnYWJjMTIzJyB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNGZXRjaEVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBhbnkpIHtcbiAgICBzdXBlcignRmFpbGVkIHRvIHNlbmQgYSByZXF1ZXN0IHRvIHRoZSBFZGdlIEZ1bmN0aW9uJywgJ0Z1bmN0aW9uc0ZldGNoRXJyb3InLCBjb250ZXh0KVxuICB9XG59XG5cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIFN1cGFiYXNlIHJlbGF5IGNhbm5vdCByZWFjaCB0aGUgRWRnZSBGdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEZ1bmN0aW9uc1JlbGF5RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuICpcbiAqIHRocm93IG5ldyBGdW5jdGlvbnNSZWxheUVycm9yKHsgcmVnaW9uOiAndXMtZWFzdC0xJyB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNSZWxheUVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBhbnkpIHtcbiAgICBzdXBlcignUmVsYXkgRXJyb3IgaW52b2tpbmcgdGhlIEVkZ2UgRnVuY3Rpb24nLCAnRnVuY3Rpb25zUmVsYXlFcnJvcicsIGNvbnRleHQpXG4gIH1cbn1cblxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgRWRnZSBGdW5jdGlvbiByZXR1cm5zIGEgbm9uLTJ4eCBzdGF0dXMgY29kZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEZ1bmN0aW9uc0h0dHBFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG4gKlxuICogdGhyb3cgbmV3IEZ1bmN0aW9uc0h0dHBFcnJvcih7IHN0YXR1czogNTAwIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0h0dHBFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgY29uc3RydWN0b3IoY29udGV4dDogYW55KSB7XG4gICAgc3VwZXIoJ0VkZ2UgRnVuY3Rpb24gcmV0dXJuZWQgYSBub24tMnh4IHN0YXR1cyBjb2RlJywgJ0Z1bmN0aW9uc0h0dHBFcnJvcicsIGNvbnRleHQpXG4gIH1cbn1cbi8vIERlZmluZSB0aGUgZW51bSBmb3IgdGhlICdyZWdpb24nIHByb3BlcnR5XG5leHBvcnQgZW51bSBGdW5jdGlvblJlZ2lvbiB7XG4gIEFueSA9ICdhbnknLFxuICBBcE5vcnRoZWFzdDEgPSAnYXAtbm9ydGhlYXN0LTEnLFxuICBBcE5vcnRoZWFzdDIgPSAnYXAtbm9ydGhlYXN0LTInLFxuICBBcFNvdXRoMSA9ICdhcC1zb3V0aC0xJyxcbiAgQXBTb3V0aGVhc3QxID0gJ2FwLXNvdXRoZWFzdC0xJyxcbiAgQXBTb3V0aGVhc3QyID0gJ2FwLXNvdXRoZWFzdC0yJyxcbiAgQ2FDZW50cmFsMSA9ICdjYS1jZW50cmFsLTEnLFxuICBFdUNlbnRyYWwxID0gJ2V1LWNlbnRyYWwtMScsXG4gIEV1V2VzdDEgPSAnZXUtd2VzdC0xJyxcbiAgRXVXZXN0MiA9ICdldS13ZXN0LTInLFxuICBFdVdlc3QzID0gJ2V1LXdlc3QtMycsXG4gIFNhRWFzdDEgPSAnc2EtZWFzdC0xJyxcbiAgVXNFYXN0MSA9ICd1cy1lYXN0LTEnLFxuICBVc1dlc3QxID0gJ3VzLXdlc3QtMScsXG4gIFVzV2VzdDIgPSAndXMtd2VzdC0yJyxcbn1cblxuZXhwb3J0IHR5cGUgRnVuY3Rpb25JbnZva2VPcHRpb25zID0ge1xuICAvKipcbiAgICogT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaGVhZGVycyB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3QuXG4gICAqL1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICAvKipcbiAgICogVGhlIEhUVFAgdmVyYiBvZiB0aGUgcmVxdWVzdFxuICAgKi9cbiAgbWV0aG9kPzogJ1BPU1QnIHwgJ0dFVCcgfCAnUFVUJyB8ICdQQVRDSCcgfCAnREVMRVRFJ1xuICAvKipcbiAgICogVGhlIFJlZ2lvbiB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIGluLlxuICAgKi9cbiAgcmVnaW9uPzogRnVuY3Rpb25SZWdpb25cbiAgLyoqXG4gICAqIFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYm9keT86XG4gICAgfCBGaWxlXG4gICAgfCBCbG9iXG4gICAgfCBBcnJheUJ1ZmZlclxuICAgIHwgRm9ybURhdGFcbiAgICB8IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBBYm9ydFNpZ25hbCB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiAqL1xuICBzaWduYWw/OiBBYm9ydFNpZ25hbFxuICAvKipcbiAgICogVGhlIHRpbWVvdXQgZm9yIHRoZSByZXF1ZXN0IGluIG1pbGxpc2Vjb25kcy5cbiAgICogSWYgdGhlIGZ1bmN0aW9uIHRha2VzIGxvbmdlciB0aGFuIHRoaXMsIHRoZSByZXF1ZXN0IHdpbGwgYmUgYWJvcnRlZC5cbiAgICogKi9cbiAgdGltZW91dD86IG51bWJlclxufVxuIiwgImltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4vaGVscGVyJ1xuaW1wb3J0IHtcbiAgRmV0Y2gsXG4gIEZ1bmN0aW9uSW52b2tlT3B0aW9ucyxcbiAgRnVuY3Rpb25SZWdpb24sXG4gIEZ1bmN0aW9uc0ZldGNoRXJyb3IsXG4gIEZ1bmN0aW9uc0h0dHBFcnJvcixcbiAgRnVuY3Rpb25zUmVsYXlFcnJvcixcbiAgRnVuY3Rpb25zUmVzcG9uc2UsXG59IGZyb20gJy4vdHlwZXMnXG5cbi8qKlxuICogQ2xpZW50IGZvciBpbnZva2luZyBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0NsaWVudCB7XG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBwcm90ZWN0ZWQgcmVnaW9uOiBGdW5jdGlvblJlZ2lvblxuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRnVuY3Rpb25zIGNsaWVudCBib3VuZCB0byBhbiBFZGdlIEZ1bmN0aW9ucyBVUkwuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7IEZ1bmN0aW9uc0NsaWVudCwgRnVuY3Rpb25SZWdpb24gfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuICAgKlxuICAgKiBjb25zdCBmdW5jdGlvbnMgPSBuZXcgRnVuY3Rpb25zQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vZnVuY3Rpb25zL3YxJywge1xuICAgKiAgIGhlYWRlcnM6IHsgYXBpa2V5OiAncHVibGljLWFub24ta2V5JyB9LFxuICAgKiAgIHJlZ2lvbjogRnVuY3Rpb25SZWdpb24uVXNFYXN0MSxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB1cmw6IHN0cmluZyxcbiAgICB7XG4gICAgICBoZWFkZXJzID0ge30sXG4gICAgICBjdXN0b21GZXRjaCxcbiAgICAgIHJlZ2lvbiA9IEZ1bmN0aW9uUmVnaW9uLkFueSxcbiAgICB9OiB7XG4gICAgICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgICAgY3VzdG9tRmV0Y2g/OiBGZXRjaFxuICAgICAgcmVnaW9uPzogRnVuY3Rpb25SZWdpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gICAgdGhpcy5yZWdpb24gPSByZWdpb25cbiAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAqIEBwYXJhbSB0b2tlbiAtIHRoZSBuZXcgand0IHRva2VuIHNlbnQgaW4gdGhlIGF1dGhvcmlzYXRpb24gaGVhZGVyXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGZ1bmN0aW9ucy5zZXRBdXRoKHNlc3Npb24uYWNjZXNzX3Rva2VuKVxuICAgKiBgYGBcbiAgICovXG4gIHNldEF1dGgodG9rZW46IHN0cmluZykge1xuICAgIHRoaXMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWBcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGEgZnVuY3Rpb25cbiAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBGdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgaW52b2tpbmcgdGhlIEZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBmdW5jdGlvbnMuaW52b2tlKCdoZWxsby13b3JsZCcsIHtcbiAgICogICBib2R5OiB7IG5hbWU6ICdBZGEnIH0sXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgaW52b2tlPFQgPSBhbnk+KFxuICAgIGZ1bmN0aW9uTmFtZTogc3RyaW5nLFxuICAgIG9wdGlvbnM6IEZ1bmN0aW9uSW52b2tlT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8RnVuY3Rpb25zUmVzcG9uc2U8VD4+IHtcbiAgICBsZXQgdGltZW91dElkOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZFxuICAgIGxldCB0aW1lb3V0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgdW5kZWZpbmVkXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBoZWFkZXJzLCBtZXRob2QsIGJvZHk6IGZ1bmN0aW9uQXJncywgc2lnbmFsLCB0aW1lb3V0IH0gPSBvcHRpb25zXG4gICAgICBsZXQgX2hlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICAgICAgbGV0IHsgcmVnaW9uIH0gPSBvcHRpb25zXG4gICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICByZWdpb24gPSB0aGlzLnJlZ2lvblxuICAgICAgfVxuICAgICAgLy8gQWRkIHJlZ2lvbiBhcyBxdWVyeSBwYXJhbWV0ZXIgdXNpbmcgVVJMIEFQSVxuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vJHtmdW5jdGlvbk5hbWV9YClcbiAgICAgIGlmIChyZWdpb24gJiYgcmVnaW9uICE9PSAnYW55Jykge1xuICAgICAgICBfaGVhZGVyc1sneC1yZWdpb24nXSA9IHJlZ2lvblxuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnZm9yY2VGdW5jdGlvblJlZ2lvbicsIHJlZ2lvbilcbiAgICAgIH1cbiAgICAgIGxldCBib2R5OiBhbnlcbiAgICAgIGlmIChcbiAgICAgICAgZnVuY3Rpb25BcmdzICYmXG4gICAgICAgICgoaGVhZGVycyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKSkgfHwgIWhlYWRlcnMpXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgICBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxuICAgICAgICApIHtcbiAgICAgICAgICAvLyB3aWxsIHdvcmsgZm9yIEZpbGUgYXMgRmlsZSBpbmhlcml0cyBCbG9iXG4gICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgQXJyYXlCdWZmZXIgYXMgaXQgaXMgdGhlIHNhbWUgdW5kZXJseWluZyBzdHJ1Y3R1cmUgYXMgYSBCbG9iXG4gICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcbiAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uQXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBwbGFpbiBzdHJpbmdcbiAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAndGV4dC9wbGFpbidcbiAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgIC8vIGRvbid0IHNldCBjb250ZW50LXR5cGUgaGVhZGVyc1xuICAgICAgICAgIC8vIFJlcXVlc3Qgd2lsbCBhdXRvbWF0aWNhbGx5IGFkZCB0aGUgcmlnaHQgYm91bmRhcnkgdmFsdWVcbiAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVmYXVsdCwgYXNzdW1lIHRoaXMgaXMgSlNPTlxuICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShmdW5jdGlvbkFyZ3MpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBmdW5jdGlvbkFyZ3MgJiZcbiAgICAgICAgICB0eXBlb2YgZnVuY3Rpb25BcmdzICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICEodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEJsb2IpICYmXG4gICAgICAgICAgIShmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiZcbiAgICAgICAgICAhKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgRm9ybURhdGEpXG4gICAgICAgICkge1xuICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShmdW5jdGlvbkFyZ3MpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJnc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSB0aW1lb3V0IGJ5IGNyZWF0aW5nIGFuIEFib3J0Q29udHJvbGxlclxuICAgICAgbGV0IGVmZmVjdGl2ZVNpZ25hbCA9IHNpZ25hbFxuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgdGltZW91dENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB0aW1lb3V0Q29udHJvbGxlciEuYWJvcnQoKSwgdGltZW91dClcblxuICAgICAgICAvLyBJZiB1c2VyIHByb3ZpZGVkIHRoZWlyIG93biBzaWduYWwsIHdlIG5lZWQgdG8gcmVzcGVjdCBib3RoXG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICBlZmZlY3RpdmVTaWduYWwgPSB0aW1lb3V0Q29udHJvbGxlci5zaWduYWxcbiAgICAgICAgICAvLyBJZiB0aGUgdXNlcidzIHNpZ25hbCBpcyBhYm9ydGVkLCBhYm9ydCBvdXIgdGltZW91dCBjb250cm9sbGVyIHRvb1xuICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRpbWVvdXRDb250cm9sbGVyIS5hYm9ydCgpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVmZmVjdGl2ZVNpZ25hbCA9IHRpbWVvdXRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCB8fCAnUE9TVCcsXG4gICAgICAgIC8vIGhlYWRlcnMgcHJpb3JpdHkgaXMgKGhpZ2ggdG8gbG93KTpcbiAgICAgICAgLy8gMS4gaW52b2tlLWxldmVsIGhlYWRlcnNcbiAgICAgICAgLy8gMi4gY2xpZW50LWxldmVsIGhlYWRlcnNcbiAgICAgICAgLy8gMy4gZGVmYXVsdCBDb250ZW50LVR5cGUgaGVhZGVyXG4gICAgICAgIGhlYWRlcnM6IHsgLi4uX2hlYWRlcnMsIC4uLnRoaXMuaGVhZGVycywgLi4uaGVhZGVycyB9LFxuICAgICAgICBib2R5LFxuICAgICAgICBzaWduYWw6IGVmZmVjdGl2ZVNpZ25hbCxcbiAgICAgIH0pLmNhdGNoKChmZXRjaEVycm9yKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNGZXRjaEVycm9yKGZldGNoRXJyb3IpXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBpc1JlbGF5RXJyb3IgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1yZWxheS1lcnJvcicpXG4gICAgICBpZiAoaXNSZWxheUVycm9yICYmIGlzUmVsYXlFcnJvciA9PT0gJ3RydWUnKSB7XG4gICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNSZWxheUVycm9yKHJlc3BvbnNlKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNIdHRwRXJyb3IocmVzcG9uc2UpXG4gICAgICB9XG5cbiAgICAgIGxldCByZXNwb25zZVR5cGUgPSAocmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpID8/ICd0ZXh0L3BsYWluJykuc3BsaXQoJzsnKVswXS50cmltKClcbiAgICAgIGxldCBkYXRhOiBhbnlcbiAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09ICdhcHBsaWNhdGlvbi9qc29uJykge1xuICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICByZXNwb25zZVR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIHx8XG4gICAgICAgIHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3BkZidcbiAgICAgICkge1xuICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpXG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQvZXZlbnQtc3RyZWFtJykge1xuICAgICAgICBkYXRhID0gcmVzcG9uc2VcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpIHtcbiAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmZvcm1EYXRhKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQgdG8gdGV4dFxuICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsLCByZXNwb25zZSB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yLFxuICAgICAgICByZXNwb25zZTpcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEZ1bmN0aW9uc0h0dHBFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEZ1bmN0aW9uc1JlbGF5RXJyb3JcbiAgICAgICAgICAgID8gZXJyb3IuY29udGV4dFxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFyIHRoZSB0aW1lb3V0IGlmIGl0IHdhcyBzZXRcbiAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsICIvKipcbiAqIEVycm9yIGZvcm1hdFxuICpcbiAqIHtAbGluayBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sP2hpZ2hsaWdodD1vcHRpb25zI2Vycm9ycy1hbmQtaHR0cC1zdGF0dXMtY29kZXN9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBkZXRhaWxzOiBzdHJpbmdcbiAgaGludDogc3RyaW5nXG4gIGNvZGU6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgUG9zdGdyZXN0RXJyb3IgZnJvbSAnQHN1cGFiYXNlL3Bvc3RncmVzdC1qcydcbiAgICpcbiAgICogdGhyb3cgbmV3IFBvc3RncmVzdEVycm9yKHtcbiAgICogICBtZXNzYWdlOiAnUm93IGxldmVsIHNlY3VyaXR5IHByZXZlbnRlZCB0aGUgcmVxdWVzdCcsXG4gICAqICAgZGV0YWlsczogJ1JMUyBkZW5pZWQgdGhlIGluc2VydCcsXG4gICAqICAgaGludDogJ0NoZWNrIHlvdXIgcG9saWNpZXMnLFxuICAgKiAgIGNvZGU6ICdQR1JTVDMwMScsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29udGV4dDogeyBtZXNzYWdlOiBzdHJpbmc7IGRldGFpbHM6IHN0cmluZzsgaGludDogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfSkge1xuICAgIHN1cGVyKGNvbnRleHQubWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUG9zdGdyZXN0RXJyb3InXG4gICAgdGhpcy5kZXRhaWxzID0gY29udGV4dC5kZXRhaWxzXG4gICAgdGhpcy5oaW50ID0gY29udGV4dC5oaW50XG4gICAgdGhpcy5jb2RlID0gY29udGV4dC5jb2RlXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7XG4gIFBvc3RncmVzdFNpbmdsZVJlc3BvbnNlLFxuICBQb3N0Z3Jlc3RSZXNwb25zZVN1Y2Nlc3MsXG4gIENoZWNrTWF0Y2hpbmdBcnJheVR5cGVzLFxuICBNZXJnZVBhcnRpYWxSZXN1bHQsXG4gIElzVmFsaWRSZXN1bHRPdmVycmlkZSxcbn0gZnJvbSAnLi90eXBlcy90eXBlcydcbmltcG9ydCB7IENsaWVudFNlcnZlck9wdGlvbnMsIEZldGNoIH0gZnJvbSAnLi90eXBlcy9jb21tb24vY29tbW9uJ1xuaW1wb3J0IFBvc3RncmVzdEVycm9yIGZyb20gJy4vUG9zdGdyZXN0RXJyb3InXG5pbXBvcnQgeyBDb250YWluc051bGwgfSBmcm9tICcuL3NlbGVjdC1xdWVyeS1wYXJzZXIvdHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFBvc3RncmVzdEJ1aWxkZXI8XG4gIENsaWVudE9wdGlvbnMgZXh0ZW5kcyBDbGllbnRTZXJ2ZXJPcHRpb25zLFxuICBSZXN1bHQsXG4gIFRocm93T25FcnJvciBleHRlbmRzIGJvb2xlYW4gPSBmYWxzZSxcbj4gaW1wbGVtZW50c1xuICAgIFByb21pc2VMaWtlPFxuICAgICAgVGhyb3dPbkVycm9yIGV4dGVuZHMgdHJ1ZSA/IFBvc3RncmVzdFJlc3BvbnNlU3VjY2VzczxSZXN1bHQ+IDogUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2U8UmVzdWx0PlxuICAgID5cbntcbiAgcHJvdGVjdGVkIG1ldGhvZDogJ0dFVCcgfCAnSEVBRCcgfCAnUE9TVCcgfCAnUEFUQ0gnIHwgJ0RFTEVURSdcbiAgcHJvdGVjdGVkIHVybDogVVJMXG4gIHByb3RlY3RlZCBoZWFkZXJzOiBIZWFkZXJzXG4gIHByb3RlY3RlZCBzY2hlbWE/OiBzdHJpbmdcbiAgcHJvdGVjdGVkIGJvZHk/OiB1bmtub3duXG4gIHByb3RlY3RlZCBzaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZVxuICBwcm90ZWN0ZWQgc2lnbmFsPzogQWJvcnRTaWduYWxcbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuICBwcm90ZWN0ZWQgaXNNYXliZVNpbmdsZTogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYnVpbGRlciBjb25maWd1cmVkIGZvciBhIHNwZWNpZmljIFBvc3RnUkVTVCByZXF1ZXN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgUG9zdGdyZXN0UXVlcnlCdWlsZGVyIGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG4gICAqXG4gICAqIGNvbnN0IGJ1aWxkZXIgPSBuZXcgUG9zdGdyZXN0UXVlcnlCdWlsZGVyKFxuICAgKiAgIG5ldyBVUkwoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9yZXN0L3YxL3VzZXJzJyksXG4gICAqICAgeyBoZWFkZXJzOiBuZXcgSGVhZGVycyh7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSkgfVxuICAgKiApXG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IoYnVpbGRlcjoge1xuICAgIG1ldGhvZDogJ0dFVCcgfCAnSEVBRCcgfCAnUE9TVCcgfCAnUEFUQ0gnIHwgJ0RFTEVURSdcbiAgICB1cmw6IFVSTFxuICAgIGhlYWRlcnM6IEhlYWRlcnNJbml0XG4gICAgc2NoZW1hPzogc3RyaW5nXG4gICAgYm9keT86IHVua25vd25cbiAgICBzaG91bGRUaHJvd09uRXJyb3I/OiBib29sZWFuXG4gICAgc2lnbmFsPzogQWJvcnRTaWduYWxcbiAgICBmZXRjaD86IEZldGNoXG4gICAgaXNNYXliZVNpbmdsZT86IGJvb2xlYW5cbiAgfSkge1xuICAgIHRoaXMubWV0aG9kID0gYnVpbGRlci5tZXRob2RcbiAgICB0aGlzLnVybCA9IGJ1aWxkZXIudXJsXG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoYnVpbGRlci5oZWFkZXJzKVxuICAgIHRoaXMuc2NoZW1hID0gYnVpbGRlci5zY2hlbWFcbiAgICB0aGlzLmJvZHkgPSBidWlsZGVyLmJvZHlcbiAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGJ1aWxkZXIuc2hvdWxkVGhyb3dPbkVycm9yID8/IGZhbHNlXG4gICAgdGhpcy5zaWduYWwgPSBidWlsZGVyLnNpZ25hbFxuICAgIHRoaXMuaXNNYXliZVNpbmdsZSA9IGJ1aWxkZXIuaXNNYXliZVNpbmdsZSA/PyBmYWxzZVxuXG4gICAgaWYgKGJ1aWxkZXIuZmV0Y2gpIHtcbiAgICAgIHRoaXMuZmV0Y2ggPSBidWlsZGVyLmZldGNoXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmV0Y2ggPSBmZXRjaFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGVyZSdzIGFuIGVycm9yIHdpdGggdGhlIHF1ZXJ5LCB0aHJvd09uRXJyb3Igd2lsbCByZWplY3QgdGhlIHByb21pc2UgYnlcbiAgICogdGhyb3dpbmcgdGhlIGVycm9yIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGFzIHBhcnQgb2YgYSBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3N1cGFiYXNlLWpzL2lzc3Vlcy85Mn1cbiAgICovXG4gIHRocm93T25FcnJvcigpOiB0aGlzICYgUG9zdGdyZXN0QnVpbGRlcjxDbGllbnRPcHRpb25zLCBSZXN1bHQsIHRydWU+IHtcbiAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWVcbiAgICByZXR1cm4gdGhpcyBhcyB0aGlzICYgUG9zdGdyZXN0QnVpbGRlcjxDbGllbnRPcHRpb25zLCBSZXN1bHQsIHRydWU+XG4gIH1cblxuICAvKipcbiAgICogU2V0IGFuIEhUVFAgaGVhZGVyIGZvciB0aGUgcmVxdWVzdC5cbiAgICovXG4gIHNldEhlYWRlcihuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpXG4gICAgdGhpcy5oZWFkZXJzLnNldChuYW1lLCB2YWx1ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdGhlbjxcbiAgICBUUmVzdWx0MSA9IFRocm93T25FcnJvciBleHRlbmRzIHRydWVcbiAgICAgID8gUG9zdGdyZXN0UmVzcG9uc2VTdWNjZXNzPFJlc3VsdD5cbiAgICAgIDogUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2U8UmVzdWx0PixcbiAgICBUUmVzdWx0MiA9IG5ldmVyLFxuICA+KFxuICAgIG9uZnVsZmlsbGVkPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB2YWx1ZTogVGhyb3dPbkVycm9yIGV4dGVuZHMgdHJ1ZVxuICAgICAgICAgICAgPyBQb3N0Z3Jlc3RSZXNwb25zZVN1Y2Nlc3M8UmVzdWx0PlxuICAgICAgICAgICAgOiBQb3N0Z3Jlc3RTaW5nbGVSZXNwb25zZTxSZXN1bHQ+XG4gICAgICAgICkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pXG4gICAgICB8IHVuZGVmaW5lZFxuICAgICAgfCBudWxsLFxuICAgIG9ucmVqZWN0ZWQ/OiAoKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0MiB8IFByb21pc2VMaWtlPFRSZXN1bHQyPikgfCB1bmRlZmluZWQgfCBudWxsXG4gICk6IFByb21pc2VMaWtlPFRSZXN1bHQxIHwgVFJlc3VsdDI+IHtcbiAgICAvLyBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI3N3aXRjaGluZy1zY2hlbWFzXG4gICAgaWYgKHRoaXMuc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHNraXBcbiAgICB9IGVsc2UgaWYgKFsnR0VUJywgJ0hFQUQnXS5pbmNsdWRlcyh0aGlzLm1ldGhvZCkpIHtcbiAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0FjY2VwdC1Qcm9maWxlJywgdGhpcy5zY2hlbWEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0NvbnRlbnQtUHJvZmlsZScsIHRoaXMuc2NoZW1hKVxuICAgIH1cbiAgICBpZiAodGhpcy5tZXRob2QgIT09ICdHRVQnICYmIHRoaXMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJylcbiAgICB9XG5cbiAgICAvLyBOT1RFOiBJbnZva2Ugdy9vIGB0aGlzYCB0byBhdm9pZCBpbGxlZ2FsIGludm9jYXRpb24gZXJyb3IuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9wdWxsLzI0N1xuICAgIGNvbnN0IF9mZXRjaCA9IHRoaXMuZmV0Y2hcbiAgICBsZXQgcmVzID0gX2ZldGNoKHRoaXMudXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpLFxuICAgICAgc2lnbmFsOiB0aGlzLnNpZ25hbCxcbiAgICB9KS50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgIGxldCBlcnJvciA9IG51bGxcbiAgICAgIGxldCBkYXRhID0gbnVsbFxuICAgICAgbGV0IGNvdW50OiBudW1iZXIgfCBudWxsID0gbnVsbFxuICAgICAgbGV0IHN0YXR1cyA9IHJlcy5zdGF0dXNcbiAgICAgIGxldCBzdGF0dXNUZXh0ID0gcmVzLnN0YXR1c1RleHRcblxuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXMudGV4dCgpXG4gICAgICAgICAgaWYgKGJvZHkgPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBQcmVmZXI6IHJldHVybj1taW5pbWFsXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhlYWRlcnMuZ2V0KCdBY2NlcHQnKSA9PT0gJ3RleHQvY3N2Jykge1xuICAgICAgICAgICAgZGF0YSA9IGJvZHlcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLmdldCgnQWNjZXB0JykgJiZcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5nZXQoJ0FjY2VwdCcpPy5pbmNsdWRlcygnYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rdGV4dCcpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkYXRhID0gYm9keVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50SGVhZGVyID0gdGhpcy5oZWFkZXJzLmdldCgnUHJlZmVyJyk/Lm1hdGNoKC9jb3VudD0oZXhhY3R8cGxhbm5lZHxlc3RpbWF0ZWQpLylcbiAgICAgICAgY29uc3QgY29udGVudFJhbmdlID0gcmVzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXJhbmdlJyk/LnNwbGl0KCcvJylcbiAgICAgICAgaWYgKGNvdW50SGVhZGVyICYmIGNvbnRlbnRSYW5nZSAmJiBjb250ZW50UmFuZ2UubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvdW50ID0gcGFyc2VJbnQoY29udGVudFJhbmdlWzFdKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVtcG9yYXJ5IHBhcnRpYWwgZml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8zNjFcbiAgICAgICAgLy8gSXNzdWUgcGVyc2lzdHMgZS5nLiBmb3IgYC5pbnNlcnQoWy4uLl0pLnNlbGVjdCgpLm1heWJlU2luZ2xlKClgXG4gICAgICAgIGlmICh0aGlzLmlzTWF5YmVTaW5nbGUgJiYgdGhpcy5tZXRob2QgPT09ICdHRVQnICYmIEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1Bvc3RnUkVTVC9wb3N0Z3Jlc3QvYmxvYi9hODY3ZDc5YzQyNDE5YWYxNmMxOGMzZmIwMTllYmE4ZGY5OTI2MjZmL3NyYy9Qb3N0Z1JFU1QvRXJyb3IuaHMjTDU1M1xuICAgICAgICAgICAgICBjb2RlOiAnUEdSU1QxMTYnLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVzdWx0cyBjb250YWluICR7ZGF0YS5sZW5ndGh9IHJvd3MsIGFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvbiByZXF1aXJlcyAxIHJvd2AsXG4gICAgICAgICAgICAgIGhpbnQ6IG51bGwsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdKU09OIG9iamVjdCByZXF1ZXN0ZWQsIG11bHRpcGxlIChvciBubykgcm93cyByZXR1cm5lZCcsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gbnVsbFxuICAgICAgICAgICAgY291bnQgPSBudWxsXG4gICAgICAgICAgICBzdGF0dXMgPSA0MDZcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSAnTm90IEFjY2VwdGFibGUnXG4gICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZGF0YSA9IGRhdGFbMF1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXMudGV4dCgpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlcnJvciA9IEpTT04ucGFyc2UoYm9keSlcblxuICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzI5NVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVycm9yKSAmJiByZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbXVxuICAgICAgICAgICAgZXJyb3IgPSBudWxsXG4gICAgICAgICAgICBzdGF0dXMgPSAyMDBcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSAnT0snXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8yOTVcbiAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0ICYmIGJvZHkgPT09ICcnKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAyMDRcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSAnTm8gQ29udGVudCdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGJvZHksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yICYmIHRoaXMuaXNNYXliZVNpbmdsZSAmJiBlcnJvcj8uZGV0YWlscz8uaW5jbHVkZXMoJzAgcm93cycpKSB7XG4gICAgICAgICAgZXJyb3IgPSBudWxsXG4gICAgICAgICAgc3RhdHVzID0gMjAwXG4gICAgICAgICAgc3RhdHVzVGV4dCA9ICdPSydcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciAmJiB0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBQb3N0Z3Jlc3RFcnJvcihlcnJvcilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwb3N0Z3Jlc3RSZXNwb25zZSA9IHtcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQsXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3N0Z3Jlc3RSZXNwb25zZVxuICAgIH0pXG4gICAgaWYgKCF0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgcmVzID0gcmVzLmNhdGNoKChmZXRjaEVycm9yKSA9PiB7XG4gICAgICAgIC8vIEJ1aWxkIGRldGFpbGVkIGVycm9yIGluZm9ybWF0aW9uIGluY2x1ZGluZyBjYXVzZSBpZiBhdmFpbGFibGVcbiAgICAgICAgLy8gTm90ZTogV2UgZG9uJ3QgcG9wdWxhdGUgY29kZS9oaW50IGZvciBjbGllbnQtc2lkZSBuZXR3b3JrIGVycm9ycyBzaW5jZSB0aG9zZVxuICAgICAgICAvLyBmaWVsZHMgYXJlIG1lYW50IGZvciB1cHN0cmVhbSBzZXJ2aWNlIGVycm9ycyAoUG9zdGdSRVNUL1Bvc3RncmVTUUwpXG4gICAgICAgIGxldCBlcnJvckRldGFpbHMgPSAnJ1xuXG4gICAgICAgIC8vIEFkZCBjYXVzZSBpbmZvcm1hdGlvbiBpZiBhdmFpbGFibGUgKGUuZy4sIEROUyBlcnJvcnMsIG5ldHdvcmsgZmFpbHVyZXMpXG4gICAgICAgIGNvbnN0IGNhdXNlID0gZmV0Y2hFcnJvcj8uY2F1c2VcbiAgICAgICAgaWYgKGNhdXNlKSB7XG4gICAgICAgICAgY29uc3QgY2F1c2VNZXNzYWdlID0gY2F1c2U/Lm1lc3NhZ2UgPz8gJydcbiAgICAgICAgICBjb25zdCBjYXVzZUNvZGUgPSBjYXVzZT8uY29kZSA/PyAnJ1xuXG4gICAgICAgICAgZXJyb3JEZXRhaWxzID0gYCR7ZmV0Y2hFcnJvcj8ubmFtZSA/PyAnRmV0Y2hFcnJvcid9OiAke2ZldGNoRXJyb3I/Lm1lc3NhZ2V9YFxuICAgICAgICAgIGVycm9yRGV0YWlscyArPSBgXFxuXFxuQ2F1c2VkIGJ5OiAke2NhdXNlPy5uYW1lID8/ICdFcnJvcid9OiAke2NhdXNlTWVzc2FnZX1gXG4gICAgICAgICAgaWYgKGNhdXNlQ29kZSkge1xuICAgICAgICAgICAgZXJyb3JEZXRhaWxzICs9IGAgKCR7Y2F1c2VDb2RlfSlgXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYXVzZT8uc3RhY2spIHtcbiAgICAgICAgICAgIGVycm9yRGV0YWlscyArPSBgXFxuJHtjYXVzZS5zdGFja31gXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGNhdXNlIGF2YWlsYWJsZSwganVzdCBpbmNsdWRlIHRoZSBlcnJvciBzdGFja1xuICAgICAgICAgIGVycm9yRGV0YWlscyA9IGZldGNoRXJyb3I/LnN0YWNrID8/ICcnXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBgJHtmZXRjaEVycm9yPy5uYW1lID8/ICdGZXRjaEVycm9yJ306ICR7ZmV0Y2hFcnJvcj8ubWVzc2FnZX1gLFxuICAgICAgICAgICAgZGV0YWlsczogZXJyb3JEZXRhaWxzLFxuICAgICAgICAgICAgaGludDogJycsXG4gICAgICAgICAgICBjb2RlOiAnJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgY291bnQ6IG51bGwsXG4gICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgIHN0YXR1c1RleHQ6ICcnLFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiByZXMudGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZClcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgYGRhdGFgLlxuICAgKlxuICAgKiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgcmVzdWx0IHR5cGUgdG8gb3ZlcnJpZGUgd2l0aFxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVUeXBlczx5b3VyVHlwZSwgeyBtZXJnZTogZmFsc2UgfT4oKSBtZXRob2QgYXQgdGhlIGVuZCBvZiB5b3VyIGNhbGwgY2hhaW4gaW5zdGVhZFxuICAgKi9cbiAgcmV0dXJuczxOZXdSZXN1bHQ+KCk6IFBvc3RncmVzdEJ1aWxkZXI8XG4gICAgQ2xpZW50T3B0aW9ucyxcbiAgICBDaGVja01hdGNoaW5nQXJyYXlUeXBlczxSZXN1bHQsIE5ld1Jlc3VsdD4sXG4gICAgVGhyb3dPbkVycm9yXG4gID4ge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFxuICAgICAgQ2xpZW50T3B0aW9ucyxcbiAgICAgIENoZWNrTWF0Y2hpbmdBcnJheVR5cGVzPFJlc3VsdCwgTmV3UmVzdWx0PixcbiAgICAgIFRocm93T25FcnJvclxuICAgID5cbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgYGRhdGFgIGZpZWxkIGluIHRoZSByZXNwb25zZS5cbiAgICpcbiAgICogQHR5cGVQYXJhbSBOZXdSZXN1bHQgLSBUaGUgbmV3IHR5cGUgdG8gY2FzdCB0aGUgcmVzcG9uc2UgZGF0YSB0b1xuICAgKiBAdHlwZVBhcmFtIE9wdGlvbnMgLSBPcHRpb25hbCB0eXBlIGNvbmZpZ3VyYXRpb24gKGRlZmF1bHRzIHRvIHsgbWVyZ2U6IHRydWUgfSlcbiAgICogQHR5cGVQYXJhbSBPcHRpb25zLm1lcmdlIC0gV2hlbiB0cnVlLCBtZXJnZXMgdGhlIG5ldyB0eXBlIHdpdGggZXhpc3RpbmcgcmV0dXJuIHR5cGUuIFdoZW4gZmFsc2UsIHJlcGxhY2VzIHRoZSBleGlzdGluZyB0eXBlcyBlbnRpcmVseSAoZGVmYXVsdHMgdG8gdHJ1ZSlcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiAvLyBNZXJnZSB3aXRoIGV4aXN0aW5nIHR5cGVzIChkZWZhdWx0IGJlaGF2aW9yKVxuICAgKiBjb25zdCBxdWVyeSA9IHN1cGFiYXNlXG4gICAqICAgLmZyb20oJ3VzZXJzJylcbiAgICogICAuc2VsZWN0KClcbiAgICogICAub3ZlcnJpZGVUeXBlczx7IGN1c3RvbV9maWVsZDogc3RyaW5nIH0+KClcbiAgICpcbiAgICogLy8gUmVwbGFjZSBleGlzdGluZyB0eXBlcyBjb21wbGV0ZWx5XG4gICAqIGNvbnN0IHJlcGxhY2VRdWVyeSA9IHN1cGFiYXNlXG4gICAqICAgLmZyb20oJ3VzZXJzJylcbiAgICogICAuc2VsZWN0KClcbiAgICogICAub3ZlcnJpZGVUeXBlczx7IGlkOiBudW1iZXI7IG5hbWU6IHN0cmluZyB9LCB7IG1lcmdlOiBmYWxzZSB9PigpXG4gICAqIGBgYFxuICAgKiBAcmV0dXJucyBBIFBvc3RncmVzdEJ1aWxkZXIgaW5zdGFuY2Ugd2l0aCB0aGUgbmV3IHR5cGVcbiAgICovXG4gIG92ZXJyaWRlVHlwZXM8XG4gICAgTmV3UmVzdWx0LFxuICAgIE9wdGlvbnMgZXh0ZW5kcyB7IG1lcmdlPzogYm9vbGVhbiB9ID0geyBtZXJnZTogdHJ1ZSB9LFxuICA+KCk6IFBvc3RncmVzdEJ1aWxkZXI8XG4gICAgQ2xpZW50T3B0aW9ucyxcbiAgICBJc1ZhbGlkUmVzdWx0T3ZlcnJpZGU8UmVzdWx0LCBOZXdSZXN1bHQsIGZhbHNlLCBmYWxzZT4gZXh0ZW5kcyB0cnVlXG4gICAgICA/IC8vIFByZXNlcnZlIHRoZSBvcHRpb25hbGl0eSBvZiB0aGUgcmVzdWx0IGlmIHRoZSBvdmVycmlkZW4gdHlwZSBpcyBhbiBvYmplY3QgKGNhc2Ugb2YgY2hhaW5pbmcgd2l0aCBgbWF5YmVTaW5nbGVgKVxuICAgICAgICBDb250YWluc051bGw8UmVzdWx0PiBleHRlbmRzIHRydWVcbiAgICAgICAgPyBNZXJnZVBhcnRpYWxSZXN1bHQ8TmV3UmVzdWx0LCBOb25OdWxsYWJsZTxSZXN1bHQ+LCBPcHRpb25zPiB8IG51bGxcbiAgICAgICAgOiBNZXJnZVBhcnRpYWxSZXN1bHQ8TmV3UmVzdWx0LCBSZXN1bHQsIE9wdGlvbnM+XG4gICAgICA6IENoZWNrTWF0Y2hpbmdBcnJheVR5cGVzPFJlc3VsdCwgTmV3UmVzdWx0PixcbiAgICBUaHJvd09uRXJyb3JcbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFxuICAgICAgQ2xpZW50T3B0aW9ucyxcbiAgICAgIElzVmFsaWRSZXN1bHRPdmVycmlkZTxSZXN1bHQsIE5ld1Jlc3VsdCwgZmFsc2UsIGZhbHNlPiBleHRlbmRzIHRydWVcbiAgICAgICAgPyAvLyBQcmVzZXJ2ZSB0aGUgb3B0aW9uYWxpdHkgb2YgdGhlIHJlc3VsdCBpZiB0aGUgb3ZlcnJpZGVuIHR5cGUgaXMgYW4gb2JqZWN0IChjYXNlIG9mIGNoYWluaW5nIHdpdGggYG1heWJlU2luZ2xlYClcbiAgICAgICAgICBDb250YWluc051bGw8UmVzdWx0PiBleHRlbmRzIHRydWVcbiAgICAgICAgICA/IE1lcmdlUGFydGlhbFJlc3VsdDxOZXdSZXN1bHQsIE5vbk51bGxhYmxlPFJlc3VsdD4sIE9wdGlvbnM+IHwgbnVsbFxuICAgICAgICAgIDogTWVyZ2VQYXJ0aWFsUmVzdWx0PE5ld1Jlc3VsdCwgUmVzdWx0LCBPcHRpb25zPlxuICAgICAgICA6IENoZWNrTWF0Y2hpbmdBcnJheVR5cGVzPFJlc3VsdCwgTmV3UmVzdWx0PixcbiAgICAgIFRocm93T25FcnJvclxuICAgID5cbiAgfVxufVxuIiwgImltcG9ydCBQb3N0Z3Jlc3RCdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0QnVpbGRlcidcbmltcG9ydCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLCB7IEludmFsaWRNZXRob2RFcnJvciB9IGZyb20gJy4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlcidcbmltcG9ydCB7IEdldFJlc3VsdCB9IGZyb20gJy4vc2VsZWN0LXF1ZXJ5LXBhcnNlci9yZXN1bHQnXG5pbXBvcnQgeyBDaGVja01hdGNoaW5nQXJyYXlUeXBlcyB9IGZyb20gJy4vdHlwZXMvdHlwZXMnXG5pbXBvcnQgeyBDbGllbnRTZXJ2ZXJPcHRpb25zLCBHZW5lcmljU2NoZW1hIH0gZnJvbSAnLi90eXBlcy9jb21tb24vY29tbW9uJ1xuaW1wb3J0IHR5cGUgeyBNYXhBZmZlY3RlZEVuYWJsZWQgfSBmcm9tICcuL3R5cGVzL2ZlYXR1cmUtZmxhZ3MnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXI8XG4gIENsaWVudE9wdGlvbnMgZXh0ZW5kcyBDbGllbnRTZXJ2ZXJPcHRpb25zLFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hLFxuICBSb3cgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgUmVzdWx0LFxuICBSZWxhdGlvbk5hbWUgPSB1bmtub3duLFxuICBSZWxhdGlvbnNoaXBzID0gdW5rbm93bixcbiAgTWV0aG9kID0gdW5rbm93bixcbj4gZXh0ZW5kcyBQb3N0Z3Jlc3RCdWlsZGVyPENsaWVudE9wdGlvbnMsIFJlc3VsdD4ge1xuICAvKipcbiAgICogUGVyZm9ybSBhIFNFTEVDVCBvbiB0aGUgcXVlcnkgcmVzdWx0LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgLmluc2VydCgpYCwgYC51cGRhdGUoKWAsIGAudXBzZXJ0KClgLCBhbmQgYC5kZWxldGUoKWAgZG8gbm90XG4gICAqIHJldHVybiBtb2RpZmllZCByb3dzLiBCeSBjYWxsaW5nIHRoaXMgbWV0aG9kLCBtb2RpZmllZCByb3dzIGFyZSByZXR1cm5lZCBpblxuICAgKiBgZGF0YWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW5zIC0gVGhlIGNvbHVtbnMgdG8gcmV0cmlldmUsIHNlcGFyYXRlZCBieSBjb21tYXNcbiAgICovXG4gIHNlbGVjdDxcbiAgICBRdWVyeSBleHRlbmRzIHN0cmluZyA9ICcqJyxcbiAgICBOZXdSZXN1bHRPbmUgPSBHZXRSZXN1bHQ8U2NoZW1hLCBSb3csIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcywgUXVlcnksIENsaWVudE9wdGlvbnM+LFxuICA+KFxuICAgIGNvbHVtbnM/OiBRdWVyeVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFxuICAgIENsaWVudE9wdGlvbnMsXG4gICAgU2NoZW1hLFxuICAgIFJvdyxcbiAgICBNZXRob2QgZXh0ZW5kcyAnUlBDJ1xuICAgICAgPyBSZXN1bHQgZXh0ZW5kcyB1bmtub3duW11cbiAgICAgICAgPyBOZXdSZXN1bHRPbmVbXVxuICAgICAgICA6IE5ld1Jlc3VsdE9uZVxuICAgICAgOiBOZXdSZXN1bHRPbmVbXSxcbiAgICBSZWxhdGlvbk5hbWUsXG4gICAgUmVsYXRpb25zaGlwcyxcbiAgICBNZXRob2RcbiAgPiB7XG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VzIGV4Y2VwdCB3aGVuIHF1b3RlZFxuICAgIGxldCBxdW90ZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgPz8gJyonKVxuICAgICAgLnNwbGl0KCcnKVxuICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH0pXG4gICAgICAuam9pbignJylcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucylcbiAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCAncmV0dXJuPXJlcHJlc2VudGF0aW9uJylcbiAgICByZXR1cm4gdGhpcyBhcyB1bmtub3duIGFzIFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8XG4gICAgICBDbGllbnRPcHRpb25zLFxuICAgICAgU2NoZW1hLFxuICAgICAgUm93LFxuICAgICAgTWV0aG9kIGV4dGVuZHMgJ1JQQydcbiAgICAgICAgPyBSZXN1bHQgZXh0ZW5kcyB1bmtub3duW11cbiAgICAgICAgICA/IE5ld1Jlc3VsdE9uZVtdXG4gICAgICAgICAgOiBOZXdSZXN1bHRPbmVcbiAgICAgICAgOiBOZXdSZXN1bHRPbmVbXSxcbiAgICAgIFJlbGF0aW9uTmFtZSxcbiAgICAgIFJlbGF0aW9uc2hpcHMsXG4gICAgICBNZXRob2RcbiAgICA+XG4gIH1cblxuICBvcmRlcjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgb3B0aW9ucz86IHsgYXNjZW5kaW5nPzogYm9vbGVhbjsgbnVsbHNGaXJzdD86IGJvb2xlYW47IHJlZmVyZW5jZWRUYWJsZT86IHVuZGVmaW5lZCB9XG4gICk6IHRoaXNcbiAgb3JkZXIoXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgYXNjZW5kaW5nPzogYm9vbGVhbjsgbnVsbHNGaXJzdD86IGJvb2xlYW47IHJlZmVyZW5jZWRUYWJsZT86IHN0cmluZyB9XG4gICk6IHRoaXNcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgIGluc3RlYWQgb2YgYG9wdGlvbnMuZm9yZWlnblRhYmxlYFxuICAgKi9cbiAgb3JkZXI8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIG9wdGlvbnM/OiB7IGFzY2VuZGluZz86IGJvb2xlYW47IG51bGxzRmlyc3Q/OiBib29sZWFuOyBmb3JlaWduVGFibGU/OiB1bmRlZmluZWQgfVxuICApOiB0aGlzXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYCBpbnN0ZWFkIG9mIGBvcHRpb25zLmZvcmVpZ25UYWJsZWBcbiAgICovXG4gIG9yZGVyKFxuICAgIGNvbHVtbjogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IGFzY2VuZGluZz86IGJvb2xlYW47IG51bGxzRmlyc3Q/OiBib29sZWFuOyBmb3JlaWduVGFibGU/OiBzdHJpbmcgfVxuICApOiB0aGlzXG4gIC8qKlxuICAgKiBPcmRlciB0aGUgcXVlcnkgcmVzdWx0IGJ5IGBjb2x1bW5gLlxuICAgKlxuICAgKiBZb3UgY2FuIGNhbGwgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgdG8gb3JkZXIgYnkgbXVsdGlwbGUgY29sdW1ucy5cbiAgICpcbiAgICogWW91IGNhbiBvcmRlciByZWZlcmVuY2VkIHRhYmxlcywgYnV0IGl0IG9ubHkgYWZmZWN0cyB0aGUgb3JkZXJpbmcgb2YgdGhlXG4gICAqIHBhcmVudCB0YWJsZSBpZiB5b3UgdXNlIGAhaW5uZXJgIGluIHRoZSBxdWVyeS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gb3JkZXIgYnlcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLmFzY2VuZGluZyAtIElmIGB0cnVlYCwgdGhlIHJlc3VsdCB3aWxsIGJlIGluIGFzY2VuZGluZyBvcmRlclxuICAgKiBAcGFyYW0gb3B0aW9ucy5udWxsc0ZpcnN0IC0gSWYgYHRydWVgLCBgbnVsbGBzIGFwcGVhciBmaXJzdC4gSWYgYGZhbHNlYCxcbiAgICogYG51bGxgcyBhcHBlYXIgbGFzdC5cbiAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gb3JkZXIgYSByZWZlcmVuY2VkIHRhYmxlIGJ5XG4gICAqIGl0cyBjb2x1bW5zXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG4gICAqIGluc3RlYWRcbiAgICovXG4gIG9yZGVyKFxuICAgIGNvbHVtbjogc3RyaW5nLFxuICAgIHtcbiAgICAgIGFzY2VuZGluZyA9IHRydWUsXG4gICAgICBudWxsc0ZpcnN0LFxuICAgICAgZm9yZWlnblRhYmxlLFxuICAgICAgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLFxuICAgIH06IHtcbiAgICAgIGFzY2VuZGluZz86IGJvb2xlYW5cbiAgICAgIG51bGxzRmlyc3Q/OiBib29sZWFuXG4gICAgICBmb3JlaWduVGFibGU/OiBzdHJpbmdcbiAgICAgIHJlZmVyZW5jZWRUYWJsZT86IHN0cmluZ1xuICAgIH0gPSB7fVxuICApOiB0aGlzIHtcbiAgICBjb25zdCBrZXkgPSByZWZlcmVuY2VkVGFibGUgPyBgJHtyZWZlcmVuY2VkVGFibGV9Lm9yZGVyYCA6ICdvcmRlcidcbiAgICBjb25zdCBleGlzdGluZ09yZGVyID0gdGhpcy51cmwuc2VhcmNoUGFyYW1zLmdldChrZXkpXG5cbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAga2V5LFxuICAgICAgYCR7ZXhpc3RpbmdPcmRlciA/IGAke2V4aXN0aW5nT3JkZXJ9LGAgOiAnJ30ke2NvbHVtbn0uJHthc2NlbmRpbmcgPyAnYXNjJyA6ICdkZXNjJ30ke1xuICAgICAgICBudWxsc0ZpcnN0ID09PSB1bmRlZmluZWQgPyAnJyA6IG51bGxzRmlyc3QgPyAnLm51bGxzZmlyc3QnIDogJy5udWxsc2xhc3QnXG4gICAgICB9YFxuICAgIClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIExpbWl0IHRoZSBxdWVyeSByZXN1bHQgYnkgYGNvdW50YC5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gcmV0dXJuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBsaW1pdCByb3dzIG9mIHJlZmVyZW5jZWRcbiAgICogdGFibGVzIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuICAgKiBpbnN0ZWFkXG4gICAqL1xuICBsaW1pdChcbiAgICBjb3VudDogbnVtYmVyLFxuICAgIHtcbiAgICAgIGZvcmVpZ25UYWJsZSxcbiAgICAgIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSxcbiAgICB9OiB7IGZvcmVpZ25UYWJsZT86IHN0cmluZzsgcmVmZXJlbmNlZFRhYmxlPzogc3RyaW5nIH0gPSB7fVxuICApOiB0aGlzIHtcbiAgICBjb25zdCBrZXkgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSAndW5kZWZpbmVkJyA/ICdsaW1pdCcgOiBgJHtyZWZlcmVuY2VkVGFibGV9LmxpbWl0YFxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBgJHtjb3VudH1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogTGltaXQgdGhlIHF1ZXJ5IHJlc3VsdCBieSBzdGFydGluZyBhdCBhbiBvZmZzZXQgYGZyb21gIGFuZCBlbmRpbmcgYXQgdGhlIG9mZnNldCBgdG9gLlxuICAgKiBPbmx5IHJlY29yZHMgd2l0aGluIHRoaXMgcmFuZ2UgYXJlIHJldHVybmVkLlxuICAgKiBUaGlzIHJlc3BlY3RzIHRoZSBxdWVyeSBvcmRlciBhbmQgaWYgdGhlcmUgaXMgbm8gb3JkZXIgY2xhdXNlIHRoZSByYW5nZSBjb3VsZCBiZWhhdmUgdW5leHBlY3RlZGx5LlxuICAgKiBUaGUgYGZyb21gIGFuZCBgdG9gIHZhbHVlcyBhcmUgMC1iYXNlZCBhbmQgaW5jbHVzaXZlOiBgcmFuZ2UoMSwgMylgIHdpbGwgaW5jbHVkZSB0aGUgc2Vjb25kLCB0aGlyZFxuICAgKiBhbmQgZm91cnRoIHJvd3Mgb2YgdGhlIHF1ZXJ5LlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBzdGFydGluZyBpbmRleCBmcm9tIHdoaWNoIHRvIGxpbWl0IHRoZSByZXN1bHRcbiAgICogQHBhcmFtIHRvIC0gVGhlIGxhc3QgaW5kZXggdG8gd2hpY2ggdG8gbGltaXQgdGhlIHJlc3VsdFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gbGltaXQgcm93cyBvZiByZWZlcmVuY2VkXG4gICAqIHRhYmxlcyBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcbiAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcbiAgICogaW5zdGVhZFxuICAgKi9cbiAgcmFuZ2UoXG4gICAgZnJvbTogbnVtYmVyLFxuICAgIHRvOiBudW1iZXIsXG4gICAge1xuICAgICAgZm9yZWlnblRhYmxlLFxuICAgICAgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLFxuICAgIH06IHsgZm9yZWlnblRhYmxlPzogc3RyaW5nOyByZWZlcmVuY2VkVGFibGU/OiBzdHJpbmcgfSA9IHt9XG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGtleU9mZnNldCA9XG4gICAgICB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSAndW5kZWZpbmVkJyA/ICdvZmZzZXQnIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5vZmZzZXRgXG4gICAgY29uc3Qga2V5TGltaXQgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSAndW5kZWZpbmVkJyA/ICdsaW1pdCcgOiBgJHtyZWZlcmVuY2VkVGFibGV9LmxpbWl0YFxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5T2Zmc2V0LCBgJHtmcm9tfWApXG4gICAgLy8gUmFuZ2UgaXMgaW5jbHVzaXZlLCBzbyBhZGQgMVxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5TGltaXQsIGAke3RvIC0gZnJvbSArIDF9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgQWJvcnRTaWduYWwgZm9yIHRoZSBmZXRjaCByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gc2lnbmFsIC0gVGhlIEFib3J0U2lnbmFsIHRvIHVzZSBmb3IgdGhlIGZldGNoIHJlcXVlc3RcbiAgICovXG4gIGFib3J0U2lnbmFsKHNpZ25hbDogQWJvcnRTaWduYWwpOiB0aGlzIHtcbiAgICB0aGlzLnNpZ25hbCA9IHNpZ25hbFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGBkYXRhYCBhcyBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBvYmplY3RzLlxuICAgKlxuICAgKiBRdWVyeSByZXN1bHQgbXVzdCBiZSBvbmUgcm93IChlLmcuIHVzaW5nIGAubGltaXQoMSlgKSwgb3RoZXJ3aXNlIHRoaXNcbiAgICogcmV0dXJucyBhbiBlcnJvci5cbiAgICovXG4gIHNpbmdsZTxSZXN1bHRPbmUgPSBSZXN1bHQgZXh0ZW5kcyAoaW5mZXIgUmVzdWx0T25lKVtdID8gUmVzdWx0T25lIDogbmV2ZXI+KCk6IFBvc3RncmVzdEJ1aWxkZXI8XG4gICAgQ2xpZW50T3B0aW9ucyxcbiAgICBSZXN1bHRPbmVcbiAgPiB7XG4gICAgdGhpcy5oZWFkZXJzLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvbicpXG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPENsaWVudE9wdGlvbnMsIFJlc3VsdE9uZT5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIHplcm8gb3Igb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZVxuICAgKiB0aGlzIHJldHVybnMgYW4gZXJyb3IuXG4gICAqL1xuICBtYXliZVNpbmdsZTxcbiAgICBSZXN1bHRPbmUgPSBSZXN1bHQgZXh0ZW5kcyAoaW5mZXIgUmVzdWx0T25lKVtdID8gUmVzdWx0T25lIDogbmV2ZXIsXG4gID4oKTogUG9zdGdyZXN0QnVpbGRlcjxDbGllbnRPcHRpb25zLCBSZXN1bHRPbmUgfCBudWxsPiB7XG4gICAgLy8gVGVtcG9yYXJ5IHBhcnRpYWwgZml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8zNjFcbiAgICAvLyBJc3N1ZSBwZXJzaXN0cyBlLmcuIGZvciBgLmluc2VydChbLi4uXSkuc2VsZWN0KCkubWF5YmVTaW5nbGUoKWBcbiAgICBpZiAodGhpcy5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICB0aGlzLmhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nKVxuICAgIH1cbiAgICB0aGlzLmlzTWF5YmVTaW5nbGUgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPENsaWVudE9wdGlvbnMsIFJlc3VsdE9uZSB8IG51bGw+XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGBkYXRhYCBhcyBhIHN0cmluZyBpbiBDU1YgZm9ybWF0LlxuICAgKi9cbiAgY3N2KCk6IFBvc3RncmVzdEJ1aWxkZXI8Q2xpZW50T3B0aW9ucywgc3RyaW5nPiB7XG4gICAgdGhpcy5oZWFkZXJzLnNldCgnQWNjZXB0JywgJ3RleHQvY3N2JylcbiAgICByZXR1cm4gdGhpcyBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8Q2xpZW50T3B0aW9ucywgc3RyaW5nPlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgZGF0YWAgYXMgYW4gb2JqZWN0IGluIFtHZW9KU09OXShodHRwczovL2dlb2pzb24ub3JnKSBmb3JtYXQuXG4gICAqL1xuICBnZW9qc29uKCk6IFBvc3RncmVzdEJ1aWxkZXI8Q2xpZW50T3B0aW9ucywgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+IHtcbiAgICB0aGlzLmhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vZ2VvK2pzb24nKVxuICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxDbGllbnRPcHRpb25zLCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIHRoZSBFWFBMQUlOIHBsYW4gZm9yIHRoZSBxdWVyeS5cbiAgICpcbiAgICogWW91IG5lZWQgdG8gZW5hYmxlIHRoZVxuICAgKiBbZGJfcGxhbl9lbmFibGVkXShodHRwczovL3N1cGFiYXNlLmNvbS9kb2NzL2d1aWRlcy9kYXRhYmFzZS9kZWJ1Z2dpbmctcGVyZm9ybWFuY2UjZW5hYmxpbmctZXhwbGFpbilcbiAgICogc2V0dGluZyBiZWZvcmUgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5hbmFseXplIC0gSWYgYHRydWVgLCB0aGUgcXVlcnkgd2lsbCBiZSBleGVjdXRlZCBhbmQgdGhlXG4gICAqIGFjdHVhbCBydW4gdGltZSB3aWxsIGJlIHJldHVybmVkXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnZlcmJvc2UgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSBpZGVudGlmaWVyIHdpbGwgYmUgcmV0dXJuZWRcbiAgICogYW5kIGBkYXRhYCB3aWxsIGluY2x1ZGUgdGhlIG91dHB1dCBjb2x1bW5zIG9mIHRoZSBxdWVyeVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zZXR0aW5ncyAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBjb25maWd1cmF0aW9uXG4gICAqIHBhcmFtZXRlcnMgdGhhdCBhZmZlY3QgcXVlcnkgcGxhbm5pbmdcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuYnVmZmVycyAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBidWZmZXIgdXNhZ2VcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMud2FsIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIFdBTCByZWNvcmQgZ2VuZXJhdGlvblxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JtYXQgLSBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQsIGNhbiBiZSBgXCJ0ZXh0XCJgIChkZWZhdWx0KVxuICAgKiBvciBgXCJqc29uXCJgXG4gICAqL1xuICBleHBsYWluKHtcbiAgICBhbmFseXplID0gZmFsc2UsXG4gICAgdmVyYm9zZSA9IGZhbHNlLFxuICAgIHNldHRpbmdzID0gZmFsc2UsXG4gICAgYnVmZmVycyA9IGZhbHNlLFxuICAgIHdhbCA9IGZhbHNlLFxuICAgIGZvcm1hdCA9ICd0ZXh0JyxcbiAgfToge1xuICAgIGFuYWx5emU/OiBib29sZWFuXG4gICAgdmVyYm9zZT86IGJvb2xlYW5cbiAgICBzZXR0aW5ncz86IGJvb2xlYW5cbiAgICBidWZmZXJzPzogYm9vbGVhblxuICAgIHdhbD86IGJvb2xlYW5cbiAgICBmb3JtYXQ/OiAnanNvbicgfCAndGV4dCdcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IFtcbiAgICAgIGFuYWx5emUgPyAnYW5hbHl6ZScgOiBudWxsLFxuICAgICAgdmVyYm9zZSA/ICd2ZXJib3NlJyA6IG51bGwsXG4gICAgICBzZXR0aW5ncyA/ICdzZXR0aW5ncycgOiBudWxsLFxuICAgICAgYnVmZmVycyA/ICdidWZmZXJzJyA6IG51bGwsXG4gICAgICB3YWwgPyAnd2FsJyA6IG51bGwsXG4gICAgXVxuICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgLmpvaW4oJ3wnKVxuICAgIC8vIEFuIEFjY2VwdCBoZWFkZXIgY2FuIGNhcnJ5IG11bHRpcGxlIG1lZGlhIHR5cGVzIGJ1dCBwb3N0Z3Jlc3QtanMgYWx3YXlzIHNlbmRzIG9uZVxuICAgIGNvbnN0IGZvck1lZGlhdHlwZSA9IHRoaXMuaGVhZGVycy5nZXQoJ0FjY2VwdCcpID8/ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIHRoaXMuaGVhZGVycy5zZXQoXG4gICAgICAnQWNjZXB0JyxcbiAgICAgIGBhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbiske2Zvcm1hdH07IGZvcj1cIiR7Zm9yTWVkaWF0eXBlfVwiOyBvcHRpb25zPSR7b3B0aW9uc307YFxuICAgIClcbiAgICBpZiAoZm9ybWF0ID09PSAnanNvbicpIHtcbiAgICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxDbGllbnRPcHRpb25zLCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdPlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcyBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8Q2xpZW50T3B0aW9ucywgc3RyaW5nPlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSb2xsYmFjayB0aGUgcXVlcnkuXG4gICAqXG4gICAqIGBkYXRhYCB3aWxsIHN0aWxsIGJlIHJldHVybmVkLCBidXQgdGhlIHF1ZXJ5IGlzIG5vdCBjb21taXR0ZWQuXG4gICAqL1xuICByb2xsYmFjaygpOiB0aGlzIHtcbiAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCAndHg9cm9sbGJhY2snKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYC5cbiAgICpcbiAgICogQHR5cGVQYXJhbSBOZXdSZXN1bHQgLSBUaGUgbmV3IHJlc3VsdCB0eXBlIHRvIG92ZXJyaWRlIHdpdGhcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlVHlwZXM8eW91clR5cGUsIHsgbWVyZ2U6IGZhbHNlIH0+KCkgbWV0aG9kIGF0IHRoZSBlbmQgb2YgeW91ciBjYWxsIGNoYWluIGluc3RlYWRcbiAgICovXG4gIHJldHVybnM8TmV3UmVzdWx0PigpOiBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFxuICAgIENsaWVudE9wdGlvbnMsXG4gICAgU2NoZW1hLFxuICAgIFJvdyxcbiAgICBDaGVja01hdGNoaW5nQXJyYXlUeXBlczxSZXN1bHQsIE5ld1Jlc3VsdD4sXG4gICAgUmVsYXRpb25OYW1lLFxuICAgIFJlbGF0aW9uc2hpcHMsXG4gICAgTWV0aG9kXG4gID4ge1xuICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxcbiAgICAgIENsaWVudE9wdGlvbnMsXG4gICAgICBTY2hlbWEsXG4gICAgICBSb3csXG4gICAgICBDaGVja01hdGNoaW5nQXJyYXlUeXBlczxSZXN1bHQsIE5ld1Jlc3VsdD4sXG4gICAgICBSZWxhdGlvbk5hbWUsXG4gICAgICBSZWxhdGlvbnNoaXBzLFxuICAgICAgTWV0aG9kXG4gICAgPlxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0aGF0IGNhbiBiZSBhZmZlY3RlZCBieSB0aGUgcXVlcnkuXG4gICAqIE9ubHkgYXZhaWxhYmxlIGluIFBvc3RnUkVTVCB2MTMrIGFuZCBvbmx5IHdvcmtzIHdpdGggUEFUQ0ggYW5kIERFTEVURSBtZXRob2RzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0aGF0IGNhbiBiZSBhZmZlY3RlZFxuICAgKi9cbiAgbWF4QWZmZWN0ZWQodmFsdWU6IG51bWJlcik6IE1heEFmZmVjdGVkRW5hYmxlZDxDbGllbnRPcHRpb25zWydQb3N0Z3Jlc3RWZXJzaW9uJ10+IGV4dGVuZHMgdHJ1ZVxuICAgID8gLy8gVE9ETzogdXBkYXRlIHRoZSBSUEMgY2FzZSB0byBvbmx5IHdvcmsgb24gUlBDIHRoYXQgcmV0dXJucyBTRVRPRiByb3dzXG4gICAgICBNZXRob2QgZXh0ZW5kcyAnUEFUQ0gnIHwgJ0RFTEVURScgfCAnUlBDJ1xuICAgICAgPyB0aGlzXG4gICAgICA6IEludmFsaWRNZXRob2RFcnJvcjwnbWF4QWZmZWN0ZWQgbWV0aG9kIG9ubHkgYXZhaWxhYmxlIG9uIHVwZGF0ZSBvciBkZWxldGUnPlxuICAgIDogSW52YWxpZE1ldGhvZEVycm9yPCdtYXhBZmZlY3RlZCBtZXRob2Qgb25seSBhdmFpbGFibGUgb24gcG9zdGdyZXN0IDEzKyc+IHtcbiAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCAnaGFuZGxpbmc9c3RyaWN0JylcbiAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCBgbWF4LWFmZmVjdGVkPSR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpcyBhcyB1bmtub3duIGFzIE1heEFmZmVjdGVkRW5hYmxlZDxDbGllbnRPcHRpb25zWydQb3N0Z3Jlc3RWZXJzaW9uJ10+IGV4dGVuZHMgdHJ1ZVxuICAgICAgPyBNZXRob2QgZXh0ZW5kcyAnUEFUQ0gnIHwgJ0RFTEVURScgfCAnUlBDJ1xuICAgICAgICA/IHRoaXNcbiAgICAgICAgOiBJbnZhbGlkTWV0aG9kRXJyb3I8J21heEFmZmVjdGVkIG1ldGhvZCBvbmx5IGF2YWlsYWJsZSBvbiB1cGRhdGUgb3IgZGVsZXRlJz5cbiAgICAgIDogSW52YWxpZE1ldGhvZEVycm9yPCdtYXhBZmZlY3RlZCBtZXRob2Qgb25seSBhdmFpbGFibGUgb24gcG9zdGdyZXN0IDEzKyc+XG4gIH1cbn1cbiIsICJpbXBvcnQgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXInXG5pbXBvcnQgeyBKc29uUGF0aFRvQWNjZXNzb3IsIEpzb25QYXRoVG9UeXBlIH0gZnJvbSAnLi9zZWxlY3QtcXVlcnktcGFyc2VyL3V0aWxzJ1xuaW1wb3J0IHsgQ2xpZW50U2VydmVyT3B0aW9ucywgR2VuZXJpY1NjaGVtYSB9IGZyb20gJy4vdHlwZXMvY29tbW9uL2NvbW1vbidcblxudHlwZSBGaWx0ZXJPcGVyYXRvciA9XG4gIHwgJ2VxJ1xuICB8ICduZXEnXG4gIHwgJ2d0J1xuICB8ICdndGUnXG4gIHwgJ2x0J1xuICB8ICdsdGUnXG4gIHwgJ2xpa2UnXG4gIHwgJ2lsaWtlJ1xuICB8ICdpcydcbiAgfCAnaXNkaXN0aW5jdCdcbiAgfCAnaW4nXG4gIHwgJ2NzJ1xuICB8ICdjZCdcbiAgfCAnc2wnXG4gIHwgJ3NyJ1xuICB8ICdueGwnXG4gIHwgJ254cidcbiAgfCAnYWRqJ1xuICB8ICdvdidcbiAgfCAnZnRzJ1xuICB8ICdwbGZ0cydcbiAgfCAncGhmdHMnXG4gIHwgJ3dmdHMnXG4gIHwgJ21hdGNoJ1xuICB8ICdpbWF0Y2gnXG5cbmV4cG9ydCB0eXBlIElzU3RyaW5nT3BlcmF0b3I8UGF0aCBleHRlbmRzIHN0cmluZz4gPSBQYXRoIGV4dGVuZHMgYCR7c3RyaW5nfS0+PiR7c3RyaW5nfWBcbiAgPyB0cnVlXG4gIDogZmFsc2VcblxuY29uc3QgUG9zdGdyZXN0UmVzZXJ2ZWRDaGFyc1JlZ2V4cCA9IG5ldyBSZWdFeHAoJ1ssKCldJylcblxuLy8gTWF0Y2ggcmVsYXRpb25zaGlwIGZpbHRlcnMgd2l0aCBgdGFibGUuY29sdW1uYCBzeW50YXggYW5kIHJlc29sdmUgdW5kZXJseWluZ1xuLy8gY29sdW1uIHZhbHVlLiBJZiBub3QgbWF0Y2hlZCwgZmFsbGJhY2sgdG8gZ2VuZXJpYyB0eXBlLlxuLy8gVE9ETzogVmFsaWRhdGUgdGhlIHJlbGF0aW9uc2hpcCBpdHNlbGYgYWxhIHNlbGVjdC1xdWVyeS1wYXJzZXIuIEN1cnJlbnRseSB3ZVxuLy8gYXNzdW1lIHRoYXQgYWxsIHRhYmxlcyBoYXZlIHZhbGlkIHJlbGF0aW9uc2hpcHMgdG8gZWFjaCBvdGhlciwgZGVzcGl0ZVxuLy8gbm9uZXhpc3RlbnQgZm9yZWlnbiBrZXlzLlxudHlwZSBSZXNvbHZlRmlsdGVyVmFsdWU8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJvdyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nLFxuPiA9IENvbHVtbk5hbWUgZXh0ZW5kcyBgJHtpbmZlciBSZWxhdGlvbnNoaXBUYWJsZX0uJHtpbmZlciBSZW1haW5kZXJ9YFxuICA/IFJlbWFpbmRlciBleHRlbmRzIGAke2luZmVyIF99LiR7aW5mZXIgX31gXG4gICAgPyBSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIFJlbWFpbmRlcj5cbiAgICA6IFJlc29sdmVGaWx0ZXJSZWxhdGlvbnNoaXBWYWx1ZTxTY2hlbWEsIFJlbGF0aW9uc2hpcFRhYmxlLCBSZW1haW5kZXI+XG4gIDogQ29sdW1uTmFtZSBleHRlbmRzIGtleW9mIFJvd1xuICAgID8gUm93W0NvbHVtbk5hbWVdXG4gICAgOiAvLyBJZiB0aGUgY29sdW1uIHNlbGVjdGlvbiBpcyBhIGpzb25wYXRoIGxpa2UgYGRhdGEtPnZhbHVlYCBvciBgZGF0YS0+PnZhbHVlYCB3ZSBhdHRlbXB0IHRvIG1hdGNoXG4gICAgICAvLyB0aGUgZXhwZWN0ZWQgdHlwZSB3aXRoIHRoZSBwYXJzZWQgY3VzdG9tIGpzb24gdHlwZVxuICAgICAgSXNTdHJpbmdPcGVyYXRvcjxDb2x1bW5OYW1lPiBleHRlbmRzIHRydWVcbiAgICAgID8gc3RyaW5nXG4gICAgICA6IEpzb25QYXRoVG9UeXBlPFJvdywgSnNvblBhdGhUb0FjY2Vzc29yPENvbHVtbk5hbWU+PiBleHRlbmRzIGluZmVyIEpzb25QYXRoVmFsdWVcbiAgICAgICAgPyBKc29uUGF0aFZhbHVlIGV4dGVuZHMgbmV2ZXJcbiAgICAgICAgICA/IG5ldmVyXG4gICAgICAgICAgOiBKc29uUGF0aFZhbHVlXG4gICAgICAgIDogbmV2ZXJcblxudHlwZSBSZXNvbHZlRmlsdGVyUmVsYXRpb25zaGlwVmFsdWU8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJlbGF0aW9uc2hpcFRhYmxlIGV4dGVuZHMgc3RyaW5nLFxuICBSZWxhdGlvbnNoaXBDb2x1bW4gZXh0ZW5kcyBzdHJpbmcsXG4+ID0gU2NoZW1hWydUYWJsZXMnXSAmIFNjaGVtYVsnVmlld3MnXSBleHRlbmRzIGluZmVyIFRhYmxlc0FuZFZpZXdzXG4gID8gUmVsYXRpb25zaGlwVGFibGUgZXh0ZW5kcyBrZXlvZiBUYWJsZXNBbmRWaWV3c1xuICAgID8gJ1JvdycgZXh0ZW5kcyBrZXlvZiBUYWJsZXNBbmRWaWV3c1tSZWxhdGlvbnNoaXBUYWJsZV1cbiAgICAgID8gUmVsYXRpb25zaGlwQ29sdW1uIGV4dGVuZHMga2V5b2YgVGFibGVzQW5kVmlld3NbUmVsYXRpb25zaGlwVGFibGVdWydSb3cnXVxuICAgICAgICA/IFRhYmxlc0FuZFZpZXdzW1JlbGF0aW9uc2hpcFRhYmxlXVsnUm93J11bUmVsYXRpb25zaGlwQ29sdW1uXVxuICAgICAgICA6IHVua25vd25cbiAgICAgIDogdW5rbm93blxuICAgIDogdW5rbm93blxuICA6IG5ldmVyXG5cbmV4cG9ydCB0eXBlIEludmFsaWRNZXRob2RFcnJvcjxTIGV4dGVuZHMgc3RyaW5nPiA9IHsgRXJyb3I6IFMgfVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFxuICBDbGllbnRPcHRpb25zIGV4dGVuZHMgQ2xpZW50U2VydmVyT3B0aW9ucyxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSxcbiAgUm93IGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIFJlc3VsdCxcbiAgUmVsYXRpb25OYW1lID0gdW5rbm93bixcbiAgUmVsYXRpb25zaGlwcyA9IHVua25vd24sXG4gIE1ldGhvZCA9IHVua25vd24sXG4+IGV4dGVuZHMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxcbiAgQ2xpZW50T3B0aW9ucyxcbiAgU2NoZW1hLFxuICBSb3csXG4gIFJlc3VsdCxcbiAgUmVsYXRpb25OYW1lLFxuICBSZWxhdGlvbnNoaXBzLFxuICBNZXRob2Rcbj4ge1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIFRvIGNoZWNrIGlmIHRoZSB2YWx1ZSBvZiBgY29sdW1uYCBpcyBOVUxMLCB5b3Ugc2hvdWxkIHVzZSBgLmlzKClgIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGVxPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogUmVzb2x2ZUZpbHRlclZhbHVlPFNjaGVtYSwgUm93LCBDb2x1bW5OYW1lPiBleHRlbmRzIG5ldmVyXG4gICAgICA/IE5vbk51bGxhYmxlPHVua25vd24+XG4gICAgICA6IC8vIFdlIHdhbnQgdG8gaW5mZXIgdGhlIHR5cGUgYmVmb3JlIHdyYXBwaW5nIGl0IGludG8gYSBgTm9uTnVsbGFibGVgIHRvIGF2b2lkIHRvbyBkZWVwXG4gICAgICAgIC8vIHR5cGUgcmVzb2x1dGlvbiBlcnJvclxuICAgICAgICBSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIENvbHVtbk5hbWU+IGV4dGVuZHMgaW5mZXIgUmVzb2x2ZWRGaWx0ZXJWYWx1ZVxuICAgICAgICA/IE5vbk51bGxhYmxlPFJlc29sdmVkRmlsdGVyVmFsdWU+XG4gICAgICAgIDogLy8gV2Ugc2hvdWxkIG5ldmVyIGVudGVyIHRoaXMgY2FzZSBhcyBhbGwgdGhlIGJyYW5jaGVzIGFyZSBjb3ZlcmVkIGFib3ZlXG4gICAgICAgICAgbmV2ZXJcbiAgKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBlcS4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbm90IGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIG5lcTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nPihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWU6IFJlc29sdmVGaWx0ZXJWYWx1ZTxTY2hlbWEsIFJvdywgQ29sdW1uTmFtZT4gZXh0ZW5kcyBuZXZlclxuICAgICAgPyB1bmtub3duXG4gICAgICA6IFJlc29sdmVGaWx0ZXJWYWx1ZTxTY2hlbWEsIFJvdywgQ29sdW1uTmFtZT4gZXh0ZW5kcyBpbmZlciBSZXNvbHZlZEZpbHRlclZhbHVlXG4gICAgICAgID8gUmVzb2x2ZWRGaWx0ZXJWYWx1ZVxuICAgICAgICA6IG5ldmVyXG4gICk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbmVxLiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ3Q8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCB2YWx1ZTogUm93W0NvbHVtbk5hbWVdKTogdGhpc1xuICBndChjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGd0KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZ3QuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBndGU8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCB2YWx1ZTogUm93W0NvbHVtbk5hbWVdKTogdGhpc1xuICBndGUoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBndGUoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBndGUuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsdDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHZhbHVlOiBSb3dbQ29sdW1uTmFtZV0pOiB0aGlzXG4gIGx0KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBsZXNzIHRoYW4gYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgbHQoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsdC4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGx0ZTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHZhbHVlOiBSb3dbQ29sdW1uTmFtZV0pOiB0aGlzXG4gIGx0ZShjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGx0ZShjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGx0ZS4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGxpa2U8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzXG4gIGxpa2UoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZyk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGBwYXR0ZXJuYCBjYXNlLXNlbnNpdGl2ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBsaWtlKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UuJHtwYXR0ZXJufWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGxpa2VBbGxPZjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdXG4gICk6IHRoaXNcbiAgbGlrZUFsbE9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbGwgb2YgYHBhdHRlcm5zYCBjYXNlLXNlbnNpdGl2ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcbiAgICovXG4gIGxpa2VBbGxPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsaWtlQW55T2Y8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXVxuICApOiB0aGlzXG4gIGxpa2VBbnlPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYW55IG9mIGBwYXR0ZXJuc2AgY2FzZS1zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBsaWtlQW55T2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaWxpa2U8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzXG4gIGlsaWtlKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBpbGlrZShjb2x1bW46IHN0cmluZywgcGF0dGVybjogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZS4ke3BhdHRlcm59YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaWxpa2VBbGxPZjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdXG4gICk6IHRoaXNcbiAgaWxpa2VBbGxPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcbiAgICovXG4gIGlsaWtlQWxsT2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UoYWxsKS57JHtwYXR0ZXJucy5qb2luKCcsJyl9fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlsaWtlQW55T2Y8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXVxuICApOiB0aGlzXG4gIGlsaWtlQW55T2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBpbGlrZUFueU9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlKGFueSkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZWdleE1hdGNoPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICByZWdleE1hdGNoKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyB0aGUgUG9zdGdyZVNRTCByZWdleCBgcGF0dGVybmBcbiAgICogY2FzZS1zZW5zaXRpdmVseSAodXNpbmcgdGhlIGB+YCBvcGVyYXRvcikuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcGF0dGVybiAtIFRoZSBQb3N0Z3JlU1FMIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcbiAgICovXG4gIHJlZ2V4TWF0Y2goY29sdW1uOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbWF0Y2guJHtwYXR0ZXJufWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlZ2V4SU1hdGNoPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICByZWdleElNYXRjaChjb2x1bW46IHN0cmluZywgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgdGhlIFBvc3RncmVTUUwgcmVnZXggYHBhdHRlcm5gXG4gICAqIGNhc2UtaW5zZW5zaXRpdmVseSAodXNpbmcgdGhlIGB+KmAgb3BlcmF0b3IpLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHBhdHRlcm4gLSBUaGUgUG9zdGdyZVNRTCByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiB0byBtYXRjaCB3aXRoXG4gICAqL1xuICByZWdleElNYXRjaChjb2x1bW46IHN0cmluZywgcGF0dGVybjogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbWF0Y2guJHtwYXR0ZXJufWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlzPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogUm93W0NvbHVtbk5hbWVdICYgKGJvb2xlYW4gfCBudWxsKVxuICApOiB0aGlzXG4gIGlzKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogYm9vbGVhbiB8IG51bGwpOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgSVMgYHZhbHVlYC5cbiAgICpcbiAgICogRm9yIG5vbi1ib29sZWFuIGNvbHVtbnMsIHRoaXMgaXMgb25seSByZWxldmFudCBmb3IgY2hlY2tpbmcgaWYgdGhlIHZhbHVlIG9mXG4gICAqIGBjb2x1bW5gIGlzIE5VTEwgYnkgc2V0dGluZyBgdmFsdWVgIHRvIGBudWxsYC5cbiAgICpcbiAgICogRm9yIGJvb2xlYW4gY29sdW1ucywgeW91IGNhbiBhbHNvIHNldCBgdmFsdWVgIHRvIGB0cnVlYCBvciBgZmFsc2VgIGFuZCBpdFxuICAgKiB3aWxsIGJlaGF2ZSB0aGUgc2FtZSB3YXkgYXMgYC5lcSgpYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgaXMoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBib29sZWFuIHwgbnVsbCk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaXMuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIElTIERJU1RJTkNUIEZST00gYHZhbHVlYC5cbiAgICpcbiAgICogVW5saWtlIGAubmVxKClgLCB0aGlzIHRyZWF0cyBgTlVMTGAgYXMgYSBjb21wYXJhYmxlIHZhbHVlLiBUd28gYE5VTExgIHZhbHVlc1xuICAgKiBhcmUgY29uc2lkZXJlZCBlcXVhbCAobm90IGRpc3RpbmN0KSwgYW5kIGNvbXBhcmluZyBgTlVMTGAgd2l0aCBhbnkgbm9uLU5VTExcbiAgICogdmFsdWUgcmV0dXJucyB0cnVlIChkaXN0aW5jdCkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGlzRGlzdGluY3Q8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHZhbHVlOiBSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIENvbHVtbk5hbWU+IGV4dGVuZHMgbmV2ZXJcbiAgICAgID8gdW5rbm93blxuICAgICAgOiBSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIENvbHVtbk5hbWU+IGV4dGVuZHMgaW5mZXIgUmVzb2x2ZWRGaWx0ZXJWYWx1ZVxuICAgICAgICA/IFJlc29sdmVkRmlsdGVyVmFsdWVcbiAgICAgICAgOiBuZXZlclxuICApOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlzZGlzdGluY3QuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGluY2x1ZGVkIGluIHRoZSBgdmFsdWVzYCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIGFycmF5IHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBpbjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nPihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWVzOiBSZWFkb25seUFycmF5PFxuICAgICAgUmVzb2x2ZUZpbHRlclZhbHVlPFNjaGVtYSwgUm93LCBDb2x1bW5OYW1lPiBleHRlbmRzIG5ldmVyXG4gICAgICAgID8gdW5rbm93blxuICAgICAgICA6IC8vIFdlIHdhbnQgdG8gaW5mZXIgdGhlIHR5cGUgYmVmb3JlIHdyYXBwaW5nIGl0IGludG8gYSBgTm9uTnVsbGFibGVgIHRvIGF2b2lkIHRvbyBkZWVwXG4gICAgICAgICAgLy8gdHlwZSByZXNvbHV0aW9uIGVycm9yXG4gICAgICAgICAgUmVzb2x2ZUZpbHRlclZhbHVlPFNjaGVtYSwgUm93LCBDb2x1bW5OYW1lPiBleHRlbmRzIGluZmVyIFJlc29sdmVkRmlsdGVyVmFsdWVcbiAgICAgICAgICA/IFJlc29sdmVkRmlsdGVyVmFsdWVcbiAgICAgICAgICA6IC8vIFdlIHNob3VsZCBuZXZlciBlbnRlciB0aGlzIGNhc2UgYXMgYWxsIHRoZSBicmFuY2hlcyBhcmUgY292ZXJlZCBhYm92ZVxuICAgICAgICAgICAgbmV2ZXJcbiAgICA+XG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGNsZWFuZWRWYWx1ZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodmFsdWVzKSlcbiAgICAgIC5tYXAoKHMpID0+IHtcbiAgICAgICAgLy8gaGFuZGxlIHBvc3RncmVzdCByZXNlcnZlZCBjaGFyYWN0ZXJzXG4gICAgICAgIC8vIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi92Ny4wLjAvYXBpLmh0bWwjcmVzZXJ2ZWQtY2hhcmFjdGVyc1xuICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnICYmIFBvc3RncmVzdFJlc2VydmVkQ2hhcnNSZWdleHAudGVzdChzKSkgcmV0dXJuIGBcIiR7c31cImBcbiAgICAgICAgZWxzZSByZXR1cm4gYCR7c31gXG4gICAgICB9KVxuICAgICAgLmpvaW4oJywnKVxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaW4uKCR7Y2xlYW5lZFZhbHVlc30pYClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBOT1QgaW5jbHVkZWQgaW4gdGhlIGB2YWx1ZXNgIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgYXJyYXkgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIG5vdEluPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8XG4gICAgICBSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIENvbHVtbk5hbWU+IGV4dGVuZHMgbmV2ZXJcbiAgICAgICAgPyB1bmtub3duXG4gICAgICAgIDogUmVzb2x2ZUZpbHRlclZhbHVlPFNjaGVtYSwgUm93LCBDb2x1bW5OYW1lPiBleHRlbmRzIGluZmVyIFJlc29sdmVkRmlsdGVyVmFsdWVcbiAgICAgICAgICA/IFJlc29sdmVkRmlsdGVyVmFsdWVcbiAgICAgICAgICA6IG5ldmVyXG4gICAgPlxuICApOiB0aGlzIHtcbiAgICBjb25zdCBjbGVhbmVkVmFsdWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykpXG4gICAgICAubWFwKChzKSA9PiB7XG4gICAgICAgIC8vIGhhbmRsZSBwb3N0Z3Jlc3QgcmVzZXJ2ZWQgY2hhcmFjdGVyc1xuICAgICAgICAvLyBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vdjcuMC4wL2FwaS5odG1sI3Jlc2VydmVkLWNoYXJhY3RlcnNcbiAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJyAmJiBQb3N0Z3Jlc3RSZXNlcnZlZENoYXJzUmVnZXhwLnRlc3QocykpIHJldHVybiBgXCIke3N9XCJgXG4gICAgICAgIGVsc2UgcmV0dXJuIGAke3N9YFxuICAgICAgfSlcbiAgICAgIC5qb2luKCcsJylcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5vdC5pbi4oJHtjbGVhbmVkVmFsdWVzfSlgKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjb250YWluczxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWU6IHN0cmluZyB8IFJlYWRvbmx5QXJyYXk8Um93W0NvbHVtbk5hbWVdPiB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICk6IHRoaXNcbiAgY29udGFpbnMoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCByZWFkb25seSB1bmtub3duW10gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIGpzb25iLCBhcnJheSwgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgKiBgY29sdW1uYCBjb250YWlucyBldmVyeSBlbGVtZW50IGFwcGVhcmluZyBpbiBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgY29udGFpbnMoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCByZWFkb25seSB1bmtub3duW10gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHRoaXMge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyByYW5nZSB0eXBlcyBjYW4gYmUgaW5jbHVzaXZlICdbJywgJ10nIG9yIGV4Y2x1c2l2ZSAnKCcsICcpJyBzbyBqdXN0XG4gICAgICAvLyBrZWVwIGl0IHNpbXBsZSBhbmQgYWNjZXB0IGEgc3RyaW5nXG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLiR7dmFsdWV9YClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBhcnJheVxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy57JHt2YWx1ZS5qb2luKCcsJyl9fWApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGpzb25cbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNvbnRhaW5lZEJ5PENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogc3RyaW5nIHwgUmVhZG9ubHlBcnJheTxSb3dbQ29sdW1uTmFtZV0+IHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgKTogdGhpc1xuICBjb250YWluZWRCeShjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IganNvbmIsIGFycmF5LCBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAqIGV2ZXJ5IGVsZW1lbnQgYXBwZWFyaW5nIGluIGBjb2x1bW5gIGlzIGNvbnRhaW5lZCBieSBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgY29udGFpbmVkQnkoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCByZWFkb25seSB1bmtub3duW10gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHRoaXMge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyByYW5nZVxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC4ke3ZhbHVlfWApXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgLy8gYXJyYXlcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QueyR7dmFsdWUuam9pbignLCcpfX1gKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBqc29uXG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByYW5nZUd0PENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgcmFuZ2VHdChjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAqIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBhbnkgZWxlbWVudCBpbiBgcmFuZ2VgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICByYW5nZUd0KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBzci4ke3JhbmdlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJhbmdlR3RlPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgcmFuZ2VHdGUoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgKiBgY29sdW1uYCBpcyBlaXRoZXIgY29udGFpbmVkIGluIGByYW5nZWAgb3IgZ3JlYXRlciB0aGFuIGFueSBlbGVtZW50IGluXG4gICAqIGByYW5nZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIHJhbmdlR3RlKGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBueGwuJHtyYW5nZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByYW5nZUx0PENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgcmFuZ2VMdChjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAqIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpbiBgcmFuZ2VgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICByYW5nZUx0KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBzbC4ke3JhbmdlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJhbmdlTHRlPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgcmFuZ2VMdGUoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgKiBgY29sdW1uYCBpcyBlaXRoZXIgY29udGFpbmVkIGluIGByYW5nZWAgb3IgbGVzcyB0aGFuIGFueSBlbGVtZW50IGluXG4gICAqIGByYW5nZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIHJhbmdlTHRlKGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBueHIuJHtyYW5nZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByYW5nZUFkamFjZW50PENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgcmFuZ2VBZGphY2VudChjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpc1xuICAgKiBtdXR1YWxseSBleGNsdXNpdmUgdG8gYHJhbmdlYCBhbmQgdGhlcmUgY2FuIGJlIG5vIGVsZW1lbnQgYmV0d2VlbiB0aGUgdHdvXG4gICAqIHJhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgcmFuZ2VBZGphY2VudChjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgYWRqLiR7cmFuZ2V9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgb3ZlcmxhcHM8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBSZWFkb25seUFycmF5PFJvd1tDb2x1bW5OYW1lXT5cbiAgKTogdGhpc1xuICBvdmVybGFwcyhjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIGFycmF5IGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICogYGNvbHVtbmAgYW5kIGB2YWx1ZWAgaGF2ZSBhbiBlbGVtZW50IGluIGNvbW1vbi5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBhcnJheSBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhcnJheSBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgb3ZlcmxhcHMoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCByZWFkb25seSB1bmtub3duW10pOiB0aGlzIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gcmFuZ2VcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgb3YuJHt2YWx1ZX1gKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhcnJheVxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBvdi57JHt2YWx1ZS5qb2luKCcsJyl9fWApXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0ZXh0U2VhcmNoPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBxdWVyeTogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IGNvbmZpZz86IHN0cmluZzsgdHlwZT86ICdwbGFpbicgfCAncGhyYXNlJyB8ICd3ZWJzZWFyY2gnIH1cbiAgKTogdGhpc1xuICB0ZXh0U2VhcmNoKFxuICAgIGNvbHVtbjogc3RyaW5nLFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgY29uZmlnPzogc3RyaW5nOyB0eXBlPzogJ3BsYWluJyB8ICdwaHJhc2UnIHwgJ3dlYnNlYXJjaCcgfVxuICApOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciB0ZXh0IGFuZCB0c3ZlY3RvciBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICogYGNvbHVtbmAgbWF0Y2hlcyB0aGUgcXVlcnkgc3RyaW5nIGluIGBxdWVyeWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgdGV4dCBvciB0c3ZlY3RvciBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0ZXh0IHRvIG1hdGNoIHdpdGhcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvbmZpZyAtIFRoZSB0ZXh0IHNlYXJjaCBjb25maWd1cmF0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0gb3B0aW9ucy50eXBlIC0gQ2hhbmdlIGhvdyB0aGUgYHF1ZXJ5YCB0ZXh0IGlzIGludGVycHJldGVkXG4gICAqL1xuICB0ZXh0U2VhcmNoKFxuICAgIGNvbHVtbjogc3RyaW5nLFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICAgeyBjb25maWcsIHR5cGUgfTogeyBjb25maWc/OiBzdHJpbmc7IHR5cGU/OiAncGxhaW4nIHwgJ3BocmFzZScgfCAnd2Vic2VhcmNoJyB9ID0ge31cbiAgKTogdGhpcyB7XG4gICAgbGV0IHR5cGVQYXJ0ID0gJydcbiAgICBpZiAodHlwZSA9PT0gJ3BsYWluJykge1xuICAgICAgdHlwZVBhcnQgPSAncGwnXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAncGhyYXNlJykge1xuICAgICAgdHlwZVBhcnQgPSAncGgnXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnd2Vic2VhcmNoJykge1xuICAgICAgdHlwZVBhcnQgPSAndydcbiAgICB9XG4gICAgY29uc3QgY29uZmlnUGFydCA9IGNvbmZpZyA9PT0gdW5kZWZpbmVkID8gJycgOiBgKCR7Y29uZmlnfSlgXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGAke3R5cGVQYXJ0fWZ0cyR7Y29uZmlnUGFydH0uJHtxdWVyeX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBtYXRjaDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihxdWVyeTogUmVjb3JkPENvbHVtbk5hbWUsIFJvd1tDb2x1bW5OYW1lXT4pOiB0aGlzXG4gIG1hdGNoKHF1ZXJ5OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBlYWNoIGNvbHVtbiBpbiBgcXVlcnlgIGtleXMgaXMgZXF1YWwgdG8gaXRzXG4gICAqIGFzc29jaWF0ZWQgdmFsdWUuIFNob3J0aGFuZCBmb3IgbXVsdGlwbGUgYC5lcSgpYHMuXG4gICAqXG4gICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBvYmplY3QgdG8gZmlsdGVyIHdpdGgsIHdpdGggY29sdW1uIG5hbWVzIGFzIGtleXMgbWFwcGVkXG4gICAqIHRvIHRoZWlyIGZpbHRlciB2YWx1ZXNcbiAgICovXG4gIG1hdGNoKHF1ZXJ5OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHRoaXMge1xuICAgIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KS5mb3JFYWNoKChbY29sdW1uLCB2YWx1ZV0pID0+IHtcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZXEuJHt2YWx1ZX1gKVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG5vdDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgb3BlcmF0b3I6IEZpbHRlck9wZXJhdG9yLFxuICAgIHZhbHVlOiBSb3dbQ29sdW1uTmFtZV1cbiAgKTogdGhpc1xuICBub3QoY29sdW1uOiBzdHJpbmcsIG9wZXJhdG9yOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIGRvZXNuJ3Qgc2F0aXNmeSB0aGUgZmlsdGVyLlxuICAgKlxuICAgKiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgb3BlYXJhdG9yYCBhbmQgYHZhbHVlYCBhcmUgdXNlZCBhcy1pcyBhbmQgbmVlZCB0b1xuICAgKiBmb2xsb3cgW1Bvc3RnUkVTVFxuICAgKiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuICAgKiB0byBtYWtlIHN1cmUgdGhleSBhcmUgcHJvcGVybHkgc2FuaXRpemVkLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIG9wZXJhdG9yIC0gVGhlIG9wZXJhdG9yIHRvIGJlIG5lZ2F0ZWQgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZ1xuICAgKiBQb3N0Z1JFU1Qgc3ludGF4XG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcbiAgICovXG4gIG5vdChjb2x1bW46IHN0cmluZywgb3BlcmF0b3I6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5vdC4ke29wZXJhdG9yfS4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggc2F0aXNmeSBhdCBsZWFzdCBvbmUgb2YgdGhlIGZpbHRlcnMuXG4gICAqXG4gICAqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBmaWx0ZXJzYCBpcyB1c2VkIGFzLWlzIGFuZCBuZWVkcyB0byBmb2xsb3cgW1Bvc3RnUkVTVFxuICAgKiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuICAgKiB0byBtYWtlIHN1cmUgaXQncyBwcm9wZXJseSBzYW5pdGl6ZWQuXG4gICAqXG4gICAqIEl0J3MgY3VycmVudGx5IG5vdCBwb3NzaWJsZSB0byBkbyBhbiBgLm9yKClgIGZpbHRlciBhY3Jvc3MgbXVsdGlwbGUgdGFibGVzLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIHVzZSwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGZpbHRlciBvbiByZWZlcmVuY2VkIHRhYmxlc1xuICAgKiBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcbiAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGByZWZlcmVuY2VkVGFibGVgIGluc3RlYWRcbiAgICovXG4gIG9yKFxuICAgIGZpbHRlcnM6IHN0cmluZyxcbiAgICB7XG4gICAgICBmb3JlaWduVGFibGUsXG4gICAgICByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsXG4gICAgfTogeyBmb3JlaWduVGFibGU/OiBzdHJpbmc7IHJlZmVyZW5jZWRUYWJsZT86IHN0cmluZyB9ID0ge31cbiAgKTogdGhpcyB7XG4gICAgY29uc3Qga2V5ID0gcmVmZXJlbmNlZFRhYmxlID8gYCR7cmVmZXJlbmNlZFRhYmxlfS5vcmAgOiAnb3InXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIGAoJHtmaWx0ZXJzfSlgKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBmaWx0ZXI8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIG9wZXJhdG9yOiBgJHsnJyB8ICdub3QuJ30ke0ZpbHRlck9wZXJhdG9yfWAsXG4gICAgdmFsdWU6IHVua25vd25cbiAgKTogdGhpc1xuICBmaWx0ZXIoY29sdW1uOiBzdHJpbmcsIG9wZXJhdG9yOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIHNhdGlzZnkgdGhlIGZpbHRlci4gVGhpcyBpcyBhbiBlc2NhcGUgaGF0Y2ggLSB5b3VcbiAgICogc2hvdWxkIHVzZSB0aGUgc3BlY2lmaWMgZmlsdGVyIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUuXG4gICAqXG4gICAqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBvcGVhcmF0b3JgIGFuZCBgdmFsdWVgIGFyZSB1c2VkIGFzLWlzIGFuZCBuZWVkIHRvXG4gICAqIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAqIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBwcm9wZXJseSBzYW5pdGl6ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gb3BlcmF0b3IgLSBUaGUgb3BlcmF0b3IgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcbiAgICovXG4gIGZpbHRlcihjb2x1bW46IHN0cmluZywgb3BlcmF0b3I6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYCR7b3BlcmF0b3J9LiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG4iLCAiaW1wb3J0IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyJ1xuaW1wb3J0IHsgR2V0UmVzdWx0IH0gZnJvbSAnLi9zZWxlY3QtcXVlcnktcGFyc2VyL3Jlc3VsdCdcbmltcG9ydCB7XG4gIENsaWVudFNlcnZlck9wdGlvbnMsXG4gIEZldGNoLFxuICBHZW5lcmljU2NoZW1hLFxuICBHZW5lcmljVGFibGUsXG4gIEdlbmVyaWNWaWV3LFxufSBmcm9tICcuL3R5cGVzL2NvbW1vbi9jb21tb24nXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxcbiAgQ2xpZW50T3B0aW9ucyBleHRlbmRzIENsaWVudFNlcnZlck9wdGlvbnMsXG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJlbGF0aW9uIGV4dGVuZHMgR2VuZXJpY1RhYmxlIHwgR2VuZXJpY1ZpZXcsXG4gIFJlbGF0aW9uTmFtZSA9IHVua25vd24sXG4gIFJlbGF0aW9uc2hpcHMgPSBSZWxhdGlvbiBleHRlbmRzIHsgUmVsYXRpb25zaGlwczogaW5mZXIgUiB9ID8gUiA6IHVua25vd24sXG4+IHtcbiAgdXJsOiBVUkxcbiAgaGVhZGVyczogSGVhZGVyc1xuICBzY2hlbWE/OiBzdHJpbmdcbiAgc2lnbmFsPzogQWJvcnRTaWduYWxcbiAgZmV0Y2g/OiBGZXRjaFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcXVlcnkgYnVpbGRlciBzY29wZWQgdG8gYSBQb3N0Z3JlcyB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgUG9zdGdyZXN0UXVlcnlCdWlsZGVyIGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG4gICAqXG4gICAqIGNvbnN0IHF1ZXJ5ID0gbmV3IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcihcbiAgICogICBuZXcgVVJMKCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vcmVzdC92MS91c2VycycpLFxuICAgKiAgIHsgaGVhZGVyczogeyBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknIH0gfVxuICAgKiApXG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgdXJsOiBVUkwsXG4gICAge1xuICAgICAgaGVhZGVycyA9IHt9LFxuICAgICAgc2NoZW1hLFxuICAgICAgZmV0Y2gsXG4gICAgfToge1xuICAgICAgaGVhZGVycz86IEhlYWRlcnNJbml0XG4gICAgICBzY2hlbWE/OiBzdHJpbmdcbiAgICAgIGZldGNoPzogRmV0Y2hcbiAgICB9XG4gICkge1xuICAgIHRoaXMudXJsID0gdXJsXG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycylcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYVxuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaFxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lIFVSTCBhbmQgaGVhZGVycyB0byBwcmV2ZW50IHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIG9wZXJhdGlvbnMuXG4gICAqL1xuICBwcml2YXRlIGNsb25lUmVxdWVzdFN0YXRlKCk6IHsgdXJsOiBVUkw7IGhlYWRlcnM6IEhlYWRlcnMgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogbmV3IFVSTCh0aGlzLnVybC50b1N0cmluZygpKSxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBTRUxFQ1QgcXVlcnkgb24gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW5zIC0gVGhlIGNvbHVtbnMgdG8gcmV0cmlldmUsIHNlcGFyYXRlZCBieSBjb21tYXMuIENvbHVtbnMgY2FuIGJlIHJlbmFtZWQgd2hlbiByZXR1cm5lZCB3aXRoIGBjdXN0b21OYW1lOmNvbHVtbk5hbWVgXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgaW4gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBXaGVuIHVzaW5nIGBjb3VudGAgd2l0aCBgLnJhbmdlKClgIG9yIGAubGltaXQoKWAsIHRoZSByZXR1cm5lZCBgY291bnRgIGlzIHRoZSB0b3RhbCBudW1iZXIgb2Ygcm93c1xuICAgKiB0aGF0IG1hdGNoIHlvdXIgZmlsdGVycywgbm90IHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgY3VycmVudCBwYWdlLiBVc2UgdGhpcyB0byBidWlsZCBwYWdpbmF0aW9uIFVJLlxuICAgKi9cbiAgc2VsZWN0PFxuICAgIFF1ZXJ5IGV4dGVuZHMgc3RyaW5nID0gJyonLFxuICAgIFJlc3VsdE9uZSA9IEdldFJlc3VsdDxcbiAgICAgIFNjaGVtYSxcbiAgICAgIFJlbGF0aW9uWydSb3cnXSxcbiAgICAgIFJlbGF0aW9uTmFtZSxcbiAgICAgIFJlbGF0aW9uc2hpcHMsXG4gICAgICBRdWVyeSxcbiAgICAgIENsaWVudE9wdGlvbnNcbiAgICA+LFxuICA+KFxuICAgIGNvbHVtbnM/OiBRdWVyeSxcbiAgICBvcHRpb25zPzoge1xuICAgICAgaGVhZD86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFxuICAgIENsaWVudE9wdGlvbnMsXG4gICAgU2NoZW1hLFxuICAgIFJlbGF0aW9uWydSb3cnXSxcbiAgICBSZXN1bHRPbmVbXSxcbiAgICBSZWxhdGlvbk5hbWUsXG4gICAgUmVsYXRpb25zaGlwcyxcbiAgICAnR0VUJ1xuICA+IHtcbiAgICBjb25zdCB7IGhlYWQgPSBmYWxzZSwgY291bnQgfSA9IG9wdGlvbnMgPz8ge31cblxuICAgIGNvbnN0IG1ldGhvZCA9IGhlYWQgPyAnSEVBRCcgOiAnR0VUJ1xuICAgIC8vIFJlbW92ZSB3aGl0ZXNwYWNlcyBleGNlcHQgd2hlbiBxdW90ZWRcbiAgICBsZXQgcXVvdGVkID0gZmFsc2VcbiAgICBjb25zdCBjbGVhbmVkQ29sdW1ucyA9IChjb2x1bW5zID8/ICcqJylcbiAgICAgIC5zcGxpdCgnJylcbiAgICAgIC5tYXAoKGMpID0+IHtcbiAgICAgICAgaWYgKC9cXHMvLnRlc3QoYykgJiYgIXF1b3RlZCkge1xuICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgcXVvdGVkID0gIXF1b3RlZFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9KVxuICAgICAgLmpvaW4oJycpXG5cbiAgICBjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gdGhpcy5jbG9uZVJlcXVlc3RTdGF0ZSgpXG4gICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3NlbGVjdCcsIGNsZWFuZWRDb2x1bW5zKVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgYGNvdW50PSR7Y291bnR9YClcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICB9KVxuICB9XG5cbiAgLy8gVE9ETyh2Myk6IE1ha2UgYGRlZmF1bHRUb051bGxgIGNvbnNpc3RlbnQgZm9yIGJvdGggc2luZ2xlICYgYnVsayBpbnNlcnRzLlxuICBpbnNlcnQ8Um93IGV4dGVuZHMgUmVsYXRpb24gZXh0ZW5kcyB7IEluc2VydDogdW5rbm93biB9ID8gUmVsYXRpb25bJ0luc2VydCddIDogbmV2ZXI+KFxuICAgIHZhbHVlczogUm93LFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgIH1cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxcbiAgICBDbGllbnRPcHRpb25zLFxuICAgIFNjaGVtYSxcbiAgICBSZWxhdGlvblsnUm93J10sXG4gICAgbnVsbCxcbiAgICBSZWxhdGlvbk5hbWUsXG4gICAgUmVsYXRpb25zaGlwcyxcbiAgICAnUE9TVCdcbiAgPlxuICBpbnNlcnQ8Um93IGV4dGVuZHMgUmVsYXRpb24gZXh0ZW5kcyB7IEluc2VydDogdW5rbm93biB9ID8gUmVsYXRpb25bJ0luc2VydCddIDogbmV2ZXI+KFxuICAgIHZhbHVlczogUm93W10sXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgICBkZWZhdWx0VG9OdWxsPzogYm9vbGVhblxuICAgIH1cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxcbiAgICBDbGllbnRPcHRpb25zLFxuICAgIFNjaGVtYSxcbiAgICBSZWxhdGlvblsnUm93J10sXG4gICAgbnVsbCxcbiAgICBSZWxhdGlvbk5hbWUsXG4gICAgUmVsYXRpb25zaGlwcyxcbiAgICAnUE9TVCdcbiAgPlxuICAvKipcbiAgICogUGVyZm9ybSBhbiBJTlNFUlQgaW50byB0aGUgdGFibGUgb3Igdmlldy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgaW5zZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAqIHdpdGggYC5zZWxlY3QoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGluc2VydC4gUGFzcyBhbiBvYmplY3QgdG8gaW5zZXJ0IGEgc2luZ2xlIHJvd1xuICAgKiBvciBhbiBhcnJheSB0byBpbnNlcnQgbXVsdGlwbGUgcm93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCBpbnNlcnRlZCByb3dzLlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdFRvTnVsbCAtIE1ha2UgbWlzc2luZyBmaWVsZHMgZGVmYXVsdCB0byBgbnVsbGAuXG4gICAqIE90aGVyd2lzZSwgdXNlIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgY29sdW1uLiBPbmx5IGFwcGxpZXMgZm9yIGJ1bGtcbiAgICogaW5zZXJ0cy5cbiAgICovXG4gIGluc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3cgfCBSb3dbXSxcbiAgICB7XG4gICAgICBjb3VudCxcbiAgICAgIGRlZmF1bHRUb051bGwgPSB0cnVlLFxuICAgIH06IHtcbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgICBkZWZhdWx0VG9OdWxsPzogYm9vbGVhblxuICAgIH0gPSB7fVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFxuICAgIENsaWVudE9wdGlvbnMsXG4gICAgU2NoZW1hLFxuICAgIFJlbGF0aW9uWydSb3cnXSxcbiAgICBudWxsLFxuICAgIFJlbGF0aW9uTmFtZSxcbiAgICBSZWxhdGlvbnNoaXBzLFxuICAgICdQT1NUJ1xuICA+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCdcbiAgICBjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gdGhpcy5jbG9uZVJlcXVlc3RTdGF0ZSgpXG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCBgY291bnQ9JHtjb3VudH1gKVxuICAgIH1cbiAgICBpZiAoIWRlZmF1bHRUb051bGwpIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCBgbWlzc2luZz1kZWZhdWx0YClcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICBjb25zdCBjb2x1bW5zID0gdmFsdWVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MuY29uY2F0KE9iamVjdC5rZXlzKHgpKSwgW10gYXMgc3RyaW5nW10pXG4gICAgICBpZiAoY29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHVuaXF1ZUNvbHVtbnMgPSBbLi4ubmV3IFNldChjb2x1bW5zKV0ubWFwKChjb2x1bW4pID0+IGBcIiR7Y29sdW1ufVwiYClcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvbHVtbnMnLCB1bmlxdWVDb2x1bW5zLmpvaW4oJywnKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICBib2R5OiB2YWx1ZXMsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCA/PyBmZXRjaCxcbiAgICB9KVxuICB9XG5cbiAgLy8gVE9ETyh2Myk6IE1ha2UgYGRlZmF1bHRUb051bGxgIGNvbnNpc3RlbnQgZm9yIGJvdGggc2luZ2xlICYgYnVsayB1cHNlcnRzLlxuICB1cHNlcnQ8Um93IGV4dGVuZHMgUmVsYXRpb24gZXh0ZW5kcyB7IEluc2VydDogdW5rbm93biB9ID8gUmVsYXRpb25bJ0luc2VydCddIDogbmV2ZXI+KFxuICAgIHZhbHVlczogUm93LFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICBvbkNvbmZsaWN0Pzogc3RyaW5nXG4gICAgICBpZ25vcmVEdXBsaWNhdGVzPzogYm9vbGVhblxuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICB9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8XG4gICAgQ2xpZW50T3B0aW9ucyxcbiAgICBTY2hlbWEsXG4gICAgUmVsYXRpb25bJ1JvdyddLFxuICAgIG51bGwsXG4gICAgUmVsYXRpb25OYW1lLFxuICAgIFJlbGF0aW9uc2hpcHMsXG4gICAgJ1BPU1QnXG4gID5cbiAgdXBzZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvd1tdLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICBvbkNvbmZsaWN0Pzogc3RyaW5nXG4gICAgICBpZ25vcmVEdXBsaWNhdGVzPzogYm9vbGVhblxuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICAgIGRlZmF1bHRUb051bGw/OiBib29sZWFuXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFxuICAgIENsaWVudE9wdGlvbnMsXG4gICAgU2NoZW1hLFxuICAgIFJlbGF0aW9uWydSb3cnXSxcbiAgICBudWxsLFxuICAgIFJlbGF0aW9uTmFtZSxcbiAgICBSZWxhdGlvbnNoaXBzLFxuICAgICdQT1NUJ1xuICA+XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIFVQU0VSVCBvbiB0aGUgdGFibGUgb3Igdmlldy4gRGVwZW5kaW5nIG9uIHRoZSBjb2x1bW4ocykgcGFzc2VkXG4gICAqIHRvIGBvbkNvbmZsaWN0YCwgYC51cHNlcnQoKWAgYWxsb3dzIHlvdSB0byBwZXJmb3JtIHRoZSBlcXVpdmFsZW50IG9mXG4gICAqIGAuaW5zZXJ0KClgIGlmIGEgcm93IHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgYG9uQ29uZmxpY3RgIGNvbHVtbnMgZG9lc24ndFxuICAgKiBleGlzdCwgb3IgaWYgaXQgZG9lcyBleGlzdCwgcGVyZm9ybSBhbiBhbHRlcm5hdGl2ZSBhY3Rpb24gZGVwZW5kaW5nIG9uXG4gICAqIGBpZ25vcmVEdXBsaWNhdGVzYC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdXBzZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAqIHdpdGggYC5zZWxlY3QoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHVwc2VydCB3aXRoLiBQYXNzIGFuIG9iamVjdCB0byB1cHNlcnQgYVxuICAgKiBzaW5nbGUgcm93IG9yIGFuIGFycmF5IHRvIHVwc2VydCBtdWx0aXBsZSByb3dzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMub25Db25mbGljdCAtIENvbW1hLXNlcGFyYXRlZCBVTklRVUUgY29sdW1uKHMpIHRvIHNwZWNpZnkgaG93XG4gICAqIGR1cGxpY2F0ZSByb3dzIGFyZSBkZXRlcm1pbmVkLiBUd28gcm93cyBhcmUgZHVwbGljYXRlcyBpZiBhbGwgdGhlXG4gICAqIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGFyZSBlcXVhbC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyAtIElmIGB0cnVlYCwgZHVwbGljYXRlIHJvd3MgYXJlIGlnbm9yZWQuIElmXG4gICAqIGBmYWxzZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBtZXJnZWQgd2l0aCBleGlzdGluZyByb3dzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgdXBzZXJ0ZWQgcm93cy5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRUb051bGwgLSBNYWtlIG1pc3NpbmcgZmllbGRzIGRlZmF1bHQgdG8gYG51bGxgLlxuICAgKiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gVGhpcyBvbmx5IGFwcGxpZXMgd2hlblxuICAgKiBpbnNlcnRpbmcgbmV3IHJvd3MsIG5vdCB3aGVuIG1lcmdpbmcgd2l0aCBleGlzdGluZyByb3dzIHVuZGVyXG4gICAqIGBpZ25vcmVEdXBsaWNhdGVzOiBmYWxzZWAuIFRoaXMgYWxzbyBvbmx5IGFwcGxpZXMgd2hlbiBkb2luZyBidWxrIHVwc2VydHMuXG4gICAqXG4gICAqIEBleGFtcGxlIFVwc2VydCBhIHNpbmdsZSByb3cgdXNpbmcgYSB1bmlxdWUga2V5XG4gICAqIGBgYHRzXG4gICAqIC8vIFVwc2VydGluZyBhIHNpbmdsZSByb3csIG92ZXJ3cml0aW5nIGJhc2VkIG9uIHRoZSAndXNlcm5hbWUnIHVuaXF1ZSBjb2x1bW5cbiAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICogICAuZnJvbSgndXNlcnMnKVxuICAgKiAgIC51cHNlcnQoeyB1c2VybmFtZTogJ3N1cGFib3QnIH0sIHsgb25Db25mbGljdDogJ3VzZXJuYW1lJyB9KVxuICAgKlxuICAgKiAvLyBFeGFtcGxlIHJlc3BvbnNlOlxuICAgKiAvLyB7XG4gICAqIC8vICAgZGF0YTogW1xuICAgKiAvLyAgICAgeyBpZDogNCwgbWVzc2FnZTogJ2JhcicsIHVzZXJuYW1lOiAnc3VwYWJvdCcgfVxuICAgKiAvLyAgIF0sXG4gICAqIC8vICAgZXJyb3I6IG51bGxcbiAgICogLy8gfVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgVXBzZXJ0IHdpdGggY29uZmxpY3QgcmVzb2x1dGlvbiBhbmQgZXhhY3Qgcm93IGNvdW50aW5nXG4gICAqIGBgYHRzXG4gICAqIC8vIFVwc2VydGluZyBhbmQgcmV0dXJuaW5nIGV4YWN0IGNvdW50XG4gICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IsIGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5mcm9tKCd1c2VycycpXG4gICAqICAgLnVwc2VydChcbiAgICogICAgIHtcbiAgICogICAgICAgaWQ6IDMsXG4gICAqICAgICAgIG1lc3NhZ2U6ICdmb28nLFxuICAgKiAgICAgICB1c2VybmFtZTogJ3N1cGFib3QnXG4gICAqICAgICB9LFxuICAgKiAgICAge1xuICAgKiAgICAgICBvbkNvbmZsaWN0OiAndXNlcm5hbWUnLFxuICAgKiAgICAgICBjb3VudDogJ2V4YWN0J1xuICAgKiAgICAgfVxuICAgKiAgIClcbiAgICpcbiAgICogLy8gRXhhbXBsZSByZXNwb25zZTpcbiAgICogLy8ge1xuICAgKiAvLyAgIGRhdGE6IFtcbiAgICogLy8gICAgIHtcbiAgICogLy8gICAgICAgaWQ6IDQyLFxuICAgKiAvLyAgICAgICBoYW5kbGU6IFwic2FvaXJzZVwiLFxuICAgKiAvLyAgICAgICBkaXNwbGF5X25hbWU6IFwiU2FvaXJzZVwiXG4gICAqIC8vICAgICB9XG4gICAqIC8vICAgXSxcbiAgICogLy8gICBjb3VudDogMSxcbiAgICogLy8gICBlcnJvcjogbnVsbFxuICAgKiAvLyB9XG4gICAqIGBgYFxuICAgKi9cblxuICB1cHNlcnQ8Um93IGV4dGVuZHMgUmVsYXRpb24gZXh0ZW5kcyB7IEluc2VydDogdW5rbm93biB9ID8gUmVsYXRpb25bJ0luc2VydCddIDogbmV2ZXI+KFxuICAgIHZhbHVlczogUm93IHwgUm93W10sXG4gICAge1xuICAgICAgb25Db25mbGljdCxcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZXMgPSBmYWxzZSxcbiAgICAgIGNvdW50LFxuICAgICAgZGVmYXVsdFRvTnVsbCA9IHRydWUsXG4gICAgfToge1xuICAgICAgb25Db25mbGljdD86IHN0cmluZ1xuICAgICAgaWdub3JlRHVwbGljYXRlcz86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgICBkZWZhdWx0VG9OdWxsPzogYm9vbGVhblxuICAgIH0gPSB7fVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFxuICAgIENsaWVudE9wdGlvbnMsXG4gICAgU2NoZW1hLFxuICAgIFJlbGF0aW9uWydSb3cnXSxcbiAgICBudWxsLFxuICAgIFJlbGF0aW9uTmFtZSxcbiAgICBSZWxhdGlvbnNoaXBzLFxuICAgICdQT1NUJ1xuICA+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCdcbiAgICBjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gdGhpcy5jbG9uZVJlcXVlc3RTdGF0ZSgpXG5cbiAgICBoZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgYHJlc29sdXRpb249JHtpZ25vcmVEdXBsaWNhdGVzID8gJ2lnbm9yZScgOiAnbWVyZ2UnfS1kdXBsaWNhdGVzYClcblxuICAgIGlmIChvbkNvbmZsaWN0ICE9PSB1bmRlZmluZWQpIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdvbl9jb25mbGljdCcsIG9uQ29uZmxpY3QpXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgYGNvdW50PSR7Y291bnR9YClcbiAgICB9XG4gICAgaWYgKCFkZWZhdWx0VG9OdWxsKSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgJ21pc3Npbmc9ZGVmYXVsdCcpXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgY29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdIGFzIHN0cmluZ1tdKVxuICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB1bmlxdWVDb2x1bW5zID0gWy4uLm5ldyBTZXQoY29sdW1ucyldLm1hcCgoY29sdW1uKSA9PiBgXCIke2NvbHVtbn1cImApXG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2x1bW5zJywgdW5pcXVlQ29sdW1ucy5qb2luKCcsJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2ggPz8gZmV0Y2gsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIFVQREFURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdXBkYXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cGRhdGUgd2l0aFxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwZGF0ZWQgcm93cy5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqL1xuICB1cGRhdGU8Um93IGV4dGVuZHMgUmVsYXRpb24gZXh0ZW5kcyB7IFVwZGF0ZTogdW5rbm93biB9ID8gUmVsYXRpb25bJ1VwZGF0ZSddIDogbmV2ZXI+KFxuICAgIHZhbHVlczogUm93LFxuICAgIHtcbiAgICAgIGNvdW50LFxuICAgIH06IHtcbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8XG4gICAgQ2xpZW50T3B0aW9ucyxcbiAgICBTY2hlbWEsXG4gICAgUmVsYXRpb25bJ1JvdyddLFxuICAgIG51bGwsXG4gICAgUmVsYXRpb25OYW1lLFxuICAgIFJlbGF0aW9uc2hpcHMsXG4gICAgJ1BBVENIJ1xuICA+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnUEFUQ0gnXG4gICAgY29uc3QgeyB1cmwsIGhlYWRlcnMgfSA9IHRoaXMuY2xvbmVSZXF1ZXN0U3RhdGUoKVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgYGNvdW50PSR7Y291bnR9YClcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICBib2R5OiB2YWx1ZXMsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCA/PyBmZXRjaCxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBERUxFVEUgb24gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGRlbGV0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAqIHdpdGggYC5zZWxlY3QoKWAgYWZ0ZXIgZmlsdGVycy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCBkZWxldGVkIHJvd3MuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKi9cbiAgZGVsZXRlKHtcbiAgICBjb3VudCxcbiAgfToge1xuICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gIH0gPSB7fSk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8XG4gICAgQ2xpZW50T3B0aW9ucyxcbiAgICBTY2hlbWEsXG4gICAgUmVsYXRpb25bJ1JvdyddLFxuICAgIG51bGwsXG4gICAgUmVsYXRpb25OYW1lLFxuICAgIFJlbGF0aW9uc2hpcHMsXG4gICAgJ0RFTEVURSdcbiAgPiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSdcbiAgICBjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gdGhpcy5jbG9uZVJlcXVlc3RTdGF0ZSgpXG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCBgY291bnQ9JHtjb3VudH1gKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoID8/IGZldGNoLFxuICAgIH0pXG4gIH1cbn1cbiIsICJpbXBvcnQgUG9zdGdyZXN0UXVlcnlCdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0UXVlcnlCdWlsZGVyJ1xuaW1wb3J0IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyJ1xuaW1wb3J0IHsgRmV0Y2gsIEdlbmVyaWNTY2hlbWEsIENsaWVudFNlcnZlck9wdGlvbnMgfSBmcm9tICcuL3R5cGVzL2NvbW1vbi9jb21tb24nXG5pbXBvcnQgeyBHZXRScGNGdW5jdGlvbkZpbHRlckJ1aWxkZXJCeUFyZ3MgfSBmcm9tICcuL3R5cGVzL2NvbW1vbi9ycGMnXG5cbi8qKlxuICogUG9zdGdSRVNUIGNsaWVudC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGFiYXNlIC0gVHlwZXMgZm9yIHRoZSBzY2hlbWEgZnJvbSB0aGUgW3R5cGVcbiAqIGdlbmVyYXRvcl0oaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9yZWZlcmVuY2UvamF2YXNjcmlwdC9uZXh0L3R5cGVzY3JpcHQtc3VwcG9ydClcbiAqXG4gKiBAdHlwZVBhcmFtIFNjaGVtYU5hbWUgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvLiBNdXN0IGJlIGEgc3RyaW5nXG4gKiBsaXRlcmFsLCB0aGUgc2FtZSBvbmUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gSWYgdGhlIHNjaGVtYSBpcyBub3RcbiAqIGBcInB1YmxpY1wiYCwgdGhpcyBtdXN0IGJlIHN1cHBsaWVkIG1hbnVhbGx5LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3N0Z3Jlc3RDbGllbnQ8XG4gIERhdGFiYXNlID0gYW55LFxuICBDbGllbnRPcHRpb25zIGV4dGVuZHMgQ2xpZW50U2VydmVyT3B0aW9ucyA9IERhdGFiYXNlIGV4dGVuZHMge1xuICAgIF9fSW50ZXJuYWxTdXBhYmFzZTogaW5mZXIgSSBleHRlbmRzIENsaWVudFNlcnZlck9wdGlvbnNcbiAgfVxuICAgID8gSVxuICAgIDoge30sXG4gIFNjaGVtYU5hbWUgZXh0ZW5kcyBzdHJpbmcgJlxuICAgIGtleW9mIE9taXQ8RGF0YWJhc2UsICdfX0ludGVybmFsU3VwYWJhc2UnPiA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgT21pdDxcbiAgICBEYXRhYmFzZSxcbiAgICAnX19JbnRlcm5hbFN1cGFiYXNlJ1xuICA+XG4gICAgPyAncHVibGljJ1xuICAgIDogc3RyaW5nICYga2V5b2YgT21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+LFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hID0gT21pdDxcbiAgICBEYXRhYmFzZSxcbiAgICAnX19JbnRlcm5hbFN1cGFiYXNlJ1xuICA+W1NjaGVtYU5hbWVdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYVxuICAgID8gT21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+W1NjaGVtYU5hbWVdXG4gICAgOiBhbnksXG4+IHtcbiAgdXJsOiBzdHJpbmdcbiAgaGVhZGVyczogSGVhZGVyc1xuICBzY2hlbWFOYW1lPzogU2NoZW1hTmFtZVxuICBmZXRjaD86IEZldGNoXG5cbiAgLy8gVE9ETzogQWRkIGJhY2sgc2hvdWxkVGhyb3dPbkVycm9yIG9uY2Ugd2UgZmlndXJlIG91dCB0aGUgdHlwaW5nc1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBvc3RnUkVTVCBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSB1cmwgLSBVUkwgb2YgdGhlIFBvc3RnUkVTVCBlbmRwb2ludFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuaGVhZGVycyAtIEN1c3RvbSBoZWFkZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnNjaGVtYSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG9cbiAgICogQHBhcmFtIG9wdGlvbnMuZmV0Y2ggLSBDdXN0b20gZmV0Y2hcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IFBvc3RncmVzdENsaWVudCBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuICAgKlxuICAgKiBjb25zdCBwb3N0Z3Jlc3QgPSBuZXcgUG9zdGdyZXN0Q2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vcmVzdC92MScsIHtcbiAgICogICBoZWFkZXJzOiB7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSxcbiAgICogICBzY2hlbWE6ICdwdWJsaWMnLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHtcbiAgICAgIGhlYWRlcnMgPSB7fSxcbiAgICAgIHNjaGVtYSxcbiAgICAgIGZldGNoLFxuICAgIH06IHtcbiAgICAgIGhlYWRlcnM/OiBIZWFkZXJzSW5pdFxuICAgICAgc2NoZW1hPzogU2NoZW1hTmFtZVxuICAgICAgZmV0Y2g/OiBGZXRjaFxuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMpXG4gICAgdGhpcy5zY2hlbWFOYW1lID0gc2NoZW1hXG4gICAgdGhpcy5mZXRjaCA9IGZldGNoXG4gIH1cbiAgZnJvbTxcbiAgICBUYWJsZU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ1RhYmxlcyddLFxuICAgIFRhYmxlIGV4dGVuZHMgU2NoZW1hWydUYWJsZXMnXVtUYWJsZU5hbWVdLFxuICA+KHJlbGF0aW9uOiBUYWJsZU5hbWUpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8Q2xpZW50T3B0aW9ucywgU2NoZW1hLCBUYWJsZSwgVGFibGVOYW1lPlxuICBmcm9tPFZpZXdOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydWaWV3cyddLCBWaWV3IGV4dGVuZHMgU2NoZW1hWydWaWV3cyddW1ZpZXdOYW1lXT4oXG4gICAgcmVsYXRpb246IFZpZXdOYW1lXG4gICk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxDbGllbnRPcHRpb25zLCBTY2hlbWEsIFZpZXcsIFZpZXdOYW1lPlxuICAvKipcbiAgICogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgdGFibGUgb3IgdmlldyBuYW1lIHRvIHF1ZXJ5XG4gICAqL1xuICBmcm9tKHJlbGF0aW9uOiBzdHJpbmcpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8Q2xpZW50T3B0aW9ucywgU2NoZW1hLCBhbnksIGFueT4ge1xuICAgIGlmICghcmVsYXRpb24gfHwgdHlwZW9mIHJlbGF0aW9uICE9PSAnc3RyaW5nJyB8fCByZWxhdGlvbi50cmltKCkgPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVsYXRpb24gbmFtZTogcmVsYXRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuJylcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3RoaXMudXJsfS8ke3JlbGF0aW9ufWApXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIodXJsLCB7XG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYU5hbWUsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhIHNjaGVtYSB0byBxdWVyeSBvciBwZXJmb3JtIGFuIGZ1bmN0aW9uIChycGMpIGNhbGwuXG4gICAqXG4gICAqIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cbiAgICpcbiAgICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gcXVlcnlcbiAgICovXG4gIHNjaGVtYTxEeW5hbWljU2NoZW1hIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgT21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+PihcbiAgICBzY2hlbWE6IER5bmFtaWNTY2hlbWFcbiAgKTogUG9zdGdyZXN0Q2xpZW50PFxuICAgIERhdGFiYXNlLFxuICAgIENsaWVudE9wdGlvbnMsXG4gICAgRHluYW1pY1NjaGVtYSxcbiAgICBEYXRhYmFzZVtEeW5hbWljU2NoZW1hXSBleHRlbmRzIEdlbmVyaWNTY2hlbWEgPyBEYXRhYmFzZVtEeW5hbWljU2NoZW1hXSA6IGFueVxuICA+IHtcbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdENsaWVudCh0aGlzLnVybCwge1xuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgc2NoZW1hLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgZnVuY3Rpb24gY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIG5hbWUgdG8gY2FsbFxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gY2FsbFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgKiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmdldCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGhcbiAgICogcmVhZC1vbmx5IGFjY2VzcyBtb2RlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyByZXR1cm5lZCBieSB0aGVcbiAgICogZnVuY3Rpb24uIE9ubHkgYXBwbGljYWJsZSBmb3IgW3NldC1yZXR1cm5pbmdcbiAgICogZnVuY3Rpb25zXShodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzL2N1cnJlbnQvZnVuY3Rpb25zLXNyZi5odG1sKS5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIEZvciBjcm9zcy1zY2hlbWEgZnVuY3Rpb25zIHdoZXJlIHR5cGUgaW5mZXJlbmNlIGZhaWxzLCB1c2Ugb3ZlcnJpZGVUeXBlczpcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zY2hlbWEoJ3NjaGVtYV9iJylcbiAgICogICAucnBjKCdmdW5jdGlvbl9hJywge30pXG4gICAqICAgLm92ZXJyaWRlVHlwZXM8eyBpZDogc3RyaW5nOyB1c2VyX2lkOiBzdHJpbmcgfVtdPigpXG4gICAqIGBgYFxuICAgKi9cbiAgcnBjPFxuICAgIEZuTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFNjaGVtYVsnRnVuY3Rpb25zJ10sXG4gICAgQXJncyBleHRlbmRzIFNjaGVtYVsnRnVuY3Rpb25zJ11bRm5OYW1lXVsnQXJncyddID0gbmV2ZXIsXG4gICAgRmlsdGVyQnVpbGRlciBleHRlbmRzIEdldFJwY0Z1bmN0aW9uRmlsdGVyQnVpbGRlckJ5QXJnczxcbiAgICAgIFNjaGVtYSxcbiAgICAgIEZuTmFtZSxcbiAgICAgIEFyZ3NcbiAgICA+ID0gR2V0UnBjRnVuY3Rpb25GaWx0ZXJCdWlsZGVyQnlBcmdzPFNjaGVtYSwgRm5OYW1lLCBBcmdzPixcbiAgPihcbiAgICBmbjogRm5OYW1lLFxuICAgIGFyZ3M6IEFyZ3MgPSB7fSBhcyBBcmdzLFxuICAgIHtcbiAgICAgIGhlYWQgPSBmYWxzZSxcbiAgICAgIGdldCA9IGZhbHNlLFxuICAgICAgY291bnQsXG4gICAgfToge1xuICAgICAgaGVhZD86IGJvb2xlYW5cbiAgICAgIGdldD86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8XG4gICAgQ2xpZW50T3B0aW9ucyxcbiAgICBTY2hlbWEsXG4gICAgRmlsdGVyQnVpbGRlclsnUm93J10sXG4gICAgRmlsdGVyQnVpbGRlclsnUmVzdWx0J10sXG4gICAgRmlsdGVyQnVpbGRlclsnUmVsYXRpb25OYW1lJ10sXG4gICAgRmlsdGVyQnVpbGRlclsnUmVsYXRpb25zaGlwcyddLFxuICAgICdSUEMnXG4gID4ge1xuICAgIGxldCBtZXRob2Q6ICdIRUFEJyB8ICdHRVQnIHwgJ1BPU1QnXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vcnBjLyR7Zm59YClcbiAgICBsZXQgYm9keTogdW5rbm93biB8IHVuZGVmaW5lZFxuICAgIC8vIG9iamVjdHMvYXJyYXlzLW9mLW9iamVjdHMgY2FuJ3QgYmUgc2VyaWFsaXplZCB0byBVUkwgcGFyYW1zLCB1c2UgUE9TVCArIHJldHVybj1taW5pbWFsIGluc3RlYWRcbiAgICBjb25zdCBfaXNPYmplY3QgPSAodjogdW5rbm93bik6IGJvb2xlYW4gPT5cbiAgICAgIHYgIT09IG51bGwgJiYgdHlwZW9mIHYgPT09ICdvYmplY3QnICYmICghQXJyYXkuaXNBcnJheSh2KSB8fCB2LnNvbWUoX2lzT2JqZWN0KSlcbiAgICBjb25zdCBfaGFzT2JqZWN0QXJnID0gaGVhZCAmJiBPYmplY3QudmFsdWVzKGFyZ3MgYXMgb2JqZWN0KS5zb21lKF9pc09iamVjdClcbiAgICBpZiAoX2hhc09iamVjdEFyZykge1xuICAgICAgbWV0aG9kID0gJ1BPU1QnXG4gICAgICBib2R5ID0gYXJnc1xuICAgIH0gZWxzZSBpZiAoaGVhZCB8fCBnZXQpIHtcbiAgICAgIG1ldGhvZCA9IGhlYWQgPyAnSEVBRCcgOiAnR0VUJ1xuICAgICAgT2JqZWN0LmVudHJpZXMoYXJncylcbiAgICAgICAgLy8gcGFyYW1zIHdpdGggdW5kZWZpbmVkIHZhbHVlIG5lZWRzIHRvIGJlIGZpbHRlcmVkIG91dCwgb3RoZXJ3aXNlIGl0J2xsXG4gICAgICAgIC8vIHNob3cgdXAgYXMgYD9wYXJhbT11bmRlZmluZWRgXG4gICAgICAgIC5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIC8vIGFycmF5IHZhbHVlcyBuZWVkIHNwZWNpYWwgc3ludGF4XG4gICAgICAgIC5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IFtuYW1lLCBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGB7JHt2YWx1ZS5qb2luKCcsJyl9fWAgOiBgJHt2YWx1ZX1gXSlcbiAgICAgICAgLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0aG9kID0gJ1BPU1QnXG4gICAgICBib2R5ID0gYXJnc1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpXG4gICAgaWYgKF9oYXNPYmplY3RBcmcpIHtcbiAgICAgIGhlYWRlcnMuc2V0KCdQcmVmZXInLCBjb3VudCA/IGBjb3VudD0ke2NvdW50fSxyZXR1cm49bWluaW1hbGAgOiAncmV0dXJuPW1pbmltYWwnKVxuICAgIH0gZWxzZSBpZiAoY291bnQpIHtcbiAgICAgIGhlYWRlcnMuc2V0KCdQcmVmZXInLCBgY291bnQ9JHtjb3VudH1gKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYU5hbWUsXG4gICAgICBib2R5LFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2ggPz8gZmV0Y2gsXG4gICAgfSlcbiAgfVxufVxuIiwgImltcG9ydCBQb3N0Z3Jlc3RDbGllbnQgZnJvbSAnLi9Qb3N0Z3Jlc3RDbGllbnQnXG5pbXBvcnQgUG9zdGdyZXN0UXVlcnlCdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0UXVlcnlCdWlsZGVyJ1xuaW1wb3J0IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyJ1xuaW1wb3J0IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyJ1xuaW1wb3J0IFBvc3RncmVzdEJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RCdWlsZGVyJ1xuaW1wb3J0IFBvc3RncmVzdEVycm9yIGZyb20gJy4vUG9zdGdyZXN0RXJyb3InXG5cbmV4cG9ydCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn1cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUG9zdGdyZXN0Q2xpZW50LFxuICBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIsXG4gIFBvc3RncmVzdEJ1aWxkZXIsXG4gIFBvc3RncmVzdEVycm9yLFxufVxuZXhwb3J0IHR5cGUge1xuICBQb3N0Z3Jlc3RSZXNwb25zZSxcbiAgUG9zdGdyZXN0UmVzcG9uc2VGYWlsdXJlLFxuICBQb3N0Z3Jlc3RSZXNwb25zZVN1Y2Nlc3MsXG4gIFBvc3RncmVzdFNpbmdsZVJlc3BvbnNlLFxuICBQb3N0Z3Jlc3RNYXliZVNpbmdsZVJlc3BvbnNlLFxufSBmcm9tICcuL3R5cGVzL3R5cGVzJ1xuZXhwb3J0IHR5cGUgeyBDbGllbnRTZXJ2ZXJPcHRpb25zIGFzIFBvc3RncmVzdENsaWVudE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzL2NvbW1vbi9jb21tb24nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy81NTFcbi8vIFRvIGJlIHJlcGxhY2VkIHdpdGggYSBoZWxwZXIgdHlwZSB0aGF0IG9ubHkgdXNlcyBwdWJsaWMgdHlwZXNcbmV4cG9ydCB0eXBlIHsgR2V0UmVzdWx0IGFzIFVuc3RhYmxlR2V0UmVzdWx0IH0gZnJvbSAnLi9zZWxlY3QtcXVlcnktcGFyc2VyL3Jlc3VsdCdcbiIsICJleHBvcnQgaW50ZXJmYWNlIFdlYlNvY2tldExpa2Uge1xuICByZWFkb25seSBDT05ORUNUSU5HOiBudW1iZXJcbiAgcmVhZG9ubHkgT1BFTjogbnVtYmVyXG4gIHJlYWRvbmx5IENMT1NJTkc6IG51bWJlclxuICByZWFkb25seSBDTE9TRUQ6IG51bWJlclxuICByZWFkb25seSByZWFkeVN0YXRlOiBudW1iZXJcbiAgcmVhZG9ubHkgdXJsOiBzdHJpbmdcbiAgcmVhZG9ubHkgcHJvdG9jb2w6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHNvY2tldCwgb3B0aW9uYWxseSBwcm92aWRpbmcgYSBjbG9zZSBjb2RlIGFuZCByZWFzb24uXG4gICAqL1xuICBjbG9zZShjb2RlPzogbnVtYmVyLCByZWFzb24/OiBzdHJpbmcpOiB2b2lkXG4gIC8qKlxuICAgKiBTZW5kcyBkYXRhIHRocm91Z2ggdGhlIHNvY2tldCB1c2luZyB0aGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbi5cbiAgICovXG4gIHNlbmQoZGF0YTogc3RyaW5nIHwgQXJyYXlCdWZmZXJMaWtlIHwgQmxvYiB8IEFycmF5QnVmZmVyVmlldyk6IHZvaWRcblxuICBvbm9wZW46ICgodGhpczogYW55LCBldjogRXZlbnQpID0+IGFueSkgfCBudWxsXG4gIG9ubWVzc2FnZTogKCh0aGlzOiBhbnksIGV2OiBNZXNzYWdlRXZlbnQpID0+IGFueSkgfCBudWxsXG4gIG9uY2xvc2U6ICgodGhpczogYW55LCBldjogQ2xvc2VFdmVudCkgPT4gYW55KSB8IG51bGxcbiAgb25lcnJvcjogKCh0aGlzOiBhbnksIGV2OiBFdmVudCkgPT4gYW55KSB8IG51bGxcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQgKGNvbXBhdGlibGUgd2l0aCBicm93c2VyIFdlYlNvY2tldCBBUEkpLlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlOiBzdHJpbmcsIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyKTogdm9pZFxuICAvKipcbiAgICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZTogc3RyaW5nLCBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcik6IHZvaWRcblxuICAvLyBBZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWF5IGV4aXN0IG9uIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbnNcbiAgYmluYXJ5VHlwZT86IHN0cmluZ1xuICBidWZmZXJlZEFtb3VudD86IG51bWJlclxuICBleHRlbnNpb25zPzogc3RyaW5nXG4gIGRpc3BhdGNoRXZlbnQ/OiAoZXZlbnQ6IEV2ZW50KSA9PiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2ViU29ja2V0RW52aXJvbm1lbnQge1xuICB0eXBlOiAnbmF0aXZlJyB8ICd3cycgfCAnY2xvdWRmbGFyZScgfCAndW5zdXBwb3J0ZWQnXG4gIGNvbnN0cnVjdG9yPzogYW55XG4gIGVycm9yPzogc3RyaW5nXG4gIHdvcmthcm91bmQ/OiBzdHJpbmdcbn1cblxuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIGNyZWF0aW5nIFdlYlNvY2tldCBpbnN0YW5jZXMgYWNyb3NzIHJ1bnRpbWVzLlxuICovXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0RmFjdG9yeSB7XG4gIC8qKlxuICAgKiBTdGF0aWMtb25seSB1dGlsaXR5IFx1MjAxMyBwcmV2ZW50IGluc3RhbnRpYXRpb24uXG4gICAqL1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cbiAgcHJpdmF0ZSBzdGF0aWMgZGV0ZWN0RW52aXJvbm1lbnQoKTogV2ViU29ja2V0RW52aXJvbm1lbnQge1xuICAgIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ25hdGl2ZScsIGNvbnN0cnVjdG9yOiBXZWJTb2NrZXQgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIChnbG9iYWxUaGlzIGFzIGFueSkuV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ25hdGl2ZScsIGNvbnN0cnVjdG9yOiAoZ2xvYmFsVGhpcyBhcyBhbnkpLldlYlNvY2tldCB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiAoZ2xvYmFsIGFzIGFueSkuV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ25hdGl2ZScsIGNvbnN0cnVjdG9yOiAoZ2xvYmFsIGFzIGFueSkuV2ViU29ja2V0IH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiAoZ2xvYmFsVGhpcyBhcyBhbnkpLldlYlNvY2tldFBhaXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgZ2xvYmFsVGhpcy5XZWJTb2NrZXQgPT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY2xvdWRmbGFyZScsXG4gICAgICAgIGVycm9yOlxuICAgICAgICAgICdDbG91ZGZsYXJlIFdvcmtlcnMgZGV0ZWN0ZWQuIFdlYlNvY2tldCBjbGllbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIENsb3VkZmxhcmUgV29ya2Vycy4nLFxuICAgICAgICB3b3JrYXJvdW5kOlxuICAgICAgICAgICdVc2UgQ2xvdWRmbGFyZSBXb3JrZXJzIFdlYlNvY2tldCBBUEkgZm9yIHNlcnZlci1zaWRlIFdlYlNvY2tldCBoYW5kbGluZywgb3IgZGVwbG95IHRvIGEgZGlmZmVyZW50IHJ1bnRpbWUuJyxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIChnbG9iYWxUaGlzIGFzIGFueSkuRWRnZVJ1bnRpbWUpIHx8XG4gICAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudD8uaW5jbHVkZXMoJ1ZlcmNlbC1FZGdlJykpXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAndW5zdXBwb3J0ZWQnLFxuICAgICAgICBlcnJvcjpcbiAgICAgICAgICAnRWRnZSBydW50aW1lIGRldGVjdGVkIChWZXJjZWwgRWRnZS9OZXRsaWZ5IEVkZ2UpLiBXZWJTb2NrZXRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGVkZ2UgZnVuY3Rpb25zLicsXG4gICAgICAgIHdvcmthcm91bmQ6XG4gICAgICAgICAgJ1VzZSBzZXJ2ZXJsZXNzIGZ1bmN0aW9ucyBvciBhIGRpZmZlcmVudCBkZXBsb3ltZW50IHRhcmdldCBmb3IgV2ViU29ja2V0IGZ1bmN0aW9uYWxpdHkuJyxcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVc2UgZHluYW1pYyBwcm9wZXJ0eSBhY2Nlc3MgdG8gYXZvaWQgTmV4dC5qcyBFZGdlIFJ1bnRpbWUgc3RhdGljIGFuYWx5c2lzIHdhcm5pbmdzXG4gICAgY29uc3QgX3Byb2Nlc3MgPSAoZ2xvYmFsVGhpcyBhcyBhbnkpWydwcm9jZXNzJ11cbiAgICBpZiAoX3Byb2Nlc3MpIHtcbiAgICAgIGNvbnN0IHByb2Nlc3NWZXJzaW9ucyA9IF9wcm9jZXNzWyd2ZXJzaW9ucyddXG4gICAgICBpZiAocHJvY2Vzc1ZlcnNpb25zICYmIHByb2Nlc3NWZXJzaW9uc1snbm9kZSddKSB7XG4gICAgICAgIC8vIFJlbW92ZSAndicgcHJlZml4IGlmIHByZXNlbnQgYW5kIHBhcnNlIHRoZSBtYWpvciB2ZXJzaW9uXG4gICAgICAgIGNvbnN0IHZlcnNpb25TdHJpbmcgPSBwcm9jZXNzVmVyc2lvbnNbJ25vZGUnXVxuICAgICAgICBjb25zdCBub2RlVmVyc2lvbiA9IHBhcnNlSW50KHZlcnNpb25TdHJpbmcucmVwbGFjZSgvXnYvLCAnJykuc3BsaXQoJy4nKVswXSlcblxuICAgICAgICAvLyBOb2RlLmpzIDIyKyBzaG91bGQgaGF2ZSBuYXRpdmUgV2ViU29ja2V0XG4gICAgICAgIGlmIChub2RlVmVyc2lvbiA+PSAyMikge1xuICAgICAgICAgIC8vIENoZWNrIGlmIG5hdGl2ZSBXZWJTb2NrZXQgaXMgYXZhaWxhYmxlIChzaG91bGQgYmUgaW4gTm9kZS5qcyAyMispXG4gICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICduYXRpdmUnLCBjb25zdHJ1Y3RvcjogZ2xvYmFsVGhpcy5XZWJTb2NrZXQgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiBub3QgYXZhaWxhYmxlLCB1c2VyIG5lZWRzIHRvIHByb3ZpZGUgaXRcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3Vuc3VwcG9ydGVkJyxcbiAgICAgICAgICAgIGVycm9yOiBgTm9kZS5qcyAke25vZGVWZXJzaW9ufSBkZXRlY3RlZCBidXQgbmF0aXZlIFdlYlNvY2tldCBub3QgZm91bmQuYCxcbiAgICAgICAgICAgIHdvcmthcm91bmQ6ICdQcm92aWRlIGEgV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIHZpYSB0aGUgdHJhbnNwb3J0IG9wdGlvbi4nLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vZGUuanMgPCAyMiBkb2Vzbid0IGhhdmUgbmF0aXZlIFdlYlNvY2tldFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICd1bnN1cHBvcnRlZCcsXG4gICAgICAgICAgZXJyb3I6IGBOb2RlLmpzICR7bm9kZVZlcnNpb259IGRldGVjdGVkIHdpdGhvdXQgbmF0aXZlIFdlYlNvY2tldCBzdXBwb3J0LmAsXG4gICAgICAgICAgd29ya2Fyb3VuZDpcbiAgICAgICAgICAgICdGb3IgTm9kZS5qcyA8IDIyLCBpbnN0YWxsIFwid3NcIiBwYWNrYWdlIGFuZCBwcm92aWRlIGl0IHZpYSB0aGUgdHJhbnNwb3J0IG9wdGlvbjpcXG4nICtcbiAgICAgICAgICAgICdpbXBvcnQgd3MgZnJvbSBcIndzXCJcXG4nICtcbiAgICAgICAgICAgICduZXcgUmVhbHRpbWVDbGllbnQodXJsLCB7IHRyYW5zcG9ydDogd3MgfSknLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd1bnN1cHBvcnRlZCcsXG4gICAgICBlcnJvcjogJ1Vua25vd24gSmF2YVNjcmlwdCBydW50aW1lIHdpdGhvdXQgV2ViU29ja2V0IHN1cHBvcnQuJyxcbiAgICAgIHdvcmthcm91bmQ6XG4gICAgICAgIFwiRW5zdXJlIHlvdSdyZSBydW5uaW5nIGluIGEgc3VwcG9ydGVkIGVudmlyb25tZW50IChicm93c2VyLCBOb2RlLmpzLCBEZW5vKSBvciBwcm92aWRlIGEgY3VzdG9tIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbi5cIixcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmVzdCBhdmFpbGFibGUgV2ViU29ja2V0IGNvbnN0cnVjdG9yIGZvciB0aGUgY3VycmVudCBydW50aW1lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBXUyA9IFdlYlNvY2tldEZhY3RvcnkuZ2V0V2ViU29ja2V0Q29uc3RydWN0b3IoKVxuICAgKiBjb25zdCBzb2NrZXQgPSBuZXcgV1MoJ3dzczovL3JlYWx0aW1lLnN1cGFiYXNlLmNvL3NvY2tldCcpXG4gICAqIGBgYFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXRXZWJTb2NrZXRDb25zdHJ1Y3RvcigpOiB0eXBlb2YgV2ViU29ja2V0IHtcbiAgICBjb25zdCBlbnYgPSB0aGlzLmRldGVjdEVudmlyb25tZW50KClcbiAgICBpZiAoZW52LmNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZW52LmNvbnN0cnVjdG9yXG4gICAgfVxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBlbnYuZXJyb3IgfHwgJ1dlYlNvY2tldCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuJ1xuICAgIGlmIChlbnYud29ya2Fyb3VuZCkge1xuICAgICAgZXJyb3JNZXNzYWdlICs9IGBcXG5cXG5TdWdnZXN0ZWQgc29sdXRpb246ICR7ZW52Lndvcmthcm91bmR9YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBXZWJTb2NrZXQgdXNpbmcgdGhlIGRldGVjdGVkIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBzb2NrZXQgPSBXZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZVdlYlNvY2tldCgnd3NzOi8vcmVhbHRpbWUuc3VwYWJhc2UuY28vc29ja2V0JylcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZVdlYlNvY2tldCh1cmw6IHN0cmluZyB8IFVSTCwgcHJvdG9jb2xzPzogc3RyaW5nIHwgc3RyaW5nW10pOiBXZWJTb2NrZXRMaWtlIHtcbiAgICBjb25zdCBXUyA9IHRoaXMuZ2V0V2ViU29ja2V0Q29uc3RydWN0b3IoKVxuICAgIHJldHVybiBuZXcgV1ModXJsLCBwcm90b2NvbHMpXG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0cyB3aGV0aGVyIHRoZSBydW50aW1lIGNhbiBlc3RhYmxpc2ggV2ViU29ja2V0IGNvbm5lY3Rpb25zLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpZiAoIVdlYlNvY2tldEZhY3RvcnkuaXNXZWJTb2NrZXRTdXBwb3J0ZWQoKSkge1xuICAgKiAgIGNvbnNvbGUud2FybignRmFsbGluZyBiYWNrIHRvIGxvbmcgcG9sbGluZycpXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGlzV2ViU29ja2V0U3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbnYgPSB0aGlzLmRldGVjdEVudmlyb25tZW50KClcbiAgICAgIHJldHVybiBlbnYudHlwZSA9PT0gJ25hdGl2ZScgfHwgZW52LnR5cGUgPT09ICd3cydcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJTb2NrZXRGYWN0b3J5XG4iLCAiLy8gR2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIHJlbGVhc2VzIGJ5IHNjcmlwdHMvdXBkYXRlLXZlcnNpb24tZmlsZXMudHNcbi8vIFRoaXMgZmlsZSBwcm92aWRlcyBydW50aW1lIGFjY2VzcyB0byB0aGUgcGFja2FnZSB2ZXJzaW9uIGZvcjpcbi8vIC0gSFRUUCByZXF1ZXN0IGhlYWRlcnMgKGUuZy4sIFgtQ2xpZW50LUluZm8gaGVhZGVyIGZvciBBUEkgcmVxdWVzdHMpXG4vLyAtIERlYnVnZ2luZyBhbmQgc3VwcG9ydCAoaWRlbnRpZnlpbmcgd2hpY2ggdmVyc2lvbiBpcyBydW5uaW5nKVxuLy8gLSBUZWxlbWV0cnkgYW5kIGxvZ2dpbmcgKHZlcnNpb24gcmVwb3J0aW5nIGluIGVycm9ycy9hbmFseXRpY3MpXG4vLyAtIEVuc3VyaW5nIGJ1aWxkIGFydGlmYWN0cyBtYXRjaCB0aGUgcHVibGlzaGVkIHBhY2thZ2UgdmVyc2lvblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi45My4zJ1xuIiwgImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1ZFUlNJT04gPSBgcmVhbHRpbWUtanMvJHt2ZXJzaW9ufWBcblxuZXhwb3J0IGNvbnN0IFZTTl8xXzBfMDogc3RyaW5nID0gJzEuMC4wJ1xuZXhwb3J0IGNvbnN0IFZTTl8yXzBfMDogc3RyaW5nID0gJzIuMC4wJ1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVlNOOiBzdHJpbmcgPSBWU05fMl8wXzBcblxuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSB2ZXJzaW9uXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RJTUVPVVQgPSAxMDAwMFxuXG5leHBvcnQgY29uc3QgV1NfQ0xPU0VfTk9STUFMID0gMTAwMFxuZXhwb3J0IGNvbnN0IE1BWF9QVVNIX0JVRkZFUl9TSVpFID0gMTAwXG5cbmV4cG9ydCBlbnVtIFNPQ0tFVF9TVEFURVMge1xuICBjb25uZWN0aW5nID0gMCxcbiAgb3BlbiA9IDEsXG4gIGNsb3NpbmcgPSAyLFxuICBjbG9zZWQgPSAzLFxufVxuXG5leHBvcnQgZW51bSBDSEFOTkVMX1NUQVRFUyB7XG4gIGNsb3NlZCA9ICdjbG9zZWQnLFxuICBlcnJvcmVkID0gJ2Vycm9yZWQnLFxuICBqb2luZWQgPSAnam9pbmVkJyxcbiAgam9pbmluZyA9ICdqb2luaW5nJyxcbiAgbGVhdmluZyA9ICdsZWF2aW5nJyxcbn1cblxuZXhwb3J0IGVudW0gQ0hBTk5FTF9FVkVOVFMge1xuICBjbG9zZSA9ICdwaHhfY2xvc2UnLFxuICBlcnJvciA9ICdwaHhfZXJyb3InLFxuICBqb2luID0gJ3BoeF9qb2luJyxcbiAgcmVwbHkgPSAncGh4X3JlcGx5JyxcbiAgbGVhdmUgPSAncGh4X2xlYXZlJyxcbiAgYWNjZXNzX3Rva2VuID0gJ2FjY2Vzc190b2tlbicsXG59XG5cbmV4cG9ydCBlbnVtIFRSQU5TUE9SVFMge1xuICB3ZWJzb2NrZXQgPSAnd2Vic29ja2V0Jyxcbn1cblxuZXhwb3J0IGVudW0gQ09OTkVDVElPTl9TVEFURSB7XG4gIENvbm5lY3RpbmcgPSAnY29ubmVjdGluZycsXG4gIE9wZW4gPSAnb3BlbicsXG4gIENsb3NpbmcgPSAnY2xvc2luZycsXG4gIENsb3NlZCA9ICdjbG9zZWQnLFxufVxuIiwgIi8vIFRoaXMgZmlsZSBkcmF3cyBoZWF2aWx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9jb21taXQvY2YwOThlOWNmN2E0NGVlNjQ3OWQzMWQ5MTFhOTdkM2M3NDMwYzZmZVxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG5leHBvcnQgdHlwZSBNc2c8VD4gPSB7XG4gIGpvaW5fcmVmPzogc3RyaW5nIHwgbnVsbFxuICByZWY/OiBzdHJpbmcgfCBudWxsXG4gIHRvcGljOiBzdHJpbmdcbiAgZXZlbnQ6IHN0cmluZ1xuICBwYXlsb2FkOiBUXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcmlhbGl6ZXIge1xuICBIRUFERVJfTEVOR1RIID0gMVxuICBVU0VSX0JST0FEQ0FTVF9QVVNIX01FVEFfTEVOR1RIID0gNlxuICBLSU5EUyA9IHsgdXNlckJyb2FkY2FzdFB1c2g6IDMsIHVzZXJCcm9hZGNhc3Q6IDQgfVxuICBCSU5BUllfRU5DT0RJTkcgPSAwXG4gIEpTT05fRU5DT0RJTkcgPSAxXG4gIEJST0FEQ0FTVF9FVkVOVCA9ICdicm9hZGNhc3QnXG5cbiAgYWxsb3dlZE1ldGFkYXRhS2V5czogc3RyaW5nW10gPSBbXVxuXG4gIGNvbnN0cnVjdG9yKGFsbG93ZWRNZXRhZGF0YUtleXM/OiBzdHJpbmdbXSB8IG51bGwpIHtcbiAgICB0aGlzLmFsbG93ZWRNZXRhZGF0YUtleXMgPSBhbGxvd2VkTWV0YWRhdGFLZXlzID8/IFtdXG4gIH1cblxuICBlbmNvZGUobXNnOiBNc2c8eyBba2V5OiBzdHJpbmddOiBhbnkgfT4sIGNhbGxiYWNrOiAocmVzdWx0OiBBcnJheUJ1ZmZlciB8IHN0cmluZykgPT4gYW55KSB7XG4gICAgaWYgKFxuICAgICAgbXNnLmV2ZW50ID09PSB0aGlzLkJST0FEQ0FTVF9FVkVOVCAmJlxuICAgICAgIShtc2cucGF5bG9hZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJlxuICAgICAgdHlwZW9mIG1zZy5wYXlsb2FkLmV2ZW50ID09PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKFxuICAgICAgICB0aGlzLl9iaW5hcnlFbmNvZGVVc2VyQnJvYWRjYXN0UHVzaChtc2cgYXMgTXNnPHsgZXZlbnQ6IHN0cmluZyB9ICYgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4pXG4gICAgICApXG4gICAgfVxuXG4gICAgbGV0IHBheWxvYWQgPSBbbXNnLmpvaW5fcmVmLCBtc2cucmVmLCBtc2cudG9waWMsIG1zZy5ldmVudCwgbXNnLnBheWxvYWRdXG4gICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICB9XG5cbiAgcHJpdmF0ZSBfYmluYXJ5RW5jb2RlVXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZTogTXNnPHsgZXZlbnQ6IHN0cmluZyB9ICYgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4pIHtcbiAgICBpZiAodGhpcy5faXNBcnJheUJ1ZmZlcihtZXNzYWdlLnBheWxvYWQ/LnBheWxvYWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5jb2RlQmluYXJ5VXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZUpzb25Vc2VyQnJvYWRjYXN0UHVzaChtZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2VuY29kZUJpbmFyeVVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2U6IE1zZzx7IGV2ZW50OiBzdHJpbmcgfSAmIHsgW2tleTogc3RyaW5nXTogYW55IH0+KSB7XG4gICAgY29uc3QgdXNlclBheWxvYWQgPSBtZXNzYWdlLnBheWxvYWQ/LnBheWxvYWQgPz8gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2UsIHRoaXMuQklOQVJZX0VOQ09ESU5HLCB1c2VyUGF5bG9hZClcbiAgfVxuXG4gIHByaXZhdGUgX2VuY29kZUpzb25Vc2VyQnJvYWRjYXN0UHVzaChtZXNzYWdlOiBNc2c8eyBldmVudDogc3RyaW5nIH0gJiB7IFtrZXk6IHN0cmluZ106IGFueSB9Pikge1xuICAgIGNvbnN0IHVzZXJQYXlsb2FkID0gbWVzc2FnZS5wYXlsb2FkPy5wYXlsb2FkID8/IHt9XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG4gICAgY29uc3QgZW5jb2RlZFVzZXJQYXlsb2FkID0gZW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkodXNlclBheWxvYWQpKS5idWZmZXJcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlVXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSwgdGhpcy5KU09OX0VOQ09ESU5HLCBlbmNvZGVkVXNlclBheWxvYWQpXG4gIH1cblxuICBwcml2YXRlIF9lbmNvZGVVc2VyQnJvYWRjYXN0UHVzaChcbiAgICBtZXNzYWdlOiBNc2c8eyBldmVudDogc3RyaW5nIH0gJiB7IFtrZXk6IHN0cmluZ106IGFueSB9PixcbiAgICBlbmNvZGluZ1R5cGU6IG51bWJlcixcbiAgICBlbmNvZGVkUGF5bG9hZDogQXJyYXlCdWZmZXJcbiAgKSB7XG4gICAgY29uc3QgdG9waWMgPSBtZXNzYWdlLnRvcGljXG4gICAgY29uc3QgcmVmID0gbWVzc2FnZS5yZWYgPz8gJydcbiAgICBjb25zdCBqb2luUmVmID0gbWVzc2FnZS5qb2luX3JlZiA/PyAnJ1xuICAgIGNvbnN0IHVzZXJFdmVudCA9IG1lc3NhZ2UucGF5bG9hZC5ldmVudFxuXG4gICAgLy8gRmlsdGVyIG1ldGFkYXRhIGJhc2VkIG9uIGFsbG93ZWQga2V5c1xuICAgIGNvbnN0IHJlc3QgPSB0aGlzLmFsbG93ZWRNZXRhZGF0YUtleXNcbiAgICAgID8gdGhpcy5fcGljayhtZXNzYWdlLnBheWxvYWQsIHRoaXMuYWxsb3dlZE1ldGFkYXRhS2V5cylcbiAgICAgIDoge31cblxuICAgIGNvbnN0IG1ldGFkYXRhID0gT2JqZWN0LmtleXMocmVzdCkubGVuZ3RoID09PSAwID8gJycgOiBKU09OLnN0cmluZ2lmeShyZXN0KVxuXG4gICAgLy8gVmFsaWRhdGUgbGVuZ3RocyBkb24ndCBleGNlZWQgdWludDggbWF4IHZhbHVlICgyNTUpXG4gICAgaWYgKGpvaW5SZWYubGVuZ3RoID4gMjU1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW5SZWYgbGVuZ3RoICR7am9pblJlZi5sZW5ndGh9IGV4Y2VlZHMgbWF4aW11bSBvZiAyNTVgKVxuICAgIH1cbiAgICBpZiAocmVmLmxlbmd0aCA+IDI1NSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGByZWYgbGVuZ3RoICR7cmVmLmxlbmd0aH0gZXhjZWVkcyBtYXhpbXVtIG9mIDI1NWApXG4gICAgfVxuICAgIGlmICh0b3BpYy5sZW5ndGggPiAyNTUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdG9waWMgbGVuZ3RoICR7dG9waWMubGVuZ3RofSBleGNlZWRzIG1heGltdW0gb2YgMjU1YClcbiAgICB9XG4gICAgaWYgKHVzZXJFdmVudC5sZW5ndGggPiAyNTUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdXNlckV2ZW50IGxlbmd0aCAke3VzZXJFdmVudC5sZW5ndGh9IGV4Y2VlZHMgbWF4aW11bSBvZiAyNTVgKVxuICAgIH1cbiAgICBpZiAobWV0YWRhdGEubGVuZ3RoID4gMjU1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG1ldGFkYXRhIGxlbmd0aCAke21ldGFkYXRhLmxlbmd0aH0gZXhjZWVkcyBtYXhpbXVtIG9mIDI1NWApXG4gICAgfVxuXG4gICAgY29uc3QgbWV0YUxlbmd0aCA9XG4gICAgICB0aGlzLlVTRVJfQlJPQURDQVNUX1BVU0hfTUVUQV9MRU5HVEggK1xuICAgICAgam9pblJlZi5sZW5ndGggK1xuICAgICAgcmVmLmxlbmd0aCArXG4gICAgICB0b3BpYy5sZW5ndGggK1xuICAgICAgdXNlckV2ZW50Lmxlbmd0aCArXG4gICAgICBtZXRhZGF0YS5sZW5ndGhcblxuICAgIGNvbnN0IGhlYWRlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEggKyBtZXRhTGVuZ3RoKVxuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGhlYWRlcilcbiAgICBsZXQgb2Zmc2V0ID0gMFxuXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdGhpcy5LSU5EUy51c2VyQnJvYWRjYXN0UHVzaCkgLy8ga2luZFxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGpvaW5SZWYubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHJlZi5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdG9waWMubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHVzZXJFdmVudC5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgbWV0YWRhdGEubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGVuY29kaW5nVHlwZSlcbiAgICBBcnJheS5mcm9tKGpvaW5SZWYsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20ocmVmLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKHRvcGljLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKHVzZXJFdmVudCwgKGNoYXIpID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbShtZXRhZGF0YSwgKGNoYXIpID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG5cbiAgICB2YXIgY29tYmluZWQgPSBuZXcgVWludDhBcnJheShoZWFkZXIuYnl0ZUxlbmd0aCArIGVuY29kZWRQYXlsb2FkLmJ5dGVMZW5ndGgpXG4gICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KGhlYWRlciksIDApXG4gICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KGVuY29kZWRQYXlsb2FkKSwgaGVhZGVyLmJ5dGVMZW5ndGgpXG5cbiAgICByZXR1cm4gY29tYmluZWQuYnVmZmVyXG4gIH1cblxuICBkZWNvZGUocmF3UGF5bG9hZDogQXJyYXlCdWZmZXIgfCBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIGlmICh0aGlzLl9pc0FycmF5QnVmZmVyKHJhd1BheWxvYWQpKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQgYXMgQXJyYXlCdWZmZXIpXG4gICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmF3UGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGpzb25QYXlsb2FkID0gSlNPTi5wYXJzZShyYXdQYXlsb2FkKVxuICAgICAgY29uc3QgW2pvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZF0gPSBqc29uUGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKHsgam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHt9KVxuICB9XG5cbiAgcHJpdmF0ZSBfYmluYXJ5RGVjb2RlKGJ1ZmZlcjogQXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcilcbiAgICBjb25zdCBraW5kID0gdmlldy5nZXRVaW50OCgwKVxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSB0aGlzLktJTkRTLnVzZXJCcm9hZGNhc3Q6XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVVc2VyQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9kZWNvZGVVc2VyQnJvYWRjYXN0KFxuICAgIGJ1ZmZlcjogQXJyYXlCdWZmZXIsXG4gICAgdmlldzogRGF0YVZpZXcsXG4gICAgZGVjb2RlcjogVGV4dERlY29kZXJcbiAgKToge1xuICAgIGpvaW5fcmVmOiBudWxsXG4gICAgcmVmOiBudWxsXG4gICAgdG9waWM6IHN0cmluZ1xuICAgIGV2ZW50OiBzdHJpbmdcbiAgICBwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIH0ge1xuICAgIGNvbnN0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBjb25zdCB1c2VyRXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGNvbnN0IG1ldGFkYXRhU2l6ZSA9IHZpZXcuZ2V0VWludDgoMylcbiAgICBjb25zdCBwYXlsb2FkRW5jb2RpbmcgPSB2aWV3LmdldFVpbnQ4KDQpXG5cbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgNFxuICAgIGNvbnN0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBjb25zdCB1c2VyRXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB1c2VyRXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB1c2VyRXZlbnRTaXplXG4gICAgY29uc3QgbWV0YWRhdGEgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBtZXRhZGF0YVNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIG1ldGFkYXRhU2l6ZVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgIGNvbnN0IHBhcnNlZFBheWxvYWQgPVxuICAgICAgcGF5bG9hZEVuY29kaW5nID09PSB0aGlzLkpTT05fRU5DT0RJTkcgPyBKU09OLnBhcnNlKGRlY29kZXIuZGVjb2RlKHBheWxvYWQpKSA6IHBheWxvYWRcblxuICAgIGNvbnN0IGRhdGE6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7XG4gICAgICB0eXBlOiB0aGlzLkJST0FEQ0FTVF9FVkVOVCxcbiAgICAgIGV2ZW50OiB1c2VyRXZlbnQsXG4gICAgICBwYXlsb2FkOiBwYXJzZWRQYXlsb2FkLFxuICAgIH1cblxuICAgIC8vIE1ldGFkYXRhIGlzIG9wdGlvbmFsIGFuZCBhbHdheXMgSlNPTiBlbmNvZGVkXG4gICAgaWYgKG1ldGFkYXRhU2l6ZSA+IDApIHtcbiAgICAgIGRhdGFbJ21ldGEnXSA9IEpTT04ucGFyc2UobWV0YWRhdGEpXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgam9pbl9yZWY6IG51bGwsIHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogdGhpcy5CUk9BRENBU1RfRVZFTlQsIHBheWxvYWQ6IGRhdGEgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaXNBcnJheUJ1ZmZlcihidWZmZXI6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBidWZmZXI/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnQXJyYXlCdWZmZXInXG4gIH1cblxuICBwcml2YXRlIF9waWNrKG9iajogUmVjb3JkPHN0cmluZywgYW55PiB8IG51bGwgfCB1bmRlZmluZWQsIGtleXM6IHN0cmluZ1tdKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB7fVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9iaikuZmlsdGVyKChba2V5XSkgPT4ga2V5cy5pbmNsdWRlcyhrZXkpKSlcbiAgfVxufVxuIiwgIi8qKlxuICogQ3JlYXRlcyBhIHRpbWVyIHRoYXQgYWNjZXB0cyBhIGB0aW1lckNhbGNgIGZ1bmN0aW9uIHRvIHBlcmZvcm0gY2FsY3VsYXRlZCB0aW1lb3V0IHJldHJpZXMsIHN1Y2ggYXMgZXhwb25lbnRpYWwgYmFja29mZi5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgbGV0IHJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHRoaXMuY29ubmVjdCgpLCBmdW5jdGlvbih0cmllcyl7XG4gKiAgICAgIHJldHVybiBbMTAwMCwgNTAwMCwgMTAwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAqICAgIH0pXG4gKiAgICByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKiAgICByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciA1MDAwXG4gKiAgICByZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gKiAgICByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVyIHtcbiAgdGltZXI6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICB0cmllczogbnVtYmVyID0gMFxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjYWxsYmFjazogRnVuY3Rpb24sXG4gICAgcHVibGljIHRpbWVyQ2FsYzogRnVuY3Rpb25cbiAgKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy50aW1lckNhbGMgPSB0aW1lckNhbGNcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMudHJpZXMgPSAwXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpXG4gICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gQ2FuY2VscyBhbnkgcHJldmlvdXMgc2NoZWR1bGVUaW1lb3V0IGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAgc2NoZWR1bGVUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuXG4gICAgdGhpcy50aW1lciA9IDxhbnk+c2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxXG4gICAgICAgIHRoaXMuY2FsbGJhY2soKVxuICAgICAgfSxcbiAgICAgIHRoaXMudGltZXJDYWxjKHRoaXMudHJpZXMgKyAxKVxuICAgIClcbiAgfVxufVxuIiwgIi8qKlxuICogSGVscGVycyB0byBjb252ZXJ0IHRoZSBjaGFuZ2UgUGF5bG9hZCBpbnRvIG5hdGl2ZSBKUyB0eXBlcy5cbiAqL1xuXG4vLyBBZGFwdGVkIGZyb20gZXBnc3FsIChzcmMvZXBnc3FsX2JpbmFyeS5lcmwpLCB0aGlzIG1vZHVsZSBsaWNlbnNlZCB1bmRlclxuLy8gMy1jbGF1c2UgQlNEIGZvdW5kIGhlcmU6IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lcGdzcWwvZXBnc3FsL2RldmVsL0xJQ0VOU0VcblxuZXhwb3J0IGVudW0gUG9zdGdyZXNUeXBlcyB7XG4gIGFic3RpbWUgPSAnYWJzdGltZScsXG4gIGJvb2wgPSAnYm9vbCcsXG4gIGRhdGUgPSAnZGF0ZScsXG4gIGRhdGVyYW5nZSA9ICdkYXRlcmFuZ2UnLFxuICBmbG9hdDQgPSAnZmxvYXQ0JyxcbiAgZmxvYXQ4ID0gJ2Zsb2F0OCcsXG4gIGludDIgPSAnaW50MicsXG4gIGludDQgPSAnaW50NCcsXG4gIGludDRyYW5nZSA9ICdpbnQ0cmFuZ2UnLFxuICBpbnQ4ID0gJ2ludDgnLFxuICBpbnQ4cmFuZ2UgPSAnaW50OHJhbmdlJyxcbiAganNvbiA9ICdqc29uJyxcbiAganNvbmIgPSAnanNvbmInLFxuICBtb25leSA9ICdtb25leScsXG4gIG51bWVyaWMgPSAnbnVtZXJpYycsXG4gIG9pZCA9ICdvaWQnLFxuICByZWx0aW1lID0gJ3JlbHRpbWUnLFxuICB0ZXh0ID0gJ3RleHQnLFxuICB0aW1lID0gJ3RpbWUnLFxuICB0aW1lc3RhbXAgPSAndGltZXN0YW1wJyxcbiAgdGltZXN0YW1wdHogPSAndGltZXN0YW1wdHonLFxuICB0aW1ldHogPSAndGltZXR6JyxcbiAgdHNyYW5nZSA9ICd0c3JhbmdlJyxcbiAgdHN0enJhbmdlID0gJ3RzdHpyYW5nZScsXG59XG5cbnR5cGUgQ29sdW1ucyA9IHtcbiAgbmFtZTogc3RyaW5nIC8vIHRoZSBjb2x1bW4gbmFtZS4gZWc6IFwidXNlcl9pZFwiXG4gIHR5cGU6IHN0cmluZyAvLyB0aGUgY29sdW1uIHR5cGUuIGVnOiBcInV1aWRcIlxuICBmbGFncz86IHN0cmluZ1tdIC8vIGFueSBzcGVjaWFsIGZsYWdzIGZvciB0aGUgY29sdW1uLiBlZzogW1wia2V5XCJdXG4gIHR5cGVfbW9kaWZpZXI/OiBudW1iZXIgLy8gdGhlIHR5cGUgbW9kaWZpZXIuIGVnOiA0Mjk0OTY3Mjk1XG59W11cblxudHlwZSBCYXNlVmFsdWUgPSBudWxsIHwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhblxudHlwZSBSZWNvcmRWYWx1ZSA9IEJhc2VWYWx1ZSB8IEJhc2VWYWx1ZVtdXG5cbnR5cGUgUmVjb3JkID0ge1xuICBba2V5OiBzdHJpbmddOiBSZWNvcmRWYWx1ZVxufVxuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIGNvbHVtbnMgYW5kIGFuIG9iamVjdCBvZiBzdHJpbmcgdmFsdWVzIHRoZW4gY29udmVydHMgZWFjaCBzdHJpbmcgdmFsdWVcbiAqIHRvIGl0cyBtYXBwZWQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3tuYW1lOiBTdHJpbmcsIHR5cGU6IFN0cmluZ31bXX0gY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG1hcCBvZiB2YXJpb3VzIG9wdGlvbnMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgbWFwcGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLnNraXBUeXBlcyBUaGUgYXJyYXkgb2YgdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbnZlcnRlZFxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDaGFuZ2VEYXRhKFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6JzMzJ30sIHt9KVxuICogLy89PnsgZmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6IDMzIH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDaGFuZ2VEYXRhID0gKFxuICBjb2x1bW5zOiBDb2x1bW5zLFxuICByZWNvcmQ6IFJlY29yZCB8IG51bGwsXG4gIG9wdGlvbnM6IHsgc2tpcFR5cGVzPzogc3RyaW5nW10gfSA9IHt9XG4pOiBSZWNvcmQgPT4ge1xuICBjb25zdCBza2lwVHlwZXMgPSBvcHRpb25zLnNraXBUeXBlcyA/PyBbXVxuXG4gIGlmICghcmVjb3JkKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMocmVjb3JkKS5yZWR1Y2UoKGFjYywgcmVjX2tleSkgPT4ge1xuICAgIGFjY1tyZWNfa2V5XSA9IGNvbnZlcnRDb2x1bW4ocmVjX2tleSwgY29sdW1ucywgcmVjb3JkLCBza2lwVHlwZXMpXG4gICAgcmV0dXJuIGFjY1xuICB9LCB7fSBhcyBSZWNvcmQpXG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHZhbHVlIG9mIGFuIGluZGl2aWR1YWwgY29sdW1uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5OYW1lIFRoZSBjb2x1bW4gdGhhdCB5b3Ugd2FudCB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3tuYW1lOiBTdHJpbmcsIHR5cGU6IFN0cmluZ31bXX0gY29sdW1ucyBBbGwgb2YgdGhlIGNvbHVtbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQgVGhlIG1hcCBvZiBzdHJpbmcgdmFsdWVzXG4gKiBAcGFyYW0ge0FycmF5fSBza2lwVHlwZXMgQW4gYXJyYXkgb2YgdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbnZlcnRlZFxuICogQHJldHVybiB7b2JqZWN0fSBVc2VsZXNzIGluZm9ybWF0aW9uXG4gKlxuICogQGV4YW1wbGUgY29udmVydENvbHVtbignYWdlJywgW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogJzMzJ30sIFtdKVxuICogLy89PiAzM1xuICogQGV4YW1wbGUgY29udmVydENvbHVtbignYWdlJywgW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogJzMzJ30sIFsnaW50NCddKVxuICogLy89PiBcIjMzXCJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDb2x1bW4gPSAoXG4gIGNvbHVtbk5hbWU6IHN0cmluZyxcbiAgY29sdW1uczogQ29sdW1ucyxcbiAgcmVjb3JkOiBSZWNvcmQsXG4gIHNraXBUeXBlczogc3RyaW5nW11cbik6IFJlY29yZFZhbHVlID0+IHtcbiAgY29uc3QgY29sdW1uID0gY29sdW1ucy5maW5kKCh4KSA9PiB4Lm5hbWUgPT09IGNvbHVtbk5hbWUpXG4gIGNvbnN0IGNvbFR5cGUgPSBjb2x1bW4/LnR5cGVcbiAgY29uc3QgdmFsdWUgPSByZWNvcmRbY29sdW1uTmFtZV1cblxuICBpZiAoY29sVHlwZSAmJiAhc2tpcFR5cGVzLmluY2x1ZGVzKGNvbFR5cGUpKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRDZWxsKGNvbFR5cGUsIHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIG5vb3AodmFsdWUpXG59XG5cbi8qKlxuICogSWYgdGhlIHZhbHVlIG9mIHRoZSBjZWxsIGlzIGBudWxsYCwgcmV0dXJucyBudWxsLlxuICogT3RoZXJ3aXNlIGNvbnZlcnRzIHRoZSBzdHJpbmcgdmFsdWUgdG8gdGhlIGNvcnJlY3QgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgcG9zdGdyZXMgY29sdW1uIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgY2VsbCB2YWx1ZVxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdib29sJywgJ3QnKVxuICogLy89PiB0cnVlXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnaW50OCcsICcxMCcpXG4gKiAvLz0+IDEwXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnX2ludDQnLCAnezEsMiwzLDR9JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0Q2VsbCA9ICh0eXBlOiBzdHJpbmcsIHZhbHVlOiBSZWNvcmRWYWx1ZSk6IFJlY29yZFZhbHVlID0+IHtcbiAgLy8gaWYgZGF0YSB0eXBlIGlzIGFuIGFycmF5XG4gIGlmICh0eXBlLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0eXBlLnNsaWNlKDEsIHR5cGUubGVuZ3RoKVxuICAgIHJldHVybiB0b0FycmF5KHZhbHVlLCBkYXRhVHlwZSlcbiAgfVxuXG4gIC8vIElmIG5vdCBudWxsLCBjb252ZXJ0IHRvIGNvcnJlY3QgdHlwZS5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmJvb2w6XG4gICAgICByZXR1cm4gdG9Cb29sZWFuKHZhbHVlKVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDQ6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmZsb2F0ODpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50MjpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NDpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50ODpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMubnVtZXJpYzpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMub2lkOlxuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uYjpcbiAgICAgIHJldHVybiB0b0pzb24odmFsdWUpXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWVzdGFtcDpcbiAgICAgIHJldHVybiB0b1RpbWVzdGFtcFN0cmluZyh2YWx1ZSkgLy8gRm9ybWF0IHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBQb3N0Z1JFU1RcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuYWJzdGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5kYXRlOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGVyYW5nZTpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NHJhbmdlOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ4cmFuZ2U6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm1vbmV5OlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5yZWx0aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRleHQ6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXN0YW1wdHo6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXR6OiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRzcmFuZ2U6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRzdHpyYW5nZTpcbiAgICAgIHJldHVybiBub29wKHZhbHVlKVxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciByZW1haW5pbmcgdHlwZXNcbiAgICAgIHJldHVybiBub29wKHZhbHVlKVxuICB9XG59XG5cbmNvbnN0IG5vb3AgPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICByZXR1cm4gdmFsdWVcbn1cbmV4cG9ydCBjb25zdCB0b0Jvb2xlYW4gPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSAndCc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGNhc2UgJ2YnOlxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG5leHBvcnQgY29uc3QgdG9OdW1iZXIgPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSlcbiAgICBpZiAoIU51bWJlci5pc05hTihwYXJzZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZWRWYWx1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cbmV4cG9ydCBjb25zdCB0b0pzb24gPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBvc3RncmVzIEFycmF5IGludG8gYSBuYXRpdmUgSlMgYXJyYXlcbiAqXG4gKiBAZXhhbXBsZSB0b0FycmF5KCd7fScsICdpbnQ0JylcbiAqIC8vPT4gW11cbiAqIEBleGFtcGxlIHRvQXJyYXkoJ3tcIlsyMDIxLTAxLTAxLDIwMjEtMTItMzEpXCIsXCIoMjAyMS0wMS0wMSwyMDIxLTEyLTMyXVwifScsICdkYXRlcmFuZ2UnKVxuICogLy89PiBbJ1syMDIxLTAxLTAxLDIwMjEtMTItMzEpJywgJygyMDIxLTAxLTAxLDIwMjEtMTItMzJdJ11cbiAqIEBleGFtcGxlIHRvQXJyYXkoWzEsMiwzLDRdLCAnaW50NCcpXG4gKiAvLz0+IFsxLDIsMyw0XVxuICovXG5leHBvcnQgY29uc3QgdG9BcnJheSA9ICh2YWx1ZTogUmVjb3JkVmFsdWUsIHR5cGU6IHN0cmluZyk6IFJlY29yZFZhbHVlID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGNvbnN0IGxhc3RJZHggPSB2YWx1ZS5sZW5ndGggLSAxXG4gIGNvbnN0IGNsb3NlQnJhY2UgPSB2YWx1ZVtsYXN0SWR4XVxuICBjb25zdCBvcGVuQnJhY2UgPSB2YWx1ZVswXVxuXG4gIC8vIENvbmZpcm0gdmFsdWUgaXMgYSBQb3N0Z3JlcyBhcnJheSBieSBjaGVja2luZyBjdXJseSBicmFja2V0c1xuICBpZiAob3BlbkJyYWNlID09PSAneycgJiYgY2xvc2VCcmFjZSA9PT0gJ30nKSB7XG4gICAgbGV0IGFyclxuICAgIGNvbnN0IHZhbFRyaW0gPSB2YWx1ZS5zbGljZSgxLCBsYXN0SWR4KVxuXG4gICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbiB0byBzZXBhcmF0ZSBQb3N0Z3JlcyBhcnJheSBkYXRhXG4gICAgdHJ5IHtcbiAgICAgIGFyciA9IEpTT04ucGFyc2UoJ1snICsgdmFsVHJpbSArICddJylcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAvLyBXQVJOSU5HOiBzcGxpdHRpbmcgb24gY29tbWEgZG9lcyBub3QgY292ZXIgYWxsIGVkZ2UgY2FzZXNcbiAgICAgIGFyciA9IHZhbFRyaW0gPyB2YWxUcmltLnNwbGl0KCcsJykgOiBbXVxuICAgIH1cblxuICAgIHJldHVybiBhcnIubWFwKCh2YWw6IEJhc2VWYWx1ZSkgPT4gY29udmVydENlbGwodHlwZSwgdmFsKSlcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEZpeGVzIHRpbWVzdGFtcCB0byBiZSBJU08tODYwMS4gU3dhcHMgdGhlIHNwYWNlIGJldHdlZW4gdGhlIGRhdGUgYW5kIHRpbWUgZm9yIGEgJ1QnXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3N1cGFiYXNlL2lzc3Vlcy8xOFxuICpcbiAqIEBleGFtcGxlIHRvVGltZXN0YW1wU3RyaW5nKCcyMDE5LTA5LTEwIDAwOjAwOjAwJylcbiAqIC8vPT4gJzIwMTktMDktMTBUMDA6MDA6MDAnXG4gKi9cbmV4cG9ydCBjb25zdCB0b1RpbWVzdGFtcFN0cmluZyA9ICh2YWx1ZTogUmVjb3JkVmFsdWUpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoJyAnLCAnVCcpXG4gIH1cblxuICByZXR1cm4gdmFsdWVcbn1cblxuZXhwb3J0IGNvbnN0IGh0dHBFbmRwb2ludFVSTCA9IChzb2NrZXRVcmw6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHdzVXJsID0gbmV3IFVSTChzb2NrZXRVcmwpXG5cbiAgd3NVcmwucHJvdG9jb2wgPSB3c1VybC5wcm90b2NvbC5yZXBsYWNlKC9ed3MvaSwgJ2h0dHAnKVxuXG4gIHdzVXJsLnBhdGhuYW1lID0gd3NVcmwucGF0aG5hbWVcbiAgICAucmVwbGFjZSgvXFwvKyQvLCAnJykgLy8gcmVtb3ZlIGFsbCB0cmFpbGluZyBzbGFzaGVzXG4gICAgLnJlcGxhY2UoL1xcL3NvY2tldFxcL3dlYnNvY2tldCQvaSwgJycpIC8vIHJlbW92ZSB0aGUgc29ja2V0L3dlYnNvY2tldCBwYXRoXG4gICAgLnJlcGxhY2UoL1xcL3NvY2tldCQvaSwgJycpIC8vIHJlbW92ZSB0aGUgc29ja2V0IHBhdGhcbiAgICAucmVwbGFjZSgvXFwvd2Vic29ja2V0JC9pLCAnJykgLy8gcmVtb3ZlIHRoZSB3ZWJzb2NrZXQgcGF0aFxuXG4gIGlmICh3c1VybC5wYXRobmFtZSA9PT0gJycgfHwgd3NVcmwucGF0aG5hbWUgPT09ICcvJykge1xuICAgIHdzVXJsLnBhdGhuYW1lID0gJy9hcGkvYnJvYWRjYXN0J1xuICB9IGVsc2Uge1xuICAgIHdzVXJsLnBhdGhuYW1lID0gd3NVcmwucGF0aG5hbWUgKyAnL2FwaS9icm9hZGNhc3QnXG4gIH1cblxuICByZXR1cm4gd3NVcmwuaHJlZlxufVxuIiwgImltcG9ydCB7IERFRkFVTFRfVElNRU9VVCB9IGZyb20gJy4uL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgdHlwZSBSZWFsdGltZUNoYW5uZWwgZnJvbSAnLi4vUmVhbHRpbWVDaGFubmVsJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXNoIHtcbiAgc2VudDogYm9vbGVhbiA9IGZhbHNlXG4gIHRpbWVvdXRUaW1lcjogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gIHJlZjogc3RyaW5nID0gJydcbiAgcmVjZWl2ZWRSZXNwOiB7XG4gICAgc3RhdHVzOiBzdHJpbmdcbiAgICByZXNwb25zZTogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICB9IHwgbnVsbCA9IG51bGxcbiAgcmVjSG9va3M6IHtcbiAgICBzdGF0dXM6IHN0cmluZ1xuICAgIGNhbGxiYWNrOiBGdW5jdGlvblxuICB9W10gPSBbXVxuICByZWZFdmVudDogc3RyaW5nIHwgbnVsbCA9IG51bGxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAgICpcbiAgICogQHBhcmFtIGNoYW5uZWwgVGhlIENoYW5uZWxcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCwgZm9yIGV4YW1wbGUgYFwicGh4X2pvaW5cImBcbiAgICogQHBhcmFtIHBheWxvYWQgVGhlIHBheWxvYWQsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogMTIzfWBcbiAgICogQHBhcmFtIHRpbWVvdXQgVGhlIHB1c2ggdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwsXG4gICAgcHVibGljIGV2ZW50OiBzdHJpbmcsXG4gICAgcHVibGljIHBheWxvYWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fSxcbiAgICBwdWJsaWMgdGltZW91dDogbnVtYmVyID0gREVGQVVMVF9USU1FT1VUXG4gICkge31cblxuICByZXNlbmQodGltZW91dDogbnVtYmVyKSB7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KClcbiAgICB0aGlzLnJlZiA9ICcnXG4gICAgdGhpcy5yZWZFdmVudCA9IG51bGxcbiAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGxcbiAgICB0aGlzLnNlbnQgPSBmYWxzZVxuICAgIHRoaXMuc2VuZCgpXG4gIH1cblxuICBzZW5kKCkge1xuICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZCgndGltZW91dCcpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5zdGFydFRpbWVvdXQoKVxuICAgIHRoaXMuc2VudCA9IHRydWVcbiAgICB0aGlzLmNoYW5uZWwuc29ja2V0LnB1c2goe1xuICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgcGF5bG9hZDogdGhpcy5wYXlsb2FkLFxuICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgIGpvaW5fcmVmOiB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKSxcbiAgICB9KVxuICB9XG5cbiAgdXBkYXRlUGF5bG9hZChwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogdm9pZCB7XG4gICAgdGhpcy5wYXlsb2FkID0geyAuLi50aGlzLnBheWxvYWQsIC4uLnBheWxvYWQgfVxuICB9XG5cbiAgcmVjZWl2ZShzdGF0dXM6IHN0cmluZywgY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX2hhc1JlY2VpdmVkKHN0YXR1cykpIHtcbiAgICAgIGNhbGxiYWNrKHRoaXMucmVjZWl2ZWRSZXNwPy5yZXNwb25zZSlcbiAgICB9XG5cbiAgICB0aGlzLnJlY0hvb2tzLnB1c2goeyBzdGF0dXMsIGNhbGxiYWNrIH0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0VGltZW91dCgpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0VGltZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQuX21ha2VSZWYoKVxuICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwuX3JlcGx5RXZlbnROYW1lKHRoaXMucmVmKVxuXG4gICAgY29uc3QgY2FsbGJhY2sgPSAocGF5bG9hZDogYW55KSA9PiB7XG4gICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpXG4gICAgICB0aGlzLl9jYW5jZWxUaW1lb3V0KClcbiAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gcGF5bG9hZFxuICAgICAgdGhpcy5fbWF0Y2hSZWNlaXZlKHBheWxvYWQpXG4gICAgfVxuXG4gICAgdGhpcy5jaGFubmVsLl9vbih0aGlzLnJlZkV2ZW50LCB7fSwgY2FsbGJhY2spXG5cbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IDxhbnk+c2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3RpbWVvdXQnLCB7fSlcbiAgICB9LCB0aGlzLnRpbWVvdXQpXG4gIH1cblxuICB0cmlnZ2VyKHN0YXR1czogc3RyaW5nLCByZXNwb25zZTogYW55KSB7XG4gICAgaWYgKHRoaXMucmVmRXZlbnQpIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcih0aGlzLnJlZkV2ZW50LCB7IHN0YXR1cywgcmVzcG9uc2UgfSlcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKVxuICAgIHRoaXMuX2NhbmNlbFRpbWVvdXQoKVxuICB9XG5cbiAgcHJpdmF0ZSBfY2FuY2VsUmVmRXZlbnQoKSB7XG4gICAgaWYgKCF0aGlzLnJlZkV2ZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNoYW5uZWwuX29mZih0aGlzLnJlZkV2ZW50LCB7fSlcbiAgfVxuXG4gIHByaXZhdGUgX2NhbmNlbFRpbWVvdXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKVxuICAgIHRoaXMudGltZW91dFRpbWVyID0gdW5kZWZpbmVkXG4gIH1cblxuICBwcml2YXRlIF9tYXRjaFJlY2VpdmUoeyBzdGF0dXMsIHJlc3BvbnNlIH06IHsgc3RhdHVzOiBzdHJpbmc7IHJlc3BvbnNlOiBGdW5jdGlvbiB9KSB7XG4gICAgdGhpcy5yZWNIb29rcy5maWx0ZXIoKGgpID0+IGguc3RhdHVzID09PSBzdGF0dXMpLmZvckVhY2goKGgpID0+IGguY2FsbGJhY2socmVzcG9uc2UpKVxuICB9XG5cbiAgcHJpdmF0ZSBfaGFzUmVjZWl2ZWQoc3RhdHVzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXNcbiAgfVxufVxuIiwgIi8qXG4gIFRoaXMgZmlsZSBkcmF3cyBoZWF2aWx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9ibG9iL2QzNDRlYzBhNzMyYWI0ZWUyMDQyMTViMzFkZTY5Y2Y0YmU3MmUzYmYvYXNzZXRzL2pzL3Bob2VuaXgvcHJlc2VuY2UuanNcbiAgTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9ibG9iL2QzNDRlYzBhNzMyYWI0ZWUyMDQyMTViMzFkZTY5Y2Y0YmU3MmUzYmYvTElDRU5TRS5tZFxuKi9cblxuaW1wb3J0IHR5cGUgeyBQcmVzZW5jZU9wdHMsIFByZXNlbmNlT25Kb2luQ2FsbGJhY2ssIFByZXNlbmNlT25MZWF2ZUNhbGxiYWNrIH0gZnJvbSAncGhvZW5peCdcbmltcG9ydCB0eXBlIFJlYWx0aW1lQ2hhbm5lbCBmcm9tICcuL1JlYWx0aW1lQ2hhbm5lbCdcblxudHlwZSBQcmVzZW5jZTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9PiA9IHtcbiAgcHJlc2VuY2VfcmVmOiBzdHJpbmdcbn0gJiBUXG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUHJlc2VuY2VTdGF0ZTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9PiA9IHtcbiAgW2tleTogc3RyaW5nXTogUHJlc2VuY2U8VD5bXVxufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVByZXNlbmNlSm9pblBheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID0ge1xuICBldmVudDogYCR7UkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUy5KT0lOfWBcbiAga2V5OiBzdHJpbmdcbiAgY3VycmVudFByZXNlbmNlczogUHJlc2VuY2U8VD5bXVxuICBuZXdQcmVzZW5jZXM6IFByZXNlbmNlPFQ+W11cbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQcmVzZW5jZUxlYXZlUGF5bG9hZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4gPSB7XG4gIGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLkxFQVZFfWBcbiAga2V5OiBzdHJpbmdcbiAgY3VycmVudFByZXNlbmNlczogUHJlc2VuY2U8VD5bXVxuICBsZWZ0UHJlc2VuY2VzOiBQcmVzZW5jZTxUPltdXG59XG5cbmV4cG9ydCBlbnVtIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMge1xuICBTWU5DID0gJ3N5bmMnLFxuICBKT0lOID0gJ2pvaW4nLFxuICBMRUFWRSA9ICdsZWF2ZScsXG59XG5cbnR5cGUgUHJlc2VuY2VEaWZmID0ge1xuICBqb2luczogUmVhbHRpbWVQcmVzZW5jZVN0YXRlXG4gIGxlYXZlczogUmVhbHRpbWVQcmVzZW5jZVN0YXRlXG59XG5cbnR5cGUgUmF3UHJlc2VuY2VTdGF0ZSA9IHtcbiAgW2tleTogc3RyaW5nXToge1xuICAgIG1ldGFzOiB7XG4gICAgICBwaHhfcmVmPzogc3RyaW5nXG4gICAgICBwaHhfcmVmX3ByZXY/OiBzdHJpbmdcbiAgICAgIFtrZXk6IHN0cmluZ106IGFueVxuICAgIH1bXVxuICB9XG59XG5cbnR5cGUgUmF3UHJlc2VuY2VEaWZmID0ge1xuICBqb2luczogUmF3UHJlc2VuY2VTdGF0ZVxuICBsZWF2ZXM6IFJhd1ByZXNlbmNlU3RhdGVcbn1cblxudHlwZSBQcmVzZW5jZUNob29zZXI8VD4gPSAoa2V5OiBzdHJpbmcsIHByZXNlbmNlczogUHJlc2VuY2VbXSkgPT4gVFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZVByZXNlbmNlIHtcbiAgc3RhdGU6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSA9IHt9XG4gIHBlbmRpbmdEaWZmczogUmF3UHJlc2VuY2VEaWZmW10gPSBbXVxuICBqb2luUmVmOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBlbmFibGVkOiBib29sZWFuID0gZmFsc2VcbiAgY2FsbGVyOiB7XG4gICAgb25Kb2luOiBQcmVzZW5jZU9uSm9pbkNhbGxiYWNrXG4gICAgb25MZWF2ZTogUHJlc2VuY2VPbkxlYXZlQ2FsbGJhY2tcbiAgICBvblN5bmM6ICgpID0+IHZvaWRcbiAgfSA9IHtcbiAgICBvbkpvaW46ICgpID0+IHt9LFxuICAgIG9uTGVhdmU6ICgpID0+IHt9LFxuICAgIG9uU3luYzogKCkgPT4ge30sXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFByZXNlbmNlIGhlbHBlciB0aGF0IGtlZXBzIHRoZSBsb2NhbCBwcmVzZW5jZSBzdGF0ZSBpbiBzeW5jIHdpdGggdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIGNoYW5uZWwgLSBUaGUgcmVhbHRpbWUgY2hhbm5lbCB0byBiaW5kIHRvLlxuICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIGN1c3RvbSBldmVudCBuYW1lcywgZS5nLiBgeyBldmVudHM6IHsgc3RhdGU6ICdzdGF0ZScsIGRpZmY6ICdkaWZmJyB9IH1gLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBwcmVzZW5jZSA9IG5ldyBSZWFsdGltZVByZXNlbmNlKGNoYW5uZWwpXG4gICAqXG4gICAqIGNoYW5uZWwub24oJ3ByZXNlbmNlJywgKHsgZXZlbnQsIGtleSB9KSA9PiB7XG4gICAqICAgY29uc29sZS5sb2coYFByZXNlbmNlICR7ZXZlbnR9IG9uICR7a2V5fWApXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCxcbiAgICBvcHRzPzogUHJlc2VuY2VPcHRzXG4gICkge1xuICAgIGNvbnN0IGV2ZW50cyA9IG9wdHM/LmV2ZW50cyB8fCB7XG4gICAgICBzdGF0ZTogJ3ByZXNlbmNlX3N0YXRlJyxcbiAgICAgIGRpZmY6ICdwcmVzZW5jZV9kaWZmJyxcbiAgICB9XG5cbiAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5zdGF0ZSwge30sIChuZXdTdGF0ZTogUmF3UHJlc2VuY2VTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgdGhpcy5qb2luUmVmID0gdGhpcy5jaGFubmVsLl9qb2luUmVmKClcblxuICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpXG5cbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goKGRpZmYpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKVxuICAgICAgfSlcblxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuXG4gICAgICBvblN5bmMoKVxuICAgIH0pXG5cbiAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5kaWZmLCB7fSwgKGRpZmY6IFJhd1ByZXNlbmNlRGlmZikgPT4ge1xuICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgaWYgKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMucHVzaChkaWZmKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKVxuXG4gICAgICAgIG9uU3luYygpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMub25Kb2luKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHtcbiAgICAgICAgZXZlbnQ6ICdqb2luJyxcbiAgICAgICAga2V5LFxuICAgICAgICBjdXJyZW50UHJlc2VuY2VzLFxuICAgICAgICBuZXdQcmVzZW5jZXMsXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uTGVhdmUoKGtleSwgY3VycmVudFByZXNlbmNlcywgbGVmdFByZXNlbmNlcykgPT4ge1xuICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHtcbiAgICAgICAgZXZlbnQ6ICdsZWF2ZScsXG4gICAgICAgIGtleSxcbiAgICAgICAgY3VycmVudFByZXNlbmNlcyxcbiAgICAgICAgbGVmdFByZXNlbmNlcyxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMub25TeW5jKCgpID0+IHtcbiAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7IGV2ZW50OiAnc3luYycgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc3luYyB0aGUgbGlzdCBvZiBwcmVzZW5jZXMgb24gdGhlIHNlcnZlciB3aXRoIHRoZVxuICAgKiBjbGllbnQncyBzdGF0ZS5cbiAgICpcbiAgICogQW4gb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFjayBjYW4gYmUgcHJvdmlkZWQgdG9cbiAgICogcmVhY3QgdG8gY2hhbmdlcyBpbiB0aGUgY2xpZW50J3MgbG9jYWwgcHJlc2VuY2VzIGFjcm9zc1xuICAgKiBkaXNjb25uZWN0cyBhbmQgcmVjb25uZWN0cyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgc3luY1N0YXRlKFxuICAgIGN1cnJlbnRTdGF0ZTogUmVhbHRpbWVQcmVzZW5jZVN0YXRlLFxuICAgIG5ld1N0YXRlOiBSYXdQcmVzZW5jZVN0YXRlIHwgUmVhbHRpbWVQcmVzZW5jZVN0YXRlLFxuICAgIG9uSm9pbjogUHJlc2VuY2VPbkpvaW5DYWxsYmFjayxcbiAgICBvbkxlYXZlOiBQcmVzZW5jZU9uTGVhdmVDYWxsYmFja1xuICApOiBSZWFsdGltZVByZXNlbmNlU3RhdGUge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5jbG9uZURlZXAoY3VycmVudFN0YXRlKVxuICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RhdGUgPSB0aGlzLnRyYW5zZm9ybVN0YXRlKG5ld1N0YXRlKVxuICAgIGNvbnN0IGpvaW5zOiBSZWFsdGltZVByZXNlbmNlU3RhdGUgPSB7fVxuICAgIGNvbnN0IGxlYXZlczogUmVhbHRpbWVQcmVzZW5jZVN0YXRlID0ge31cblxuICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5OiBzdHJpbmcsIHByZXNlbmNlczogUHJlc2VuY2VbXSkgPT4ge1xuICAgICAgaWYgKCF0cmFuc2Zvcm1lZFN0YXRlW2tleV0pIHtcbiAgICAgICAgbGVhdmVzW2tleV0gPSBwcmVzZW5jZXNcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5tYXAodHJhbnNmb3JtZWRTdGF0ZSwgKGtleSwgbmV3UHJlc2VuY2VzOiBQcmVzZW5jZVtdKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzOiBQcmVzZW5jZVtdID0gc3RhdGVba2V5XVxuXG4gICAgICBpZiAoY3VycmVudFByZXNlbmNlcykge1xuICAgICAgICBjb25zdCBuZXdQcmVzZW5jZVJlZnMgPSBuZXdQcmVzZW5jZXMubWFwKChtOiBQcmVzZW5jZSkgPT4gbS5wcmVzZW5jZV9yZWYpXG4gICAgICAgIGNvbnN0IGN1clByZXNlbmNlUmVmcyA9IGN1cnJlbnRQcmVzZW5jZXMubWFwKChtOiBQcmVzZW5jZSkgPT4gbS5wcmVzZW5jZV9yZWYpXG4gICAgICAgIGNvbnN0IGpvaW5lZFByZXNlbmNlczogUHJlc2VuY2VbXSA9IG5ld1ByZXNlbmNlcy5maWx0ZXIoXG4gICAgICAgICAgKG06IFByZXNlbmNlKSA9PiBjdXJQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgbGVmdFByZXNlbmNlczogUHJlc2VuY2VbXSA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKFxuICAgICAgICAgIChtOiBQcmVzZW5jZSkgPT4gbmV3UHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGpvaW5lZFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgam9pbnNba2V5XSA9IGpvaW5lZFByZXNlbmNlc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlZnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxlYXZlc1trZXldID0gbGVmdFByZXNlbmNlc1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VzXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7IGpvaW5zLCBsZWF2ZXMgfSwgb25Kb2luLCBvbkxlYXZlKVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc3luYyBhIGRpZmYgb2YgcHJlc2VuY2Ugam9pbiBhbmQgbGVhdmUgZXZlbnRzIGZyb20gdGhlXG4gICAqIHNlcnZlciwgYXMgdGhleSBoYXBwZW4uXG4gICAqXG4gICAqIExpa2UgYHN5bmNTdGF0ZWAsIGBzeW5jRGlmZmAgYWNjZXB0cyBvcHRpb25hbCBgb25Kb2luYCBhbmRcbiAgICogYG9uTGVhdmVgIGNhbGxiYWNrcyB0byByZWFjdCB0byBhIHVzZXIgam9pbmluZyBvciBsZWF2aW5nIGZyb20gYVxuICAgKiBkZXZpY2UuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgc3luY0RpZmYoXG4gICAgc3RhdGU6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSxcbiAgICBkaWZmOiBSYXdQcmVzZW5jZURpZmYgfCBQcmVzZW5jZURpZmYsXG4gICAgb25Kb2luOiBQcmVzZW5jZU9uSm9pbkNhbGxiYWNrLFxuICAgIG9uTGVhdmU6IFByZXNlbmNlT25MZWF2ZUNhbGxiYWNrXG4gICk6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSB7XG4gICAgY29uc3QgeyBqb2lucywgbGVhdmVzIH0gPSB7XG4gICAgICBqb2luczogdGhpcy50cmFuc2Zvcm1TdGF0ZShkaWZmLmpvaW5zKSxcbiAgICAgIGxlYXZlczogdGhpcy50cmFuc2Zvcm1TdGF0ZShkaWZmLmxlYXZlcyksXG4gICAgfVxuXG4gICAgaWYgKCFvbkpvaW4pIHtcbiAgICAgIG9uSm9pbiA9ICgpID0+IHt9XG4gICAgfVxuXG4gICAgaWYgKCFvbkxlYXZlKSB7XG4gICAgICBvbkxlYXZlID0gKCkgPT4ge31cbiAgICB9XG5cbiAgICB0aGlzLm1hcChqb2lucywgKGtleSwgbmV3UHJlc2VuY2VzOiBQcmVzZW5jZVtdKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzOiBQcmVzZW5jZVtdID0gc3RhdGVba2V5XSA/PyBbXVxuICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmVEZWVwKG5ld1ByZXNlbmNlcylcblxuICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBqb2luZWRQcmVzZW5jZVJlZnMgPSBzdGF0ZVtrZXldLm1hcCgobTogUHJlc2VuY2UpID0+IG0ucHJlc2VuY2VfcmVmKVxuICAgICAgICBjb25zdCBjdXJQcmVzZW5jZXM6IFByZXNlbmNlW10gPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcihcbiAgICAgICAgICAobTogUHJlc2VuY2UpID0+IGpvaW5lZFByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDBcbiAgICAgICAgKVxuXG4gICAgICAgIHN0YXRlW2tleV0udW5zaGlmdCguLi5jdXJQcmVzZW5jZXMpXG4gICAgICB9XG5cbiAgICAgIG9uSm9pbihrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcylcbiAgICB9KVxuXG4gICAgdGhpcy5tYXAobGVhdmVzLCAoa2V5LCBsZWZ0UHJlc2VuY2VzOiBQcmVzZW5jZVtdKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlczogUHJlc2VuY2VbXSA9IHN0YXRlW2tleV1cblxuICAgICAgaWYgKCFjdXJyZW50UHJlc2VuY2VzKSByZXR1cm5cblxuICAgICAgY29uc3QgcHJlc2VuY2VSZWZzVG9SZW1vdmUgPSBsZWZ0UHJlc2VuY2VzLm1hcCgobTogUHJlc2VuY2UpID0+IG0ucHJlc2VuY2VfcmVmKVxuICAgICAgY3VycmVudFByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKFxuICAgICAgICAobTogUHJlc2VuY2UpID0+IHByZXNlbmNlUmVmc1RvUmVtb3ZlLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMFxuICAgICAgKVxuXG4gICAgICBzdGF0ZVtrZXldID0gY3VycmVudFByZXNlbmNlc1xuXG4gICAgICBvbkxlYXZlKGtleSwgY3VycmVudFByZXNlbmNlcywgbGVmdFByZXNlbmNlcylcblxuICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMubGVuZ3RoID09PSAwKSBkZWxldGUgc3RhdGVba2V5XVxuICAgIH0pXG5cbiAgICByZXR1cm4gc3RhdGVcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgbWFwPFQgPSBhbnk+KG9iajogUmVhbHRpbWVQcmVzZW5jZVN0YXRlLCBmdW5jOiBQcmVzZW5jZUNob29zZXI8VD4pOiBUW10ge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLm1hcCgoa2V5KSA9PiBmdW5jKGtleSwgb2JqW2tleV0pKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSAnbWV0YXMnIGtleVxuICAgKiBDaGFuZ2UgJ3BoeF9yZWYnIHRvICdwcmVzZW5jZV9yZWYnXG4gICAqIFJlbW92ZSAncGh4X3JlZicgYW5kICdwaHhfcmVmX3ByZXYnXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIHJldHVybnMge1xuICAgKiAgYWJjMTIzOiBbXG4gICAqICAgIHsgcHJlc2VuY2VfcmVmOiAnMicsIHVzZXJfaWQ6IDEgfSxcbiAgICogICAgeyBwcmVzZW5jZV9yZWY6ICczJywgdXNlcl9pZDogMiB9XG4gICAqICBdXG4gICAqIH1cbiAgICogUmVhbHRpbWVQcmVzZW5jZS50cmFuc2Zvcm1TdGF0ZSh7XG4gICAqICBhYmMxMjM6IHtcbiAgICogICAgbWV0YXM6IFtcbiAgICogICAgICB7IHBoeF9yZWY6ICcyJywgcGh4X3JlZl9wcmV2OiAnMScgdXNlcl9pZDogMSB9LFxuICAgKiAgICAgIHsgcGh4X3JlZjogJzMnLCB1c2VyX2lkOiAyIH1cbiAgICogICAgXVxuICAgKiAgfVxuICAgKiB9KVxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHRyYW5zZm9ybVN0YXRlKFxuICAgIHN0YXRlOiBSYXdQcmVzZW5jZVN0YXRlIHwgUmVhbHRpbWVQcmVzZW5jZVN0YXRlXG4gICk6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSB7XG4gICAgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChzdGF0ZSlcblxuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdGF0ZSkucmVkdWNlKChuZXdTdGF0ZSwga2V5KSA9PiB7XG4gICAgICBjb25zdCBwcmVzZW5jZXMgPSBzdGF0ZVtrZXldXG5cbiAgICAgIGlmICgnbWV0YXMnIGluIHByZXNlbmNlcykge1xuICAgICAgICBuZXdTdGF0ZVtrZXldID0gcHJlc2VuY2VzLm1ldGFzLm1hcCgocHJlc2VuY2UpID0+IHtcbiAgICAgICAgICBwcmVzZW5jZVsncHJlc2VuY2VfcmVmJ10gPSBwcmVzZW5jZVsncGh4X3JlZiddXG5cbiAgICAgICAgICBkZWxldGUgcHJlc2VuY2VbJ3BoeF9yZWYnXVxuICAgICAgICAgIGRlbGV0ZSBwcmVzZW5jZVsncGh4X3JlZl9wcmV2J11cblxuICAgICAgICAgIHJldHVybiBwcmVzZW5jZVxuICAgICAgICB9KSBhcyBQcmVzZW5jZVtdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdTdGF0ZVtrZXldID0gcHJlc2VuY2VzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdTdGF0ZVxuICAgIH0sIHt9IGFzIFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgY2xvbmVEZWVwKG9iajogeyBba2V5OiBzdHJpbmddOiBhbnkgfSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgb25Kb2luKGNhbGxiYWNrOiBQcmVzZW5jZU9uSm9pbkNhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2tcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBvbkxlYXZlKGNhbGxiYWNrOiBQcmVzZW5jZU9uTGVhdmVDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFja1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIG9uU3luYyhjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuY2FsbGVyLm9uU3luYyA9IGNhbGxiYWNrXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgaW5QZW5kaW5nU3luY1N0YXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5qb2luUmVmIHx8IHRoaXMuam9pblJlZiAhPT0gdGhpcy5jaGFubmVsLl9qb2luUmVmKClcbiAgfVxufVxuIiwgImltcG9ydCB7IENIQU5ORUxfRVZFTlRTLCBDSEFOTkVMX1NUQVRFUywgTUFYX1BVU0hfQlVGRkVSX1NJWkUgfSBmcm9tICcuL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgUHVzaCBmcm9tICcuL2xpYi9wdXNoJ1xuaW1wb3J0IHR5cGUgUmVhbHRpbWVDbGllbnQgZnJvbSAnLi9SZWFsdGltZUNsaWVudCdcbmltcG9ydCBUaW1lciBmcm9tICcuL2xpYi90aW1lcidcbmltcG9ydCBSZWFsdGltZVByZXNlbmNlLCB7IFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMgfSBmcm9tICcuL1JlYWx0aW1lUHJlc2VuY2UnXG5pbXBvcnQgdHlwZSB7XG4gIFJlYWx0aW1lUHJlc2VuY2VKb2luUGF5bG9hZCxcbiAgUmVhbHRpbWVQcmVzZW5jZUxlYXZlUGF5bG9hZCxcbiAgUmVhbHRpbWVQcmVzZW5jZVN0YXRlLFxufSBmcm9tICcuL1JlYWx0aW1lUHJlc2VuY2UnXG5pbXBvcnQgKiBhcyBUcmFuc2Zvcm1lcnMgZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJ1xuaW1wb3J0IHsgaHR0cEVuZHBvaW50VVJMIH0gZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJ1xuXG50eXBlIFJlcGxheU9wdGlvbiA9IHtcbiAgc2luY2U6IG51bWJlclxuICBsaW1pdD86IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZUNoYW5uZWxPcHRpb25zID0ge1xuICBjb25maWc6IHtcbiAgICAvKipcbiAgICAgKiBzZWxmIG9wdGlvbiBlbmFibGVzIGNsaWVudCB0byByZWNlaXZlIG1lc3NhZ2UgaXQgYnJvYWRjYXN0XG4gICAgICogYWNrIG9wdGlvbiBpbnN0cnVjdHMgc2VydmVyIHRvIGFja25vd2xlZGdlIHRoYXQgYnJvYWRjYXN0IG1lc3NhZ2Ugd2FzIHJlY2VpdmVkXG4gICAgICogcmVwbGF5IG9wdGlvbiBpbnN0cnVjdHMgc2VydmVyIHRvIHJlcGxheSBicm9hZGNhc3QgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBicm9hZGNhc3Q/OiB7IHNlbGY/OiBib29sZWFuOyBhY2s/OiBib29sZWFuOyByZXBsYXk/OiBSZXBsYXlPcHRpb24gfVxuICAgIC8qKlxuICAgICAqIGtleSBvcHRpb24gaXMgdXNlZCB0byB0cmFjayBwcmVzZW5jZSBwYXlsb2FkIGFjcm9zcyBjbGllbnRzXG4gICAgICovXG4gICAgcHJlc2VuY2U/OiB7IGtleT86IHN0cmluZzsgZW5hYmxlZD86IGJvb2xlYW4gfVxuICAgIC8qKlxuICAgICAqIGRlZmluZXMgaWYgdGhlIGNoYW5uZWwgaXMgcHJpdmF0ZSBvciBub3QgYW5kIGlmIFJMUyBwb2xpY2llcyB3aWxsIGJlIHVzZWQgdG8gY2hlY2sgZGF0YVxuICAgICAqL1xuICAgIHByaXZhdGU/OiBib29sZWFuXG4gIH1cbn1cblxudHlwZSBSZWFsdGltZUNoYW5nZXNQYXlsb2FkQmFzZSA9IHtcbiAgc2NoZW1hOiBzdHJpbmdcbiAgdGFibGU6IHN0cmluZ1xufVxuXG50eXBlIFJlYWx0aW1lQnJvYWRjYXN0Q2hhbmdlc1BheWxvYWRCYXNlID0gUmVhbHRpbWVDaGFuZ2VzUGF5bG9hZEJhc2UgJiB7XG4gIGlkOiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVCcm9hZGNhc3RJbnNlcnRQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9XG4gIFJlYWx0aW1lQnJvYWRjYXN0Q2hhbmdlc1BheWxvYWRCYXNlICYge1xuICAgIG9wZXJhdGlvbjogYCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuSU5TRVJUfWBcbiAgICByZWNvcmQ6IFRcbiAgICBvbGRfcmVjb3JkOiBudWxsXG4gIH1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVCcm9hZGNhc3RVcGRhdGVQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9XG4gIFJlYWx0aW1lQnJvYWRjYXN0Q2hhbmdlc1BheWxvYWRCYXNlICYge1xuICAgIG9wZXJhdGlvbjogYCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuVVBEQVRFfWBcbiAgICByZWNvcmQ6IFRcbiAgICBvbGRfcmVjb3JkOiBUXG4gIH1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVCcm9hZGNhc3REZWxldGVQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9XG4gIFJlYWx0aW1lQnJvYWRjYXN0Q2hhbmdlc1BheWxvYWRCYXNlICYge1xuICAgIG9wZXJhdGlvbjogYCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuREVMRVRFfWBcbiAgICByZWNvcmQ6IG51bGxcbiAgICBvbGRfcmVjb3JkOiBUXG4gIH1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVCcm9hZGNhc3RQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9XG4gIHwgUmVhbHRpbWVCcm9hZGNhc3RJbnNlcnRQYXlsb2FkPFQ+XG4gIHwgUmVhbHRpbWVCcm9hZGNhc3RVcGRhdGVQYXlsb2FkPFQ+XG4gIHwgUmVhbHRpbWVCcm9hZGNhc3REZWxldGVQYXlsb2FkPFQ+XG5cbnR5cGUgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkQmFzZSA9IHtcbiAgc2NoZW1hOiBzdHJpbmdcbiAgdGFibGU6IHN0cmluZ1xuICBjb21taXRfdGltZXN0YW1wOiBzdHJpbmdcbiAgZXJyb3JzOiBzdHJpbmdbXVxufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVBvc3RncmVzSW5zZXJ0UGF5bG9hZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4gPVxuICBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWRCYXNlICYge1xuICAgIGV2ZW50VHlwZTogYCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuSU5TRVJUfWBcbiAgICBuZXc6IFRcbiAgICBvbGQ6IHt9XG4gIH1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQb3N0Z3Jlc1VwZGF0ZVBheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID1cbiAgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkQmFzZSAmIHtcbiAgICBldmVudFR5cGU6IGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULlVQREFURX1gXG4gICAgbmV3OiBUXG4gICAgb2xkOiBQYXJ0aWFsPFQ+XG4gIH1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQb3N0Z3Jlc0RlbGV0ZVBheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID1cbiAgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkQmFzZSAmIHtcbiAgICBldmVudFR5cGU6IGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULkRFTEVURX1gXG4gICAgbmV3OiB7fVxuICAgIG9sZDogUGFydGlhbDxUPlxuICB9XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4gPVxuICB8IFJlYWx0aW1lUG9zdGdyZXNJbnNlcnRQYXlsb2FkPFQ+XG4gIHwgUmVhbHRpbWVQb3N0Z3Jlc1VwZGF0ZVBheWxvYWQ8VD5cbiAgfCBSZWFsdGltZVBvc3RncmVzRGVsZXRlUGF5bG9hZDxUPlxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc0ZpbHRlcjxUIGV4dGVuZHMgYCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlR9YD4gPSB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBkYXRhYmFzZSBjaGFuZ2UgdG8gbGlzdGVuIHRvLlxuICAgKi9cbiAgZXZlbnQ6IFRcbiAgLyoqXG4gICAqIFRoZSBkYXRhYmFzZSBzY2hlbWEgdG8gbGlzdGVuIHRvLlxuICAgKi9cbiAgc2NoZW1hOiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBkYXRhYmFzZSB0YWJsZSB0byBsaXN0ZW4gdG8uXG4gICAqL1xuICB0YWJsZT86IHN0cmluZ1xuICAvKipcbiAgICogUmVjZWl2ZSBkYXRhYmFzZSBjaGFuZ2VzIHdoZW4gZmlsdGVyIGlzIG1hdGNoZWQuXG4gICAqL1xuICBmaWx0ZXI/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVDaGFubmVsU2VuZFJlc3BvbnNlID0gJ29rJyB8ICd0aW1lZCBvdXQnIHwgJ2Vycm9yJ1xuXG5leHBvcnQgZW51bSBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCB7XG4gIEFMTCA9ICcqJyxcbiAgSU5TRVJUID0gJ0lOU0VSVCcsXG4gIFVQREFURSA9ICdVUERBVEUnLFxuICBERUxFVEUgPSAnREVMRVRFJyxcbn1cblxuZXhwb3J0IGVudW0gUkVBTFRJTUVfTElTVEVOX1RZUEVTIHtcbiAgQlJPQURDQVNUID0gJ2Jyb2FkY2FzdCcsXG4gIFBSRVNFTkNFID0gJ3ByZXNlbmNlJyxcbiAgUE9TVEdSRVNfQ0hBTkdFUyA9ICdwb3N0Z3Jlc19jaGFuZ2VzJyxcbiAgU1lTVEVNID0gJ3N5c3RlbScsXG59XG5cbmV4cG9ydCBlbnVtIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMge1xuICBTVUJTQ1JJQkVEID0gJ1NVQlNDUklCRUQnLFxuICBUSU1FRF9PVVQgPSAnVElNRURfT1VUJyxcbiAgQ0xPU0VEID0gJ0NMT1NFRCcsXG4gIENIQU5ORUxfRVJST1IgPSAnQ0hBTk5FTF9FUlJPUicsXG59XG5cbmV4cG9ydCBjb25zdCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyA9IENIQU5ORUxfU1RBVEVTXG5cbmludGVyZmFjZSBQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXJzIHtcbiAgcG9zdGdyZXNfY2hhbmdlczoge1xuICAgIGlkOiBzdHJpbmdcbiAgICBldmVudDogc3RyaW5nXG4gICAgc2NoZW1hPzogc3RyaW5nXG4gICAgdGFibGU/OiBzdHJpbmdcbiAgICBmaWx0ZXI/OiBzdHJpbmdcbiAgfVtdXG59XG4vKiogQSBjaGFubmVsIGlzIHRoZSBiYXNpYyBidWlsZGluZyBibG9jayBvZiBSZWFsdGltZVxuICogYW5kIG5hcnJvd3MgdGhlIHNjb3BlIG9mIGRhdGEgZmxvdyB0byBzdWJzY3JpYmVkIGNsaWVudHMuXG4gKiBZb3UgY2FuIHRoaW5rIG9mIGEgY2hhbm5lbCBhcyBhIGNoYXRyb29tIHdoZXJlIHBhcnRpY2lwYW50cyBhcmUgYWJsZSB0byBzZWUgd2hvJ3Mgb25saW5lXG4gKiBhbmQgc2VuZCBhbmQgcmVjZWl2ZSBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVDaGFubmVsIHtcbiAgYmluZGluZ3M6IHtcbiAgICBba2V5OiBzdHJpbmddOiB7XG4gICAgICB0eXBlOiBzdHJpbmdcbiAgICAgIGZpbHRlcjogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICAgICAgY2FsbGJhY2s6IEZ1bmN0aW9uXG4gICAgICBpZD86IHN0cmluZ1xuICAgIH1bXVxuICB9ID0ge31cbiAgdGltZW91dDogbnVtYmVyXG4gIHN0YXRlOiBDSEFOTkVMX1NUQVRFUyA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICBqb2luZWRPbmNlID0gZmFsc2VcbiAgam9pblB1c2g6IFB1c2hcbiAgcmVqb2luVGltZXI6IFRpbWVyXG4gIHB1c2hCdWZmZXI6IFB1c2hbXSA9IFtdXG4gIHByZXNlbmNlOiBSZWFsdGltZVByZXNlbmNlXG4gIGJyb2FkY2FzdEVuZHBvaW50VVJMOiBzdHJpbmdcbiAgc3ViVG9waWM6IHN0cmluZ1xuICBwcml2YXRlOiBib29sZWFuXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjaGFubmVsIHRoYXQgY2FuIGJyb2FkY2FzdCBtZXNzYWdlcywgc3luYyBwcmVzZW5jZSwgYW5kIGxpc3RlbiB0byBQb3N0Z3JlcyBjaGFuZ2VzLlxuICAgKlxuICAgKiBUaGUgdG9waWMgZGV0ZXJtaW5lcyB3aGljaCByZWFsdGltZSBzdHJlYW0geW91IGFyZSBzdWJzY3JpYmluZyB0by4gQ29uZmlnIG9wdGlvbnMgbGV0IHlvdVxuICAgKiBlbmFibGUgYWNrbm93bGVkZ2VtZW50IGZvciBicm9hZGNhc3RzLCBwcmVzZW5jZSB0cmFja2luZywgb3IgcHJpdmF0ZSBjaGFubmVscy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IFJlYWx0aW1lQ2xpZW50IGZyb20gJ0BzdXBhYmFzZS9yZWFsdGltZS1qcydcbiAgICpcbiAgICogY29uc3QgY2xpZW50ID0gbmV3IFJlYWx0aW1lQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vcmVhbHRpbWUvdjEnLCB7XG4gICAqICAgcGFyYW1zOiB7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSxcbiAgICogfSlcbiAgICogY29uc3QgY2hhbm5lbCA9IG5ldyBSZWFsdGltZUNoYW5uZWwoJ3JlYWx0aW1lOnB1YmxpYzptZXNzYWdlcycsIHsgY29uZmlnOiB7fSB9LCBjbGllbnQpXG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRvcGljIG5hbWUgY2FuIGJlIGFueSBzdHJpbmcuICovXG4gICAgcHVibGljIHRvcGljOiBzdHJpbmcsXG4gICAgcHVibGljIHBhcmFtczogUmVhbHRpbWVDaGFubmVsT3B0aW9ucyA9IHsgY29uZmlnOiB7fSB9LFxuICAgIHB1YmxpYyBzb2NrZXQ6IFJlYWx0aW1lQ2xpZW50XG4gICkge1xuICAgIHRoaXMuc3ViVG9waWMgPSB0b3BpYy5yZXBsYWNlKC9ecmVhbHRpbWU6L2ksICcnKVxuICAgIHRoaXMucGFyYW1zLmNvbmZpZyA9IHtcbiAgICAgIC4uLntcbiAgICAgICAgYnJvYWRjYXN0OiB7IGFjazogZmFsc2UsIHNlbGY6IGZhbHNlIH0sXG4gICAgICAgIHByZXNlbmNlOiB7IGtleTogJycsIGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICAgIHByaXZhdGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIC4uLnBhcmFtcy5jb25maWcsXG4gICAgfVxuICAgIHRoaXMudGltZW91dCA9IHRoaXMuc29ja2V0LnRpbWVvdXRcbiAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dClcbiAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHRoaXMuX3Jlam9pblVudGlsQ29ubmVjdGVkKCksIHRoaXMuc29ja2V0LnJlY29ubmVjdEFmdGVyTXMpXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2goKHB1c2hFdmVudDogUHVzaCkgPT4gcHVzaEV2ZW50LnNlbmQoKSlcbiAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdXG4gICAgfSlcbiAgICB0aGlzLl9vbkNsb3NlKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGNsb3NlICR7dGhpcy50b3BpY30gJHt0aGlzLl9qb2luUmVmKCl9YClcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgICAgIHRoaXMuc29ja2V0Ll9yZW1vdmUodGhpcylcbiAgICB9KVxuICAgIHRoaXMuX29uRXJyb3IoKHJlYXNvbjogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAodGhpcy5faXNMZWF2aW5nKCkgfHwgdGhpcy5faXNDbG9zZWQoKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICB9KVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5faXNKb2luaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgdGltZW91dCAke3RoaXMudG9waWN9YCwgdGhpcy5qb2luUHVzaC50aW1lb3V0KVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICB9KVxuXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKCdlcnJvcicsIChyZWFzb246IGFueSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpIHx8IHRoaXMuX2lzQ2xvc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbilcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgfSlcbiAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwge30sIChwYXlsb2FkOiBhbnksIHJlZjogc3RyaW5nKSA9PiB7XG4gICAgICB0aGlzLl90cmlnZ2VyKHRoaXMuX3JlcGx5RXZlbnROYW1lKHJlZiksIHBheWxvYWQpXG4gICAgfSlcblxuICAgIHRoaXMucHJlc2VuY2UgPSBuZXcgUmVhbHRpbWVQcmVzZW5jZSh0aGlzKVxuXG4gICAgdGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCA9IGh0dHBFbmRwb2ludFVSTCh0aGlzLnNvY2tldC5lbmRQb2ludClcbiAgICB0aGlzLnByaXZhdGUgPSB0aGlzLnBhcmFtcy5jb25maWcucHJpdmF0ZSB8fCBmYWxzZVxuXG4gICAgaWYgKCF0aGlzLnByaXZhdGUgJiYgdGhpcy5wYXJhbXMuY29uZmlnPy5icm9hZGNhc3Q/LnJlcGxheSkge1xuICAgICAgdGhyb3cgYHRyaWVkIHRvIHVzZSByZXBsYXkgb24gcHVibGljIGNoYW5uZWwgJyR7dGhpcy50b3BpY30nLiBJdCBtdXN0IGJlIGEgcHJpdmF0ZSBjaGFubmVsLmBcbiAgICB9XG4gIH1cblxuICAvKiogU3Vic2NyaWJlIHJlZ2lzdGVycyB5b3VyIGNsaWVudCB3aXRoIHRoZSBzZXJ2ZXIgKi9cbiAgc3Vic2NyaWJlKFxuICAgIGNhbGxiYWNrPzogKHN0YXR1czogUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUywgZXJyPzogRXJyb3IpID0+IHZvaWQsXG4gICAgdGltZW91dCA9IHRoaXMudGltZW91dFxuICApOiBSZWFsdGltZUNoYW5uZWwge1xuICAgIGlmICghdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhpcy5zb2NrZXQuY29ubmVjdCgpXG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09IENIQU5ORUxfU1RBVEVTLmNsb3NlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb25maWc6IHsgYnJvYWRjYXN0LCBwcmVzZW5jZSwgcHJpdmF0ZTogaXNQcml2YXRlIH0sXG4gICAgICB9ID0gdGhpcy5wYXJhbXNcblxuICAgICAgY29uc3QgcG9zdGdyZXNfY2hhbmdlcyA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcz8ubWFwKChyKSA9PiByLmZpbHRlcikgPz8gW11cblxuICAgICAgY29uc3QgcHJlc2VuY2VfZW5hYmxlZCA9XG4gICAgICAgICghIXRoaXMuYmluZGluZ3NbUkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFXSAmJlxuICAgICAgICAgIHRoaXMuYmluZGluZ3NbUkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFXS5sZW5ndGggPiAwKSB8fFxuICAgICAgICB0aGlzLnBhcmFtcy5jb25maWcucHJlc2VuY2U/LmVuYWJsZWQgPT09IHRydWVcbiAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuUGF5bG9hZDogeyBhY2Nlc3NfdG9rZW4/OiBzdHJpbmcgfSA9IHt9XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIGJyb2FkY2FzdCxcbiAgICAgICAgcHJlc2VuY2U6IHsgLi4ucHJlc2VuY2UsIGVuYWJsZWQ6IHByZXNlbmNlX2VuYWJsZWQgfSxcbiAgICAgICAgcG9zdGdyZXNfY2hhbmdlcyxcbiAgICAgICAgcHJpdmF0ZTogaXNQcml2YXRlLFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZSkge1xuICAgICAgICBhY2Nlc3NUb2tlblBheWxvYWQuYWNjZXNzX3Rva2VuID0gdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9vbkVycm9yKChlOiBFcnJvcikgPT4gY2FsbGJhY2s/LihSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsIGUpKVxuXG4gICAgICB0aGlzLl9vbkNsb3NlKCgpID0+IGNhbGxiYWNrPy4oUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DTE9TRUQpKVxuXG4gICAgICB0aGlzLnVwZGF0ZUpvaW5QYXlsb2FkKHsgLi4ueyBjb25maWcgfSwgLi4uYWNjZXNzVG9rZW5QYXlsb2FkIH0pXG5cbiAgICAgIHRoaXMuam9pbmVkT25jZSA9IHRydWVcbiAgICAgIHRoaXMuX3Jlam9pbih0aW1lb3V0KVxuXG4gICAgICB0aGlzLmpvaW5QdXNoXG4gICAgICAgIC5yZWNlaXZlKCdvaycsIGFzeW5jICh7IHBvc3RncmVzX2NoYW5nZXMgfTogUG9zdGdyZXNDaGFuZ2VzRmlsdGVycykgPT4ge1xuICAgICAgICAgIC8vIE9ubHkgcmVmcmVzaCBhdXRoIGlmIHVzaW5nIGNhbGxiYWNrLWJhc2VkIHRva2Vuc1xuICAgICAgICAgIGlmICghdGhpcy5zb2NrZXQuX2lzTWFudWFsVG9rZW4oKSkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2V0QXV0aCgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3N0Z3Jlc19jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrPy4oUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5TVUJTQ1JJQkVEKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudFBvc3RncmVzQmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXNcbiAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdzTGVuID0gY2xpZW50UG9zdGdyZXNCaW5kaW5ncz8ubGVuZ3RoID8/IDBcbiAgICAgICAgICAgIGNvbnN0IG5ld1Bvc3RncmVzQmluZGluZ3MgPSBbXVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgY2xpZW50UG9zdGdyZXNCaW5kaW5nID0gY2xpZW50UG9zdGdyZXNCaW5kaW5nc1tpXVxuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiB7IGV2ZW50LCBzY2hlbWEsIHRhYmxlLCBmaWx0ZXIgfSxcbiAgICAgICAgICAgICAgfSA9IGNsaWVudFBvc3RncmVzQmluZGluZ1xuICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciA9IHBvc3RncmVzX2NoYW5nZXMgJiYgcG9zdGdyZXNfY2hhbmdlc1tpXVxuXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciAmJlxuICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLmV2ZW50ID09PSBldmVudCAmJlxuICAgICAgICAgICAgICAgIFJlYWx0aW1lQ2hhbm5lbC5pc0ZpbHRlclZhbHVlRXF1YWwoc2VydmVyUG9zdGdyZXNGaWx0ZXIuc2NoZW1hLCBzY2hlbWEpICYmXG4gICAgICAgICAgICAgICAgUmVhbHRpbWVDaGFubmVsLmlzRmlsdGVyVmFsdWVFcXVhbChzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci50YWJsZSwgdGFibGUpICYmXG4gICAgICAgICAgICAgICAgUmVhbHRpbWVDaGFubmVsLmlzRmlsdGVyVmFsdWVFcXVhbChzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5maWx0ZXIsIGZpbHRlcilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbmV3UG9zdGdyZXNCaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIC4uLmNsaWVudFBvc3RncmVzQmluZGluZyxcbiAgICAgICAgICAgICAgICAgIGlkOiBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5pZCxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjaz8uKFxuICAgICAgICAgICAgICAgICAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DSEFOTkVMX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCdtaXNtYXRjaCBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IGJpbmRpbmdzIGZvciBwb3N0Z3JlcyBjaGFuZ2VzJylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzID0gbmV3UG9zdGdyZXNCaW5kaW5nc1xuXG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlNVQlNDUklCRUQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKCdlcnJvcicsIChlcnJvcjogeyBba2V5OiBzdHJpbmddOiBhbnkgfSkgPT4ge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICAgICAgY2FsbGJhY2s/LihcbiAgICAgICAgICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0hBTk5FTF9FUlJPUixcbiAgICAgICAgICAgIG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShPYmplY3QudmFsdWVzKGVycm9yKS5qb2luKCcsICcpIHx8ICdlcnJvcicpKVxuICAgICAgICAgIClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSlcbiAgICAgICAgLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2s/LihSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlRJTUVEX09VVClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHByZXNlbmNlIHN0YXRlIGZvciB0aGlzIGNoYW5uZWwuXG4gICAqXG4gICAqIFRoZSBzaGFwZSBpcyBhIG1hcCBrZXllZCBieSBwcmVzZW5jZSBrZXkgKGZvciBleGFtcGxlIGEgdXNlciBpZCkgd2hlcmUgZWFjaCBlbnRyeSBjb250YWlucyB0aGVcbiAgICogdHJhY2tlZCBtZXRhZGF0YSBmb3IgdGhhdCB1c2VyLlxuICAgKi9cbiAgcHJlc2VuY2VTdGF0ZTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9PigpOiBSZWFsdGltZVByZXNlbmNlU3RhdGU8VD4ge1xuICAgIHJldHVybiB0aGlzLnByZXNlbmNlLnN0YXRlIGFzIFJlYWx0aW1lUHJlc2VuY2VTdGF0ZTxUPlxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBzdXBwbGllZCBwYXlsb2FkIHRvIHRoZSBwcmVzZW5jZSB0cmFja2VyIHNvIG90aGVyIHN1YnNjcmliZXJzIGNhbiBzZWUgdGhhdCB0aGlzXG4gICAqIGNsaWVudCBpcyBvbmxpbmUuIFVzZSBgdW50cmFja2AgdG8gc3RvcCBicm9hZGNhc3RpbmcgcHJlc2VuY2UgZm9yIHRoZSBzYW1lIGtleS5cbiAgICovXG4gIGFzeW5jIHRyYWNrKFxuICAgIHBheWxvYWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0sXG4gICAgb3B0czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9XG4gICk6IFByb21pc2U8UmVhbHRpbWVDaGFubmVsU2VuZFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZChcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgZXZlbnQ6ICd0cmFjaycsXG4gICAgICAgIHBheWxvYWQsXG4gICAgICB9LFxuICAgICAgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dFxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBjdXJyZW50IHByZXNlbmNlIHN0YXRlIGZvciB0aGlzIGNsaWVudC5cbiAgICovXG4gIGFzeW5jIHVudHJhY2sob3B0czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9KTogUHJvbWlzZTxSZWFsdGltZUNoYW5uZWxTZW5kUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKFxuICAgICAge1xuICAgICAgICB0eXBlOiAncHJlc2VuY2UnLFxuICAgICAgICBldmVudDogJ3VudHJhY2snLFxuICAgICAgfSxcbiAgICAgIG9wdHNcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBldmVudCBoYW5kbGVyIHRoYXQgbGlzdGVucyB0byBjaGFuZ2VzLlxuICAgKi9cbiAgb24oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLlNZTkN9YCB9LFxuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLkpPSU59YCB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogUmVhbHRpbWVQcmVzZW5jZUpvaW5QYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLkxFQVZFfWAgfSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUHJlc2VuY2VMZWF2ZVBheWxvYWQ8VD4pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuUE9TVEdSRVNfQ0hBTkdFU31gLFxuICAgIGZpbHRlcjogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXI8YCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuQUxMfWA+LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBPU1RHUkVTX0NIQU5HRVN9YCxcbiAgICBmaWx0ZXI6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULklOU0VSVH1gPixcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNJbnNlcnRQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBPU1RHUkVTX0NIQU5HRVN9YCxcbiAgICBmaWx0ZXI6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULlVQREFURX1gPixcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNVcGRhdGVQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBPU1RHUkVTX0NIQU5HRVN9YCxcbiAgICBmaWx0ZXI6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULkRFTEVURX1gPixcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNEZWxldGVQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBPU1RHUkVTX0NIQU5HRVN9YCxcbiAgICBmaWx0ZXI6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UfWA+LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICAvKipcbiAgICogVGhlIGZvbGxvd2luZyBpcyBwbGFjZWQgaGVyZSB0byBkaXNwbGF5IG9uIHN1cGFiYXNlLmNvbS9kb2NzL3JlZmVyZW5jZS9qYXZhc2NyaXB0L3N1YnNjcmliZS5cbiAgICogQHBhcmFtIHR5cGUgT25lIG9mIFwiYnJvYWRjYXN0XCIsIFwicHJlc2VuY2VcIiwgb3IgXCJwb3N0Z3Jlc19jaGFuZ2VzXCIuXG4gICAqIEBwYXJhbSBmaWx0ZXIgQ3VzdG9tIG9iamVjdCBzcGVjaWZpYyB0byB0aGUgUmVhbHRpbWUgZmVhdHVyZSBkZXRhaWxpbmcgd2hpY2ggcGF5bG9hZHMgdG8gcmVjZWl2ZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiBldmVudCBoYW5kbGVyIGlzIHRyaWdnZXJlZC5cbiAgICovXG4gIG9uKFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5CUk9BRENBU1R9YCxcbiAgICBmaWx0ZXI6IHsgZXZlbnQ6IHN0cmluZyB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDoge1xuICAgICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLkJST0FEQ0FTVH1gXG4gICAgICBldmVudDogc3RyaW5nXG4gICAgICBtZXRhPzoge1xuICAgICAgICByZXBsYXllZD86IGJvb2xlYW5cbiAgICAgICAgaWQ6IHN0cmluZ1xuICAgICAgfVxuICAgICAgW2tleTogc3RyaW5nXTogYW55XG4gICAgfSkgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5CUk9BRENBU1R9YCxcbiAgICBmaWx0ZXI6IHsgZXZlbnQ6IHN0cmluZyB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDoge1xuICAgICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLkJST0FEQ0FTVH1gXG4gICAgICBldmVudDogc3RyaW5nXG4gICAgICBtZXRhPzoge1xuICAgICAgICByZXBsYXllZD86IGJvb2xlYW5cbiAgICAgICAgaWQ6IHN0cmluZ1xuICAgICAgfVxuICAgICAgcGF5bG9hZDogVFxuICAgIH0pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLkJST0FEQ0FTVH1gLFxuICAgIGZpbHRlcjogeyBldmVudDogUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuQUxMIH0sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiB7XG4gICAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuQlJPQURDQVNUfWBcbiAgICAgIGV2ZW50OiBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5BTExcbiAgICAgIHBheWxvYWQ6IFJlYWx0aW1lQnJvYWRjYXN0UGF5bG9hZDxUPlxuICAgIH0pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuQlJPQURDQVNUfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5JTlNFUlQgfSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IHtcbiAgICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5CUk9BRENBU1R9YFxuICAgICAgZXZlbnQ6IFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULklOU0VSVFxuICAgICAgcGF5bG9hZDogUmVhbHRpbWVCcm9hZGNhc3RJbnNlcnRQYXlsb2FkPFQ+XG4gICAgfSkgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5CUk9BRENBU1R9YCxcbiAgICBmaWx0ZXI6IHsgZXZlbnQ6IFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULlVQREFURSB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDoge1xuICAgICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLkJST0FEQ0FTVH1gXG4gICAgICBldmVudDogUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuVVBEQVRFXG4gICAgICBwYXlsb2FkOiBSZWFsdGltZUJyb2FkY2FzdFVwZGF0ZVBheWxvYWQ8VD5cbiAgICB9KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLkJST0FEQ0FTVH1gLFxuICAgIGZpbHRlcjogeyBldmVudDogUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuREVMRVRFIH0sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiB7XG4gICAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuQlJPQURDQVNUfWBcbiAgICAgIGV2ZW50OiBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5ERUxFVEVcbiAgICAgIHBheWxvYWQ6IFJlYWx0aW1lQnJvYWRjYXN0RGVsZXRlUGF5bG9hZDxUPlxuICAgIH0pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuU1lTVEVNfWAsXG4gICAgZmlsdGVyOiB7fSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IGFueSkgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb24oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBzdHJpbmc7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogYW55KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZCAmJiB0eXBlID09PSBSRUFMVElNRV9MSVNURU5fVFlQRVMuUFJFU0VOQ0UpIHtcbiAgICAgIHRoaXMuc29ja2V0LmxvZyhcbiAgICAgICAgJ2NoYW5uZWwnLFxuICAgICAgICBgcmVzdWJzY3JpYmUgdG8gJHt0aGlzLnRvcGljfSBkdWUgdG8gY2hhbmdlIGluIHByZXNlbmNlIGNhbGxiYWNrcyBvbiBqb2luZWQgY2hhbm5lbGBcbiAgICAgIClcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKS50aGVuKGFzeW5jICgpID0+IGF3YWl0IHRoaXMuc3Vic2NyaWJlKCkpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKVxuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIGJyb2FkY2FzdCBtZXNzYWdlIGV4cGxpY2l0bHkgdmlhIFJFU1QgQVBJLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhbHdheXMgdXNlcyB0aGUgUkVTVCBBUEkgZW5kcG9pbnQgcmVnYXJkbGVzcyBvZiBXZWJTb2NrZXQgY29ubmVjdGlvbiBzdGF0ZS5cbiAgICogVXNlZnVsIHdoZW4geW91IHdhbnQgdG8gZ3VhcmFudGVlIFJFU1QgZGVsaXZlcnkgb3Igd2hlbiBncmFkdWFsbHkgbWlncmF0aW5nIGZyb20gaW1wbGljaXQgUkVTVCBmYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBicm9hZGNhc3QgZXZlbnRcbiAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCB0byBiZSBzZW50IChyZXF1aXJlZClcbiAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyBpbmNsdWRpbmcgdGltZW91dFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBvYmplY3Qgd2l0aCBzdWNjZXNzIHN0YXR1cywgYW5kIGVycm9yIGRldGFpbHMgaWYgZmFpbGVkXG4gICAqL1xuICBhc3luYyBodHRwU2VuZChcbiAgICBldmVudDogc3RyaW5nLFxuICAgIHBheWxvYWQ6IGFueSxcbiAgICBvcHRzOiB7IHRpbWVvdXQ/OiBudW1iZXIgfSA9IHt9XG4gICk6IFByb21pc2U8eyBzdWNjZXNzOiB0cnVlIH0gfCB7IHN1Y2Nlc3M6IGZhbHNlOyBzdGF0dXM6IG51bWJlcjsgZXJyb3I6IHN0cmluZyB9PiB7XG4gICAgaWYgKHBheWxvYWQgPT09IHVuZGVmaW5lZCB8fCBwYXlsb2FkID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1BheWxvYWQgaXMgcmVxdWlyZWQgZm9yIGh0dHBTZW5kKCknKVxuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICBhcGlrZXk6IHRoaXMuc29ja2V0LmFwaUtleSA/IHRoaXMuc29ja2V0LmFwaUtleSA6ICcnLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZSkge1xuICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3RoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWV9YFxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdG9waWM6IHRoaXMuc3ViVG9waWMsXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBwcml2YXRlOiB0aGlzLnByaXZhdGUsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0pLFxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2hXaXRoVGltZW91dChcbiAgICAgIHRoaXMuYnJvYWRjYXN0RW5kcG9pbnRVUkwsXG4gICAgICBvcHRpb25zLFxuICAgICAgb3B0cy50aW1lb3V0ID8/IHRoaXMudGltZW91dFxuICAgIClcblxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMikge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgfVxuXG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvckJvZHkuZXJyb3IgfHwgZXJyb3JCb2R5Lm1lc3NhZ2UgfHwgZXJyb3JNZXNzYWdlXG4gICAgfSBjYXRjaCB7fVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpKVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSBpbnRvIHRoZSBjaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gc2VuZCB0byBjaGFubmVsXG4gICAqIEBwYXJhbSBhcmdzLnR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gc2VuZFxuICAgKiBAcGFyYW0gYXJncy5ldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgYmVpbmcgc2VudFxuICAgKiBAcGFyYW0gYXJncy5wYXlsb2FkIFBheWxvYWQgdG8gYmUgc2VudFxuICAgKiBAcGFyYW0gb3B0cyBPcHRpb25zIHRvIGJlIHVzZWQgZHVyaW5nIHRoZSBzZW5kIHByb2Nlc3NcbiAgICovXG4gIGFzeW5jIHNlbmQoXG4gICAgYXJnczoge1xuICAgICAgdHlwZTogJ2Jyb2FkY2FzdCcgfCAncHJlc2VuY2UnIHwgJ3Bvc3RncmVzX2NoYW5nZXMnXG4gICAgICBldmVudDogc3RyaW5nXG4gICAgICBwYXlsb2FkPzogYW55XG4gICAgICBba2V5OiBzdHJpbmddOiBhbnlcbiAgICB9LFxuICAgIG9wdHM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fVxuICApOiBQcm9taXNlPFJlYWx0aW1lQ2hhbm5lbFNlbmRSZXNwb25zZT4ge1xuICAgIGlmICghdGhpcy5fY2FuUHVzaCgpICYmIGFyZ3MudHlwZSA9PT0gJ2Jyb2FkY2FzdCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1JlYWx0aW1lIHNlbmQoKSBpcyBhdXRvbWF0aWNhbGx5IGZhbGxpbmcgYmFjayB0byBSRVNUIEFQSS4gJyArXG4gICAgICAgICAgJ1RoaXMgYmVoYXZpb3Igd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuICcgK1xuICAgICAgICAgICdQbGVhc2UgdXNlIGh0dHBTZW5kKCkgZXhwbGljaXRseSBmb3IgUkVTVCBkZWxpdmVyeS4nXG4gICAgICApXG5cbiAgICAgIGNvbnN0IHsgZXZlbnQsIHBheWxvYWQ6IGVuZHBvaW50X3BheWxvYWQgfSA9IGFyZ3NcbiAgICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgIGFwaWtleTogdGhpcy5zb2NrZXQuYXBpS2V5ID8gdGhpcy5zb2NrZXQuYXBpS2V5IDogJycsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlKSB7XG4gICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlfWBcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0b3BpYzogdGhpcy5zdWJUb3BpYyxcbiAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGVuZHBvaW50X3BheWxvYWQsXG4gICAgICAgICAgICAgIHByaXZhdGU6IHRoaXMucHJpdmF0ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSksXG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2hXaXRoVGltZW91dChcbiAgICAgICAgICB0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgb3B0cy50aW1lb3V0ID8/IHRoaXMudGltZW91dFxuICAgICAgICApXG5cbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuYm9keT8uY2FuY2VsKClcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rID8gJ29rJyA6ICdlcnJvcidcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIHJldHVybiAndGltZWQgb3V0J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnZXJyb3InXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IHB1c2ggPSB0aGlzLl9wdXNoKGFyZ3MudHlwZSwgYXJncywgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dClcblxuICAgICAgICBpZiAoYXJncy50eXBlID09PSAnYnJvYWRjYXN0JyAmJiAhdGhpcy5wYXJhbXM/LmNvbmZpZz8uYnJvYWRjYXN0Py5hY2spIHtcbiAgICAgICAgICByZXNvbHZlKCdvaycpXG4gICAgICAgIH1cblxuICAgICAgICBwdXNoLnJlY2VpdmUoJ29rJywgKCkgPT4gcmVzb2x2ZSgnb2snKSlcbiAgICAgICAgcHVzaC5yZWNlaXZlKCdlcnJvcicsICgpID0+IHJlc29sdmUoJ2Vycm9yJykpXG4gICAgICAgIHB1c2gucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHJlc29sdmUoJ3RpbWVkIG91dCcpKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcGF5bG9hZCB0aGF0IHdpbGwgYmUgc2VudCB0aGUgbmV4dCB0aW1lIHRoZSBjaGFubmVsIGpvaW5zIChyZWNvbm5lY3RzKS5cbiAgICogVXNlZnVsIGZvciByb3RhdGluZyBhY2Nlc3MgdG9rZW5zIG9yIHVwZGF0aW5nIGNvbmZpZyB3aXRob3V0IHJlLWNyZWF0aW5nIHRoZSBjaGFubmVsLlxuICAgKi9cbiAgdXBkYXRlSm9pblBheWxvYWQocGF5bG9hZDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IHZvaWQge1xuICAgIHRoaXMuam9pblB1c2gudXBkYXRlUGF5bG9hZChwYXlsb2FkKVxuICB9XG5cbiAgLyoqXG4gICAqIExlYXZlcyB0aGUgY2hhbm5lbC5cbiAgICpcbiAgICogVW5zdWJzY3JpYmVzIGZyb20gc2VydmVyIGV2ZW50cywgYW5kIGluc3RydWN0cyBjaGFubmVsIHRvIHRlcm1pbmF0ZSBvbiBzZXJ2ZXIuXG4gICAqIFRyaWdnZXJzIG9uQ2xvc2UoKSBob29rcy5cbiAgICpcbiAgICogVG8gcmVjZWl2ZSBsZWF2ZSBhY2tub3dsZWRnZW1lbnRzLCB1c2UgdGhlIGEgYHJlY2VpdmVgIGhvb2sgdG8gYmluZCB0byB0aGUgc2VydmVyIGFjaywgaWU6XG4gICAqIGNoYW5uZWwudW5zdWJzY3JpYmUoKS5yZWNlaXZlKFwib2tcIiwgKCkgPT4gYWxlcnQoXCJsZWZ0IVwiKSApXG4gICAqL1xuICB1bnN1YnNjcmliZSh0aW1lb3V0ID0gdGhpcy50aW1lb3V0KTogUHJvbWlzZTwnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InPiB7XG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmxlYXZpbmdcbiAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGxlYXZlICR7dGhpcy50b3BpY31gKVxuICAgICAgdGhpcy5fdHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5jbG9zZSwgJ2xlYXZlJywgdGhpcy5fam9pblJlZigpKVxuICAgIH1cblxuICAgIHRoaXMuam9pblB1c2guZGVzdHJveSgpXG5cbiAgICBsZXQgbGVhdmVQdXNoOiBQdXNoIHwgbnVsbCA9IG51bGxcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxSZWFsdGltZUNoYW5uZWxTZW5kUmVzcG9uc2U+KChyZXNvbHZlKSA9PiB7XG4gICAgICBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwge30sIHRpbWVvdXQpXG4gICAgICBsZWF2ZVB1c2hcbiAgICAgICAgLnJlY2VpdmUoJ29rJywgKCkgPT4ge1xuICAgICAgICAgIG9uQ2xvc2UoKVxuICAgICAgICAgIHJlc29sdmUoJ29rJylcbiAgICAgICAgfSlcbiAgICAgICAgLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgb25DbG9zZSgpXG4gICAgICAgICAgcmVzb2x2ZSgndGltZWQgb3V0JylcbiAgICAgICAgfSlcbiAgICAgICAgLnJlY2VpdmUoJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoJ2Vycm9yJylcbiAgICAgICAgfSlcblxuICAgICAgbGVhdmVQdXNoLnNlbmQoKVxuICAgICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgICAgbGVhdmVQdXNoLnRyaWdnZXIoJ29rJywge30pXG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBsZWF2ZVB1c2g/LmRlc3Ryb3koKVxuICAgIH0pXG4gIH1cbiAgLyoqXG4gICAqIFRlYXJkb3duIHRoZSBjaGFubmVsLlxuICAgKlxuICAgKiBEZXN0cm95cyBhbmQgc3RvcHMgcmVsYXRlZCB0aW1lcnMuXG4gICAqL1xuICB0ZWFyZG93bigpIHtcbiAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaDogUHVzaCkgPT4gcHVzaC5kZXN0cm95KCkpXG4gICAgdGhpcy5wdXNoQnVmZmVyID0gW11cbiAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICB0aGlzLmpvaW5QdXNoLmRlc3Ryb3koKVxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgICB0aGlzLmJpbmRpbmdzID0ge31cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBhc3luYyBfZmV0Y2hXaXRoVGltZW91dCh1cmw6IHN0cmluZywgb3B0aW9uczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSwgdGltZW91dDogbnVtYmVyKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc29ja2V0LmZldGNoKHVybCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgfSlcblxuICAgIGNsZWFyVGltZW91dChpZClcblxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVzaChldmVudDogc3RyaW5nLCBwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgaWYgKCF0aGlzLmpvaW5lZE9uY2UpIHtcbiAgICAgIHRocm93IGB0cmllZCB0byBwdXNoICcke2V2ZW50fScgdG8gJyR7dGhpcy50b3BpY30nIGJlZm9yZSBqb2luaW5nLiBVc2UgY2hhbm5lbC5zdWJzY3JpYmUoKSBiZWZvcmUgcHVzaGluZyBldmVudHNgXG4gICAgfVxuICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgUHVzaCh0aGlzLCBldmVudCwgcGF5bG9hZCwgdGltZW91dClcbiAgICBpZiAodGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICBwdXNoRXZlbnQuc2VuZCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZFRvUHVzaEJ1ZmZlcihwdXNoRXZlbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHB1c2hFdmVudFxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYWRkVG9QdXNoQnVmZmVyKHB1c2hFdmVudDogUHVzaCkge1xuICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKVxuICAgIHRoaXMucHVzaEJ1ZmZlci5wdXNoKHB1c2hFdmVudClcblxuICAgIC8vIEVuZm9yY2UgYnVmZmVyIHNpemUgbGltaXRcbiAgICBpZiAodGhpcy5wdXNoQnVmZmVyLmxlbmd0aCA+IE1BWF9QVVNIX0JVRkZFUl9TSVpFKSB7XG4gICAgICBjb25zdCByZW1vdmVkUHVzaCA9IHRoaXMucHVzaEJ1ZmZlci5zaGlmdCgpXG4gICAgICBpZiAocmVtb3ZlZFB1c2gpIHtcbiAgICAgICAgcmVtb3ZlZFB1c2guZGVzdHJveSgpXG4gICAgICAgIHRoaXMuc29ja2V0LmxvZyhcbiAgICAgICAgICAnY2hhbm5lbCcsXG4gICAgICAgICAgYGRpc2NhcmRlZCBwdXNoIGR1ZSB0byBidWZmZXIgb3ZlcmZsb3c6ICR7cmVtb3ZlZFB1c2guZXZlbnR9YCxcbiAgICAgICAgICByZW1vdmVkUHVzaC5wYXlsb2FkXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgbWVzc2FnZSBob29rXG4gICAqXG4gICAqIFJlY2VpdmVzIGFsbCBldmVudHMgZm9yIHNwZWNpYWxpemVkIG1lc3NhZ2UgaGFuZGxpbmcgYmVmb3JlIGRpc3BhdGNoaW5nIHRvIHRoZSBjaGFubmVsIGNhbGxiYWNrcy5cbiAgICogTXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX29uTWVzc2FnZShfZXZlbnQ6IHN0cmluZywgcGF5bG9hZDogYW55LCBfcmVmPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHBheWxvYWRcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2lzTWVtYmVyKHRvcGljOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy50b3BpYyA9PT0gdG9waWNcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2pvaW5SZWYoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5qb2luUHVzaC5yZWZcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RyaWdnZXIodHlwZTogc3RyaW5nLCBwYXlsb2FkPzogYW55LCByZWY/OiBzdHJpbmcpIHtcbiAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKClcbiAgICBjb25zdCB7IGNsb3NlLCBlcnJvciwgbGVhdmUsIGpvaW4gfSA9IENIQU5ORUxfRVZFTlRTXG4gICAgY29uc3QgZXZlbnRzOiBzdHJpbmdbXSA9IFtjbG9zZSwgZXJyb3IsIGxlYXZlLCBqb2luXVxuICAgIGlmIChyZWYgJiYgZXZlbnRzLmluZGV4T2YodHlwZUxvd2VyKSA+PSAwICYmIHJlZiAhPT0gdGhpcy5fam9pblJlZigpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbGV0IGhhbmRsZWRQYXlsb2FkID0gdGhpcy5fb25NZXNzYWdlKHR5cGVMb3dlciwgcGF5bG9hZCwgcmVmKVxuICAgIGlmIChwYXlsb2FkICYmICFoYW5kbGVkUGF5bG9hZCkge1xuICAgICAgdGhyb3cgJ2NoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZCdcbiAgICB9XG5cbiAgICBpZiAoWydpbnNlcnQnLCAndXBkYXRlJywgJ2RlbGV0ZSddLmluY2x1ZGVzKHR5cGVMb3dlcikpIHtcbiAgICAgIHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlc1xuICAgICAgICA/LmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgIHJldHVybiBiaW5kLmZpbHRlcj8uZXZlbnQgPT09ICcqJyB8fCBiaW5kLmZpbHRlcj8uZXZlbnQ/LnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHR5cGVMb3dlclxuICAgICAgICB9KVxuICAgICAgICAubWFwKChiaW5kKSA9PiBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl1cbiAgICAgICAgPy5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICBpZiAoWydicm9hZGNhc3QnLCAncHJlc2VuY2UnLCAncG9zdGdyZXNfY2hhbmdlcyddLmluY2x1ZGVzKHR5cGVMb3dlcikpIHtcbiAgICAgICAgICAgIGlmICgnaWQnIGluIGJpbmQpIHtcbiAgICAgICAgICAgICAgY29uc3QgYmluZElkID0gYmluZC5pZFxuICAgICAgICAgICAgICBjb25zdCBiaW5kRXZlbnQgPSBiaW5kLmZpbHRlcj8uZXZlbnRcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBiaW5kSWQgJiZcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlkcz8uaW5jbHVkZXMoYmluZElkKSAmJlxuICAgICAgICAgICAgICAgIChiaW5kRXZlbnQgPT09ICcqJyB8fFxuICAgICAgICAgICAgICAgICAgYmluZEV2ZW50Py50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSBwYXlsb2FkLmRhdGE/LnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgYmluZEV2ZW50ID0gYmluZD8uZmlsdGVyPy5ldmVudD8udG9Mb2NhbGVMb3dlckNhc2UoKVxuICAgICAgICAgICAgICByZXR1cm4gYmluZEV2ZW50ID09PSAnKicgfHwgYmluZEV2ZW50ID09PSBwYXlsb2FkPy5ldmVudD8udG9Mb2NhbGVMb3dlckNhc2UoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZC50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHR5cGVMb3dlclxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm1hcCgoYmluZCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlZFBheWxvYWQgPT09ICdvYmplY3QnICYmICdpZHMnIGluIGhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc0NoYW5nZXMgPSBoYW5kbGVkUGF5bG9hZC5kYXRhXG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYSwgdGFibGUsIGNvbW1pdF90aW1lc3RhbXAsIHR5cGUsIGVycm9ycyB9ID0gcG9zdGdyZXNDaGFuZ2VzXG4gICAgICAgICAgICBjb25zdCBlbnJpY2hlZFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICAgIGNvbW1pdF90aW1lc3RhbXA6IGNvbW1pdF90aW1lc3RhbXAsXG4gICAgICAgICAgICAgIGV2ZW50VHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgbmV3OiB7fSxcbiAgICAgICAgICAgICAgb2xkOiB7fSxcbiAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVkUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgLi4uZW5yaWNoZWRQYXlsb2FkLFxuICAgICAgICAgICAgICAuLi50aGlzLl9nZXRQYXlsb2FkUmVjb3Jkcyhwb3N0Z3Jlc0NoYW5nZXMpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYpXG4gICAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaXNDbG9zZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaXNKb2luZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZFxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaXNKb2luaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9pc0xlYXZpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmxlYXZpbmdcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlcGx5RXZlbnROYW1lKHJlZjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYGNoYW5fcmVwbHlfJHtyZWZ9YFxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb24odHlwZTogc3RyaW5nLCBmaWx0ZXI6IHsgW2tleTogc3RyaW5nXTogYW55IH0sIGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKVxuICAgIGNvbnN0IGJpbmRpbmcgPSB7XG4gICAgICB0eXBlOiB0eXBlTG93ZXIsXG4gICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0ucHVzaChiaW5kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0gPSBbYmluZGluZ11cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb2ZmKHR5cGU6IHN0cmluZywgZmlsdGVyOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSB7XG4gICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpXG5cbiAgICBpZiAodGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0gPSB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0uZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICAgIHJldHVybiAhKFxuICAgICAgICAgIGJpbmQudHlwZT8udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gdHlwZUxvd2VyICYmXG4gICAgICAgICAgUmVhbHRpbWVDaGFubmVsLmlzRXF1YWwoYmluZC5maWx0ZXIsIGZpbHRlcilcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgaXNFcXVhbChvYmoxOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LCBvYmoyOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqMSkge1xuICAgICAgaWYgKG9iajFba10gIT09IG9iajJba10pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gb3B0aW9uYWwgZmlsdGVyIHZhbHVlcyBmb3IgZXF1YWxpdHkuXG4gICAqIFRyZWF0cyB1bmRlZmluZWQsIG51bGwsIGFuZCBlbXB0eSBzdHJpbmcgYXMgZXF1aXZhbGVudCBlbXB0eSB2YWx1ZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgaXNGaWx0ZXJWYWx1ZUVxdWFsKFxuICAgIHNlcnZlclZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsLFxuICAgIGNsaWVudFZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFNlcnZlciA9IHNlcnZlclZhbHVlID8/IHVuZGVmaW5lZFxuICAgIGNvbnN0IG5vcm1hbGl6ZWRDbGllbnQgPSBjbGllbnRWYWx1ZSA/PyB1bmRlZmluZWRcbiAgICByZXR1cm4gbm9ybWFsaXplZFNlcnZlciA9PT0gbm9ybWFsaXplZENsaWVudFxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9yZWpvaW5VbnRpbENvbm5lY3RlZCgpIHtcbiAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgaWYgKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRoaXMuX3Jlam9pbigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjaGFubmVsIGNsb3Nlcy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF9vbkNsb3NlKGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIHRoaXMuX29uKENIQU5ORUxfRVZFTlRTLmNsb3NlLCB7fSwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgZW5jb3VudGVyZXMgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBfb25FcnJvcihjYWxsYmFjazogRnVuY3Rpb24pIHtcbiAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5lcnJvciwge30sIChyZWFzb246IHN0cmluZykgPT4gY2FsbGJhY2socmVhc29uKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZCBhbmQgdGhlIGNoYW5uZWwgaGFzIGJlZW4gam9pbmVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgX2NhblB1c2goKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5faXNKb2luZWQoKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9yZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9pc0xlYXZpbmcoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuc29ja2V0Ll9sZWF2ZU9wZW5Ub3BpYyh0aGlzLnRvcGljKVxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nXG4gICAgdGhpcy5qb2luUHVzaC5yZXNlbmQodGltZW91dClcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfZ2V0UGF5bG9hZFJlY29yZHMocGF5bG9hZDogYW55KSB7XG4gICAgY29uc3QgcmVjb3JkcyA9IHtcbiAgICAgIG5ldzoge30sXG4gICAgICBvbGQ6IHt9LFxuICAgIH1cblxuICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdJTlNFUlQnIHx8IHBheWxvYWQudHlwZSA9PT0gJ1VQREFURScpIHtcbiAgICAgIHJlY29yZHMubmV3ID0gVHJhbnNmb3JtZXJzLmNvbnZlcnRDaGFuZ2VEYXRhKHBheWxvYWQuY29sdW1ucywgcGF5bG9hZC5yZWNvcmQpXG4gICAgfVxuXG4gICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ1VQREFURScgfHwgcGF5bG9hZC50eXBlID09PSAnREVMRVRFJykge1xuICAgICAgcmVjb3Jkcy5vbGQgPSBUcmFuc2Zvcm1lcnMuY29udmVydENoYW5nZURhdGEocGF5bG9hZC5jb2x1bW5zLCBwYXlsb2FkLm9sZF9yZWNvcmQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY29yZHNcbiAgfVxufVxuIiwgImltcG9ydCBXZWJTb2NrZXRGYWN0b3J5LCB7IFdlYlNvY2tldExpa2UgfSBmcm9tICcuL2xpYi93ZWJzb2NrZXQtZmFjdG9yeSdcblxuaW1wb3J0IHtcbiAgQ0hBTk5FTF9FVkVOVFMsXG4gIENPTk5FQ1RJT05fU1RBVEUsXG4gIERFRkFVTFRfVkVSU0lPTixcbiAgREVGQVVMVF9USU1FT1VULFxuICBTT0NLRVRfU1RBVEVTLFxuICBUUkFOU1BPUlRTLFxuICBERUZBVUxUX1ZTTixcbiAgVlNOXzFfMF8wLFxuICBWU05fMl8wXzAsXG4gIFdTX0NMT1NFX05PUk1BTCxcbn0gZnJvbSAnLi9saWIvY29uc3RhbnRzJ1xuXG5pbXBvcnQgU2VyaWFsaXplciBmcm9tICcuL2xpYi9zZXJpYWxpemVyJ1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJ1xuXG5pbXBvcnQgeyBodHRwRW5kcG9pbnRVUkwgfSBmcm9tICcuL2xpYi90cmFuc2Zvcm1lcnMnXG5pbXBvcnQgUmVhbHRpbWVDaGFubmVsIGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJ1xuaW1wb3J0IHR5cGUgeyBSZWFsdGltZUNoYW5uZWxPcHRpb25zIH0gZnJvbSAnLi9SZWFsdGltZUNoYW5uZWwnXG5cbnR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IHR5cGUgQ2hhbm5lbCA9IHtcbiAgbmFtZTogc3RyaW5nXG4gIGluc2VydGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG4gIGlkOiBudW1iZXJcbn1cbmV4cG9ydCB0eXBlIExvZ0xldmVsID0gJ2luZm8nIHwgJ3dhcm4nIHwgJ2Vycm9yJ1xuXG5leHBvcnQgdHlwZSBSZWFsdGltZU1lc3NhZ2UgPSB7XG4gIHRvcGljOiBzdHJpbmdcbiAgZXZlbnQ6IHN0cmluZ1xuICBwYXlsb2FkOiBhbnlcbiAgcmVmOiBzdHJpbmdcbiAgam9pbl9yZWY/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVSZW1vdmVDaGFubmVsUmVzcG9uc2UgPSAnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InXG5leHBvcnQgdHlwZSBIZWFydGJlYXRTdGF0dXMgPSAnc2VudCcgfCAnb2snIHwgJ2Vycm9yJyB8ICd0aW1lb3V0JyB8ICdkaXNjb25uZWN0ZWQnXG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG50eXBlIFJlYWx0aW1lQ2xpZW50U3RhdGUgPSAnY29ubmVjdGluZycgfCAnY29ubmVjdGVkJyB8ICdkaXNjb25uZWN0aW5nJyB8ICdkaXNjb25uZWN0ZWQnXG5cbi8vIENvbm5lY3Rpb24tcmVsYXRlZCBjb25zdGFudHNcbmNvbnN0IENPTk5FQ1RJT05fVElNRU9VVFMgPSB7XG4gIEhFQVJUQkVBVF9JTlRFUlZBTDogMjUwMDAsXG4gIFJFQ09OTkVDVF9ERUxBWTogMTAsXG4gIEhFQVJUQkVBVF9USU1FT1VUX0ZBTExCQUNLOiAxMDAsXG59IGFzIGNvbnN0XG5cbmNvbnN0IFJFQ09OTkVDVF9JTlRFUlZBTFMgPSBbMTAwMCwgMjAwMCwgNTAwMCwgMTAwMDBdIGFzIGNvbnN0XG5jb25zdCBERUZBVUxUX1JFQ09OTkVDVF9GQUxMQkFDSyA9IDEwMDAwXG5cbi8qKlxuICogTWluaW1hbCBXZWJTb2NrZXQgY29uc3RydWN0b3IgaW50ZXJmYWNlIHRoYXQgUmVhbHRpbWVDbGllbnQgY2FuIHdvcmsgd2l0aC5cbiAqIFN1cHBseSBhIGNvbXBhdGlibGUgaW1wbGVtZW50YXRpb24gKG5hdGl2ZSBXZWJTb2NrZXQsIGB3c2AsIGV0Yykgd2hlbiBydW5uaW5nIG91dHNpZGUgdGhlIGJyb3dzZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV2ViU29ja2V0TGlrZUNvbnN0cnVjdG9yIHtcbiAgbmV3IChhZGRyZXNzOiBzdHJpbmcgfCBVUkwsIHN1YnByb3RvY29scz86IHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkKTogV2ViU29ja2V0TGlrZVxuICAvLyBBbGxvdyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtYXkgZXhpc3Qgb24gV2ViU29ja2V0IGNvbnN0cnVjdG9yc1xuICBba2V5OiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXZWJTb2NrZXRMaWtlRXJyb3Ige1xuICBlcnJvcjogYW55XG4gIG1lc3NhZ2U6IHN0cmluZ1xuICB0eXBlOiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVDbGllbnRPcHRpb25zID0ge1xuICB0cmFuc3BvcnQ/OiBXZWJTb2NrZXRMaWtlQ29uc3RydWN0b3JcbiAgdGltZW91dD86IG51bWJlclxuICBoZWFydGJlYXRJbnRlcnZhbE1zPzogbnVtYmVyXG4gIGhlYXJ0YmVhdENhbGxiYWNrPzogKHN0YXR1czogSGVhcnRiZWF0U3RhdHVzLCBsYXRlbmN5PzogbnVtYmVyKSA9PiB2b2lkXG4gIHZzbj86IHN0cmluZ1xuICBsb2dnZXI/OiBGdW5jdGlvblxuICBlbmNvZGU/OiBGdW5jdGlvblxuICBkZWNvZGU/OiBGdW5jdGlvblxuICByZWNvbm5lY3RBZnRlck1zPzogRnVuY3Rpb25cbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgcGFyYW1zPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICAvL0RlcHJlY2F0ZWQ6IFVzZSBpdCBpbiBmYXZvdXIgb2YgY29ycmVjdCBjYXNpbmcgYGxvZ0xldmVsYFxuICBsb2dfbGV2ZWw/OiBMb2dMZXZlbFxuICBsb2dMZXZlbD86IExvZ0xldmVsXG4gIGZldGNoPzogRmV0Y2hcbiAgd29ya2VyPzogYm9vbGVhblxuICB3b3JrZXJVcmw/OiBzdHJpbmdcbiAgYWNjZXNzVG9rZW4/OiAoKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGw+XG59XG5cbmNvbnN0IFdPUktFUl9TQ1JJUFQgPSBgXG4gIGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XG4gICAgaWYgKGUuZGF0YS5ldmVudCA9PT0gXCJzdGFydFwiKSB7XG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiBwb3N0TWVzc2FnZSh7IGV2ZW50OiBcImtlZXBBbGl2ZVwiIH0pLCBlLmRhdGEuaW50ZXJ2YWwpO1xuICAgIH1cbiAgfSk7YFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZUNsaWVudCB7XG4gIGFjY2Vzc1Rva2VuVmFsdWU6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gIGFwaUtleTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBfbWFudWFsbHlTZXRUb2tlbjogYm9vbGVhbiA9IGZhbHNlXG4gIGNoYW5uZWxzOiBSZWFsdGltZUNoYW5uZWxbXSA9IG5ldyBBcnJheSgpXG4gIGVuZFBvaW50OiBzdHJpbmcgPSAnJ1xuICBodHRwRW5kcG9pbnQ6IHN0cmluZyA9ICcnXG4gIC8qKiBAZGVwcmVjYXRlZCBoZWFkZXJzIGNhbm5vdCBiZSBzZXQgb24gd2Vic29ja2V0IGNvbm5lY3Rpb25zICovXG4gIGhlYWRlcnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge31cbiAgcGFyYW1zPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9XG4gIHRpbWVvdXQ6IG51bWJlciA9IERFRkFVTFRfVElNRU9VVFxuICB0cmFuc3BvcnQ6IFdlYlNvY2tldExpa2VDb25zdHJ1Y3RvciB8IG51bGwgPSBudWxsXG4gIGhlYXJ0YmVhdEludGVydmFsTXM6IG51bWJlciA9IENPTk5FQ1RJT05fVElNRU9VVFMuSEVBUlRCRUFUX0lOVEVSVkFMXG4gIGhlYXJ0YmVhdFRpbWVyOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRJbnRlcnZhbD4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgcGVuZGluZ0hlYXJ0YmVhdFJlZjogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgaGVhcnRiZWF0Q2FsbGJhY2s6IChzdGF0dXM6IEhlYXJ0YmVhdFN0YXR1cywgbGF0ZW5jeT86IG51bWJlcikgPT4gdm9pZCA9IG5vb3BcbiAgcmVmOiBudW1iZXIgPSAwXG4gIHJlY29ubmVjdFRpbWVyOiBUaW1lciB8IG51bGwgPSBudWxsXG4gIHZzbjogc3RyaW5nID0gREVGQVVMVF9WU05cbiAgbG9nZ2VyOiBGdW5jdGlvbiA9IG5vb3BcbiAgbG9nTGV2ZWw/OiBMb2dMZXZlbFxuICBlbmNvZGUhOiBGdW5jdGlvblxuICBkZWNvZGUhOiBGdW5jdGlvblxuICByZWNvbm5lY3RBZnRlck1zITogRnVuY3Rpb25cbiAgY29ubjogV2ViU29ja2V0TGlrZSB8IG51bGwgPSBudWxsXG4gIHNlbmRCdWZmZXI6IEZ1bmN0aW9uW10gPSBbXVxuICBzZXJpYWxpemVyOiBTZXJpYWxpemVyID0gbmV3IFNlcmlhbGl6ZXIoKVxuICBzdGF0ZUNoYW5nZUNhbGxiYWNrczoge1xuICAgIG9wZW46IEZ1bmN0aW9uW11cbiAgICBjbG9zZTogRnVuY3Rpb25bXVxuICAgIGVycm9yOiBGdW5jdGlvbltdXG4gICAgbWVzc2FnZTogRnVuY3Rpb25bXVxuICB9ID0ge1xuICAgIG9wZW46IFtdLFxuICAgIGNsb3NlOiBbXSxcbiAgICBlcnJvcjogW10sXG4gICAgbWVzc2FnZTogW10sXG4gIH1cbiAgZmV0Y2g6IEZldGNoXG4gIGFjY2Vzc1Rva2VuOiAoKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPikgfCBudWxsID0gbnVsbFxuICB3b3JrZXI/OiBib29sZWFuXG4gIHdvcmtlclVybD86IHN0cmluZ1xuICB3b3JrZXJSZWY/OiBXb3JrZXJcbiAgcHJpdmF0ZSBfY29ubmVjdGlvblN0YXRlOiBSZWFsdGltZUNsaWVudFN0YXRlID0gJ2Rpc2Nvbm5lY3RlZCdcbiAgcHJpdmF0ZSBfd2FzTWFudWFsRGlzY29ubmVjdDogYm9vbGVhbiA9IGZhbHNlXG4gIHByaXZhdGUgX2F1dGhQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBfaGVhcnRiZWF0U2VudEF0OiBudW1iZXIgfCBudWxsID0gbnVsbFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gZW5kUG9pbnQgVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBcIndzOi8vZXhhbXBsZS5jb20vc29ja2V0XCIsIFwid3NzOi8vZXhhbXBsZS5jb21cIiwgXCIvc29ja2V0XCIgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gICAqIEBwYXJhbSBodHRwRW5kcG9pbnQgVGhlIHN0cmluZyBIVFRQIGVuZHBvaW50LCBpZSwgXCJodHRwczovL2V4YW1wbGUuY29tXCIsIFwiL1wiIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc3BvcnQgVGhlIFdlYnNvY2tldCBUcmFuc3BvcnQsIGZvciBleGFtcGxlIFdlYlNvY2tldC4gVGhpcyBjYW4gYmUgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dCBUaGUgZGVmYXVsdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byB0cmlnZ2VyIHB1c2ggdGltZW91dHMuXG4gICAqIEBwYXJhbSBvcHRpb25zLnBhcmFtcyBUaGUgb3B0aW9uYWwgcGFyYW1zIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIERlcHJlY2F0ZWQ6IGhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiB3ZWJzb2NrZXQgY29ubmVjdGlvbnMgYW5kIHRoaXMgb3B0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFydGJlYXRJbnRlcnZhbE1zIFRoZSBtaWxsaXNlYyBpbnRlcnZhbCB0byBzZW5kIGEgaGVhcnRiZWF0IG1lc3NhZ2UuXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYXJ0YmVhdENhbGxiYWNrIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0byBoYW5kbGUgaGVhcnRiZWF0IHN0YXR1cyBhbmQgbGF0ZW5jeS5cbiAgICogQHBhcmFtIG9wdGlvbnMubG9nZ2VyIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6IGxvZ2dlcjogKGtpbmQsIG1zZywgZGF0YSkgPT4geyBjb25zb2xlLmxvZyhgJHtraW5kfTogJHttc2d9YCwgZGF0YSkgfVxuICAgKiBAcGFyYW0gb3B0aW9ucy5sb2dMZXZlbCBTZXRzIHRoZSBsb2cgbGV2ZWwgZm9yIFJlYWx0aW1lXG4gICAqIEBwYXJhbSBvcHRpb25zLmVuY29kZSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBKU09OOiAocGF5bG9hZCwgY2FsbGJhY2spID0+IGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5kZWNvZGUgVGhlIGZ1bmN0aW9uIHRvIGRlY29kZSBpbmNvbWluZyBtZXNzYWdlcy4gRGVmYXVsdHMgdG8gU2VyaWFsaXplcidzIGRlY29kZS5cbiAgICogQHBhcmFtIG9wdGlvbnMucmVjb25uZWN0QWZ0ZXJNcyBoZSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1pbGxzZWMgcmVjb25uZWN0IGludGVydmFsLiBEZWZhdWx0cyB0byBzdGVwcGVkIGJhY2tvZmYgb2ZmLlxuICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXIgVXNlIFdlYiBXb3JrZXIgdG8gc2V0IGEgc2lkZSBmbG93LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICogQHBhcmFtIG9wdGlvbnMud29ya2VyVXJsIFRoZSBVUkwgb2YgdGhlIHdvcmtlciBzY3JpcHQuIERlZmF1bHRzIHRvIGh0dHBzOi8vcmVhbHRpbWUuc3VwYWJhc2UuY29tL3dvcmtlci5qcyB0aGF0IGluY2x1ZGVzIGEgaGVhcnRiZWF0IGV2ZW50IGNhbGwgdG8ga2VlcCB0aGUgY29ubmVjdGlvbiBhbGl2ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMudnNuIFRoZSBwcm90b2NvbCB2ZXJzaW9uIHRvIHVzZSB3aGVuIGNvbm5lY3RpbmcuIFN1cHBvcnRlZCB2ZXJzaW9ucyBhcmUgXCIxLjAuMFwiIGFuZCBcIjIuMC4wXCIuIERlZmF1bHRzIHRvIFwiMi4wLjBcIi5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IFJlYWx0aW1lQ2xpZW50IGZyb20gJ0BzdXBhYmFzZS9yZWFsdGltZS1qcydcbiAgICpcbiAgICogY29uc3QgY2xpZW50ID0gbmV3IFJlYWx0aW1lQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vcmVhbHRpbWUvdjEnLCB7XG4gICAqICAgcGFyYW1zOiB7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSxcbiAgICogfSlcbiAgICogY2xpZW50LmNvbm5lY3QoKVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVuZFBvaW50OiBzdHJpbmcsIG9wdGlvbnM/OiBSZWFsdGltZUNsaWVudE9wdGlvbnMpIHtcbiAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBwYXJhbWV0ZXJzXG4gICAgaWYgKCFvcHRpb25zPy5wYXJhbXM/LmFwaWtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkga2V5IGlzIHJlcXVpcmVkIHRvIGNvbm5lY3QgdG8gUmVhbHRpbWUnKVxuICAgIH1cbiAgICB0aGlzLmFwaUtleSA9IG9wdGlvbnMucGFyYW1zLmFwaWtleVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBlbmRwb2ludCBVUkxzXG4gICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWBcbiAgICB0aGlzLmh0dHBFbmRwb2ludCA9IGh0dHBFbmRwb2ludFVSTChlbmRQb2ludClcblxuICAgIHRoaXMuX2luaXRpYWxpemVPcHRpb25zKG9wdGlvbnMpXG4gICAgdGhpcy5fc2V0dXBSZWNvbm5lY3Rpb25UaW1lcigpXG4gICAgdGhpcy5mZXRjaCA9IHRoaXMuX3Jlc29sdmVGZXRjaChvcHRpb25zPy5mZXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0aGUgc29ja2V0LCB1bmxlc3MgYWxyZWFkeSBjb25uZWN0ZWQuXG4gICAqL1xuICBjb25uZWN0KCk6IHZvaWQge1xuICAgIC8vIFNraXAgaWYgYWxyZWFkeSBjb25uZWN0aW5nLCBkaXNjb25uZWN0aW5nLCBvciBjb25uZWN0ZWRcbiAgICBpZiAoXG4gICAgICB0aGlzLmlzQ29ubmVjdGluZygpIHx8XG4gICAgICB0aGlzLmlzRGlzY29ubmVjdGluZygpIHx8XG4gICAgICAodGhpcy5jb25uICE9PSBudWxsICYmIHRoaXMuaXNDb25uZWN0ZWQoKSlcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnY29ubmVjdGluZycpXG5cbiAgICAvLyBUcmlnZ2VyIGF1dGggaWYgbmVlZGVkIGFuZCBub3QgYWxyZWFkeSBpbiBwcm9ncmVzc1xuICAgIC8vIFRoaXMgZW5zdXJlcyBhdXRoIGlzIGNhbGxlZCBmb3Igc3RhbmRhbG9uZSBSZWFsdGltZUNsaWVudCB1c2FnZVxuICAgIC8vIHdoaWxlIGF2b2lkaW5nIHJhY2UgY29uZGl0aW9ucyB3aXRoIFN1cGFiYXNlQ2xpZW50J3MgaW1tZWRpYXRlIHNldEF1dGggY2FsbFxuICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuICYmICF0aGlzLl9hdXRoUHJvbWlzZSkge1xuICAgICAgdGhpcy5fc2V0QXV0aFNhZmVseSgnY29ubmVjdCcpXG4gICAgfVxuXG4gICAgLy8gRXN0YWJsaXNoIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAvLyBVc2UgY3VzdG9tIHRyYW5zcG9ydCBpZiBwcm92aWRlZFxuICAgICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kcG9pbnRVUkwoKSkgYXMgV2ViU29ja2V0TGlrZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcnkgdG8gdXNlIG5hdGl2ZSBXZWJTb2NrZXRcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY29ubiA9IFdlYlNvY2tldEZhY3RvcnkuY3JlYXRlV2ViU29ja2V0KHRoaXMuZW5kcG9pbnRVUkwoKSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJylcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlXG5cbiAgICAgICAgLy8gUHJvdmlkZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gZW52aXJvbm1lbnRcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnTm9kZS5qcycpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYCR7ZXJyb3JNZXNzYWdlfVxcblxcbmAgK1xuICAgICAgICAgICAgICAnVG8gdXNlIFJlYWx0aW1lIGluIE5vZGUuanMsIHlvdSBuZWVkIHRvIHByb3ZpZGUgYSBXZWJTb2NrZXQgaW1wbGVtZW50YXRpb246XFxuXFxuJyArXG4gICAgICAgICAgICAgICdPcHRpb24gMTogVXNlIE5vZGUuanMgMjIrIHdoaWNoIGhhcyBuYXRpdmUgV2ViU29ja2V0IHN1cHBvcnRcXG4nICtcbiAgICAgICAgICAgICAgJ09wdGlvbiAyOiBJbnN0YWxsIGFuZCBwcm92aWRlIHRoZSBcIndzXCIgcGFja2FnZTpcXG5cXG4nICtcbiAgICAgICAgICAgICAgJyAgbnBtIGluc3RhbGwgd3NcXG5cXG4nICtcbiAgICAgICAgICAgICAgJyAgaW1wb3J0IHdzIGZyb20gXCJ3c1wiXFxuJyArXG4gICAgICAgICAgICAgICcgIGNvbnN0IGNsaWVudCA9IG5ldyBSZWFsdGltZUNsaWVudCh1cmwsIHtcXG4nICtcbiAgICAgICAgICAgICAgJyAgICAuLi5vcHRpb25zLFxcbicgK1xuICAgICAgICAgICAgICAnICAgIHRyYW5zcG9ydDogd3NcXG4nICtcbiAgICAgICAgICAgICAgJyAgfSknXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV2ViU29ja2V0IG5vdCBhdmFpbGFibGU6ICR7ZXJyb3JNZXNzYWdlfWApXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldHVwQ29ubmVjdGlvbkhhbmRsZXJzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBVUkwgb2YgdGhlIHdlYnNvY2tldC5cbiAgICogQHJldHVybnMgc3RyaW5nIFRoZSBVUkwgb2YgdGhlIHdlYnNvY2tldC5cbiAgICovXG4gIGVuZHBvaW50VVJMKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2FwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmFtcywgeyB2c246IHRoaXMudnNuIH0pKVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBjb2RlIEEgbnVtZXJpYyBzdGF0dXMgY29kZSB0byBzZW5kIG9uIGRpc2Nvbm5lY3QuXG4gICAqIEBwYXJhbSByZWFzb24gQSBjdXN0b20gcmVhc29uIGZvciB0aGUgZGlzY29ubmVjdC5cbiAgICovXG4gIGRpc2Nvbm5lY3QoY29kZT86IG51bWJlciwgcmVhc29uPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEaXNjb25uZWN0aW5nKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGluZycsIHRydWUpXG5cbiAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAvLyBTZXR1cCBmYWxsYmFjayB0aW1lciB0byBwcmV2ZW50IGhhbmdpbmcgaW4gZGlzY29ubmVjdGluZyBzdGF0ZVxuICAgICAgY29uc3QgZmFsbGJhY2tUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpXG4gICAgICB9LCAxMDApXG5cbiAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoZmFsbGJhY2tUaW1lcilcbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKVxuICAgICAgfVxuXG4gICAgICAvLyBDbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaWYgY2xvc2UgbWV0aG9kIGV4aXN0c1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbm4uY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uID8/ICcnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGVhcmRvd25Db25uZWN0aW9uKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBjcmVhdGVkIGNoYW5uZWxzXG4gICAqL1xuICBnZXRDaGFubmVscygpOiBSZWFsdGltZUNoYW5uZWxbXSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYSBzaW5nbGUgY2hhbm5lbFxuICAgKiBAcGFyYW0gY2hhbm5lbCBBIFJlYWx0aW1lQ2hhbm5lbCBpbnN0YW5jZVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQ2hhbm5lbChjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwpOiBQcm9taXNlPFJlYWx0aW1lUmVtb3ZlQ2hhbm5lbFJlc3BvbnNlPiB7XG4gICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgY2hhbm5lbC51bnN1YnNjcmliZSgpXG5cbiAgICBpZiAodGhpcy5jaGFubmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXR1c1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhbGwgY2hhbm5lbHNcbiAgICovXG4gIGFzeW5jIHJlbW92ZUFsbENoYW5uZWxzKCk6IFByb21pc2U8UmVhbHRpbWVSZW1vdmVDaGFubmVsUmVzcG9uc2VbXT4ge1xuICAgIGNvbnN0IHZhbHVlc18xID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jaGFubmVscy5tYXAoKGNoYW5uZWwpID0+IGNoYW5uZWwudW5zdWJzY3JpYmUoKSkpXG4gICAgdGhpcy5jaGFubmVscyA9IFtdXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICByZXR1cm4gdmFsdWVzXzFcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSBtZXNzYWdlLlxuICAgKlxuICAgKiBGb3IgY3VzdG9taXplZCBsb2dnaW5nLCBgdGhpcy5sb2dnZXJgIGNhbiBiZSBvdmVycmlkZGVuLlxuICAgKi9cbiAgbG9nKGtpbmQ6IHN0cmluZywgbXNnOiBzdHJpbmcsIGRhdGE/OiBhbnkpIHtcbiAgICB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc29ja2V0LlxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCk6IENPTk5FQ1RJT05fU1RBVEUge1xuICAgIHN3aXRjaCAodGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzpcbiAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuQ29ubmVjdGluZ1xuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46XG4gICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLk9wZW5cbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jbG9zaW5nOlxuICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5DbG9zaW5nXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5DbG9zZWRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaXMgdGhlIGNvbm5lY3Rpb24gaXMgb3Blbi5cbiAgICovXG4gIGlzQ29ubmVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBDT05ORUNUSU9OX1NUQVRFLk9wZW5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgY29ubmVjdGluZy5cbiAgICovXG4gIGlzQ29ubmVjdGluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGluZydcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgZGlzY29ubmVjdGluZy5cbiAgICovXG4gIGlzRGlzY29ubmVjdGluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGluZydcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIChvciByZXVzZXMpIGEge0BsaW5rIFJlYWx0aW1lQ2hhbm5lbH0gZm9yIHRoZSBwcm92aWRlZCB0b3BpYy5cbiAgICpcbiAgICogVG9waWNzIGFyZSBhdXRvbWF0aWNhbGx5IHByZWZpeGVkIHdpdGggYHJlYWx0aW1lOmAgdG8gbWF0Y2ggdGhlIFJlYWx0aW1lIHNlcnZpY2UuXG4gICAqIElmIGEgY2hhbm5lbCB3aXRoIHRoZSBzYW1lIHRvcGljIGFscmVhZHkgZXhpc3RzIGl0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBjcmVhdGluZ1xuICAgKiBhIGR1cGxpY2F0ZSBjb25uZWN0aW9uLlxuICAgKi9cbiAgY2hhbm5lbCh0b3BpYzogc3RyaW5nLCBwYXJhbXM6IFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMgPSB7IGNvbmZpZzoge30gfSk6IFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgY29uc3QgcmVhbHRpbWVUb3BpYyA9IGByZWFsdGltZToke3RvcGljfWBcbiAgICBjb25zdCBleGlzdHMgPSB0aGlzLmdldENoYW5uZWxzKCkuZmluZCgoYzogUmVhbHRpbWVDaGFubmVsKSA9PiBjLnRvcGljID09PSByZWFsdGltZVRvcGljKVxuXG4gICAgaWYgKCFleGlzdHMpIHtcbiAgICAgIGNvbnN0IGNoYW4gPSBuZXcgUmVhbHRpbWVDaGFubmVsKGByZWFsdGltZToke3RvcGljfWAsIHBhcmFtcywgdGhpcylcbiAgICAgIHRoaXMuY2hhbm5lbHMucHVzaChjaGFuKVxuXG4gICAgICByZXR1cm4gY2hhblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXhpc3RzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggb3V0IGEgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICpcbiAgICogSWYgdGhlIHNvY2tldCBpcyBub3QgY29ubmVjdGVkLCB0aGUgbWVzc2FnZSBnZXRzIGVucXVldWVkIHdpdGhpbiBhIGxvY2FsIGJ1ZmZlciwgYW5kIHNlbnQgb3V0IHdoZW4gYSBjb25uZWN0aW9uIGlzIG5leHQgZXN0YWJsaXNoZWQuXG4gICAqL1xuICBwdXNoKGRhdGE6IFJlYWx0aW1lTWVzc2FnZSk6IHZvaWQge1xuICAgIGNvbnN0IHsgdG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYgfSA9IGRhdGFcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgICB0aGlzLmNvbm4/LnNlbmQocmVzdWx0KVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5sb2coJ3B1c2gnLCBgJHt0b3BpY30gJHtldmVudH0gKCR7cmVmfSlgLCBwYXlsb2FkKVxuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIEpXVCBhY2Nlc3MgdG9rZW4gdXNlZCBmb3IgY2hhbm5lbCBzdWJzY3JpcHRpb24gYXV0aG9yaXphdGlvbiBhbmQgUmVhbHRpbWUgUkxTLlxuICAgKlxuICAgKiBJZiBwYXJhbSBpcyBudWxsIGl0IHdpbGwgdXNlIHRoZSBgYWNjZXNzVG9rZW5gIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIHRoZSB0b2tlbiBzZXQgb24gdGhlIGNsaWVudC5cbiAgICpcbiAgICogT24gY2FsbGJhY2sgdXNlZCwgaXQgd2lsbCBzZXQgdGhlIHZhbHVlIG9mIHRoZSB0b2tlbiBpbnRlcm5hbCB0byB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBXaGVuIGEgdG9rZW4gaXMgZXhwbGljaXRseSBwcm92aWRlZCwgaXQgd2lsbCBiZSBwcmVzZXJ2ZWQgYWNyb3NzIGNoYW5uZWwgb3BlcmF0aW9uc1xuICAgKiAoaW5jbHVkaW5nIHJlbW92ZUNoYW5uZWwgYW5kIHJlc3Vic2NyaWJlKS4gVGhlIGBhY2Nlc3NUb2tlbmAgY2FsbGJhY2sgd2lsbCBub3QgYmVcbiAgICogaW52b2tlZCB1bnRpbCBgc2V0QXV0aCgpYCBpcyBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB0b2tlbiBBIEpXVCBzdHJpbmcgdG8gb3ZlcnJpZGUgdGhlIHRva2VuIHNldCBvbiB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBVc2UgYSBtYW51YWwgdG9rZW4gKHByZXNlcnZlZCBhY3Jvc3MgcmVzdWJzY3JpYmVzLCBpZ25vcmVzIGFjY2Vzc1Rva2VuIGNhbGxiYWNrKVxuICAgKiBjbGllbnQucmVhbHRpbWUuc2V0QXV0aCgnbXktY3VzdG9tLWp3dCcpXG4gICAqXG4gICAqIC8vIFN3aXRjaCBiYWNrIHRvIHVzaW5nIHRoZSBhY2Nlc3NUb2tlbiBjYWxsYmFja1xuICAgKiBjbGllbnQucmVhbHRpbWUuc2V0QXV0aCgpXG4gICAqL1xuICBhc3luYyBzZXRBdXRoKHRva2VuOiBzdHJpbmcgfCBudWxsID0gbnVsbCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuX2F1dGhQcm9taXNlID0gdGhpcy5fcGVyZm9ybUF1dGgodG9rZW4pXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX2F1dGhQcm9taXNlXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2F1dGhQcm9taXNlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgYWNjZXNzIHRva2VuIHdhcyBleHBsaWNpdGx5IHNldCB2aWEgc2V0QXV0aCh0b2tlbiksXG4gICAqIGZhbHNlIGlmIGl0IHdhcyBvYnRhaW5lZCB2aWEgdGhlIGFjY2Vzc1Rva2VuIGNhbGxiYWNrLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9pc01hbnVhbFRva2VuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9tYW51YWxseVNldFRva2VuXG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBoZWFydGJlYXQgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICovXG4gIGFzeW5jIHNlbmRIZWFydGJlYXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2soJ2Rpc2Nvbm5lY3RlZCcpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdlcnJvciBpbiBoZWFydGJlYXQgY2FsbGJhY2snLCBlKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGhlYXJ0YmVhdCB0aW1lb3V0IGFuZCBmb3JjZSByZWNvbm5lY3Rpb24gaWYgbmVlZGVkXG4gICAgaWYgKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgICAgdGhpcy5faGVhcnRiZWF0U2VudEF0ID0gbnVsbFxuICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsICdoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvbicpXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrKCd0aW1lb3V0JylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIGluIGhlYXJ0YmVhdCBjYWxsYmFjaycsIGUpXG4gICAgICB9XG5cbiAgICAgIC8vIEZvcmNlIHJlY29ubmVjdGlvbiBhZnRlciBoZWFydGJlYXQgdGltZW91dFxuICAgICAgdGhpcy5fd2FzTWFudWFsRGlzY29ubmVjdCA9IGZhbHNlXG4gICAgICB0aGlzLmNvbm4/LmNsb3NlKFdTX0NMT1NFX05PUk1BTCwgJ2hlYXJ0YmVhdCB0aW1lb3V0JylcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lcj8uc2NoZWR1bGVUaW1lb3V0KClcbiAgICAgICAgfVxuICAgICAgfSwgQ09OTkVDVElPTl9USU1FT1VUUy5IRUFSVEJFQVRfVElNRU9VVF9GQUxMQkFDSylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFNlbmQgaGVhcnRiZWF0IG1lc3NhZ2UgdG8gc2VydmVyXG4gICAgdGhpcy5faGVhcnRiZWF0U2VudEF0ID0gRGF0ZS5ub3coKVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IHRoaXMuX21ha2VSZWYoKVxuICAgIHRoaXMucHVzaCh7XG4gICAgICB0b3BpYzogJ3Bob2VuaXgnLFxuICAgICAgZXZlbnQ6ICdoZWFydGJlYXQnLFxuICAgICAgcGF5bG9hZDoge30sXG4gICAgICByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZixcbiAgICB9KVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrKCdzZW50JylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZygnZXJyb3InLCAnZXJyb3IgaW4gaGVhcnRiZWF0IGNhbGxiYWNrJywgZSlcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRBdXRoU2FmZWx5KCdoZWFydGJlYXQnKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIGxpZmVjeWNsZSBldmVudHMgZm9yIGludGVybmFsIGhlYXJ0YmVhdCBtZXNzYWdlcy5cbiAgICogVXNlZnVsIGZvciBpbnN0cnVtZW50aW5nIGNvbm5lY3Rpb24gaGVhbHRoIChlLmcuIHNlbnQvb2svdGltZW91dC9kaXNjb25uZWN0ZWQpLlxuICAgKi9cbiAgb25IZWFydGJlYXQoY2FsbGJhY2s6IChzdGF0dXM6IEhlYXJ0YmVhdFN0YXR1cywgbGF0ZW5jeT86IG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2sgPSBjYWxsYmFja1xuICB9XG4gIC8qKlxuICAgKiBGbHVzaGVzIHNlbmQgYnVmZmVyXG4gICAqL1xuICBmbHVzaFNlbmRCdWZmZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKVxuICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlIGVpdGhlciBjdXN0b20gZmV0Y2gsIGlmIHByb3ZpZGVkLCBvciBkZWZhdWx0IGZldGNoIHRvIG1ha2UgSFRUUCByZXF1ZXN0c1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4gY3VzdG9tRmV0Y2goLi4uYXJncylcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmV4dCBtZXNzYWdlIHJlZiwgYWNjb3VudGluZyBmb3Igb3ZlcmZsb3dzXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX21ha2VSZWYoKTogc3RyaW5nIHtcbiAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYgKyAxXG4gICAgaWYgKG5ld1JlZiA9PT0gdGhpcy5yZWYpIHtcbiAgICAgIHRoaXMucmVmID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZiA9IG5ld1JlZlxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlZi50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBjaGFubmVscyB3aXRoIHRoZSBzcGVjaWZpZWQgdG9waWMuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2xlYXZlT3BlblRvcGljKHRvcGljOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsZXQgZHVwQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZChcbiAgICAgIChjKSA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5faXNKb2luZWQoKSB8fCBjLl9pc0pvaW5pbmcoKSlcbiAgICApXG4gICAgaWYgKGR1cENoYW5uZWwpIHtcbiAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBgbGVhdmluZyBkdXBsaWNhdGUgdG9waWMgXCIke3RvcGljfVwiYClcbiAgICAgIGR1cENoYW5uZWwudW5zdWJzY3JpYmUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgc3Vic2NyaXB0aW9uIGZyb20gdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIGNoYW5uZWwgQW4gb3BlbiBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3JlbW92ZShjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwpIHtcbiAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy5jaGFubmVscy5maWx0ZXIoKGMpID0+IGMudG9waWMgIT09IGNoYW5uZWwudG9waWMpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX29uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZTogeyBkYXRhOiBhbnkgfSkge1xuICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgKG1zZzogUmVhbHRpbWVNZXNzYWdlKSA9PiB7XG4gICAgICAvLyBIYW5kbGUgaGVhcnRiZWF0IHJlc3BvbnNlc1xuICAgICAgaWYgKFxuICAgICAgICBtc2cudG9waWMgPT09ICdwaG9lbml4JyAmJlxuICAgICAgICBtc2cuZXZlbnQgPT09ICdwaHhfcmVwbHknICYmXG4gICAgICAgIG1zZy5yZWYgJiZcbiAgICAgICAgbXNnLnJlZiA9PT0gdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbGF0ZW5jeSA9IHRoaXMuX2hlYXJ0YmVhdFNlbnRBdCA/IERhdGUubm93KCkgLSB0aGlzLl9oZWFydGJlYXRTZW50QXQgOiB1bmRlZmluZWRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrKG1zZy5wYXlsb2FkLnN0YXR1cyA9PT0gJ29rJyA/ICdvaycgOiAnZXJyb3InLCBsYXRlbmN5KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIGluIGhlYXJ0YmVhdCBjYWxsYmFjaycsIGUpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhcnRiZWF0U2VudEF0ID0gbnVsbFxuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIC8vIExvZyBpbmNvbWluZyBtZXNzYWdlXG4gICAgICBjb25zdCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmIH0gPSBtc2dcbiAgICAgIGNvbnN0IHJlZlN0cmluZyA9IHJlZiA/IGAoJHtyZWZ9KWAgOiAnJ1xuICAgICAgY29uc3Qgc3RhdHVzID0gcGF5bG9hZC5zdGF0dXMgfHwgJydcbiAgICAgIHRoaXMubG9nKCdyZWNlaXZlJywgYCR7c3RhdHVzfSAke3RvcGljfSAke2V2ZW50fSAke3JlZlN0cmluZ31gLnRyaW0oKSwgcGF5bG9hZClcblxuICAgICAgLy8gUm91dGUgbWVzc2FnZSB0byBhcHByb3ByaWF0ZSBjaGFubmVsc1xuICAgICAgdGhpcy5jaGFubmVsc1xuICAgICAgICAuZmlsdGVyKChjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwpID0+IGNoYW5uZWwuX2lzTWVtYmVyKHRvcGljKSlcbiAgICAgICAgLmZvckVhY2goKGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCkgPT4gY2hhbm5lbC5fdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmKSlcblxuICAgICAgdGhpcy5fdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKCdtZXNzYWdlJywgbXNnKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgc3BlY2lmaWMgdGltZXJcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF9jbGVhclRpbWVyKHRpbWVyOiAnaGVhcnRiZWF0JyB8ICdyZWNvbm5lY3QnKTogdm9pZCB7XG4gICAgaWYgKHRpbWVyID09PSAnaGVhcnRiZWF0JyAmJiB0aGlzLmhlYXJ0YmVhdFRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gdW5kZWZpbmVkXG4gICAgfSBlbHNlIGlmICh0aW1lciA9PT0gJ3JlY29ubmVjdCcpIHtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXI/LnJlc2V0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIHRpbWVyc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgX2NsZWFyQWxsVGltZXJzKCk6IHZvaWQge1xuICAgIHRoaXMuX2NsZWFyVGltZXIoJ2hlYXJ0YmVhdCcpXG4gICAgdGhpcy5fY2xlYXJUaW1lcigncmVjb25uZWN0JylcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBjb25uZWN0aW9uIGhhbmRsZXJzIGZvciBXZWJTb2NrZXQgZXZlbnRzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0dXBDb25uZWN0aW9uSGFuZGxlcnMoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNvbm4pIHJldHVyblxuXG4gICAgLy8gU2V0IGJpbmFyeSB0eXBlIGlmIHN1cHBvcnRlZCAoYnJvd3NlcnMgYW5kIG1vc3QgV2ViU29ja2V0IGltcGxlbWVudGF0aW9ucylcbiAgICBpZiAoJ2JpbmFyeVR5cGUnIGluIHRoaXMuY29ubikge1xuICAgICAgOyh0aGlzLmNvbm4gYXMgYW55KS5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICAgIH1cblxuICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLl9vbkNvbm5PcGVuKClcbiAgICB0aGlzLmNvbm4ub25lcnJvciA9IChlcnJvcjogRXZlbnQpID0+IHRoaXMuX29uQ29ubkVycm9yKGVycm9yKVxuICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSAoZXZlbnQ6IGFueSkgPT4gdGhpcy5fb25Db25uTWVzc2FnZShldmVudClcbiAgICB0aGlzLmNvbm4ub25jbG9zZSA9IChldmVudDogYW55KSA9PiB0aGlzLl9vbkNvbm5DbG9zZShldmVudClcblxuICAgIGlmICh0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5vcGVuKSB7XG4gICAgICB0aGlzLl9vbkNvbm5PcGVuKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGVhcmRvd24gY29ubmVjdGlvbiBhbmQgY2xlYW51cCByZXNvdXJjZXNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF90ZWFyZG93bkNvbm5lY3Rpb24oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5vcGVuIHx8XG4gICAgICAgIHRoaXMuY29ubi5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmdcbiAgICAgICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnRXJyb3IgY2xvc2luZyBjb25uZWN0aW9uJywgZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbm4ub25vcGVuID0gbnVsbFxuICAgICAgdGhpcy5jb25uLm9uZXJyb3IgPSBudWxsXG4gICAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gbnVsbFxuICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBudWxsXG4gICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgfVxuICAgIHRoaXMuX2NsZWFyQWxsVGltZXJzKClcbiAgICB0aGlzLl90ZXJtaW5hdGVXb3JrZXIoKVxuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4gY2hhbm5lbC50ZWFyZG93bigpKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9vbkNvbm5PcGVuKCkge1xuICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnY29ubmVjdGVkJylcbiAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgYGNvbm5lY3RlZCB0byAke3RoaXMuZW5kcG9pbnRVUkwoKX1gKVxuXG4gICAgLy8gV2FpdCBmb3IgYW55IHBlbmRpbmcgYXV0aCBvcGVyYXRpb25zIGJlZm9yZSBmbHVzaGluZyBzZW5kIGJ1ZmZlclxuICAgIC8vIFRoaXMgZW5zdXJlcyBjaGFubmVsIGpvaW4gbWVzc2FnZXMgaW5jbHVkZSB0aGUgY29ycmVjdCBhY2Nlc3MgdG9rZW5cbiAgICBjb25zdCBhdXRoUHJvbWlzZSA9XG4gICAgICB0aGlzLl9hdXRoUHJvbWlzZSB8fFxuICAgICAgKHRoaXMuYWNjZXNzVG9rZW4gJiYgIXRoaXMuYWNjZXNzVG9rZW5WYWx1ZSA/IHRoaXMuc2V0QXV0aCgpIDogUHJvbWlzZS5yZXNvbHZlKCkpXG5cbiAgICBhdXRoUHJvbWlzZVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdlcnJvciB3YWl0aW5nIGZvciBhdXRoIG9uIGNvbm5lY3QnLCBlKVxuICAgICAgICAvLyBQcm9jZWVkIGFueXdheSB0byBhdm9pZCBoYW5naW5nIGNvbm5lY3Rpb25zXG4gICAgICAgIHRoaXMuZmx1c2hTZW5kQnVmZmVyKClcbiAgICAgIH0pXG5cbiAgICB0aGlzLl9jbGVhclRpbWVyKCdyZWNvbm5lY3QnKVxuXG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhpcy5fc3RhcnRIZWFydGJlYXQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMud29ya2VyUmVmKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0V29ya2VySGVhcnRiZWF0KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl90cmlnZ2VyU3RhdGVDYWxsYmFja3MoJ29wZW4nKVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfc3RhcnRIZWFydGJlYXQoKSB7XG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX3N0YXJ0V29ya2VySGVhcnRiZWF0KCkge1xuICAgIGlmICh0aGlzLndvcmtlclVybCkge1xuICAgICAgdGhpcy5sb2coJ3dvcmtlcicsIGBzdGFydGluZyB3b3JrZXIgZm9yIGZyb20gJHt0aGlzLndvcmtlclVybH1gKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZygnd29ya2VyJywgYHN0YXJ0aW5nIGRlZmF1bHQgd29ya2VyYClcbiAgICB9XG4gICAgY29uc3Qgb2JqZWN0VXJsID0gdGhpcy5fd29ya2VyT2JqZWN0VXJsKHRoaXMud29ya2VyVXJsISlcbiAgICB0aGlzLndvcmtlclJlZiA9IG5ldyBXb3JrZXIob2JqZWN0VXJsKVxuICAgIHRoaXMud29ya2VyUmVmLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMubG9nKCd3b3JrZXInLCAnd29ya2VyIGVycm9yJywgKGVycm9yIGFzIEVycm9yRXZlbnQpLm1lc3NhZ2UpXG4gICAgICB0aGlzLl90ZXJtaW5hdGVXb3JrZXIoKVxuICAgIH1cbiAgICB0aGlzLndvcmtlclJlZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kYXRhLmV2ZW50ID09PSAna2VlcEFsaXZlJykge1xuICAgICAgICB0aGlzLnNlbmRIZWFydGJlYXQoKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndvcmtlclJlZi5wb3N0TWVzc2FnZSh7XG4gICAgICBldmVudDogJ3N0YXJ0JyxcbiAgICAgIGludGVydmFsOiB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXJtaW5hdGUgdGhlIFdlYiBXb3JrZXIgYW5kIGNsZWFyIHRoZSByZWZlcmVuY2VcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF90ZXJtaW5hdGVXb3JrZXIoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMud29ya2VyUmVmKSB7XG4gICAgICB0aGlzLmxvZygnd29ya2VyJywgJ3Rlcm1pbmF0aW5nIHdvcmtlcicpXG4gICAgICB0aGlzLndvcmtlclJlZi50ZXJtaW5hdGUoKVxuICAgICAgdGhpcy53b3JrZXJSZWYgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9vbkNvbm5DbG9zZShldmVudDogYW55KSB7XG4gICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKVxuICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCAnY2xvc2UnLCBldmVudClcbiAgICB0aGlzLl90cmlnZ2VyQ2hhbkVycm9yKClcbiAgICB0aGlzLl9jbGVhclRpbWVyKCdoZWFydGJlYXQnKVxuXG4gICAgLy8gT25seSBzY2hlZHVsZSByZWNvbm5lY3Rpb24gaWYgaXQgd2Fzbid0IGEgbWFudWFsIGRpc2Nvbm5lY3RcbiAgICBpZiAoIXRoaXMuX3dhc01hbnVhbERpc2Nvbm5lY3QpIHtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXI/LnNjaGVkdWxlVGltZW91dCgpXG4gICAgfVxuXG4gICAgdGhpcy5fdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKCdjbG9zZScsIGV2ZW50KVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9vbkNvbm5FcnJvcihlcnJvcjogRXZlbnQpIHtcbiAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpXG4gICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGAke2Vycm9yfWApXG4gICAgdGhpcy5fdHJpZ2dlckNoYW5FcnJvcigpXG4gICAgdGhpcy5fdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKCdlcnJvcicsIGVycm9yKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrKCdlcnJvcicpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIGluIGhlYXJ0YmVhdCBjYWxsYmFjaycsIGUpXG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF90cmlnZ2VyQ2hhbkVycm9yKCkge1xuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsKSA9PiBjaGFubmVsLl90cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmVycm9yKSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfYXBwZW5kUGFyYW1zKHVybDogc3RyaW5nLCBwYXJhbXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0pOiBzdHJpbmcge1xuICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICBjb25zdCBwcmVmaXggPSB1cmwubWF0Y2goL1xcPy8pID8gJyYnIDogJz8nXG4gICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcylcbiAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7cXVlcnl9YFxuICB9XG5cbiAgcHJpdmF0ZSBfd29ya2VyT2JqZWN0VXJsKHVybDogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgICBsZXQgcmVzdWx0X3VybDogc3RyaW5nXG4gICAgaWYgKHVybCkge1xuICAgICAgcmVzdWx0X3VybCA9IHVybFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW1dPUktFUl9TQ1JJUFRdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KVxuICAgICAgcmVzdWx0X3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdF91cmxcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgY29ubmVjdGlvbiBzdGF0ZSB3aXRoIHByb3BlciBzdGF0ZSBtYW5hZ2VtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0Q29ubmVjdGlvblN0YXRlKHN0YXRlOiBSZWFsdGltZUNsaWVudFN0YXRlLCBtYW51YWwgPSBmYWxzZSk6IHZvaWQge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9IHN0YXRlXG5cbiAgICBpZiAoc3RhdGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgICAgdGhpcy5fd2FzTWFudWFsRGlzY29ubmVjdCA9IGZhbHNlXG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RpbmcnKSB7XG4gICAgICB0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0ID0gbWFudWFsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdGhlIGFjdHVhbCBhdXRoIG9wZXJhdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3BlcmZvcm1BdXRoKHRva2VuOiBzdHJpbmcgfCBudWxsID0gbnVsbCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCB0b2tlblRvU2VuZDogc3RyaW5nIHwgbnVsbFxuICAgIGxldCBpc01hbnVhbFRva2VuID0gZmFsc2VcblxuICAgIGlmICh0b2tlbikge1xuICAgICAgdG9rZW5Ub1NlbmQgPSB0b2tlblxuICAgICAgLy8gVHJhY2sgaWYgdGhpcyBpcyBhIG1hbnVhbGx5LXByb3ZpZGVkIHRva2VuXG4gICAgICBpc01hbnVhbFRva2VuID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAodGhpcy5hY2Nlc3NUb2tlbikge1xuICAgICAgLy8gQ2FsbCB0aGUgYWNjZXNzVG9rZW4gY2FsbGJhY2sgdG8gZ2V0IGZyZXNoIHRva2VuXG4gICAgICB0cnkge1xuICAgICAgICB0b2tlblRvU2VuZCA9IGF3YWl0IHRoaXMuYWNjZXNzVG9rZW4oKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnRXJyb3IgZmV0Y2hpbmcgYWNjZXNzIHRva2VuIGZyb20gY2FsbGJhY2snLCBlKVxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gY2FjaGVkIHZhbHVlIGlmIGNhbGxiYWNrIGZhaWxzXG4gICAgICAgIHRva2VuVG9TZW5kID0gdGhpcy5hY2Nlc3NUb2tlblZhbHVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuVG9TZW5kID0gdGhpcy5hY2Nlc3NUb2tlblZhbHVlXG4gICAgfVxuXG4gICAgLy8gVHJhY2sgd2hldGhlciB0aGlzIHRva2VuIHdhcyBtYW51YWxseSBzZXQgb3IgZmV0Y2hlZCB2aWEgY2FsbGJhY2tcbiAgICBpZiAoaXNNYW51YWxUb2tlbikge1xuICAgICAgdGhpcy5fbWFudWFsbHlTZXRUb2tlbiA9IHRydWVcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgIC8vIElmIHdlIHVzZWQgdGhlIGNhbGxiYWNrLCBjbGVhciB0aGUgbWFudWFsIGZsYWdcbiAgICAgIHRoaXMuX21hbnVhbGx5U2V0VG9rZW4gPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuVmFsdWUgIT0gdG9rZW5Ub1NlbmQpIHtcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW5WYWx1ZSA9IHRva2VuVG9TZW5kXG4gICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRva2VuVG9TZW5kLFxuICAgICAgICAgIHZlcnNpb246IERFRkFVTFRfVkVSU0lPTixcbiAgICAgICAgfVxuXG4gICAgICAgIHRva2VuVG9TZW5kICYmIGNoYW5uZWwudXBkYXRlSm9pblBheWxvYWQocGF5bG9hZClcblxuICAgICAgICBpZiAoY2hhbm5lbC5qb2luZWRPbmNlICYmIGNoYW5uZWwuX2lzSm9pbmVkKCkpIHtcbiAgICAgICAgICBjaGFubmVsLl9wdXNoKENIQU5ORUxfRVZFTlRTLmFjY2Vzc190b2tlbiwge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlblRvU2VuZCxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0IGZvciBhbnkgaW4tZmxpZ2h0IGF1dGggb3BlcmF0aW9ucyB0byBjb21wbGV0ZVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3dhaXRGb3JBdXRoSWZOZWVkZWQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuX2F1dGhQcm9taXNlKSB7XG4gICAgICBhd2FpdCB0aGlzLl9hdXRoUHJvbWlzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTYWZlbHkgY2FsbCBzZXRBdXRoIHdpdGggc3RhbmRhcmRpemVkIGVycm9yIGhhbmRsaW5nXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0QXV0aFNhZmVseShjb250ZXh0ID0gJ2dlbmVyYWwnKTogdm9pZCB7XG4gICAgLy8gT25seSByZWZyZXNoIGF1dGggaWYgdXNpbmcgY2FsbGJhY2stYmFzZWQgdG9rZW5zXG4gICAgaWYgKCF0aGlzLl9pc01hbnVhbFRva2VuKCkpIHtcbiAgICAgIHRoaXMuc2V0QXV0aCgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKCdlcnJvcicsIGBFcnJvciBzZXR0aW5nIGF1dGggaW4gJHtjb250ZXh0fWAsIGUpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIHN0YXRlIGNoYW5nZSBjYWxsYmFja3Mgd2l0aCBwcm9wZXIgZXJyb3IgaGFuZGxpbmdcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF90cmlnZ2VyU3RhdGVDYWxsYmFja3MoZXZlbnQ6IGtleW9mIHR5cGVvZiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLCBkYXRhPzogYW55KTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3NbZXZlbnRdLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FsbGJhY2soZGF0YSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsIGBlcnJvciBpbiAke2V2ZW50fSBjYWxsYmFja2AsIGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2coJ2Vycm9yJywgYGVycm9yIHRyaWdnZXJpbmcgJHtldmVudH0gY2FsbGJhY2tzYCwgZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgcmVjb25uZWN0aW9uIHRpbWVyIHdpdGggcHJvcGVyIGNvbmZpZ3VyYXRpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF9zZXR1cFJlY29ubmVjdGlvblRpbWVyKCk6IHZvaWQge1xuICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3dhaXRGb3JBdXRoSWZOZWVkZWQoKVxuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgICAgIH1cbiAgICAgIH0sIENPTk5FQ1RJT05fVElNRU9VVFMuUkVDT05ORUNUX0RFTEFZKVxuICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcylcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGNsaWVudCBvcHRpb25zIHdpdGggZGVmYXVsdHNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF9pbml0aWFsaXplT3B0aW9ucyhvcHRpb25zPzogUmVhbHRpbWVDbGllbnRPcHRpb25zKTogdm9pZCB7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgdGhpcy50cmFuc3BvcnQgPSBvcHRpb25zPy50cmFuc3BvcnQgPz8gbnVsbFxuICAgIHRoaXMudGltZW91dCA9IG9wdGlvbnM/LnRpbWVvdXQgPz8gREVGQVVMVF9USU1FT1VUXG4gICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID1cbiAgICAgIG9wdGlvbnM/LmhlYXJ0YmVhdEludGVydmFsTXMgPz8gQ09OTkVDVElPTl9USU1FT1VUUy5IRUFSVEJFQVRfSU5URVJWQUxcbiAgICB0aGlzLndvcmtlciA9IG9wdGlvbnM/LndvcmtlciA/PyBmYWxzZVxuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBvcHRpb25zPy5hY2Nlc3NUb2tlbiA/PyBudWxsXG4gICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayA9IG9wdGlvbnM/LmhlYXJ0YmVhdENhbGxiYWNrID8/IG5vb3BcbiAgICB0aGlzLnZzbiA9IG9wdGlvbnM/LnZzbiA/PyBERUZBVUxUX1ZTTlxuXG4gICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXNcbiAgICBpZiAob3B0aW9ucz8ucGFyYW1zKSB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zXG4gICAgaWYgKG9wdGlvbnM/LmxvZ2dlcikgdGhpcy5sb2dnZXIgPSBvcHRpb25zLmxvZ2dlclxuICAgIGlmIChvcHRpb25zPy5sb2dMZXZlbCB8fCBvcHRpb25zPy5sb2dfbGV2ZWwpIHtcbiAgICAgIHRoaXMubG9nTGV2ZWwgPSBvcHRpb25zLmxvZ0xldmVsIHx8IG9wdGlvbnMubG9nX2xldmVsXG4gICAgICB0aGlzLnBhcmFtcyA9IHsgLi4udGhpcy5wYXJhbXMsIGxvZ19sZXZlbDogdGhpcy5sb2dMZXZlbCBhcyBzdHJpbmcgfVxuICAgIH1cblxuICAgIC8vIFNldCB1cCBmdW5jdGlvbnMgd2l0aCBkZWZhdWx0c1xuICAgIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyA9XG4gICAgICBvcHRpb25zPy5yZWNvbm5lY3RBZnRlck1zID8/XG4gICAgICAoKHRyaWVzOiBudW1iZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIFJFQ09OTkVDVF9JTlRFUlZBTFNbdHJpZXMgLSAxXSB8fCBERUZBVUxUX1JFQ09OTkVDVF9GQUxMQkFDS1xuICAgICAgfSlcblxuICAgIHN3aXRjaCAodGhpcy52c24pIHtcbiAgICAgIGNhc2UgVlNOXzFfMF8wOlxuICAgICAgICB0aGlzLmVuY29kZSA9XG4gICAgICAgICAgb3B0aW9ucz8uZW5jb2RlID8/XG4gICAgICAgICAgKChwYXlsb2FkOiBKU09OLCBjYWxsYmFjazogRnVuY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuZGVjb2RlID1cbiAgICAgICAgICBvcHRpb25zPy5kZWNvZGUgPz9cbiAgICAgICAgICAoKHBheWxvYWQ6IHN0cmluZywgY2FsbGJhY2s6IEZ1bmN0aW9uKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5wYXJzZShwYXlsb2FkKSlcbiAgICAgICAgICB9KVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBWU05fMl8wXzA6XG4gICAgICAgIHRoaXMuZW5jb2RlID0gb3B0aW9ucz8uZW5jb2RlID8/IHRoaXMuc2VyaWFsaXplci5lbmNvZGUuYmluZCh0aGlzLnNlcmlhbGl6ZXIpXG4gICAgICAgIHRoaXMuZGVjb2RlID0gb3B0aW9ucz8uZGVjb2RlID8/IHRoaXMuc2VyaWFsaXplci5kZWNvZGUuYmluZCh0aGlzLnNlcmlhbGl6ZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNlcmlhbGl6ZXIgdmVyc2lvbjogJHt0aGlzLnZzbn1gKVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSB3b3JrZXIgc2V0dXBcbiAgICBpZiAodGhpcy53b3JrZXIpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93Lldvcmtlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYiBXb3JrZXIgaXMgbm90IHN1cHBvcnRlZCcpXG4gICAgICB9XG4gICAgICB0aGlzLndvcmtlclVybCA9IG9wdGlvbnM/LndvcmtlclVybFxuICAgIH1cbiAgfVxufVxuIiwgImV4cG9ydCBpbnRlcmZhY2UgSWNlYmVyZ0Vycm9yUmVzcG9uc2Uge1xuICBlcnJvcjoge1xuICAgIG1lc3NhZ2U6IHN0cmluZ1xuICAgIHR5cGU6IHN0cmluZ1xuICAgIGNvZGU6IG51bWJlclxuICAgIHN0YWNrPzogc3RyaW5nW11cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSWNlYmVyZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZWFkb25seSBzdGF0dXM6IG51bWJlclxuICByZWFkb25seSBpY2ViZXJnVHlwZT86IHN0cmluZ1xuICByZWFkb25seSBpY2ViZXJnQ29kZT86IG51bWJlclxuICByZWFkb25seSBkZXRhaWxzPzogdW5rbm93blxuICByZWFkb25seSBpc0NvbW1pdFN0YXRlVW5rbm93bjogYm9vbGVhblxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICBvcHRzOiB7XG4gICAgICBzdGF0dXM6IG51bWJlclxuICAgICAgaWNlYmVyZ1R5cGU/OiBzdHJpbmdcbiAgICAgIGljZWJlcmdDb2RlPzogbnVtYmVyXG4gICAgICBkZXRhaWxzPzogdW5rbm93blxuICAgIH1cbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSWNlYmVyZ0Vycm9yJ1xuICAgIHRoaXMuc3RhdHVzID0gb3B0cy5zdGF0dXNcbiAgICB0aGlzLmljZWJlcmdUeXBlID0gb3B0cy5pY2ViZXJnVHlwZVxuICAgIHRoaXMuaWNlYmVyZ0NvZGUgPSBvcHRzLmljZWJlcmdDb2RlXG4gICAgdGhpcy5kZXRhaWxzID0gb3B0cy5kZXRhaWxzXG5cbiAgICAvLyBEZXRlY3QgQ29tbWl0U3RhdGVVbmtub3duRXhjZXB0aW9uICg1MDAsIDUwMiwgNTA0IGR1cmluZyB0YWJsZSBjb21taXRzKVxuICAgIHRoaXMuaXNDb21taXRTdGF0ZVVua25vd24gPVxuICAgICAgb3B0cy5pY2ViZXJnVHlwZSA9PT0gJ0NvbW1pdFN0YXRlVW5rbm93bkV4Y2VwdGlvbicgfHxcbiAgICAgIChbNTAwLCA1MDIsIDUwNF0uaW5jbHVkZXMob3B0cy5zdGF0dXMpICYmIG9wdHMuaWNlYmVyZ1R5cGU/LmluY2x1ZGVzKCdDb21taXRTdGF0ZScpID09PSB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSA0MDQgTm90IEZvdW5kIGVycm9yLlxuICAgKi9cbiAgaXNOb3RGb3VuZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IDQwNFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSA0MDkgQ29uZmxpY3QgZXJyb3IuXG4gICAqL1xuICBpc0NvbmZsaWN0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gNDA5XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIDQxOSBBdXRoZW50aWNhdGlvbiBUaW1lb3V0IGVycm9yLlxuICAgKi9cbiAgaXNBdXRoZW50aWNhdGlvblRpbWVvdXQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSA0MTlcbiAgfVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBidWlsZFVybChcbiAgYmFzZVVybDogc3RyaW5nLFxuICBwYXRoOiBzdHJpbmcsXG4gIHF1ZXJ5PzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPlxuKTogc3RyaW5nIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVXJsKVxuXG4gIGlmIChxdWVyeSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXJsLnRvU3RyaW5nKClcbn1cbiIsICJpbXBvcnQgeyBJY2ViZXJnRXJyb3IsIHR5cGUgSWNlYmVyZ0Vycm9yUmVzcG9uc2UgfSBmcm9tICcuLi9lcnJvcnMvSWNlYmVyZ0Vycm9yJ1xuaW1wb3J0IHsgYnVpbGRVcmwgfSBmcm9tICcuLi91dGlscy91cmwnXG5pbXBvcnQgdHlwZSB7IEF1dGhDb25maWcsIEh0dHBDbGllbnQsIEh0dHBSZXF1ZXN0LCBIdHRwUmVzcG9uc2UgfSBmcm9tICcuL3R5cGVzJ1xuXG5hc3luYyBmdW5jdGlvbiBidWlsZEF1dGhIZWFkZXJzKGF1dGg/OiBBdXRoQ29uZmlnKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PiB7XG4gIGlmICghYXV0aCB8fCBhdXRoLnR5cGUgPT09ICdub25lJykge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgaWYgKGF1dGgudHlwZSA9PT0gJ2JlYXJlcicpIHtcbiAgICByZXR1cm4geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXV0aC50b2tlbn1gIH1cbiAgfVxuXG4gIGlmIChhdXRoLnR5cGUgPT09ICdoZWFkZXInKSB7XG4gICAgcmV0dXJuIHsgW2F1dGgubmFtZV06IGF1dGgudmFsdWUgfVxuICB9XG5cbiAgaWYgKGF1dGgudHlwZSA9PT0gJ2N1c3RvbScpIHtcbiAgICByZXR1cm4gYXdhaXQgYXV0aC5nZXRIZWFkZXJzKClcbiAgfVxuXG4gIHJldHVybiB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRmV0Y2hDbGllbnQob3B0aW9uczoge1xuICBiYXNlVXJsOiBzdHJpbmdcbiAgYXV0aD86IEF1dGhDb25maWdcbiAgZmV0Y2hJbXBsPzogdHlwZW9mIGZldGNoXG59KTogSHR0cENsaWVudCB7XG4gIGNvbnN0IGZldGNoRm4gPSBvcHRpb25zLmZldGNoSW1wbCA/PyBnbG9iYWxUaGlzLmZldGNoXG5cbiAgcmV0dXJuIHtcbiAgICBhc3luYyByZXF1ZXN0PFQ+KHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhdGgsXG4gICAgICBxdWVyeSxcbiAgICAgIGJvZHksXG4gICAgICBoZWFkZXJzLFxuICAgIH06IEh0dHBSZXF1ZXN0KTogUHJvbWlzZTxIdHRwUmVzcG9uc2U8VD4+IHtcbiAgICAgIGNvbnN0IHVybCA9IGJ1aWxkVXJsKG9wdGlvbnMuYmFzZVVybCwgcGF0aCwgcXVlcnkpXG4gICAgICBjb25zdCBhdXRoSGVhZGVycyA9IGF3YWl0IGJ1aWxkQXV0aEhlYWRlcnMob3B0aW9ucy5hdXRoKVxuXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaEZuKHVybCwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi4oYm9keSA/IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9IDoge30pLFxuICAgICAgICAgIC4uLmF1dGhIZWFkZXJzLFxuICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGJvZHkgPyBKU09OLnN0cmluZ2lmeShib2R5KSA6IHVuZGVmaW5lZCxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpXG4gICAgICBjb25zdCBpc0pzb24gPSAocmVzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJykuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgICAgY29uc3QgZGF0YSA9IGlzSnNvbiAmJiB0ZXh0ID8gKEpTT04ucGFyc2UodGV4dCkgYXMgVCkgOiAodGV4dCBhcyBUKVxuXG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBjb25zdCBlcnJCb2R5ID0gaXNKc29uID8gKGRhdGEgYXMgSWNlYmVyZ0Vycm9yUmVzcG9uc2UpIDogdW5kZWZpbmVkXG4gICAgICAgIGNvbnN0IGVycm9yRGV0YWlsID0gZXJyQm9keT8uZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEljZWJlcmdFcnJvcihcbiAgICAgICAgICBlcnJvckRldGFpbD8ubWVzc2FnZSA/PyBgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXMuc3RhdHVzfWAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgaWNlYmVyZ1R5cGU6IGVycm9yRGV0YWlsPy50eXBlLFxuICAgICAgICAgICAgaWNlYmVyZ0NvZGU6IGVycm9yRGV0YWlsPy5jb2RlLFxuICAgICAgICAgICAgZGV0YWlsczogZXJyQm9keSxcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiByZXMuc3RhdHVzLCBoZWFkZXJzOiByZXMuaGVhZGVycywgZGF0YTogZGF0YSBhcyBUIH1cbiAgICB9LFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBIdHRwQ2xpZW50IH0gZnJvbSAnLi4vaHR0cC90eXBlcydcbmltcG9ydCB7IEljZWJlcmdFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9JY2ViZXJnRXJyb3InXG5pbXBvcnQgdHlwZSB7XG4gIENyZWF0ZU5hbWVzcGFjZVJlcXVlc3QsXG4gIENyZWF0ZU5hbWVzcGFjZVJlc3BvbnNlLFxuICBHZXROYW1lc3BhY2VSZXNwb25zZSxcbiAgTGlzdE5hbWVzcGFjZXNSZXNwb25zZSxcbiAgTmFtZXNwYWNlSWRlbnRpZmllcixcbiAgTmFtZXNwYWNlTWV0YWRhdGEsXG59IGZyb20gJy4vdHlwZXMnXG5cbmZ1bmN0aW9uIG5hbWVzcGFjZVRvUGF0aChuYW1lc3BhY2U6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgcmV0dXJuIG5hbWVzcGFjZS5qb2luKCdcXHgxRicpXG59XG5cbmV4cG9ydCBjbGFzcyBOYW1lc3BhY2VPcGVyYXRpb25zIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBjbGllbnQ6IEh0dHBDbGllbnQsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwcmVmaXg6IHN0cmluZyA9ICcnXG4gICkge31cblxuICBhc3luYyBsaXN0TmFtZXNwYWNlcyhwYXJlbnQ/OiBOYW1lc3BhY2VJZGVudGlmaWVyKTogUHJvbWlzZTxOYW1lc3BhY2VJZGVudGlmaWVyW10+IHtcbiAgICBjb25zdCBxdWVyeSA9IHBhcmVudCA/IHsgcGFyZW50OiBuYW1lc3BhY2VUb1BhdGgocGFyZW50Lm5hbWVzcGFjZSkgfSA6IHVuZGVmaW5lZFxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0PExpc3ROYW1lc3BhY2VzUmVzcG9uc2U+KHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlc2AsXG4gICAgICBxdWVyeSxcbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubmFtZXNwYWNlcy5tYXAoKG5zKSA9PiAoeyBuYW1lc3BhY2U6IG5zIH0pKVxuICB9XG5cbiAgYXN5bmMgY3JlYXRlTmFtZXNwYWNlKFxuICAgIGlkOiBOYW1lc3BhY2VJZGVudGlmaWVyLFxuICAgIG1ldGFkYXRhPzogTmFtZXNwYWNlTWV0YWRhdGFcbiAgKTogUHJvbWlzZTxDcmVhdGVOYW1lc3BhY2VSZXNwb25zZT4ge1xuICAgIGNvbnN0IHJlcXVlc3Q6IENyZWF0ZU5hbWVzcGFjZVJlcXVlc3QgPSB7XG4gICAgICBuYW1lc3BhY2U6IGlkLm5hbWVzcGFjZSxcbiAgICAgIHByb3BlcnRpZXM6IG1ldGFkYXRhPy5wcm9wZXJ0aWVzLFxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdDxDcmVhdGVOYW1lc3BhY2VSZXNwb25zZT4oe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlc2AsXG4gICAgICBib2R5OiByZXF1ZXN0LFxuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICB9XG5cbiAgYXN5bmMgZHJvcE5hbWVzcGFjZShpZDogTmFtZXNwYWNlSWRlbnRpZmllcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Q8dm9pZD4oe1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoKGlkLm5hbWVzcGFjZSl9YCxcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgbG9hZE5hbWVzcGFjZU1ldGFkYXRhKGlkOiBOYW1lc3BhY2VJZGVudGlmaWVyKTogUHJvbWlzZTxOYW1lc3BhY2VNZXRhZGF0YT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdDxHZXROYW1lc3BhY2VSZXNwb25zZT4oe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoKGlkLm5hbWVzcGFjZSl9YCxcbiAgICB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BlcnRpZXM6IHJlc3BvbnNlLmRhdGEucHJvcGVydGllcyxcbiAgICB9XG4gIH1cblxuICBhc3luYyBuYW1lc3BhY2VFeGlzdHMoaWQ6IE5hbWVzcGFjZUlkZW50aWZpZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdDx2b2lkPih7XG4gICAgICAgIG1ldGhvZDogJ0hFQUQnLFxuICAgICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aChpZC5uYW1lc3BhY2UpfWAsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBhc3luYyBjcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyhcbiAgICBpZDogTmFtZXNwYWNlSWRlbnRpZmllcixcbiAgICBtZXRhZGF0YT86IE5hbWVzcGFjZU1ldGFkYXRhXG4gICk6IFByb21pc2U8Q3JlYXRlTmFtZXNwYWNlUmVzcG9uc2UgfCB2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEljZWJlcmdFcnJvciAmJiBlcnJvci5zdGF0dXMgPT09IDQwOSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBIdHRwQ2xpZW50IH0gZnJvbSAnLi4vaHR0cC90eXBlcydcbmltcG9ydCB7IEljZWJlcmdFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9JY2ViZXJnRXJyb3InXG5pbXBvcnQgdHlwZSB7XG4gIENyZWF0ZVRhYmxlUmVxdWVzdCxcbiAgQ29tbWl0VGFibGVSZXNwb25zZSxcbiAgTGlzdFRhYmxlc1Jlc3BvbnNlLFxuICBMb2FkVGFibGVSZXNwb25zZSxcbiAgTmFtZXNwYWNlSWRlbnRpZmllcixcbiAgVGFibGVJZGVudGlmaWVyLFxuICBUYWJsZU1ldGFkYXRhLFxuICBVcGRhdGVUYWJsZVJlcXVlc3QsXG4gIERyb3BUYWJsZVJlcXVlc3QsXG59IGZyb20gJy4vdHlwZXMnXG5cbmZ1bmN0aW9uIG5hbWVzcGFjZVRvUGF0aChuYW1lc3BhY2U6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgcmV0dXJuIG5hbWVzcGFjZS5qb2luKCdcXHgxRicpXG59XG5cbmV4cG9ydCBjbGFzcyBUYWJsZU9wZXJhdGlvbnMge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNsaWVudDogSHR0cENsaWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByZWZpeDogc3RyaW5nID0gJycsXG4gICAgcHJpdmF0ZSByZWFkb25seSBhY2Nlc3NEZWxlZ2F0aW9uPzogc3RyaW5nXG4gICkge31cblxuICBhc3luYyBsaXN0VGFibGVzKG5hbWVzcGFjZTogTmFtZXNwYWNlSWRlbnRpZmllcik6IFByb21pc2U8VGFibGVJZGVudGlmaWVyW10+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Q8TGlzdFRhYmxlc1Jlc3BvbnNlPih7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgobmFtZXNwYWNlLm5hbWVzcGFjZSl9L3RhYmxlc2AsXG4gICAgfSlcblxuICAgIHJldHVybiByZXNwb25zZS5kYXRhLmlkZW50aWZpZXJzXG4gIH1cblxuICBhc3luYyBjcmVhdGVUYWJsZShcbiAgICBuYW1lc3BhY2U6IE5hbWVzcGFjZUlkZW50aWZpZXIsXG4gICAgcmVxdWVzdDogQ3JlYXRlVGFibGVSZXF1ZXN0XG4gICk6IFByb21pc2U8VGFibGVNZXRhZGF0YT4ge1xuICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICAgIGlmICh0aGlzLmFjY2Vzc0RlbGVnYXRpb24pIHtcbiAgICAgIGhlYWRlcnNbJ1gtSWNlYmVyZy1BY2Nlc3MtRGVsZWdhdGlvbiddID0gdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0PExvYWRUYWJsZVJlc3BvbnNlPih7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoKG5hbWVzcGFjZS5uYW1lc3BhY2UpfS90YWJsZXNgLFxuICAgICAgYm9keTogcmVxdWVzdCxcbiAgICAgIGhlYWRlcnMsXG4gICAgfSlcblxuICAgIHJldHVybiByZXNwb25zZS5kYXRhLm1ldGFkYXRhXG4gIH1cblxuICBhc3luYyB1cGRhdGVUYWJsZShpZDogVGFibGVJZGVudGlmaWVyLCByZXF1ZXN0OiBVcGRhdGVUYWJsZVJlcXVlc3QpOiBQcm9taXNlPENvbW1pdFRhYmxlUmVzcG9uc2U+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Q8TG9hZFRhYmxlUmVzcG9uc2U+KHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxuICAgICAgYm9keTogcmVxdWVzdCxcbiAgICB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICdtZXRhZGF0YS1sb2NhdGlvbic6IHJlc3BvbnNlLmRhdGFbJ21ldGFkYXRhLWxvY2F0aW9uJ10sXG4gICAgICBtZXRhZGF0YTogcmVzcG9uc2UuZGF0YS5tZXRhZGF0YSxcbiAgICB9XG4gIH1cblxuICBhc3luYyBkcm9wVGFibGUoaWQ6IFRhYmxlSWRlbnRpZmllciwgb3B0aW9ucz86IERyb3BUYWJsZVJlcXVlc3QpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0PHZvaWQ+KHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aChpZC5uYW1lc3BhY2UpfS90YWJsZXMvJHtpZC5uYW1lfWAsXG4gICAgICBxdWVyeTogeyBwdXJnZVJlcXVlc3RlZDogU3RyaW5nKG9wdGlvbnM/LnB1cmdlID8/IGZhbHNlKSB9LFxuICAgIH0pXG4gIH1cblxuICBhc3luYyBsb2FkVGFibGUoaWQ6IFRhYmxlSWRlbnRpZmllcik6IFByb21pc2U8VGFibGVNZXRhZGF0YT4ge1xuICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICAgIGlmICh0aGlzLmFjY2Vzc0RlbGVnYXRpb24pIHtcbiAgICAgIGhlYWRlcnNbJ1gtSWNlYmVyZy1BY2Nlc3MtRGVsZWdhdGlvbiddID0gdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0PExvYWRUYWJsZVJlc3BvbnNlPih7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxuICAgICAgaGVhZGVycyxcbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubWV0YWRhdGFcbiAgfVxuXG4gIGFzeW5jIHRhYmxlRXhpc3RzKGlkOiBUYWJsZUlkZW50aWZpZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgICBpZiAodGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKSB7XG4gICAgICBoZWFkZXJzWydYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb24nXSA9IHRoaXMuYWNjZXNzRGVsZWdhdGlvblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0PHZvaWQ+KHtcbiAgICAgICAgbWV0aG9kOiAnSEVBRCcsXG4gICAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoKGlkLm5hbWVzcGFjZSl9L3RhYmxlcy8ke2lkLm5hbWV9YCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJY2ViZXJnRXJyb3IgJiYgZXJyb3Iuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMoXG4gICAgbmFtZXNwYWNlOiBOYW1lc3BhY2VJZGVudGlmaWVyLFxuICAgIHJlcXVlc3Q6IENyZWF0ZVRhYmxlUmVxdWVzdFxuICApOiBQcm9taXNlPFRhYmxlTWV0YWRhdGE+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlVGFibGUobmFtZXNwYWNlLCByZXF1ZXN0KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJY2ViZXJnRXJyb3IgJiYgZXJyb3Iuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9hZFRhYmxlKHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UubmFtZXNwYWNlLCBuYW1lOiByZXF1ZXN0Lm5hbWUgfSlcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgY3JlYXRlRmV0Y2hDbGllbnQgfSBmcm9tICcuLi9odHRwL2NyZWF0ZUZldGNoQ2xpZW50J1xuaW1wb3J0IHR5cGUgeyBBdXRoQ29uZmlnLCBIdHRwQ2xpZW50IH0gZnJvbSAnLi4vaHR0cC90eXBlcydcbmltcG9ydCB7IE5hbWVzcGFjZU9wZXJhdGlvbnMgfSBmcm9tICcuL25hbWVzcGFjZXMnXG5pbXBvcnQgeyBUYWJsZU9wZXJhdGlvbnMgfSBmcm9tICcuL3RhYmxlcydcbmltcG9ydCB0eXBlIHtcbiAgQ3JlYXRlVGFibGVSZXF1ZXN0LFxuICBDcmVhdGVOYW1lc3BhY2VSZXNwb25zZSxcbiAgQ29tbWl0VGFibGVSZXNwb25zZSxcbiAgTmFtZXNwYWNlSWRlbnRpZmllcixcbiAgTmFtZXNwYWNlTWV0YWRhdGEsXG4gIFRhYmxlSWRlbnRpZmllcixcbiAgVGFibGVNZXRhZGF0YSxcbiAgVXBkYXRlVGFibGVSZXF1ZXN0LFxuICBEcm9wVGFibGVSZXF1ZXN0LFxufSBmcm9tICcuL3R5cGVzJ1xuXG4vKipcbiAqIEFjY2VzcyBkZWxlZ2F0aW9uIG1lY2hhbmlzbXMgc3VwcG9ydGVkIGJ5IHRoZSBJY2ViZXJnIFJFU1QgQ2F0YWxvZy5cbiAqXG4gKiAtIGB2ZW5kZWQtY3JlZGVudGlhbHNgOiBTZXJ2ZXIgcHJvdmlkZXMgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIGZvciBkYXRhIGFjY2Vzc1xuICogLSBgcmVtb3RlLXNpZ25pbmdgOiBTZXJ2ZXIgc2lnbnMgcmVxdWVzdHMgb24gYmVoYWxmIG9mIHRoZSBjbGllbnRcbiAqL1xuZXhwb3J0IHR5cGUgQWNjZXNzRGVsZWdhdGlvbiA9ICd2ZW5kZWQtY3JlZGVudGlhbHMnIHwgJ3JlbW90ZS1zaWduaW5nJ1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEljZWJlcmcgUkVTVCBDYXRhbG9nIGNsaWVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJY2ViZXJnUmVzdENhdGFsb2dPcHRpb25zIHtcbiAgLyoqIEJhc2UgVVJMIG9mIHRoZSBJY2ViZXJnIFJFU1QgQ2F0YWxvZyBBUEkgKi9cbiAgYmFzZVVybDogc3RyaW5nXG4gIC8qKiBPcHRpb25hbCBjYXRhbG9nIG5hbWUgcHJlZml4IGZvciBtdWx0aS1jYXRhbG9nIHNlcnZlcnMgKi9cbiAgY2F0YWxvZ05hbWU/OiBzdHJpbmdcbiAgLyoqIEF1dGhlbnRpY2F0aW9uIGNvbmZpZ3VyYXRpb24gKi9cbiAgYXV0aD86IEF1dGhDb25maWdcbiAgLyoqIEN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvbiAoZGVmYXVsdHMgdG8gZ2xvYmFsVGhpcy5mZXRjaCkgKi9cbiAgZmV0Y2g/OiB0eXBlb2YgZmV0Y2hcbiAgLyoqXG4gICAqIEFjY2VzcyBkZWxlZ2F0aW9uIG1lY2hhbmlzbXMgdG8gcmVxdWVzdCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqIFdoZW4gc3BlY2lmaWVkLCB0aGUgWC1JY2ViZXJnLUFjY2Vzcy1EZWxlZ2F0aW9uIGhlYWRlciB3aWxsIGJlIHNlbnRcbiAgICogd2l0aCBzdXBwb3J0ZWQgb3BlcmF0aW9ucyAoY3JlYXRlVGFibGUsIGxvYWRUYWJsZSkuXG4gICAqXG4gICAqIEBleGFtcGxlIFsndmVuZGVkLWNyZWRlbnRpYWxzJ11cbiAgICogQGV4YW1wbGUgWyd2ZW5kZWQtY3JlZGVudGlhbHMnLCAncmVtb3RlLXNpZ25pbmcnXVxuICAgKi9cbiAgYWNjZXNzRGVsZWdhdGlvbj86IEFjY2Vzc0RlbGVnYXRpb25bXVxufVxuXG4vKipcbiAqIENsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbiBBcGFjaGUgSWNlYmVyZyBSRVNUIENhdGFsb2cuXG4gKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBtZXRob2RzIGZvciBtYW5hZ2luZyBuYW1lc3BhY2VzIGFuZCB0YWJsZXMgaW4gYW4gSWNlYmVyZyBjYXRhbG9nLlxuICogSXQgaGFuZGxlcyBhdXRoZW50aWNhdGlvbiwgcmVxdWVzdCBmb3JtYXR0aW5nLCBhbmQgZXJyb3IgaGFuZGxpbmcgYXV0b21hdGljYWxseS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgY2F0YWxvZyA9IG5ldyBJY2ViZXJnUmVzdENhdGFsb2coe1xuICogICBiYXNlVXJsOiAnaHR0cHM6Ly9teS1jYXRhbG9nLmV4YW1wbGUuY29tL2ljZWJlcmcvdjEnLFxuICogICBhdXRoOiB7IHR5cGU6ICdiZWFyZXInLCB0b2tlbjogcHJvY2Vzcy5lbnYuSUNFQkVSR19UT0tFTiB9XG4gKiB9KTtcbiAqXG4gKiAvLyBDcmVhdGUgYSBuYW1lc3BhY2VcbiAqIGF3YWl0IGNhdGFsb2cuY3JlYXRlTmFtZXNwYWNlKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICpcbiAqIC8vIENyZWF0ZSBhIHRhYmxlXG4gKiBhd2FpdCBjYXRhbG9nLmNyZWF0ZVRhYmxlKFxuICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9LFxuICogICB7XG4gKiAgICAgbmFtZTogJ2V2ZW50cycsXG4gKiAgICAgc2NoZW1hOiB7IHR5cGU6ICdzdHJ1Y3QnLCBmaWVsZHM6IFsuLi5dIH1cbiAqICAgfVxuICogKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSWNlYmVyZ1Jlc3RDYXRhbG9nIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjbGllbnQ6IEh0dHBDbGllbnRcbiAgcHJpdmF0ZSByZWFkb25seSBuYW1lc3BhY2VPcHM6IE5hbWVzcGFjZU9wZXJhdGlvbnNcbiAgcHJpdmF0ZSByZWFkb25seSB0YWJsZU9wczogVGFibGVPcGVyYXRpb25zXG4gIHByaXZhdGUgcmVhZG9ubHkgYWNjZXNzRGVsZWdhdGlvbj86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEljZWJlcmcgUkVTVCBDYXRhbG9nIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjYXRhbG9nIGNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9uczogSWNlYmVyZ1Jlc3RDYXRhbG9nT3B0aW9ucykge1xuICAgIGxldCBwcmVmaXggPSAndjEnXG4gICAgaWYgKG9wdGlvbnMuY2F0YWxvZ05hbWUpIHtcbiAgICAgIHByZWZpeCArPSBgLyR7b3B0aW9ucy5jYXRhbG9nTmFtZX1gXG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybC5lbmRzV2l0aCgnLycpID8gb3B0aW9ucy5iYXNlVXJsIDogYCR7b3B0aW9ucy5iYXNlVXJsfS9gXG5cbiAgICB0aGlzLmNsaWVudCA9IGNyZWF0ZUZldGNoQ2xpZW50KHtcbiAgICAgIGJhc2VVcmwsXG4gICAgICBhdXRoOiBvcHRpb25zLmF1dGgsXG4gICAgICBmZXRjaEltcGw6IG9wdGlvbnMuZmV0Y2gsXG4gICAgfSlcblxuICAgIC8vIEZvcm1hdCBhY2Nlc3NEZWxlZ2F0aW9uIGFzIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcgcGVyIHNwZWNcbiAgICB0aGlzLmFjY2Vzc0RlbGVnYXRpb24gPSBvcHRpb25zLmFjY2Vzc0RlbGVnYXRpb24/LmpvaW4oJywnKVxuXG4gICAgdGhpcy5uYW1lc3BhY2VPcHMgPSBuZXcgTmFtZXNwYWNlT3BlcmF0aW9ucyh0aGlzLmNsaWVudCwgcHJlZml4KVxuICAgIHRoaXMudGFibGVPcHMgPSBuZXcgVGFibGVPcGVyYXRpb25zKHRoaXMuY2xpZW50LCBwcmVmaXgsIHRoaXMuYWNjZXNzRGVsZWdhdGlvbilcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgbmFtZXNwYWNlcyBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCAtIE9wdGlvbmFsIHBhcmVudCBuYW1lc3BhY2UgdG8gbGlzdCBjaGlsZHJlbiB1bmRlclxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBuYW1lc3BhY2UgaWRlbnRpZmllcnNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiAvLyBMaXN0IGFsbCB0b3AtbGV2ZWwgbmFtZXNwYWNlc1xuICAgKiBjb25zdCBuYW1lc3BhY2VzID0gYXdhaXQgY2F0YWxvZy5saXN0TmFtZXNwYWNlcygpO1xuICAgKlxuICAgKiAvLyBMaXN0IG5hbWVzcGFjZXMgdW5kZXIgYSBwYXJlbnRcbiAgICogY29uc3QgY2hpbGRyZW4gPSBhd2FpdCBjYXRhbG9nLmxpc3ROYW1lc3BhY2VzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxpc3ROYW1lc3BhY2VzKHBhcmVudD86IE5hbWVzcGFjZUlkZW50aWZpZXIpOiBQcm9taXNlPE5hbWVzcGFjZUlkZW50aWZpZXJbXT4ge1xuICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZU9wcy5saXN0TmFtZXNwYWNlcyhwYXJlbnQpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBuYW1lc3BhY2UgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSBPcHRpb25hbCBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgbmFtZXNwYWNlXG4gICAqIEByZXR1cm5zIFJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIGNyZWF0ZWQgbmFtZXNwYWNlIGFuZCBpdHMgcHJvcGVydGllc1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVOYW1lc3BhY2UoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7IHByb3BlcnRpZXM6IHsgb3duZXI6ICdkYXRhLXRlYW0nIH0gfVxuICAgKiApO1xuICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS5uYW1lc3BhY2UpOyAvLyBbJ2FuYWx5dGljcyddXG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlLnByb3BlcnRpZXMpOyAvLyB7IG93bmVyOiAnZGF0YS10ZWFtJywgLi4uIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVOYW1lc3BhY2UoaWQ6IE5hbWVzcGFjZUlkZW50aWZpZXIsIG1ldGFkYXRhPzogTmFtZXNwYWNlTWV0YWRhdGEpOiBQcm9taXNlPENyZWF0ZU5hbWVzcGFjZVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpXG4gIH1cblxuICAvKipcbiAgICogRHJvcHMgYSBuYW1lc3BhY2UgZnJvbSB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogVGhlIG5hbWVzcGFjZSBtdXN0IGJlIGVtcHR5IChjb250YWluIG5vIHRhYmxlcykgYmVmb3JlIGl0IGNhbiBiZSBkcm9wcGVkLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBOYW1lc3BhY2UgaWRlbnRpZmllciB0byBkcm9wXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogYXdhaXQgY2F0YWxvZy5kcm9wTmFtZXNwYWNlKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGRyb3BOYW1lc3BhY2UoaWQ6IE5hbWVzcGFjZUlkZW50aWZpZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLm5hbWVzcGFjZU9wcy5kcm9wTmFtZXNwYWNlKGlkKVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIG1ldGFkYXRhIGZvciBhIG5hbWVzcGFjZS5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gbG9hZFxuICAgKiBAcmV0dXJucyBOYW1lc3BhY2UgbWV0YWRhdGEgaW5jbHVkaW5nIHByb3BlcnRpZXNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cubG9hZE5hbWVzcGFjZU1ldGFkYXRhKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBjb25zb2xlLmxvZyhtZXRhZGF0YS5wcm9wZXJ0aWVzKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsb2FkTmFtZXNwYWNlTWV0YWRhdGEoaWQ6IE5hbWVzcGFjZUlkZW50aWZpZXIpOiBQcm9taXNlPE5hbWVzcGFjZU1ldGFkYXRhPiB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmxvYWROYW1lc3BhY2VNZXRhZGF0YShpZClcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgdGFibGVzIGluIGEgbmFtZXNwYWNlLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gbGlzdCB0YWJsZXMgZnJvbVxuICAgKiBAcmV0dXJucyBBcnJheSBvZiB0YWJsZSBpZGVudGlmaWVyc1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHRhYmxlcyA9IGF3YWl0IGNhdGFsb2cubGlzdFRhYmxlcyh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogY29uc29sZS5sb2codGFibGVzKTsgLy8gW3sgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddLCBuYW1lOiAnZXZlbnRzJyB9LCAuLi5dXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgbGlzdFRhYmxlcyhuYW1lc3BhY2U6IE5hbWVzcGFjZUlkZW50aWZpZXIpOiBQcm9taXNlPFRhYmxlSWRlbnRpZmllcltdPiB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVPcHMubGlzdFRhYmxlcyhuYW1lc3BhY2UpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0YWJsZSBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIE5hbWVzcGFjZSB0byBjcmVhdGUgdGhlIHRhYmxlIGluXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gVGFibGUgY3JlYXRpb24gcmVxdWVzdCBpbmNsdWRpbmcgbmFtZSwgc2NoZW1hLCBwYXJ0aXRpb24gc3BlYywgZXRjLlxuICAgKiBAcmV0dXJucyBUYWJsZSBtZXRhZGF0YSBmb3IgdGhlIGNyZWF0ZWQgdGFibGVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cuY3JlYXRlVGFibGUoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7XG4gICAqICAgICBuYW1lOiAnZXZlbnRzJyxcbiAgICogICAgIHNjaGVtYToge1xuICAgKiAgICAgICB0eXBlOiAnc3RydWN0JyxcbiAgICogICAgICAgZmllbGRzOiBbXG4gICAqICAgICAgICAgeyBpZDogMSwgbmFtZTogJ2lkJywgdHlwZTogJ2xvbmcnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgKiAgICAgICAgIHsgaWQ6IDIsIG5hbWU6ICd0aW1lc3RhbXAnLCB0eXBlOiAndGltZXN0YW1wJywgcmVxdWlyZWQ6IHRydWUgfVxuICAgKiAgICAgICBdLFxuICAgKiAgICAgICAnc2NoZW1hLWlkJzogMFxuICAgKiAgICAgfSxcbiAgICogICAgICdwYXJ0aXRpb24tc3BlYyc6IHtcbiAgICogICAgICAgJ3NwZWMtaWQnOiAwLFxuICAgKiAgICAgICBmaWVsZHM6IFtcbiAgICogICAgICAgICB7IHNvdXJjZV9pZDogMiwgZmllbGRfaWQ6IDEwMDAsIG5hbWU6ICd0c19kYXknLCB0cmFuc2Zvcm06ICdkYXknIH1cbiAgICogICAgICAgXVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVUYWJsZShcbiAgICBuYW1lc3BhY2U6IE5hbWVzcGFjZUlkZW50aWZpZXIsXG4gICAgcmVxdWVzdDogQ3JlYXRlVGFibGVSZXF1ZXN0XG4gICk6IFByb21pc2U8VGFibGVNZXRhZGF0YT4ge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmNyZWF0ZVRhYmxlKG5hbWVzcGFjZSwgcmVxdWVzdClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIHRhYmxlJ3MgbWV0YWRhdGEuXG4gICAqXG4gICAqIENhbiB1cGRhdGUgdGhlIHNjaGVtYSwgcGFydGl0aW9uIHNwZWMsIG9yIHByb3BlcnRpZXMgb2YgYSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGFibGUgaWRlbnRpZmllciB0byB1cGRhdGVcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBVcGRhdGUgcmVxdWVzdCB3aXRoIGZpZWxkcyB0byBtb2RpZnlcbiAgICogQHJldHVybnMgUmVzcG9uc2UgY29udGFpbmluZyB0aGUgbWV0YWRhdGEgbG9jYXRpb24gYW5kIHVwZGF0ZWQgdGFibGUgbWV0YWRhdGFcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhdGFsb2cudXBkYXRlVGFibGUoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0sXG4gICAqICAge1xuICAgKiAgICAgcHJvcGVydGllczogeyAncmVhZC5zcGxpdC50YXJnZXQtc2l6ZSc6ICcxMzQyMTc3MjgnIH1cbiAgICogICB9XG4gICAqICk7XG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlWydtZXRhZGF0YS1sb2NhdGlvbiddKTsgLy8gczM6Ly8uLi5cbiAgICogY29uc29sZS5sb2cocmVzcG9uc2UubWV0YWRhdGEpOyAvLyBUYWJsZU1ldGFkYXRhIG9iamVjdFxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHVwZGF0ZVRhYmxlKGlkOiBUYWJsZUlkZW50aWZpZXIsIHJlcXVlc3Q6IFVwZGF0ZVRhYmxlUmVxdWVzdCk6IFByb21pc2U8Q29tbWl0VGFibGVSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLnVwZGF0ZVRhYmxlKGlkLCByZXF1ZXN0KVxuICB9XG5cbiAgLyoqXG4gICAqIERyb3BzIGEgdGFibGUgZnJvbSB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGFibGUgaWRlbnRpZmllciB0byBkcm9wXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogYXdhaXQgY2F0YWxvZy5kcm9wVGFibGUoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGRyb3BUYWJsZShpZDogVGFibGVJZGVudGlmaWVyLCBvcHRpb25zPzogRHJvcFRhYmxlUmVxdWVzdCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMudGFibGVPcHMuZHJvcFRhYmxlKGlkLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIG1ldGFkYXRhIGZvciBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBUYWJsZSBpZGVudGlmaWVyIHRvIGxvYWRcbiAgICogQHJldHVybnMgVGFibGUgbWV0YWRhdGEgaW5jbHVkaW5nIHNjaGVtYSwgcGFydGl0aW9uIHNwZWMsIGxvY2F0aW9uLCBldGMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYXRhbG9nLmxvYWRUYWJsZSh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSwgbmFtZTogJ2V2ZW50cycgfSk7XG4gICAqIGNvbnNvbGUubG9nKG1ldGFkYXRhLnNjaGVtYSk7XG4gICAqIGNvbnNvbGUubG9nKG1ldGFkYXRhLmxvY2F0aW9uKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsb2FkVGFibGUoaWQ6IFRhYmxlSWRlbnRpZmllcik6IFByb21pc2U8VGFibGVNZXRhZGF0YT4ge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmxvYWRUYWJsZShpZClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBuYW1lc3BhY2UgZXhpc3RzIGluIHRoZSBjYXRhbG9nLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBOYW1lc3BhY2UgaWRlbnRpZmllciB0byBjaGVja1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBuYW1lc3BhY2UgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBleGlzdHMgPSBhd2FpdCBjYXRhbG9nLm5hbWVzcGFjZUV4aXN0cyh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogY29uc29sZS5sb2coZXhpc3RzKTsgLy8gdHJ1ZSBvciBmYWxzZVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIG5hbWVzcGFjZUV4aXN0cyhpZDogTmFtZXNwYWNlSWRlbnRpZmllcik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZU9wcy5uYW1lc3BhY2VFeGlzdHMoaWQpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgdGFibGUgZXhpc3RzIGluIHRoZSBjYXRhbG9nLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBUYWJsZSBpZGVudGlmaWVyIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRhYmxlIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgZXhpc3RzID0gYXdhaXQgY2F0YWxvZy50YWJsZUV4aXN0cyh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSwgbmFtZTogJ2V2ZW50cycgfSk7XG4gICAqIGNvbnNvbGUubG9nKGV4aXN0cyk7IC8vIHRydWUgb3IgZmFsc2VcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyB0YWJsZUV4aXN0cyhpZDogVGFibGVJZGVudGlmaWVyKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVPcHMudGFibGVFeGlzdHMoaWQpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5hbWVzcGFjZSBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogSWYgdGhlIG5hbWVzcGFjZSBhbHJlYWR5IGV4aXN0cywgcmV0dXJucyB2b2lkLiBJZiBjcmVhdGVkLCByZXR1cm5zIHRoZSByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIE9wdGlvbmFsIG1ldGFkYXRhIHByb3BlcnRpZXMgZm9yIHRoZSBuYW1lc3BhY2VcbiAgICogQHJldHVybnMgUmVzcG9uc2UgY29udGFpbmluZyB0aGUgY3JlYXRlZCBuYW1lc3BhY2UgYW5kIGl0cyBwcm9wZXJ0aWVzLCBvciB2b2lkIGlmIGl0IGFscmVhZHkgZXhpc3RzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZUlmTm90RXhpc3RzKFxuICAgKiAgIHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0sXG4gICAqICAgeyBwcm9wZXJ0aWVzOiB7IG93bmVyOiAnZGF0YS10ZWFtJyB9IH1cbiAgICogKTtcbiAgICogaWYgKHJlc3BvbnNlKSB7XG4gICAqICAgY29uc29sZS5sb2coJ0NyZWF0ZWQ6JywgcmVzcG9uc2UubmFtZXNwYWNlKTtcbiAgICogfSBlbHNlIHtcbiAgICogICBjb25zb2xlLmxvZygnQWxyZWFkeSBleGlzdHMnKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZU5hbWVzcGFjZUlmTm90RXhpc3RzKFxuICAgIGlkOiBOYW1lc3BhY2VJZGVudGlmaWVyLFxuICAgIG1ldGFkYXRhPzogTmFtZXNwYWNlTWV0YWRhdGFcbiAgKTogUHJvbWlzZTxDcmVhdGVOYW1lc3BhY2VSZXNwb25zZSB8IHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMuY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoaWQsIG1ldGFkYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0YWJsZSBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogSWYgdGhlIHRhYmxlIGFscmVhZHkgZXhpc3RzLCByZXR1cm5zIGl0cyBtZXRhZGF0YSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gTmFtZXNwYWNlIHRvIGNyZWF0ZSB0aGUgdGFibGUgaW5cbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUYWJsZSBjcmVhdGlvbiByZXF1ZXN0IGluY2x1ZGluZyBuYW1lLCBzY2hlbWEsIHBhcnRpdGlvbiBzcGVjLCBldGMuXG4gICAqIEByZXR1cm5zIFRhYmxlIG1ldGFkYXRhIGZvciB0aGUgY3JlYXRlZCBvciBleGlzdGluZyB0YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZUlmTm90RXhpc3RzKFxuICAgKiAgIHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0sXG4gICAqICAge1xuICAgKiAgICAgbmFtZTogJ2V2ZW50cycsXG4gICAqICAgICBzY2hlbWE6IHtcbiAgICogICAgICAgdHlwZTogJ3N0cnVjdCcsXG4gICAqICAgICAgIGZpZWxkczogW1xuICAgKiAgICAgICAgIHsgaWQ6IDEsIG5hbWU6ICdpZCcsIHR5cGU6ICdsb25nJywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICogICAgICAgICB7IGlkOiAyLCBuYW1lOiAndGltZXN0YW1wJywgdHlwZTogJ3RpbWVzdGFtcCcsIHJlcXVpcmVkOiB0cnVlIH1cbiAgICogICAgICAgXSxcbiAgICogICAgICAgJ3NjaGVtYS1pZCc6IDBcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqICk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVGFibGVJZk5vdEV4aXN0cyhcbiAgICBuYW1lc3BhY2U6IE5hbWVzcGFjZUlkZW50aWZpZXIsXG4gICAgcmVxdWVzdDogQ3JlYXRlVGFibGVSZXF1ZXN0XG4gICk6IFByb21pc2U8VGFibGVNZXRhZGF0YT4ge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMobmFtZXNwYWNlLCByZXF1ZXN0KVxuICB9XG59XG4iLCAiZXhwb3J0IGludGVyZmFjZSBOYW1lc3BhY2VJZGVudGlmaWVyIHtcbiAgbmFtZXNwYWNlOiBzdHJpbmdbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hbWVzcGFjZU1ldGFkYXRhIHtcbiAgcHJvcGVydGllczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlSWRlbnRpZmllciB7XG4gIG5hbWVzcGFjZTogc3RyaW5nW11cbiAgbmFtZTogc3RyaW5nXG59XG5cbi8qKlxuICogUHJpbWl0aXZlIHR5cGVzIGluIEljZWJlcmcgLSBhbGwgcmVwcmVzZW50ZWQgYXMgc3RyaW5ncy5cbiAqIFBhcmFtZXRlcml6ZWQgdHlwZXMgdXNlIHN0cmluZyBmb3JtYXQ6IGRlY2ltYWwocHJlY2lzaW9uLHNjYWxlKSBhbmQgZml4ZWRbbGVuZ3RoXVxuICpcbiAqIE5vdGU6IFRoZSBPcGVuQVBJIHNwZWMgZGVmaW5lcyBQcmltaXRpdmVUeXBlIGFzIGB0eXBlOiBzdHJpbmdgLCBzbyBhbnkgc3RyaW5nIGlzIHZhbGlkLlxuICogV2UgaW5jbHVkZSBrbm93biB0eXBlcyBmb3IgYXV0b2NvbXBsZXRlLCBwbHVzIGEgY2F0Y2gtYWxsIGZvciBmbGV4aWJpbGl0eS5cbiAqL1xuZXhwb3J0IHR5cGUgUHJpbWl0aXZlVHlwZSA9XG4gIHwgJ2Jvb2xlYW4nXG4gIHwgJ2ludCdcbiAgfCAnbG9uZydcbiAgfCAnZmxvYXQnXG4gIHwgJ2RvdWJsZSdcbiAgfCAnc3RyaW5nJ1xuICB8ICd0aW1lc3RhbXAnXG4gIHwgJ2RhdGUnXG4gIHwgJ3RpbWUnXG4gIHwgJ3RpbWVzdGFtcHR6J1xuICB8ICd1dWlkJ1xuICB8ICdiaW5hcnknXG4gIHwgYGRlY2ltYWwoJHtudW1iZXJ9LCR7bnVtYmVyfSlgXG4gIHwgYGZpeGVkWyR7bnVtYmVyfV1gXG4gIHwgKHN0cmluZyAmIHt9KSAvLyBjYXRjaC1hbGwgZm9yIGFueSBmb3JtYXQgKGUuZy4sIFwiZGVjaW1hbCgxMCwgMilcIiB3aXRoIHNwYWNlcykgYW5kIGZ1dHVyZSB0eXBlc1xuXG4vKipcbiAqIFJlZ2V4IHBhdHRlcm5zIGZvciBwYXJzaW5nIHBhcmFtZXRlcml6ZWQgdHlwZXMuXG4gKiBUaGVzZSBhbGxvdyBmbGV4aWJsZSB3aGl0ZXNwYWNlIG1hdGNoaW5nLlxuICovXG5jb25zdCBERUNJTUFMX1JFR0VYID0gL15kZWNpbWFsXFxzKlxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqXFwpJC9cbmNvbnN0IEZJWEVEX1JFR0VYID0gL15maXhlZFxccypcXFtcXHMqKFxcZCspXFxzKlxcXSQvXG5cbi8qKlxuICogUGFyc2UgYSBkZWNpbWFsIHR5cGUgc3RyaW5nIGludG8gaXRzIGNvbXBvbmVudHMuXG4gKiBIYW5kbGVzIGFueSB3aGl0ZXNwYWNlIGZvcm1hdHRpbmcgKGUuZy4sIFwiZGVjaW1hbCgxMCwyKVwiLCBcImRlY2ltYWwoMTAsIDIpXCIsIFwiZGVjaW1hbCggMTAgLCAyIClcIikuXG4gKlxuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBzdHJpbmcgdG8gcGFyc2VcbiAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHByZWNpc2lvbiBhbmQgc2NhbGUsIG9yIG51bGwgaWYgbm90IGEgdmFsaWQgZGVjaW1hbCB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURlY2ltYWxUeXBlKHR5cGU6IHN0cmluZyk6IHsgcHJlY2lzaW9uOiBudW1iZXI7IHNjYWxlOiBudW1iZXIgfSB8IG51bGwge1xuICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goREVDSU1BTF9SRUdFWClcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHtcbiAgICBwcmVjaXNpb246IHBhcnNlSW50KG1hdGNoWzFdLCAxMCksXG4gICAgc2NhbGU6IHBhcnNlSW50KG1hdGNoWzJdLCAxMCksXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIGZpeGVkIHR5cGUgc3RyaW5nIGludG8gaXRzIGxlbmd0aC5cbiAqIEhhbmRsZXMgYW55IHdoaXRlc3BhY2UgZm9ybWF0dGluZyAoZS5nLiwgXCJmaXhlZFsxNl1cIiwgXCJmaXhlZFsgMTYgXVwiKS5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHN0cmluZyB0byBwYXJzZVxuICogQHJldHVybnMgT2JqZWN0IHdpdGggbGVuZ3RoLCBvciBudWxsIGlmIG5vdCBhIHZhbGlkIGZpeGVkIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRml4ZWRUeXBlKHR5cGU6IHN0cmluZyk6IHsgbGVuZ3RoOiBudW1iZXIgfSB8IG51bGwge1xuICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goRklYRURfUkVHRVgpXG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsXG4gIHJldHVybiB7XG4gICAgbGVuZ3RoOiBwYXJzZUludChtYXRjaFsxXSwgMTApLFxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0eXBlIHN0cmluZyBpcyBhIGRlY2ltYWwgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVjaW1hbFR5cGUodHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBERUNJTUFMX1JFR0VYLnRlc3QodHlwZSlcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHR5cGUgc3RyaW5nIGlzIGEgZml4ZWQgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRml4ZWRUeXBlKHR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gRklYRURfUkVHRVgudGVzdCh0eXBlKVxufVxuXG4vKipcbiAqIENvbXBhcmUgdHdvIEljZWJlcmcgdHlwZSBzdHJpbmdzIGZvciBlcXVhbGl0eSwgaWdub3Jpbmcgd2hpdGVzcGFjZSBkaWZmZXJlbmNlcy5cbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gY29tcGFyaW5nIHR5cGVzIGZyb20gdXNlciBpbnB1dCB2cyBjYXRhbG9nIHJlc3BvbnNlcyxcbiAqIGFzIGNhdGFsb2dzIG1heSBub3JtYWxpemUgd2hpdGVzcGFjZSBkaWZmZXJlbnRseS5cbiAqXG4gKiBAcGFyYW0gYSAtIEZpcnN0IHR5cGUgc3RyaW5nXG4gKiBAcGFyYW0gYiAtIFNlY29uZCB0eXBlIHN0cmluZ1xuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdHlwZXMgYXJlIGVxdWl2YWxlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR5cGVzRXF1YWwoYTogc3RyaW5nLCBiOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgLy8gRm9yIGRlY2ltYWwgdHlwZXMsIGNvbXBhcmUgcGFyc2VkIHZhbHVlc1xuICBjb25zdCBkZWNpbWFsQSA9IHBhcnNlRGVjaW1hbFR5cGUoYSlcbiAgY29uc3QgZGVjaW1hbEIgPSBwYXJzZURlY2ltYWxUeXBlKGIpXG4gIGlmIChkZWNpbWFsQSAmJiBkZWNpbWFsQikge1xuICAgIHJldHVybiBkZWNpbWFsQS5wcmVjaXNpb24gPT09IGRlY2ltYWxCLnByZWNpc2lvbiAmJiBkZWNpbWFsQS5zY2FsZSA9PT0gZGVjaW1hbEIuc2NhbGVcbiAgfVxuXG4gIC8vIEZvciBmaXhlZCB0eXBlcywgY29tcGFyZSBwYXJzZWQgdmFsdWVzXG4gIGNvbnN0IGZpeGVkQSA9IHBhcnNlRml4ZWRUeXBlKGEpXG4gIGNvbnN0IGZpeGVkQiA9IHBhcnNlRml4ZWRUeXBlKGIpXG4gIGlmIChmaXhlZEEgJiYgZml4ZWRCKSB7XG4gICAgcmV0dXJuIGZpeGVkQS5sZW5ndGggPT09IGZpeGVkQi5sZW5ndGhcbiAgfVxuXG4gIC8vIEZvciBvdGhlciB0eXBlcywgZGlyZWN0IHN0cmluZyBjb21wYXJpc29uXG4gIHJldHVybiBhID09PSBiXG59XG5cbi8qKlxuICogU3RydWN0IHR5cGUgLSBhIG5lc3RlZCBzdHJ1Y3R1cmUgY29udGFpbmluZyBmaWVsZHMuXG4gKiBVc2VkIGZvciBuZXN0ZWQgcmVjb3JkcyB3aXRoaW4gYSBmaWVsZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdHJ1Y3RUeXBlIHtcbiAgdHlwZTogJ3N0cnVjdCdcbiAgZmllbGRzOiBTdHJ1Y3RGaWVsZFtdXG59XG5cbi8qKlxuICogTGlzdCB0eXBlIC0gYW4gYXJyYXkgb2YgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdFR5cGUge1xuICB0eXBlOiAnbGlzdCdcbiAgJ2VsZW1lbnQtaWQnOiBudW1iZXJcbiAgZWxlbWVudDogSWNlYmVyZ1R5cGVcbiAgJ2VsZW1lbnQtcmVxdWlyZWQnOiBib29sZWFuXG59XG5cbi8qKlxuICogTWFwIHR5cGUgLSBhIGtleS12YWx1ZSBtYXBwaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hcFR5cGUge1xuICB0eXBlOiAnbWFwJ1xuICAna2V5LWlkJzogbnVtYmVyXG4gIGtleTogSWNlYmVyZ1R5cGVcbiAgJ3ZhbHVlLWlkJzogbnVtYmVyXG4gIHZhbHVlOiBJY2ViZXJnVHlwZVxuICAndmFsdWUtcmVxdWlyZWQnOiBib29sZWFuXG59XG5cbi8qKlxuICogVW5pb24gb2YgYWxsIEljZWJlcmcgdHlwZXMuXG4gKiBDYW4gYmUgYSBwcmltaXRpdmUgdHlwZSAoc3RyaW5nKSBvciBhIGNvbXBsZXggdHlwZSAoc3RydWN0LCBsaXN0LCBtYXApLlxuICovXG5leHBvcnQgdHlwZSBJY2ViZXJnVHlwZSA9IFByaW1pdGl2ZVR5cGUgfCBTdHJ1Y3RUeXBlIHwgTGlzdFR5cGUgfCBNYXBUeXBlXG5cbi8qKlxuICogUHJpbWl0aXZlIHR5cGUgdmFsdWVzIGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqIFJlcHJlc2VudHMgdGhlIHBvc3NpYmxlIHZhbHVlcyBmb3IgaW5pdGlhbC1kZWZhdWx0IGFuZCB3cml0ZS1kZWZhdWx0LlxuICovXG5leHBvcnQgdHlwZSBQcmltaXRpdmVUeXBlVmFsdWUgPSBib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nXG5cbi8qKlxuICogQSBmaWVsZCB3aXRoaW4gYSBzdHJ1Y3QgKHVzZWQgaW4gbmVzdGVkIFN0cnVjdFR5cGUpLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0cnVjdEZpZWxkIHtcbiAgaWQ6IG51bWJlclxuICBuYW1lOiBzdHJpbmdcbiAgdHlwZTogSWNlYmVyZ1R5cGVcbiAgcmVxdWlyZWQ6IGJvb2xlYW5cbiAgZG9jPzogc3RyaW5nXG4gICdpbml0aWFsLWRlZmF1bHQnPzogUHJpbWl0aXZlVHlwZVZhbHVlXG4gICd3cml0ZS1kZWZhdWx0Jz86IFByaW1pdGl2ZVR5cGVWYWx1ZVxufVxuXG4vKipcbiAqIEEgZmllbGQgd2l0aGluIGEgdGFibGUgc2NoZW1hICh0b3AtbGV2ZWwpLlxuICogRXF1aXZhbGVudCB0byBTdHJ1Y3RGaWVsZCBidXQga2VwdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVGaWVsZCB7XG4gIGlkOiBudW1iZXJcbiAgbmFtZTogc3RyaW5nXG4gIHR5cGU6IEljZWJlcmdUeXBlXG4gIHJlcXVpcmVkOiBib29sZWFuXG4gIGRvYz86IHN0cmluZ1xuICAnaW5pdGlhbC1kZWZhdWx0Jz86IFByaW1pdGl2ZVR5cGVWYWx1ZVxuICAnd3JpdGUtZGVmYXVsdCc/OiBQcmltaXRpdmVUeXBlVmFsdWVcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVNjaGVtYSB7XG4gIHR5cGU6ICdzdHJ1Y3QnXG4gIGZpZWxkczogVGFibGVGaWVsZFtdXG4gICdzY2hlbWEtaWQnPzogbnVtYmVyXG4gICdpZGVudGlmaWVyLWZpZWxkLWlkcyc/OiBudW1iZXJbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnRpdGlvbkZpZWxkIHtcbiAgc291cmNlX2lkOiBudW1iZXJcbiAgZmllbGRfaWQ6IG51bWJlclxuICBuYW1lOiBzdHJpbmdcbiAgdHJhbnNmb3JtOiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJ0aXRpb25TcGVjIHtcbiAgJ3NwZWMtaWQnOiBudW1iZXJcbiAgZmllbGRzOiBQYXJ0aXRpb25GaWVsZFtdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29ydEZpZWxkIHtcbiAgc291cmNlX2lkOiBudW1iZXJcbiAgdHJhbnNmb3JtOiBzdHJpbmdcbiAgZGlyZWN0aW9uOiAnYXNjJyB8ICdkZXNjJ1xuICBudWxsX29yZGVyOiAnbnVsbHMtZmlyc3QnIHwgJ251bGxzLWxhc3QnXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29ydE9yZGVyIHtcbiAgJ29yZGVyLWlkJzogbnVtYmVyXG4gIGZpZWxkczogU29ydEZpZWxkW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVUYWJsZVJlcXVlc3Qge1xuICBuYW1lOiBzdHJpbmdcbiAgc2NoZW1hOiBUYWJsZVNjaGVtYVxuICAncGFydGl0aW9uLXNwZWMnPzogUGFydGl0aW9uU3BlY1xuICAnd3JpdGUtb3JkZXInPzogU29ydE9yZGVyXG4gIHByb3BlcnRpZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICdzdGFnZS1jcmVhdGUnPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZVRhYmxlUmVxdWVzdCB7XG4gIHNjaGVtYT86IFRhYmxlU2NoZW1hXG4gICdwYXJ0aXRpb24tc3BlYyc/OiBQYXJ0aXRpb25TcGVjXG4gIHByb3BlcnRpZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcFRhYmxlUmVxdWVzdCB7XG4gIHB1cmdlPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlTWV0YWRhdGEge1xuICBuYW1lPzogc3RyaW5nXG4gIGxvY2F0aW9uOiBzdHJpbmdcbiAgc2NoZW1hczogVGFibGVTY2hlbWFbXVxuICAnY3VycmVudC1zY2hlbWEtaWQnOiBudW1iZXJcbiAgJ3BhcnRpdGlvbi1zcGVjcyc6IFBhcnRpdGlvblNwZWNbXVxuICAnZGVmYXVsdC1zcGVjLWlkJz86IG51bWJlclxuICAnc29ydC1vcmRlcnMnOiBTb3J0T3JkZXJbXVxuICAnZGVmYXVsdC1zb3J0LW9yZGVyLWlkJz86IG51bWJlclxuICBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICdtZXRhZGF0YS1sb2NhdGlvbic/OiBzdHJpbmdcbiAgJ2N1cnJlbnQtc25hcHNob3QtaWQnPzogbnVtYmVyXG4gIHNuYXBzaG90cz86IHVua25vd25bXVxuICAnc25hcHNob3QtbG9nJz86IHVua25vd25bXVxuICAnbWV0YWRhdGEtbG9nJz86IHVua25vd25bXVxuICByZWZzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgJ2xhc3QtdXBkYXRlZC1tcyc/OiBudW1iZXJcbiAgJ2xhc3QtY29sdW1uLWlkJz86IG51bWJlclxuICAnbGFzdC1zZXF1ZW5jZS1udW1iZXInPzogbnVtYmVyXG4gICd0YWJsZS11dWlkJz86IHN0cmluZ1xuICAnZm9ybWF0LXZlcnNpb24nPzogbnVtYmVyXG4gICdsYXN0LXBhcnRpdGlvbi1pZCc/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVOYW1lc3BhY2VSZXF1ZXN0IHtcbiAgbmFtZXNwYWNlOiBzdHJpbmdbXVxuICBwcm9wZXJ0aWVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZU5hbWVzcGFjZVJlc3BvbnNlIHtcbiAgbmFtZXNwYWNlOiBzdHJpbmdbXVxuICBwcm9wZXJ0aWVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldE5hbWVzcGFjZVJlc3BvbnNlIHtcbiAgbmFtZXNwYWNlOiBzdHJpbmdbXVxuICBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdE5hbWVzcGFjZXNSZXNwb25zZSB7XG4gIG5hbWVzcGFjZXM6IHN0cmluZ1tdW11cbiAgJ25leHQtcGFnZS10b2tlbic/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0VGFibGVzUmVzcG9uc2Uge1xuICBpZGVudGlmaWVyczogVGFibGVJZGVudGlmaWVyW11cbiAgJ25leHQtcGFnZS10b2tlbic/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkVGFibGVSZXNwb25zZSB7XG4gICdtZXRhZGF0YS1sb2NhdGlvbic6IHN0cmluZ1xuICBtZXRhZGF0YTogVGFibGVNZXRhZGF0YVxuICBjb25maWc/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tbWl0VGFibGVSZXNwb25zZSB7XG4gICdtZXRhZGF0YS1sb2NhdGlvbic6IHN0cmluZ1xuICBtZXRhZGF0YTogVGFibGVNZXRhZGF0YVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgKGFjdGl2ZSkgc2NoZW1hIGZyb20gdGFibGUgbWV0YWRhdGEuXG4gKlxuICogQHBhcmFtIG1ldGFkYXRhIC0gVGFibGUgbWV0YWRhdGEgY29udGFpbmluZyBzY2hlbWFzIGFycmF5IGFuZCBjdXJyZW50LXNjaGVtYS1pZFxuICogQHJldHVybnMgVGhlIGN1cnJlbnQgdGFibGUgc2NoZW1hLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50U2NoZW1hKG1ldGFkYXRhOiBUYWJsZU1ldGFkYXRhKTogVGFibGVTY2hlbWEgfCB1bmRlZmluZWQge1xuICByZXR1cm4gbWV0YWRhdGEuc2NoZW1hcy5maW5kKChzKSA9PiBzWydzY2hlbWEtaWQnXSA9PT0gbWV0YWRhdGFbJ2N1cnJlbnQtc2NoZW1hLWlkJ10pXG59XG4iLCAiLyoqXG4gKiBOYW1lc3BhY2UgdHlwZSBmb3IgZXJyb3IgY2xhc3Nlc1xuICogRGV0ZXJtaW5lcyB0aGUgZXJyb3IgY2xhc3MgbmFtZXMgYW5kIHR5cGUgZ3VhcmRzXG4gKi9cbmV4cG9ydCB0eXBlIEVycm9yTmFtZXNwYWNlID0gJ3N0b3JhZ2UnIHwgJ3ZlY3RvcnMnXG5cbi8qKlxuICogQmFzZSBlcnJvciBjbGFzcyBmb3IgYWxsIFN0b3JhZ2UgZXJyb3JzXG4gKiBTdXBwb3J0cyBib3RoICdzdG9yYWdlJyBhbmQgJ3ZlY3RvcnMnIG5hbWVzcGFjZXNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0b3JhZ2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHJvdGVjdGVkIF9faXNTdG9yYWdlRXJyb3IgPSB0cnVlXG4gIHByb3RlY3RlZCBuYW1lc3BhY2U6IEVycm9yTmFtZXNwYWNlXG4gIHN0YXR1cz86IG51bWJlclxuICBzdGF0dXNDb2RlPzogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIG5hbWVzcGFjZTogRXJyb3JOYW1lc3BhY2UgPSAnc3RvcmFnZScsXG4gICAgc3RhdHVzPzogbnVtYmVyLFxuICAgIHN0YXR1c0NvZGU/OiBzdHJpbmdcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZVxuICAgIHRoaXMubmFtZSA9IG5hbWVzcGFjZSA9PT0gJ3ZlY3RvcnMnID8gJ1N0b3JhZ2VWZWN0b3JzRXJyb3InIDogJ1N0b3JhZ2VFcnJvcidcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGVcbiAgfVxufVxuXG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYW4gZXJyb3IgaXMgYSBTdG9yYWdlRXJyb3JcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVja1xuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSBTdG9yYWdlRXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RvcmFnZUVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgU3RvcmFnZUVycm9yIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNTdG9yYWdlRXJyb3InIGluIGVycm9yXG59XG5cbi8qKlxuICogQVBJIGVycm9yIHJldHVybmVkIGZyb20gU3RvcmFnZSBzZXJ2aWNlXG4gKiBJbmNsdWRlcyBIVFRQIHN0YXR1cyBjb2RlIGFuZCBzZXJ2aWNlLXNwZWNpZmljIGVycm9yIGNvZGVcbiAqL1xuZXhwb3J0IGNsYXNzIFN0b3JhZ2VBcGlFcnJvciBleHRlbmRzIFN0b3JhZ2VFcnJvciB7XG4gIG92ZXJyaWRlIHN0YXR1czogbnVtYmVyXG4gIG92ZXJyaWRlIHN0YXR1c0NvZGU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICBzdGF0dXM6IG51bWJlcixcbiAgICBzdGF0dXNDb2RlOiBzdHJpbmcsXG4gICAgbmFtZXNwYWNlOiBFcnJvck5hbWVzcGFjZSA9ICdzdG9yYWdlJ1xuICApIHtcbiAgICBzdXBlcihtZXNzYWdlLCBuYW1lc3BhY2UsIHN0YXR1cywgc3RhdHVzQ29kZSlcbiAgICB0aGlzLm5hbWUgPSBuYW1lc3BhY2UgPT09ICd2ZWN0b3JzJyA/ICdTdG9yYWdlVmVjdG9yc0FwaUVycm9yJyA6ICdTdG9yYWdlQXBpRXJyb3InXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlXG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNDb2RlOiB0aGlzLnN0YXR1c0NvZGUsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVW5rbm93biBlcnJvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggZXhwZWN0ZWQgZXJyb3IgcGF0dGVybnNcbiAqIFdyYXBzIHRoZSBvcmlnaW5hbCBlcnJvciBmb3IgZGVidWdnaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBTdG9yYWdlVW5rbm93bkVycm9yIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcbiAgb3JpZ2luYWxFcnJvcjogdW5rbm93blxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgb3JpZ2luYWxFcnJvcjogdW5rbm93biwgbmFtZXNwYWNlOiBFcnJvck5hbWVzcGFjZSA9ICdzdG9yYWdlJykge1xuICAgIHN1cGVyKG1lc3NhZ2UsIG5hbWVzcGFjZSlcbiAgICB0aGlzLm5hbWUgPSBuYW1lc3BhY2UgPT09ICd2ZWN0b3JzJyA/ICdTdG9yYWdlVmVjdG9yc1Vua25vd25FcnJvcicgOiAnU3RvcmFnZVVua25vd25FcnJvcidcbiAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yXG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQmFja3dhcmQgQ29tcGF0aWJpbGl0eSBFeHBvcnRzIGZvciBWZWN0b3JzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIFN0b3JhZ2VFcnJvciB3aXRoIG5hbWVzcGFjZT0ndmVjdG9ycycgaW5zdGVhZFxuICogQWxpYXMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyB2ZWN0b3Igc3RvcmFnZSBjb2RlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdG9yYWdlVmVjdG9yc0Vycm9yIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ3ZlY3RvcnMnKVxuICB9XG59XG5cbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBhbiBlcnJvciBpcyBhIFN0b3JhZ2VWZWN0b3JzRXJyb3JcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVja1xuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSBTdG9yYWdlVmVjdG9yc0Vycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBTdG9yYWdlVmVjdG9yc0Vycm9yIHtcbiAgcmV0dXJuIGlzU3RvcmFnZUVycm9yKGVycm9yKSAmJiAoZXJyb3IgYXMgU3RvcmFnZUVycm9yKVsnbmFtZXNwYWNlJ10gPT09ICd2ZWN0b3JzJ1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBTdG9yYWdlQXBpRXJyb3Igd2l0aCBuYW1lc3BhY2U9J3ZlY3RvcnMnIGluc3RlYWRcbiAqIEFsaWFzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgdmVjdG9yIHN0b3JhZ2UgY29kZVxuICovXG5leHBvcnQgY2xhc3MgU3RvcmFnZVZlY3RvcnNBcGlFcnJvciBleHRlbmRzIFN0b3JhZ2VBcGlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzOiBudW1iZXIsIHN0YXR1c0NvZGU6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1cywgc3RhdHVzQ29kZSwgJ3ZlY3RvcnMnKVxuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIFN0b3JhZ2VVbmtub3duRXJyb3Igd2l0aCBuYW1lc3BhY2U9J3ZlY3RvcnMnIGluc3RlYWRcbiAqIEFsaWFzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgdmVjdG9yIHN0b3JhZ2UgY29kZVxuICovXG5leHBvcnQgY2xhc3MgU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3IgZXh0ZW5kcyBTdG9yYWdlVW5rbm93bkVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBvcmlnaW5hbEVycm9yOiB1bmtub3duKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgb3JpZ2luYWxFcnJvciwgJ3ZlY3RvcnMnKVxuICB9XG59XG5cbi8qKlxuICogRXJyb3IgY29kZXMgc3BlY2lmaWMgdG8gUzMgVmVjdG9ycyBBUElcbiAqIE1hcHMgQVdTIHNlcnZpY2UgZXJyb3JzIHRvIGFwcGxpY2F0aW9uLWZyaWVuZGx5IGVycm9yIGNvZGVzXG4gKi9cbmV4cG9ydCBlbnVtIFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlIHtcbiAgLyoqIEludGVybmFsIHNlcnZlciBmYXVsdCAoSFRUUCA1MDApICovXG4gIEludGVybmFsRXJyb3IgPSAnSW50ZXJuYWxFcnJvcicsXG4gIC8qKiBSZXNvdXJjZSBhbHJlYWR5IGV4aXN0cyAvIGNvbmZsaWN0IChIVFRQIDQwOSkgKi9cbiAgUzNWZWN0b3JDb25mbGljdEV4Y2VwdGlvbiA9ICdTM1ZlY3RvckNvbmZsaWN0RXhjZXB0aW9uJyxcbiAgLyoqIFJlc291cmNlIG5vdCBmb3VuZCAoSFRUUCA0MDQpICovXG4gIFMzVmVjdG9yTm90Rm91bmRFeGNlcHRpb24gPSAnUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvbicsXG4gIC8qKiBEZWxldGUgYnVja2V0IHdoaWxlIG5vdCBlbXB0eSAoSFRUUCA0MDApICovXG4gIFMzVmVjdG9yQnVja2V0Tm90RW1wdHkgPSAnUzNWZWN0b3JCdWNrZXROb3RFbXB0eScsXG4gIC8qKiBFeGNlZWRzIGJ1Y2tldCBxdW90YS9saW1pdCAoSFRUUCA0MDApICovXG4gIFMzVmVjdG9yTWF4QnVja2V0c0V4Y2VlZGVkID0gJ1MzVmVjdG9yTWF4QnVja2V0c0V4Y2VlZGVkJyxcbiAgLyoqIEV4Y2VlZHMgaW5kZXggcXVvdGEvbGltaXQgKEhUVFAgNDAwKSAqL1xuICBTM1ZlY3Rvck1heEluZGV4ZXNFeGNlZWRlZCA9ICdTM1ZlY3Rvck1heEluZGV4ZXNFeGNlZWRlZCcsXG59XG4iLCAidHlwZSBGZXRjaCA9IHR5cGVvZiBmZXRjaFxuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBmZXRjaCBpbXBsZW1lbnRhdGlvbiB0byB1c2VcbiAqIFVzZXMgY3VzdG9tIGZldGNoIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgdXNlcyBuYXRpdmUgZmV0Y2hcbiAqXG4gKiBAcGFyYW0gY3VzdG9tRmV0Y2ggLSBPcHRpb25hbCBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm5zIFJlc29sdmVkIGZldGNoIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBjdXN0b21GZXRjaCguLi5hcmdzKVxuICB9XG4gIHJldHVybiAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncylcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgUmVzcG9uc2UgY29uc3RydWN0b3IgdG8gdXNlXG4gKiBSZXR1cm5zIG5hdGl2ZSBSZXNwb25zZSBjb25zdHJ1Y3RvclxuICpcbiAqIEByZXR1cm5zIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlUmVzcG9uc2UgPSAoKTogdHlwZW9mIFJlc3BvbnNlID0+IHtcbiAgcmV0dXJuIFJlc3BvbnNlXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGlucHV0IGlzIGEgcGxhaW4gb2JqZWN0XG4gKiBBbiBvYmplY3QgaXMgcGxhaW4gaWYgaXQncyBjcmVhdGVkIGJ5IGVpdGhlciB7fSwgbmV3IE9iamVjdCgpLCBvciBPYmplY3QuY3JlYXRlKG51bGwpXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3RcbiAqIEBzb3VyY2UgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9pcy1wbGFpbi1vYmpcbiAqL1xuZXhwb3J0IGNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsdWU6IG9iamVjdCk6IGJvb2xlYW4gPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKVxuICByZXR1cm4gKFxuICAgIChwcm90b3R5cGUgPT09IG51bGwgfHxcbiAgICAgIHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fFxuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmXG4gICAgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpICYmXG4gICAgIShTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBjb252ZXJ0cyBvYmplY3Qga2V5cyBmcm9tIHNuYWtlX2Nhc2UgdG8gY2FtZWxDYXNlXG4gKiBVc2VkIGZvciBub3JtYWxpemluZyBBUEkgcmVzcG9uc2VzXG4gKlxuICogQHBhcmFtIGl0ZW0gLSBPYmplY3QgdG8gY29udmVydFxuICogQHJldHVybnMgQ29udmVydGVkIG9iamVjdCB3aXRoIGNhbWVsQ2FzZSBrZXlzXG4gKi9cbmV4cG9ydCBjb25zdCByZWN1cnNpdmVUb0NhbWVsID0gKGl0ZW06IFJlY29yZDxzdHJpbmcsIGFueT4pOiB1bmtub3duID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICByZXR1cm4gaXRlbS5tYXAoKGVsKSA9PiByZWN1cnNpdmVUb0NhbWVsKGVsKSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ2Z1bmN0aW9uJyB8fCBpdGVtICE9PSBPYmplY3QoaXRlbSkpIHtcbiAgICByZXR1cm4gaXRlbVxuICB9XG5cbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cbiAgT2JqZWN0LmVudHJpZXMoaXRlbSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbmV3S2V5ID0ga2V5LnJlcGxhY2UoLyhbLV9dW2Etel0pL2dpLCAoYykgPT4gYy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1stX10vZywgJycpKVxuICAgIHJlc3VsdFtuZXdLZXldID0gcmVjdXJzaXZlVG9DYW1lbCh2YWx1ZSlcbiAgfSlcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGlmIGEgZ2l2ZW4gYnVja2V0IG5hbWUgaXMgdmFsaWQgYWNjb3JkaW5nIHRvIFN1cGFiYXNlIFN0b3JhZ2UgQVBJIHJ1bGVzXG4gKiBNaXJyb3JzIGJhY2tlbmQgdmFsaWRhdGlvbiBmcm9tOiBzdG9yYWdlL3NyYy9zdG9yYWdlL2xpbWl0cy50czppc1ZhbGlkQnVja2V0TmFtZSgpXG4gKlxuICogUnVsZXM6XG4gKiAtIExlbmd0aDogMS0xMDAgY2hhcmFjdGVyc1xuICogLSBBbGxvd2VkIGNoYXJhY3RlcnM6IGFscGhhbnVtZXJpYyAoYS16LCBBLVosIDAtOSksIHVuZGVyc2NvcmUgKF8pLCBhbmQgc2FmZSBzcGVjaWFsIGNoYXJhY3RlcnNcbiAqIC0gU2FmZSBzcGVjaWFsIGNoYXJhY3RlcnM6ICEgLSAuICogJyAoICkgc3BhY2UgJiAkIEAgPSA7IDogKyAsID9cbiAqIC0gRm9yYmlkZGVuOiBwYXRoIHNlcGFyYXRvcnMgKC8sIFxcKSwgcGF0aCB0cmF2ZXJzYWwgKC4uKSwgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlXG4gKlxuICogQVdTIFMzIFJlZmVyZW5jZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC91c2VyZ3VpZGUvb2JqZWN0LWtleXMuaHRtbFxuICpcbiAqIEBwYXJhbSBidWNrZXROYW1lIC0gVGhlIGJ1Y2tldCBuYW1lIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRCdWNrZXROYW1lID0gKGJ1Y2tldE5hbWU6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICBpZiAoIWJ1Y2tldE5hbWUgfHwgdHlwZW9mIGJ1Y2tldE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBDaGVjayBsZW5ndGggY29uc3RyYWludHMgKDEtMTAwIGNoYXJhY3RlcnMpXG4gIGlmIChidWNrZXROYW1lLmxlbmd0aCA9PT0gMCB8fCBidWNrZXROYW1lLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGxlYWRpbmcvdHJhaWxpbmcgd2hpdGVzcGFjZVxuICBpZiAoYnVja2V0TmFtZS50cmltKCkgIT09IGJ1Y2tldE5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEV4cGxpY2l0bHkgcmVqZWN0IHBhdGggc2VwYXJhdG9ycyAoc2VjdXJpdHkpXG4gIC8vIE5vdGU6IENvbnNlY3V0aXZlIHBlcmlvZHMgKC4uKSBhcmUgYWxsb3dlZCBieSBiYWNrZW5kIC0gdGhlIEFXUyByZXN0cmljdGlvblxuICAvLyBvbiByZWxhdGl2ZSBwYXRocyBhcHBsaWVzIHRvIG9iamVjdCBrZXlzLCBub3QgYnVja2V0IG5hbWVzXG4gIGlmIChidWNrZXROYW1lLmluY2x1ZGVzKCcvJykgfHwgYnVja2V0TmFtZS5pbmNsdWRlcygnXFxcXCcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBWYWxpZGF0ZSBhZ2FpbnN0IGFsbG93ZWQgY2hhcmFjdGVyIHNldFxuICAvLyBQYXR0ZXJuIG1hdGNoZXMgYmFja2VuZCByZWdleDogL14oXFx3fCF8LXxcXC58XFwqfCd8XFwofFxcKXwgfCZ8XFwkfEB8PXw7fDp8XFwrfCx8XFw/KSokL1xuICAvLyBUaGlzIGV4cGxpY2l0bHkgZXhjbHVkZXMgcGF0aCBzZXBhcmF0b3JzICgvLCBcXCkgYW5kIG90aGVyIHByb2JsZW1hdGljIGNoYXJhY3RlcnNcbiAgY29uc3QgYnVja2V0TmFtZVJlZ2V4ID0gL15bXFx3IS5cXConKCkgJiRAPTs6Kyw/LV0rJC9cbiAgcmV0dXJuIGJ1Y2tldE5hbWVSZWdleC50ZXN0KGJ1Y2tldE5hbWUpXG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIG51bWJlciBhcnJheSB0byBmbG9hdDMyIGZvcm1hdFxuICogRW5zdXJlcyBhbGwgdmVjdG9yIHZhbHVlcyBhcmUgdmFsaWQgMzItYml0IGZsb2F0c1xuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBBcnJheSBvZiBudW1iZXJzIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMgTm9ybWFsaXplZCBmbG9hdDMyIGFycmF5XG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVUb0Zsb2F0MzIgPSAodmFsdWVzOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgLy8gVXNlIEZsb2F0MzJBcnJheSB0byBlbnN1cmUgcHJvcGVyIHByZWNpc2lvblxuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgRmxvYXQzMkFycmF5KHZhbHVlcykpXG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHZlY3RvciBkaW1lbnNpb25zIG1hdGNoIGV4cGVjdGVkIGRpbWVuc2lvblxuICogVGhyb3dzIGVycm9yIGlmIGRpbWVuc2lvbnMgZG9uJ3QgbWF0Y2hcbiAqXG4gKiBAcGFyYW0gdmVjdG9yIC0gVmVjdG9yIGRhdGEgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSBleHBlY3RlZERpbWVuc2lvbiAtIEV4cGVjdGVkIHZlY3RvciBkaW1lbnNpb25cbiAqIEB0aHJvd3MgRXJyb3IgaWYgZGltZW5zaW9ucyBkb24ndCBtYXRjaFxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVWZWN0b3JEaW1lbnNpb24gPSAoXG4gIHZlY3RvcjogeyBmbG9hdDMyOiBudW1iZXJbXSB9LFxuICBleHBlY3RlZERpbWVuc2lvbj86IG51bWJlclxuKTogdm9pZCA9PiB7XG4gIGlmIChleHBlY3RlZERpbWVuc2lvbiAhPT0gdW5kZWZpbmVkICYmIHZlY3Rvci5mbG9hdDMyLmxlbmd0aCAhPT0gZXhwZWN0ZWREaW1lbnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVmVjdG9yIGRpbWVuc2lvbiBtaXNtYXRjaDogZXhwZWN0ZWQgJHtleHBlY3RlZERpbWVuc2lvbn0sIGdvdCAke3ZlY3Rvci5mbG9hdDMyLmxlbmd0aH1gXG4gICAgKVxuICB9XG59XG4iLCAiaW1wb3J0IHsgU3RvcmFnZUFwaUVycm9yLCBTdG9yYWdlVW5rbm93bkVycm9yLCBFcnJvck5hbWVzcGFjZSB9IGZyb20gJy4vZXJyb3JzJ1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCwgcmVzb2x2ZVJlc3BvbnNlIH0gZnJvbSAnLi9oZWxwZXJzJ1xuXG5leHBvcnQgdHlwZSBGZXRjaCA9IHR5cGVvZiBmZXRjaFxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGZldGNoIHJlcXVlc3RzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hPcHRpb25zIHtcbiAgaGVhZGVycz86IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuICBkdXBsZXg/OiBzdHJpbmdcbiAgbm9SZXNvbHZlSnNvbj86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBBZGRpdGlvbmFsIGZldGNoIHBhcmFtZXRlcnMgKGUuZy4sIHNpZ25hbCBmb3IgY2FuY2VsbGF0aW9uKVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoUGFyYW1ldGVycyB7XG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG59XG5cbi8qKlxuICogSFRUUCBtZXRob2RzIHN1cHBvcnRlZCBieSB0aGUgQVBJXG4gKi9cbmV4cG9ydCB0eXBlIFJlcXVlc3RNZXRob2RUeXBlID0gJ0dFVCcgfCAnUE9TVCcgfCAnUFVUJyB8ICdERUxFVEUnIHwgJ0hFQUQnXG5cbi8qKlxuICogRXh0cmFjdHMgZXJyb3IgbWVzc2FnZSBmcm9tIHZhcmlvdXMgZXJyb3IgcmVzcG9uc2UgZm9ybWF0c1xuICogQHBhcmFtIGVyciAtIEVycm9yIG9iamVjdCBmcm9tIEFQSVxuICogQHJldHVybnMgSHVtYW4tcmVhZGFibGUgZXJyb3IgbWVzc2FnZVxuICovXG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycjogYW55KTogc3RyaW5nID0+XG4gIGVyci5tc2cgfHxcbiAgZXJyLm1lc3NhZ2UgfHxcbiAgZXJyLmVycm9yX2Rlc2NyaXB0aW9uIHx8XG4gICh0eXBlb2YgZXJyLmVycm9yID09PSAnc3RyaW5nJyA/IGVyci5lcnJvciA6IGVyci5lcnJvcj8ubWVzc2FnZSkgfHxcbiAgSlNPTi5zdHJpbmdpZnkoZXJyKVxuXG4vKipcbiAqIEhhbmRsZXMgZmV0Y2ggZXJyb3JzIGFuZCBjb252ZXJ0cyB0aGVtIHRvIFN0b3JhZ2UgZXJyb3IgdHlwZXNcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBjYXVnaHQgZnJvbSBmZXRjaFxuICogQHBhcmFtIHJlamVjdCAtIFByb21pc2UgcmVqZWN0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEZldGNoIG9wdGlvbnMgdGhhdCBtYXkgYWZmZWN0IGVycm9yIGhhbmRsaW5nXG4gKiBAcGFyYW0gbmFtZXNwYWNlIC0gRXJyb3IgbmFtZXNwYWNlICgnc3RvcmFnZScgb3IgJ3ZlY3RvcnMnKVxuICovXG5jb25zdCBoYW5kbGVFcnJvciA9IGFzeW5jIChcbiAgZXJyb3I6IHVua25vd24sXG4gIHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZCxcbiAgb3B0aW9uczogRmV0Y2hPcHRpb25zIHwgdW5kZWZpbmVkLFxuICBuYW1lc3BhY2U6IEVycm9yTmFtZXNwYWNlXG4pID0+IHtcbiAgLy8gQ2hlY2sgaWYgZXJyb3IgaXMgYSBSZXNwb25zZS1saWtlIG9iamVjdCAoaGFzIHN0YXR1cyBhbmQgb2sgcHJvcGVydGllcylcbiAgLy8gVGhpcyBpcyBtb3JlIHJlbGlhYmxlIHRoYW4gaW5zdGFuY2VvZiB3aGljaCBjYW4gZmFpbCBhY3Jvc3MgcmVhbG1zXG4gIGNvbnN0IGlzUmVzcG9uc2VMaWtlID1cbiAgICBlcnJvciAmJlxuICAgIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiZcbiAgICAnc3RhdHVzJyBpbiBlcnJvciAmJlxuICAgICdvaycgaW4gZXJyb3IgJiZcbiAgICB0eXBlb2YgKGVycm9yIGFzIGFueSkuc3RhdHVzID09PSAnbnVtYmVyJ1xuXG4gIGlmIChpc1Jlc3BvbnNlTGlrZSAmJiAhb3B0aW9ucz8ubm9SZXNvbHZlSnNvbikge1xuICAgIGNvbnN0IHJlc3BvbnNlRXJyb3IgPSBlcnJvciBhcyBhbnlcbiAgICBjb25zdCBzdGF0dXMgPSByZXNwb25zZUVycm9yLnN0YXR1cyB8fCA1MDBcblxuICAgIC8vIFRyeSB0byBwYXJzZSBKU09OIGJvZHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiByZXNwb25zZUVycm9yLmpzb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlc3BvbnNlRXJyb3JcbiAgICAgICAgLmpzb24oKVxuICAgICAgICAudGhlbigoZXJyOiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gZXJyPy5zdGF0dXNDb2RlIHx8IGVycj8uY29kZSB8fCBzdGF0dXMgKyAnJ1xuICAgICAgICAgIHJlamVjdChuZXcgU3RvcmFnZUFwaUVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyKSwgc3RhdHVzLCBzdGF0dXNDb2RlLCBuYW1lc3BhY2UpKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8vIElmIEpTT04gcGFyc2luZyBmYWlscyBmb3IgdmVjdG9ycywgY3JlYXRlIEFwaUVycm9yIHdpdGggSFRUUCBzdGF0dXNcbiAgICAgICAgICBpZiAobmFtZXNwYWNlID09PSAndmVjdG9ycycpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBzdGF0dXMgKyAnJ1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgXG4gICAgICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VBcGlFcnJvcihtZXNzYWdlLCBzdGF0dXMsIHN0YXR1c0NvZGUsIG5hbWVzcGFjZSkpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBzdGF0dXMgKyAnJ1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgXG4gICAgICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VBcGlFcnJvcihtZXNzYWdlLCBzdGF0dXMsIHN0YXR1c0NvZGUsIG5hbWVzcGFjZSkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBqc29uKCkgbWV0aG9kIGF2YWlsYWJsZSwgY3JlYXRlIGVycm9yIGZyb20gc3RhdHVzXG4gICAgICBjb25zdCBzdGF0dXNDb2RlID0gc3RhdHVzICsgJydcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXNwb25zZUVycm9yLnN0YXR1c1RleHQgfHwgYEhUVFAgJHtzdGF0dXN9IGVycm9yYFxuICAgICAgcmVqZWN0KG5ldyBTdG9yYWdlQXBpRXJyb3IobWVzc2FnZSwgc3RhdHVzLCBzdGF0dXNDb2RlLCBuYW1lc3BhY2UpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWplY3QobmV3IFN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yLCBuYW1lc3BhY2UpKVxuICB9XG59XG5cbi8qKlxuICogQnVpbGRzIHJlcXVlc3QgcGFyYW1ldGVycyBmb3IgZmV0Y2ggY2FsbHNcbiAqIEBwYXJhbSBtZXRob2QgLSBIVFRQIG1ldGhvZFxuICogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuICogQHBhcmFtIHBhcmFtZXRlcnMgLSBBZGRpdGlvbmFsIGZldGNoIHBhcmFtZXRlcnMgbGlrZSBBYm9ydFNpZ25hbFxuICogQHBhcmFtIGJvZHkgLSBSZXF1ZXN0IGJvZHkgKHdpbGwgYmUgSlNPTiBzdHJpbmdpZmllZCBpZiBwbGFpbiBvYmplY3QpXG4gKiBAcmV0dXJucyBDb21wbGV0ZSBmZXRjaCByZXF1ZXN0IHBhcmFtZXRlcnNcbiAqL1xuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMgPSAoXG4gIG1ldGhvZDogUmVxdWVzdE1ldGhvZFR5cGUsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnMsXG4gIGJvZHk/OiBvYmplY3RcbikgPT4ge1xuICBjb25zdCBwYXJhbXM6IHsgW2s6IHN0cmluZ106IGFueSB9ID0geyBtZXRob2QsIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnMgfHwge30gfVxuXG4gIGlmIChtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnIHx8ICFib2R5KSB7XG4gICAgcmV0dXJuIHsgLi4ucGFyYW1zLCAuLi5wYXJhbWV0ZXJzIH1cbiAgfVxuXG4gIGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgcGFyYW1zLmhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfVxuICAgIHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgfSBlbHNlIHtcbiAgICBwYXJhbXMuYm9keSA9IGJvZHlcbiAgfVxuXG4gIGlmIChvcHRpb25zPy5kdXBsZXgpIHtcbiAgICBwYXJhbXMuZHVwbGV4ID0gb3B0aW9ucy5kdXBsZXhcbiAgfVxuXG4gIHJldHVybiB7IC4uLnBhcmFtcywgLi4ucGFyYW1ldGVycyB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcmVxdWVzdCBoYW5kbGVyIHRoYXQgd3JhcHMgZmV0Y2ggd2l0aCBlcnJvciBoYW5kbGluZ1xuICogQHBhcmFtIGZldGNoZXIgLSBGZXRjaCBmdW5jdGlvbiB0byB1c2VcbiAqIEBwYXJhbSBtZXRob2QgLSBIVFRQIG1ldGhvZFxuICogQHBhcmFtIHVybCAtIFJlcXVlc3QgVVJMXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAtIEFkZGl0aW9uYWwgZmV0Y2ggcGFyYW1ldGVyc1xuICogQHBhcmFtIGJvZHkgLSBSZXF1ZXN0IGJvZHlcbiAqIEBwYXJhbSBuYW1lc3BhY2UgLSBFcnJvciBuYW1lc3BhY2UgKCdzdG9yYWdlJyBvciAndmVjdG9ycycpXG4gKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcGFyc2VkIHJlc3BvbnNlIG9yIGVycm9yXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kVHlwZSxcbiAgdXJsOiBzdHJpbmcsXG4gIG9wdGlvbnM6IEZldGNoT3B0aW9ucyB8IHVuZGVmaW5lZCxcbiAgcGFyYW1ldGVyczogRmV0Y2hQYXJhbWV0ZXJzIHwgdW5kZWZpbmVkLFxuICBib2R5OiBvYmplY3QgfCB1bmRlZmluZWQsXG4gIG5hbWVzcGFjZTogRXJyb3JOYW1lc3BhY2Vcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZmV0Y2hlcih1cmwsIF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkpXG4gICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmICghcmVzdWx0Lm9rKSB0aHJvdyByZXN1bHRcbiAgICAgICAgaWYgKG9wdGlvbnM/Lm5vUmVzb2x2ZUpzb24pIHJldHVybiByZXN1bHRcblxuICAgICAgICAvLyBBV1MgUzMgVmVjdG9ycyBBUEkgcmV0dXJucyAyMDAgT0sgd2l0aCBjb250ZW50LWxlbmd0aDogMCBmb3Igc3VjY2Vzc2Z1bCBtdXRhdGlvbnNcbiAgICAgICAgLy8gKHB1dFZlY3RvcnMsIGRlbGV0ZVZlY3RvcnMpIGluc3RlYWQgb2YgMjA0IG9yIEpTT04gcmVzcG9uc2UuIFRoaXMgaXMgQVdTJ3MgZGVzaWduIGNob2ljZVxuICAgICAgICAvLyBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIG9mIGJ1bGsgb3BlcmF0aW9ucyAodXAgdG8gNTAwIHZlY3RvcnMgcGVyIHJlcXVlc3QpLlxuICAgICAgICAvLyBXZSBoYW5kbGUgdGhpcyB0byBwcmV2ZW50IFwiVW5leHBlY3RlZCBlbmQgb2YgSlNPTiBpbnB1dFwiIGVycm9ycyB3aGVuIGNhbGxpbmcgcmVzdWx0Lmpzb24oKVxuICAgICAgICBpZiAobmFtZXNwYWNlID09PSAndmVjdG9ycycpIHtcbiAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3VsdC5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJylcbiAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gcmVzdWx0LmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpXG5cbiAgICAgICAgICAvLyBSZXR1cm4gZW1wdHkgb2JqZWN0IGZvciBleHBsaWNpdGx5IGVtcHR5IHJlc3BvbnNlc1xuICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoID09PSAnMCcgfHwgcmVzdWx0LnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAgICAgICByZXR1cm4ge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXR1cm4gZW1wdHkgb2JqZWN0IGlmIG5vIEpTT04gY29udGVudCB0eXBlXG4gICAgICAgICAgaWYgKCFjb250ZW50VHlwZSB8fCAhY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qc29uKClcbiAgICAgIH0pXG4gICAgICAudGhlbigoZGF0YSkgPT4gcmVzb2x2ZShkYXRhKSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGhhbmRsZUVycm9yKGVycm9yLCByZWplY3QsIG9wdGlvbnMsIG5hbWVzcGFjZSkpXG4gIH0pXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZldGNoIEFQSSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZXNwYWNlXG4gKiBAcGFyYW0gbmFtZXNwYWNlIC0gRXJyb3IgbmFtZXNwYWNlICgnc3RvcmFnZScgb3IgJ3ZlY3RvcnMnKVxuICogQHJldHVybnMgT2JqZWN0IHdpdGggSFRUUCBtZXRob2QgZnVuY3Rpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGZXRjaEFwaShuYW1lc3BhY2U6IEVycm9yTmFtZXNwYWNlID0gJ3N0b3JhZ2UnKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBHRVQgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBmZXRjaGVyIC0gRmV0Y2ggZnVuY3Rpb24gdG8gdXNlXG4gICAgICogQHBhcmFtIHVybCAtIFJlcXVlc3QgVVJMXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gQWRkaXRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHBhcnNlZCByZXNwb25zZVxuICAgICAqL1xuICAgIGdldDogYXN5bmMgKFxuICAgICAgZmV0Y2hlcjogRmV0Y2gsXG4gICAgICB1cmw6IHN0cmluZyxcbiAgICAgIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gICAgICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4gICAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnR0VUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCB1bmRlZmluZWQsIG5hbWVzcGFjZSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBQT1NUIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gZmV0Y2hlciAtIEZldGNoIGZ1bmN0aW9uIHRvIHVzZVxuICAgICAqIEBwYXJhbSB1cmwgLSBSZXF1ZXN0IFVSTFxuICAgICAqIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5IHRvIGJlIEpTT04gc3RyaW5naWZpZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgLSBBZGRpdGlvbmFsIGZldGNoIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcGFyc2VkIHJlc3BvbnNlXG4gICAgICovXG4gICAgcG9zdDogYXN5bmMgKFxuICAgICAgZmV0Y2hlcjogRmV0Y2gsXG4gICAgICB1cmw6IHN0cmluZyxcbiAgICAgIGJvZHk6IG9iamVjdCxcbiAgICAgIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gICAgICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4gICAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnUE9TVCcsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSwgbmFtZXNwYWNlKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIFBVVCByZXF1ZXN0XG4gICAgICogQHBhcmFtIGZldGNoZXIgLSBGZXRjaCBmdW5jdGlvbiB0byB1c2VcbiAgICAgKiBAcGFyYW0gdXJsIC0gUmVxdWVzdCBVUkxcbiAgICAgKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keSB0byBiZSBKU09OIHN0cmluZ2lmaWVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gQWRkaXRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHBhcnNlZCByZXNwb25zZVxuICAgICAqL1xuICAgIHB1dDogYXN5bmMgKFxuICAgICAgZmV0Y2hlcjogRmV0Y2gsXG4gICAgICB1cmw6IHN0cmluZyxcbiAgICAgIGJvZHk6IG9iamVjdCxcbiAgICAgIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gICAgICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4gICAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnUFVUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5LCBuYW1lc3BhY2UpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgSEVBRCByZXF1ZXN0XG4gICAgICogQHBhcmFtIGZldGNoZXIgLSBGZXRjaCBmdW5jdGlvbiB0byB1c2VcbiAgICAgKiBAcGFyYW0gdXJsIC0gUmVxdWVzdCBVUkxcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgLSBBZGRpdGlvbmFsIGZldGNoIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggUmVzcG9uc2Ugb2JqZWN0IChub3QgSlNPTiBwYXJzZWQpXG4gICAgICovXG4gICAgaGVhZDogYXN5bmMgKFxuICAgICAgZmV0Y2hlcjogRmV0Y2gsXG4gICAgICB1cmw6IHN0cmluZyxcbiAgICAgIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gICAgICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4gICAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgIHJldHVybiBfaGFuZGxlUmVxdWVzdChcbiAgICAgICAgZmV0Y2hlcixcbiAgICAgICAgJ0hFQUQnLFxuICAgICAgICB1cmwsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgREVMRVRFIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gZmV0Y2hlciAtIEZldGNoIGZ1bmN0aW9uIHRvIHVzZVxuICAgICAqIEBwYXJhbSB1cmwgLSBSZXF1ZXN0IFVSTFxuICAgICAqIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5IHRvIGJlIEpTT04gc3RyaW5naWZpZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgLSBBZGRpdGlvbmFsIGZldGNoIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcGFyc2VkIHJlc3BvbnNlXG4gICAgICovXG4gICAgcmVtb3ZlOiBhc3luYyAoXG4gICAgICBmZXRjaGVyOiBGZXRjaCxcbiAgICAgIHVybDogc3RyaW5nLFxuICAgICAgYm9keTogb2JqZWN0LFxuICAgICAgb3B0aW9ucz86IEZldGNoT3B0aW9ucyxcbiAgICAgIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbiAgICApOiBQcm9taXNlPGFueT4gPT4ge1xuICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdERUxFVEUnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHksIG5hbWVzcGFjZSlcbiAgICB9LFxuICB9XG59XG5cbi8vIERlZmF1bHQgZXhwb3J0cyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoICdzdG9yYWdlJyBuYW1lc3BhY2VcbmNvbnN0IGRlZmF1bHRBcGkgPSBjcmVhdGVGZXRjaEFwaSgnc3RvcmFnZScpXG5leHBvcnQgY29uc3QgeyBnZXQsIHBvc3QsIHB1dCwgaGVhZCwgcmVtb3ZlIH0gPSBkZWZhdWx0QXBpXG5cbi8vIFZlY3RvcnMgQVBJIHdpdGggJ3ZlY3RvcnMnIG5hbWVzcGFjZSBmb3IgcHJvcGVyIGVycm9yIGhhbmRsaW5nXG5leHBvcnQgY29uc3QgdmVjdG9yc0FwaSA9IGNyZWF0ZUZldGNoQXBpKCd2ZWN0b3JzJylcbiIsICJpbXBvcnQgeyBFcnJvck5hbWVzcGFjZSwgaXNTdG9yYWdlRXJyb3IsIFN0b3JhZ2VFcnJvciB9IGZyb20gJy4vZXJyb3JzJ1xuaW1wb3J0IHsgRmV0Y2ggfSBmcm9tICcuL2ZldGNoJ1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi9oZWxwZXJzJ1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqIEJhc2UgQVBJIGNsaWVudCBjbGFzcyBmb3IgYWxsIFN0b3JhZ2UgQVBJIGNsYXNzZXNcbiAqIFByb3ZpZGVzIGNvbW1vbiBpbmZyYXN0cnVjdHVyZSBmb3IgZXJyb3IgaGFuZGxpbmcgYW5kIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAdHlwZVBhcmFtIFRFcnJvciAtIFRoZSBlcnJvciB0eXBlIChTdG9yYWdlRXJyb3Igb3Igc3ViY2xhc3MpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEJhc2VBcGlDbGllbnQ8VEVycm9yIGV4dGVuZHMgU3RvcmFnZUVycm9yID0gU3RvcmFnZUVycm9yPiB7XG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG4gIHByb3RlY3RlZCBzaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZVxuICBwcm90ZWN0ZWQgbmFtZXNwYWNlOiBFcnJvck5hbWVzcGFjZVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEJhc2VBcGlDbGllbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHVybCAtIEJhc2UgVVJMIGZvciBBUEkgcmVxdWVzdHNcbiAgICogQHBhcmFtIGhlYWRlcnMgLSBEZWZhdWx0IGhlYWRlcnMgZm9yIEFQSSByZXF1ZXN0c1xuICAgKiBAcGFyYW0gZmV0Y2ggLSBPcHRpb25hbCBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIEVycm9yIG5hbWVzcGFjZSAoJ3N0b3JhZ2UnIG9yICd2ZWN0b3JzJylcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSxcbiAgICBmZXRjaD86IEZldGNoLFxuICAgIG5hbWVzcGFjZTogRXJyb3JOYW1lc3BhY2UgPSAnc3RvcmFnZSdcbiAgKSB7XG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaClcbiAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZVxuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aHJvd2luZyBlcnJvcnMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlbS5cbiAgICogV2hlbiBlbmFibGVkLCBlcnJvcnMgYXJlIHRocm93biBpbnN0ZWFkIG9mIHJldHVybmVkIGluIHsgZGF0YSwgZXJyb3IgfSBmb3JtYXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgLSBGb3IgbWV0aG9kIGNoYWluaW5nXG4gICAqL1xuICBwdWJsaWMgdGhyb3dPbkVycm9yKCk6IHRoaXMge1xuICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBBUEkgb3BlcmF0aW9uIHdpdGggc3RhbmRhcmRpemVkIGVycm9yIGhhbmRsaW5nXG4gICAqIEVsaW1pbmF0ZXMgcmVwZXRpdGl2ZSB0cnktY2F0Y2ggYmxvY2tzIGFjcm9zcyBhbGwgQVBJIG1ldGhvZHNcbiAgICpcbiAgICogVGhpcyB3cmFwcGVyOlxuICAgKiAxLiBFeGVjdXRlcyB0aGUgb3BlcmF0aW9uXG4gICAqIDIuIFJldHVybnMgeyBkYXRhLCBlcnJvcjogbnVsbCB9IG9uIHN1Y2Nlc3NcbiAgICogMy4gUmV0dXJucyB7IGRhdGE6IG51bGwsIGVycm9yIH0gb24gZmFpbHVyZSAoaWYgc2hvdWxkVGhyb3dPbkVycm9yIGlzIGZhbHNlKVxuICAgKiA0LiBUaHJvd3MgZXJyb3Igb24gZmFpbHVyZSAoaWYgc2hvdWxkVGhyb3dPbkVycm9yIGlzIHRydWUpXG4gICAqXG4gICAqIEB0eXBlUGFyYW0gVCAtIFRoZSBleHBlY3RlZCBkYXRhIHR5cGUgZnJvbSB0aGUgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gLSBBc3luYyBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZSBBUEkgY2FsbFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggeyBkYXRhLCBlcnJvciB9IHR1cGxlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogYXN5bmMgbGlzdEJ1Y2tldHMoKSB7XG4gICAqICAgcmV0dXJuIHRoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICogICAgIHJldHVybiBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L2J1Y2tldGAsIHtcbiAgICogICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgKiAgICAgfSlcbiAgICogICB9KVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGhhbmRsZU9wZXJhdGlvbjxUPihcbiAgICBvcGVyYXRpb246ICgpID0+IFByb21pc2U8VD5cbiAgKTogUHJvbWlzZTx7IGRhdGE6IFQ7IGVycm9yOiBudWxsIH0gfCB7IGRhdGE6IG51bGw7IGVycm9yOiBURXJyb3IgfT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgb3BlcmF0aW9uKClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBlcnJvciBhcyBURXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBpc1N0b3JhZ2VFcnJvciB9IGZyb20gJy4uL2xpYi9jb21tb24vZXJyb3JzJ1xuaW1wb3J0IHsgRG93bmxvYWRSZXN1bHQgfSBmcm9tICcuLi9saWIvdHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmVhbURvd25sb2FkQnVpbGRlciBpbXBsZW1lbnRzIFByb21pc2VMaWtlPERvd25sb2FkUmVzdWx0PFJlYWRhYmxlU3RyZWFtPj4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGRvd25sb2FkRm46ICgpID0+IFByb21pc2U8UmVzcG9uc2U+LFxuICAgIHByaXZhdGUgc2hvdWxkVGhyb3dPbkVycm9yOiBib29sZWFuXG4gICkge31cblxuICB0aGVuPFRSZXN1bHQxID0gRG93bmxvYWRSZXN1bHQ8UmVhZGFibGVTdHJlYW0+LCBUUmVzdWx0MiA9IG5ldmVyPihcbiAgICBvbmZ1bGZpbGxlZD86XG4gICAgICB8ICgodmFsdWU6IERvd25sb2FkUmVzdWx0PFJlYWRhYmxlU3RyZWFtPikgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pXG4gICAgICB8IG51bGwsXG4gICAgb25yZWplY3RlZD86ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQyIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDI+KSB8IG51bGxcbiAgKTogUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZSgpLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGV4ZWN1dGUoKTogUHJvbWlzZTxEb3dubG9hZFJlc3VsdDxSZWFkYWJsZVN0cmVhbT4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kb3dubG9hZEZuKClcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcmVzdWx0LmJvZHkgYXMgUmVhZGFibGVTdHJlYW0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgaXNTdG9yYWdlRXJyb3IgfSBmcm9tICcuLi9saWIvY29tbW9uL2Vycm9ycydcbmltcG9ydCB7IERvd25sb2FkUmVzdWx0IH0gZnJvbSAnLi4vbGliL3R5cGVzJ1xuaW1wb3J0IFN0cmVhbURvd25sb2FkQnVpbGRlciBmcm9tICcuL1N0cmVhbURvd25sb2FkQnVpbGRlcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmxvYkRvd25sb2FkQnVpbGRlciBpbXBsZW1lbnRzIFByb21pc2U8RG93bmxvYWRSZXN1bHQ8QmxvYj4+IHtcbiAgcmVhZG9ubHkgW1N5bWJvbC50b1N0cmluZ1RhZ106IHN0cmluZyA9ICdCbG9iRG93bmxvYWRCdWlsZGVyJ1xuICBwcml2YXRlIHByb21pc2U6IFByb21pc2U8RG93bmxvYWRSZXN1bHQ8QmxvYj4+IHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGRvd25sb2FkRm46ICgpID0+IFByb21pc2U8UmVzcG9uc2U+LFxuICAgIHByaXZhdGUgc2hvdWxkVGhyb3dPbkVycm9yOiBib29sZWFuXG4gICkge31cblxuICBhc1N0cmVhbSgpOiBTdHJlYW1Eb3dubG9hZEJ1aWxkZXIge1xuICAgIHJldHVybiBuZXcgU3RyZWFtRG93bmxvYWRCdWlsZGVyKHRoaXMuZG93bmxvYWRGbiwgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpXG4gIH1cblxuICB0aGVuPFRSZXN1bHQxID0gRG93bmxvYWRSZXN1bHQ8QmxvYj4sIFRSZXN1bHQyID0gbmV2ZXI+KFxuICAgIG9uZnVsZmlsbGVkPzogKCh2YWx1ZTogRG93bmxvYWRSZXN1bHQ8QmxvYj4pID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+KSB8IG51bGwsXG4gICAgb25yZWplY3RlZD86ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQyIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDI+KSB8IG51bGxcbiAgKTogUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpXG4gIH1cblxuICBjYXRjaDxUUmVzdWx0ID0gbmV2ZXI+KFxuICAgIG9ucmVqZWN0ZWQ/OiAoKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0IHwgUHJvbWlzZUxpa2U8VFJlc3VsdD4pIHwgbnVsbFxuICApOiBQcm9taXNlPERvd25sb2FkUmVzdWx0PEJsb2I+IHwgVFJlc3VsdD4ge1xuICAgIHJldHVybiB0aGlzLmdldFByb21pc2UoKS5jYXRjaChvbnJlamVjdGVkKVxuICB9XG5cbiAgZmluYWxseShvbmZpbmFsbHk/OiAoKCkgPT4gdm9pZCkgfCBudWxsKTogUHJvbWlzZTxEb3dubG9hZFJlc3VsdDxCbG9iPj4ge1xuICAgIHJldHVybiB0aGlzLmdldFByb21pc2UoKS5maW5hbGx5KG9uZmluYWxseSlcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UHJvbWlzZSgpOiBQcm9taXNlPERvd25sb2FkUmVzdWx0PEJsb2I+PiB7XG4gICAgaWYgKCF0aGlzLnByb21pc2UpIHtcbiAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMuZXhlY3V0ZSgpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb21pc2VcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZXhlY3V0ZSgpOiBQcm9taXNlPERvd25sb2FkUmVzdWx0PEJsb2I+PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZG93bmxvYWRGbigpXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGF3YWl0IHJlc3VsdC5ibG9iKCksXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgU3RvcmFnZUVycm9yLCBTdG9yYWdlVW5rbm93bkVycm9yLCBpc1N0b3JhZ2VFcnJvciB9IGZyb20gJy4uL2xpYi9jb21tb24vZXJyb3JzJ1xuaW1wb3J0IHsgZ2V0LCBoZWFkLCBwb3N0LCBwdXQsIHJlbW92ZSwgRmV0Y2ggfSBmcm9tICcuLi9saWIvY29tbW9uL2ZldGNoJ1xuaW1wb3J0IHsgcmVjdXJzaXZlVG9DYW1lbCB9IGZyb20gJy4uL2xpYi9jb21tb24vaGVscGVycydcbmltcG9ydCBCYXNlQXBpQ2xpZW50IGZyb20gJy4uL2xpYi9jb21tb24vQmFzZUFwaUNsaWVudCdcbmltcG9ydCB7XG4gIEZpbGVPYmplY3QsXG4gIEZpbGVPcHRpb25zLFxuICBTZWFyY2hPcHRpb25zLFxuICBGZXRjaFBhcmFtZXRlcnMsXG4gIFRyYW5zZm9ybU9wdGlvbnMsXG4gIERlc3RpbmF0aW9uT3B0aW9ucyxcbiAgRmlsZU9iamVjdFYyLFxuICBDYW1lbGl6ZSxcbiAgU2VhcmNoVjJPcHRpb25zLFxuICBTZWFyY2hWMlJlc3VsdCxcbn0gZnJvbSAnLi4vbGliL3R5cGVzJ1xuaW1wb3J0IEJsb2JEb3dubG9hZEJ1aWxkZXIgZnJvbSAnLi9CbG9iRG93bmxvYWRCdWlsZGVyJ1xuXG5jb25zdCBERUZBVUxUX1NFQVJDSF9PUFRJT05TID0ge1xuICBsaW1pdDogMTAwLFxuICBvZmZzZXQ6IDAsXG4gIHNvcnRCeToge1xuICAgIGNvbHVtbjogJ25hbWUnLFxuICAgIG9yZGVyOiAnYXNjJyxcbiAgfSxcbn1cblxuY29uc3QgREVGQVVMVF9GSUxFX09QVElPTlM6IEZpbGVPcHRpb25zID0ge1xuICBjYWNoZUNvbnRyb2w6ICczNjAwJyxcbiAgY29udGVudFR5cGU6ICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnLFxuICB1cHNlcnQ6IGZhbHNlLFxufVxuXG50eXBlIEZpbGVCb2R5ID1cbiAgfCBBcnJheUJ1ZmZlclxuICB8IEFycmF5QnVmZmVyVmlld1xuICB8IEJsb2JcbiAgfCBCdWZmZXJcbiAgfCBGaWxlXG4gIHwgRm9ybURhdGFcbiAgfCBOb2RlSlMuUmVhZGFibGVTdHJlYW1cbiAgfCBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuICB8IFVSTFNlYXJjaFBhcmFtc1xuICB8IHN0cmluZ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdG9yYWdlRmlsZUFwaSBleHRlbmRzIEJhc2VBcGlDbGllbnQ8U3RvcmFnZUVycm9yPiB7XG4gIHByb3RlY3RlZCBidWNrZXRJZD86IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSxcbiAgICBidWNrZXRJZD86IHN0cmluZyxcbiAgICBmZXRjaD86IEZldGNoXG4gICkge1xuICAgIHN1cGVyKHVybCwgaGVhZGVycywgZmV0Y2gsICdzdG9yYWdlJylcbiAgICB0aGlzLmJ1Y2tldElkID0gYnVja2V0SWRcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQgb3IgcmVwbGFjZXMgYW4gZXhpc3RpbmcgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCBhIG5ldyBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSBtZXRob2QgSFRUUCBtZXRob2QuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cbiAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB1cGxvYWRPclVwZGF0ZShcbiAgICBtZXRob2Q6ICdQT1NUJyB8ICdQVVQnLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBmaWxlQm9keTogRmlsZUJvZHksXG4gICAgZmlsZU9wdGlvbnM/OiBGaWxlT3B0aW9uc1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IGlkOiBzdHJpbmc7IHBhdGg6IHN0cmluZzsgZnVsbFBhdGg6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGJvZHlcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IC4uLkRFRkFVTFRfRklMRV9PUFRJT05TLCAuLi5maWxlT3B0aW9ucyB9XG4gICAgICBsZXQgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICAuLi4obWV0aG9kID09PSAnUE9TVCcgJiYgeyAneC11cHNlcnQnOiBTdHJpbmcob3B0aW9ucy51cHNlcnQgYXMgYm9vbGVhbikgfSksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YVxuXG4gICAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBib2R5ID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgYm9keS5hcHBlbmQoJ2NhY2hlQ29udHJvbCcsIG9wdGlvbnMuY2FjaGVDb250cm9sIGFzIHN0cmluZylcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgYm9keS5hcHBlbmQoJ21ldGFkYXRhJywgdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpXG4gICAgICAgIH1cbiAgICAgICAgYm9keS5hcHBlbmQoJycsIGZpbGVCb2R5KVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgYm9keSA9IGZpbGVCb2R5XG4gICAgICAgIC8vIE9ubHkgYXBwZW5kIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgICAgaWYgKCFib2R5LmhhcygnY2FjaGVDb250cm9sJykpIHtcbiAgICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wgYXMgc3RyaW5nKVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSAmJiAhYm9keS5oYXMoJ21ldGFkYXRhJykpIHtcbiAgICAgICAgICBib2R5LmFwcGVuZCgnbWV0YWRhdGEnLCB0aGlzLmVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm9keSA9IGZpbGVCb2R5XG4gICAgICAgIGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YFxuICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IG9wdGlvbnMuY29udGVudFR5cGUgYXMgc3RyaW5nXG5cbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgaGVhZGVyc1sneC1tZXRhZGF0YSddID0gdGhpcy50b0Jhc2U2NCh0aGlzLmVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vZGUuanMgc3RyZWFtcyByZXF1aXJlIGR1cGxleCBvcHRpb24gZm9yIGZldGNoIGluIE5vZGUgMjArXG4gICAgICAgIC8vIENoZWNrIGZvciBib3RoIHdlYiBSZWFkYWJsZVN0cmVhbSBhbmQgTm9kZS5qcyBzdHJlYW1zXG4gICAgICAgIGNvbnN0IGlzU3RyZWFtID1cbiAgICAgICAgICAodHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSAndW5kZWZpbmVkJyAmJiBib2R5IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHx8XG4gICAgICAgICAgKGJvZHkgJiYgdHlwZW9mIGJvZHkgPT09ICdvYmplY3QnICYmICdwaXBlJyBpbiBib2R5ICYmIHR5cGVvZiBib2R5LnBpcGUgPT09ICdmdW5jdGlvbicpXG5cbiAgICAgICAgaWYgKGlzU3RyZWFtICYmICFvcHRpb25zLmR1cGxleCkge1xuICAgICAgICAgIG9wdGlvbnMuZHVwbGV4ID0gJ2hhbGYnXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGVPcHRpb25zPy5oZWFkZXJzKSB7XG4gICAgICAgIGhlYWRlcnMgPSB7IC4uLmhlYWRlcnMsIC4uLmZpbGVPcHRpb25zLmhlYWRlcnMgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjbGVhblBhdGggPSB0aGlzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aClcbiAgICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKGNsZWFuUGF0aClcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCAobWV0aG9kID09ICdQVVQnID8gcHV0IDogcG9zdCkoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3QvJHtfcGF0aH1gLFxuICAgICAgICBib2R5IGFzIG9iamVjdCxcbiAgICAgICAgeyBoZWFkZXJzLCAuLi4ob3B0aW9ucz8uZHVwbGV4ID8geyBkdXBsZXg6IG9wdGlvbnMuZHVwbGV4IH0gOiB7fSkgfVxuICAgICAgKVxuXG4gICAgICByZXR1cm4geyBwYXRoOiBjbGVhblBhdGgsIGlkOiBkYXRhLklkLCBmdWxsUGF0aDogZGF0YS5LZXkgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkcyBhIGZpbGUgdG8gYW4gZXhpc3RpbmcgYnVja2V0LlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICogQHBhcmFtIGZpbGVPcHRpb25zIE9wdGlvbmFsIGZpbGUgdXBsb2FkIG9wdGlvbnMgaW5jbHVkaW5nIGNhY2hlQ29udHJvbCwgY29udGVudFR5cGUsIHVwc2VydCwgYW5kIG1ldGFkYXRhLlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBmaWxlIHBhdGgsIGlkLCBhbmQgZnVsbFBhdGggb3IgZXJyb3JcbiAgICpcbiAgICogQGV4YW1wbGUgVXBsb2FkIGZpbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXZhdGFyRmlsZSA9IGV2ZW50LnRhcmdldC5maWxlc1swXVxuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmZyb20oJ2F2YXRhcnMnKVxuICAgKiAgIC51cGxvYWQoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGF2YXRhckZpbGUsIHtcbiAgICogICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuICAgKiAgICAgdXBzZXJ0OiBmYWxzZVxuICAgKiAgIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBSZXNwb25zZTpcbiAgICogYGBganNvblxuICAgKiB7XG4gICAqICAgXCJkYXRhXCI6IHtcbiAgICogICAgIFwicGF0aFwiOiBcInB1YmxpYy9hdmF0YXIxLnBuZ1wiLFxuICAgKiAgICAgXCJmdWxsUGF0aFwiOiBcImF2YXRhcnMvcHVibGljL2F2YXRhcjEucG5nXCJcbiAgICogICB9LFxuICAgKiAgIFwiZXJyb3JcIjogbnVsbFxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZSBVcGxvYWQgZmlsZSB1c2luZyBgQXJyYXlCdWZmZXJgIGZyb20gYmFzZTY0IGZpbGUgZGF0YVxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyBkZWNvZGUgfSBmcm9tICdiYXNlNjQtYXJyYXlidWZmZXInXG4gICAqXG4gICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAqICAgLnN0b3JhZ2VcbiAgICogICAuZnJvbSgnYXZhdGFycycpXG4gICAqICAgLnVwbG9hZCgncHVibGljL2F2YXRhcjEucG5nJywgZGVjb2RlKCdiYXNlNjRGaWxlRGF0YScpLCB7XG4gICAqICAgICBjb250ZW50VHlwZTogJ2ltYWdlL3BuZydcbiAgICogICB9KVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHVwbG9hZChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgZmlsZUJvZHk6IEZpbGVCb2R5LFxuICAgIGZpbGVPcHRpb25zPzogRmlsZU9wdGlvbnNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBpZDogc3RyaW5nOyBwYXRoOiBzdHJpbmc7IGZ1bGxQYXRoOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMudXBsb2FkT3JVcGRhdGUoJ1BPU1QnLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkIGEgZmlsZSB3aXRoIGEgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGAuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcbiAgICogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBmaWxlIG5hbWUuIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cbiAgICogQHBhcmFtIHRva2VuIFRoZSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYFxuICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAqIEBwYXJhbSBmaWxlT3B0aW9ucyBIVFRQIGhlYWRlcnMgKGNhY2hlQ29udHJvbCwgY29udGVudFR5cGUsIGV0Yy4pLlxuICAgKiAqKk5vdGU6KiogVGhlIGB1cHNlcnRgIG9wdGlvbiBoYXMgbm8gZWZmZWN0IGhlcmUuIFRvIGVuYWJsZSB1cHNlcnQgYmVoYXZpb3IsXG4gICAqIHBhc3MgYHsgdXBzZXJ0OiB0cnVlIH1gIHdoZW4gY2FsbGluZyBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKClgIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGZpbGUgcGF0aCBhbmQgZnVsbFBhdGggb3IgZXJyb3JcbiAgICpcbiAgICogQGV4YW1wbGUgVXBsb2FkIHRvIGEgc2lnbmVkIFVSTFxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmZyb20oJ2F2YXRhcnMnKVxuICAgKiAgIC51cGxvYWRUb1NpZ25lZFVybCgnZm9sZGVyL2NhdC5qcGcnLCAndG9rZW4tZnJvbS1jcmVhdGVTaWduZWRVcGxvYWRVcmwnLCBmaWxlKVxuICAgKiBgYGBcbiAgICpcbiAgICogUmVzcG9uc2U6XG4gICAqIGBgYGpzb25cbiAgICoge1xuICAgKiAgIFwiZGF0YVwiOiB7XG4gICAqICAgICBcInBhdGhcIjogXCJmb2xkZXIvY2F0LmpwZ1wiLFxuICAgKiAgICAgXCJmdWxsUGF0aFwiOiBcImF2YXRhcnMvZm9sZGVyL2NhdC5qcGdcIlxuICAgKiAgIH0sXG4gICAqICAgXCJlcnJvclwiOiBudWxsXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyB1cGxvYWRUb1NpZ25lZFVybChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgdG9rZW46IHN0cmluZyxcbiAgICBmaWxlQm9keTogRmlsZUJvZHksXG4gICAgZmlsZU9wdGlvbnM/OiBGaWxlT3B0aW9uc1xuICApIHtcbiAgICBjb25zdCBjbGVhblBhdGggPSB0aGlzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aClcbiAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpXG5cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHRoaXMudXJsICsgYC9vYmplY3QvdXBsb2FkL3NpZ24vJHtfcGF0aH1gKVxuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCd0b2tlbicsIHRva2VuKVxuXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBib2R5XG4gICAgICBjb25zdCBvcHRpb25zID0geyB1cHNlcnQ6IERFRkFVTFRfRklMRV9PUFRJT05TLnVwc2VydCwgLi4uZmlsZU9wdGlvbnMgfVxuICAgICAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICAuLi57ICd4LXVwc2VydCc6IFN0cmluZyhvcHRpb25zLnVwc2VydCBhcyBib29sZWFuKSB9LFxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBib2R5ID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgYm9keS5hcHBlbmQoJ2NhY2hlQ29udHJvbCcsIG9wdGlvbnMuY2FjaGVDb250cm9sIGFzIHN0cmluZylcbiAgICAgICAgYm9keS5hcHBlbmQoJycsIGZpbGVCb2R5KVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgYm9keSA9IGZpbGVCb2R5XG4gICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCBhcyBzdHJpbmcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib2R5ID0gZmlsZUJvZHlcbiAgICAgICAgaGVhZGVyc1snY2FjaGUtY29udHJvbCddID0gYG1heC1hZ2U9JHtvcHRpb25zLmNhY2hlQ29udHJvbH1gXG4gICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZSBhcyBzdHJpbmdcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHB1dCh0aGlzLmZldGNoLCB1cmwudG9TdHJpbmcoKSwgYm9keSBhcyBvYmplY3QsIHsgaGVhZGVycyB9KVxuXG4gICAgICByZXR1cm4geyBwYXRoOiBjbGVhblBhdGgsIGZ1bGxQYXRoOiBkYXRhLktleSB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2lnbmVkIHVwbG9hZCBVUkwuXG4gICAqIFNpZ25lZCB1cGxvYWQgVVJMcyBjYW4gYmUgdXNlZCB0byB1cGxvYWQgZmlsZXMgdG8gdGhlIGJ1Y2tldCB3aXRob3V0IGZ1cnRoZXIgYXV0aGVudGljYXRpb24uXG4gICAqIFRoZXkgYXJlIHZhbGlkIGZvciAyIGhvdXJzLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICogQHBhcmFtIG9wdGlvbnMudXBzZXJ0IElmIHNldCB0byB0cnVlLCBhbGxvd3MgdGhlIGZpbGUgdG8gYmUgb3ZlcndyaXR0ZW4gaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHNpZ25lZCB1cGxvYWQgVVJMLCB0b2tlbiwgYW5kIHBhdGggb3IgZXJyb3JcbiAgICpcbiAgICogQGV4YW1wbGUgQ3JlYXRlIFNpZ25lZCBVcGxvYWQgVVJMXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAqICAgLnN0b3JhZ2VcbiAgICogICAuZnJvbSgnYXZhdGFycycpXG4gICAqICAgLmNyZWF0ZVNpZ25lZFVwbG9hZFVybCgnZm9sZGVyL2NhdC5qcGcnKVxuICAgKiBgYGBcbiAgICpcbiAgICogUmVzcG9uc2U6XG4gICAqIGBgYGpzb25cbiAgICoge1xuICAgKiAgIFwiZGF0YVwiOiB7XG4gICAqICAgICBcInNpZ25lZFVybFwiOiBcImh0dHBzOi8vZXhhbXBsZS5zdXBhYmFzZS5jby9zdG9yYWdlL3YxL29iamVjdC91cGxvYWQvc2lnbi9hdmF0YXJzL2ZvbGRlci9jYXQuanBnP3Rva2VuPTxUT0tFTj5cIixcbiAgICogICAgIFwicGF0aFwiOiBcImZvbGRlci9jYXQuanBnXCIsXG4gICAqICAgICBcInRva2VuXCI6IFwiPFRPS0VOPlwiXG4gICAqICAgfSxcbiAgICogICBcImVycm9yXCI6IG51bGxcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNpZ25lZFVwbG9hZFVybChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgdXBzZXJ0OiBib29sZWFuIH1cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBzaWduZWRVcmw6IHN0cmluZzsgdG9rZW46IHN0cmluZzsgcGF0aDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aClcblxuICAgICAgY29uc3QgaGVhZGVycyA9IHsgLi4udGhpcy5oZWFkZXJzIH1cblxuICAgICAgaWYgKG9wdGlvbnM/LnVwc2VydCkge1xuICAgICAgICBoZWFkZXJzWyd4LXVwc2VydCddID0gJ3RydWUnXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCxcbiAgICAgICAge30sXG4gICAgICAgIHsgaGVhZGVycyB9XG4gICAgICApXG5cbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy51cmwgKyBkYXRhLnVybClcblxuICAgICAgY29uc3QgdG9rZW4gPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgndG9rZW4nKVxuXG4gICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoJ05vIHRva2VuIHJldHVybmVkIGJ5IEFQSScpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHNpZ25lZFVybDogdXJsLnRvU3RyaW5nKCksIHBhdGgsIHRva2VuIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFuIGV4aXN0aW5nIGZpbGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIHdpdGggYSBuZXcgb25lLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG4gICAqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgKiBAcGFyYW0gZmlsZU9wdGlvbnMgT3B0aW9uYWwgZmlsZSB1cGxvYWQgb3B0aW9ucyBpbmNsdWRpbmcgY2FjaGVDb250cm9sLCBjb250ZW50VHlwZSwgdXBzZXJ0LCBhbmQgbWV0YWRhdGEuXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGZpbGUgcGF0aCwgaWQsIGFuZCBmdWxsUGF0aCBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZSBVcGRhdGUgZmlsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBhdmF0YXJGaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdXG4gICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAqICAgLnN0b3JhZ2VcbiAgICogICAuZnJvbSgnYXZhdGFycycpXG4gICAqICAgLnVwZGF0ZSgncHVibGljL2F2YXRhcjEucG5nJywgYXZhdGFyRmlsZSwge1xuICAgKiAgICAgY2FjaGVDb250cm9sOiAnMzYwMCcsXG4gICAqICAgICB1cHNlcnQ6IHRydWVcbiAgICogICB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogUmVzcG9uc2U6XG4gICAqIGBgYGpzb25cbiAgICoge1xuICAgKiAgIFwiZGF0YVwiOiB7XG4gICAqICAgICBcInBhdGhcIjogXCJwdWJsaWMvYXZhdGFyMS5wbmdcIixcbiAgICogICAgIFwiZnVsbFBhdGhcIjogXCJhdmF0YXJzL3B1YmxpYy9hdmF0YXIxLnBuZ1wiXG4gICAqICAgfSxcbiAgICogICBcImVycm9yXCI6IG51bGxcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgVXBkYXRlIGZpbGUgdXNpbmcgYEFycmF5QnVmZmVyYCBmcm9tIGJhc2U2NCBmaWxlIGRhdGFcbiAgICogYGBganNcbiAgICogaW1wb3J0IHtkZWNvZGV9IGZyb20gJ2Jhc2U2NC1hcnJheWJ1ZmZlcidcbiAgICpcbiAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICogICAuc3RvcmFnZVxuICAgKiAgIC5mcm9tKCdhdmF0YXJzJylcbiAgICogICAudXBkYXRlKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCBkZWNvZGUoJ2Jhc2U2NEZpbGVEYXRhJyksIHtcbiAgICogICAgIGNvbnRlbnRUeXBlOiAnaW1hZ2UvcG5nJ1xuICAgKiAgIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdXBkYXRlKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBmaWxlQm9keTpcbiAgICAgIHwgQXJyYXlCdWZmZXJcbiAgICAgIHwgQXJyYXlCdWZmZXJWaWV3XG4gICAgICB8IEJsb2JcbiAgICAgIHwgQnVmZmVyXG4gICAgICB8IEZpbGVcbiAgICAgIHwgRm9ybURhdGFcbiAgICAgIHwgTm9kZUpTLlJlYWRhYmxlU3RyZWFtXG4gICAgICB8IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4gICAgICB8IFVSTFNlYXJjaFBhcmFtc1xuICAgICAgfCBzdHJpbmcsXG4gICAgZmlsZU9wdGlvbnM/OiBGaWxlT3B0aW9uc1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IGlkOiBzdHJpbmc7IHBhdGg6IHN0cmluZzsgZnVsbFBhdGg6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICByZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZSgnUFVUJywgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcbiAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLW5ldy5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlIE1vdmUgZmlsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmZyb20oJ2F2YXRhcnMnKVxuICAgKiAgIC5tb3ZlKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCAncHJpdmF0ZS9hdmF0YXIyLnBuZycpXG4gICAqIGBgYFxuICAgKlxuICAgKiBSZXNwb25zZTpcbiAgICogYGBganNvblxuICAgKiB7XG4gICAqICAgXCJkYXRhXCI6IHtcbiAgICogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSBtb3ZlZFwiXG4gICAqICAgfSxcbiAgICogICBcImVycm9yXCI6IG51bGxcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIG1vdmUoXG4gICAgZnJvbVBhdGg6IHN0cmluZyxcbiAgICB0b1BhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogRGVzdGluYXRpb25PcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC9tb3ZlYCxcbiAgICAgICAge1xuICAgICAgICAgIGJ1Y2tldElkOiB0aGlzLmJ1Y2tldElkLFxuICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgZGVzdGluYXRpb25LZXk6IHRvUGF0aCxcbiAgICAgICAgICBkZXN0aW5hdGlvbkJ1Y2tldDogb3B0aW9ucz8uZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG4gICAqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSB0b1BhdGggVGhlIG5ldyBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgbmV3IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS1jb3B5LnBuZ2AuXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBkZXN0aW5hdGlvbiBvcHRpb25zLlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBjb3BpZWQgZmlsZSBwYXRoIG9yIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlIENvcHkgZmlsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmZyb20oJ2F2YXRhcnMnKVxuICAgKiAgIC5jb3B5KCdwdWJsaWMvYXZhdGFyMS5wbmcnLCAncHJpdmF0ZS9hdmF0YXIyLnBuZycpXG4gICAqIGBgYFxuICAgKlxuICAgKiBSZXNwb25zZTpcbiAgICogYGBganNvblxuICAgKiB7XG4gICAqICAgXCJkYXRhXCI6IHtcbiAgICogICAgIFwicGF0aFwiOiBcImF2YXRhcnMvcHJpdmF0ZS9hdmF0YXIyLnBuZ1wiXG4gICAqICAgfSxcbiAgICogICBcImVycm9yXCI6IG51bGxcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNvcHkoXG4gICAgZnJvbVBhdGg6IHN0cmluZyxcbiAgICB0b1BhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogRGVzdGluYXRpb25PcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgcGF0aDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC9jb3B5YCxcbiAgICAgICAge1xuICAgICAgICAgIGJ1Y2tldElkOiB0aGlzLmJ1Y2tldElkLFxuICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgZGVzdGluYXRpb25LZXk6IHRvUGF0aCxcbiAgICAgICAgICBkZXN0aW5hdGlvbkJ1Y2tldDogb3B0aW9ucz8uZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IHBhdGg6IGRhdGEuS2V5IH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaWduZWQgVVJMLiBVc2UgYSBzaWduZWQgVVJMIHRvIHNoYXJlIGEgZmlsZSBmb3IgYSBmaXhlZCBhbW91bnQgb2YgdGltZS5cbiAgICpcbiAgICogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMIGV4cGlyZXMuIEZvciBleGFtcGxlLCBgNjBgIGZvciBhIFVSTCB3aGljaCBpcyB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHNpZ25lZCBVUkwgb3IgZXJyb3JcbiAgICpcbiAgICogQGV4YW1wbGUgQ3JlYXRlIFNpZ25lZCBVUkxcbiAgICogYGBganNcbiAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICogICAuc3RvcmFnZVxuICAgKiAgIC5mcm9tKCdhdmF0YXJzJylcbiAgICogICAuY3JlYXRlU2lnbmVkVXJsKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCA2MClcbiAgICogYGBgXG4gICAqXG4gICAqIFJlc3BvbnNlOlxuICAgKiBgYGBqc29uXG4gICAqIHtcbiAgICogICBcImRhdGFcIjoge1xuICAgKiAgICAgXCJzaWduZWRVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3Qvc2lnbi9hdmF0YXJzL2ZvbGRlci9hdmF0YXIxLnBuZz90b2tlbj08VE9LRU4+XCJcbiAgICogICB9LFxuICAgKiAgIFwiZXJyb3JcIjogbnVsbFxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZSBDcmVhdGUgYSBzaWduZWQgVVJMIGZvciBhbiBhc3NldCB3aXRoIHRyYW5zZm9ybWF0aW9uc1xuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAqICAgLnN0b3JhZ2VcbiAgICogICAuZnJvbSgnYXZhdGFycycpXG4gICAqICAgLmNyZWF0ZVNpZ25lZFVybCgnZm9sZGVyL2F2YXRhcjEucG5nJywgNjAsIHtcbiAgICogICAgIHRyYW5zZm9ybToge1xuICAgKiAgICAgICB3aWR0aDogMTAwLFxuICAgKiAgICAgICBoZWlnaHQ6IDEwMCxcbiAgICogICAgIH1cbiAgICogICB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgQ3JlYXRlIGEgc2lnbmVkIFVSTCB3aGljaCB0cmlnZ2VycyB0aGUgZG93bmxvYWQgb2YgdGhlIGFzc2V0XG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICogICAuc3RvcmFnZVxuICAgKiAgIC5mcm9tKCdhdmF0YXJzJylcbiAgICogICAuY3JlYXRlU2lnbmVkVXJsKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCA2MCwge1xuICAgKiAgICAgZG93bmxvYWQ6IHRydWUsXG4gICAqICAgfSlcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVTaWduZWRVcmwoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGV4cGlyZXNJbjogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiB7IGRvd25sb2FkPzogc3RyaW5nIHwgYm9vbGVhbjsgdHJhbnNmb3JtPzogVHJhbnNmb3JtT3B0aW9ucyB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgc2lnbmVkVXJsOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuXG4gICAgICBsZXQgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3Qvc2lnbi8ke19wYXRofWAsXG4gICAgICAgIHsgZXhwaXJlc0luLCAuLi4ob3B0aW9ucz8udHJhbnNmb3JtID8geyB0cmFuc2Zvcm06IG9wdGlvbnMudHJhbnNmb3JtIH0gOiB7fSkgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gb3B0aW9ucz8uZG93bmxvYWRcbiAgICAgICAgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICAgIDogJydcbiAgICAgIGNvbnN0IHNpZ25lZFVybCA9IGVuY29kZVVSSShgJHt0aGlzLnVybH0ke2RhdGEuc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApXG4gICAgICByZXR1cm4geyBzaWduZWRVcmwgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBtdWx0aXBsZSBzaWduZWQgVVJMcy4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcbiAgICogQHBhcmFtIHBhdGhzIFRoZSBmaWxlIHBhdGhzIHRvIGJlIGRvd25sb2FkZWQsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWVzLiBGb3IgZXhhbXBsZSBgWydmb2xkZXIvaW1hZ2UucG5nJywgJ2ZvbGRlcjIvaW1hZ2UyLnBuZyddYC5cbiAgICogQHBhcmFtIGV4cGlyZXNJbiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdW50aWwgdGhlIHNpZ25lZCBVUkxzIGV4cGlyZS4gRm9yIGV4YW1wbGUsIGA2MGAgZm9yIFVSTHMgd2hpY2ggYXJlIHZhbGlkIGZvciBvbmUgbWludXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHNpZ25lZFVybCwgcGF0aCwgYW5kIGVycm9yIG9yIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlIENyZWF0ZSBTaWduZWQgVVJMc1xuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmZyb20oJ2F2YXRhcnMnKVxuICAgKiAgIC5jcmVhdGVTaWduZWRVcmxzKFsnZm9sZGVyL2F2YXRhcjEucG5nJywgJ2ZvbGRlci9hdmF0YXIyLnBuZyddLCA2MClcbiAgICogYGBgXG4gICAqXG4gICAqIFJlc3BvbnNlOlxuICAgKiBgYGBqc29uXG4gICAqIHtcbiAgICogICBcImRhdGFcIjogW1xuICAgKiAgICAge1xuICAgKiAgICAgICBcImVycm9yXCI6IG51bGwsXG4gICAqICAgICAgIFwicGF0aFwiOiBcImZvbGRlci9hdmF0YXIxLnBuZ1wiLFxuICAgKiAgICAgICBcInNpZ25lZFVSTFwiOiBcIi9vYmplY3Qvc2lnbi9hdmF0YXJzL2ZvbGRlci9hdmF0YXIxLnBuZz90b2tlbj08VE9LRU4+XCIsXG4gICAqICAgICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiXG4gICAqICAgICB9LFxuICAgKiAgICAge1xuICAgKiAgICAgICBcImVycm9yXCI6IG51bGwsXG4gICAqICAgICAgIFwicGF0aFwiOiBcImZvbGRlci9hdmF0YXIyLnBuZ1wiLFxuICAgKiAgICAgICBcInNpZ25lZFVSTFwiOiBcIi9vYmplY3Qvc2lnbi9hdmF0YXJzL2ZvbGRlci9hdmF0YXIyLnBuZz90b2tlbj08VE9LRU4+XCIsXG4gICAqICAgICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMi5wbmc/dG9rZW49PFRPS0VOPlwiXG4gICAqICAgICB9XG4gICAqICAgXSxcbiAgICogICBcImVycm9yXCI6IG51bGxcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNpZ25lZFVybHMoXG4gICAgcGF0aHM6IHN0cmluZ1tdLFxuICAgIGV4cGlyZXNJbjogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiB7IGRvd25sb2FkOiBzdHJpbmcgfCBib29sZWFuIH1cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBlcnJvcjogc3RyaW5nIHwgbnVsbDsgcGF0aDogc3RyaW5nIHwgbnVsbDsgc2lnbmVkVXJsOiBzdHJpbmcgfVtdXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3Qvc2lnbi8ke3RoaXMuYnVja2V0SWR9YCxcbiAgICAgICAgeyBleHBpcmVzSW4sIHBhdGhzIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcblxuICAgICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gb3B0aW9ucz8uZG93bmxvYWRcbiAgICAgICAgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICAgIDogJydcbiAgICAgIHJldHVybiBkYXRhLm1hcCgoZGF0dW06IHsgc2lnbmVkVVJMOiBzdHJpbmcgfSkgPT4gKHtcbiAgICAgICAgLi4uZGF0dW0sXG4gICAgICAgIHNpZ25lZFVybDogZGF0dW0uc2lnbmVkVVJMXG4gICAgICAgICAgPyBlbmNvZGVVUkkoYCR7dGhpcy51cmx9JHtkYXR1bS5zaWduZWRVUkx9JHtkb3dubG9hZFF1ZXJ5UGFyYW19YClcbiAgICAgICAgICA6IG51bGwsXG4gICAgICB9KSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkcyBhIGZpbGUgZnJvbSBhIHByaXZhdGUgYnVja2V0LiBGb3IgcHVibGljIGJ1Y2tldHMsIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBVUkwgcmV0dXJuZWQgZnJvbSBgZ2V0UHVibGljVXJsYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmdWxsIHBhdGggYW5kIGZpbGUgbmFtZSBvZiB0aGUgZmlsZSB0byBiZSBkb3dubG9hZGVkLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG4gICAqIEByZXR1cm5zIEJsb2JEb3dubG9hZEJ1aWxkZXIgaW5zdGFuY2UgZm9yIGRvd25sb2FkaW5nIHRoZSBmaWxlXG4gICAqXG4gICAqIEBleGFtcGxlIERvd25sb2FkIGZpbGVcbiAgICogYGBganNcbiAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICogICAuc3RvcmFnZVxuICAgKiAgIC5mcm9tKCdhdmF0YXJzJylcbiAgICogICAuZG93bmxvYWQoJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG4gICAqIGBgYFxuICAgKlxuICAgKiBSZXNwb25zZTpcbiAgICogYGBganNvblxuICAgKiB7XG4gICAqICAgXCJkYXRhXCI6IDxCTE9CPixcbiAgICogICBcImVycm9yXCI6IG51bGxcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgRG93bmxvYWQgZmlsZSB3aXRoIHRyYW5zZm9ybWF0aW9uc1xuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmZyb20oJ2F2YXRhcnMnKVxuICAgKiAgIC5kb3dubG9hZCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuICAgKiAgICAgdHJhbnNmb3JtOiB7XG4gICAqICAgICAgIHdpZHRoOiAxMDAsXG4gICAqICAgICAgIGhlaWdodDogMTAwLFxuICAgKiAgICAgICBxdWFsaXR5OiA4MFxuICAgKiAgICAgfVxuICAgKiAgIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgZG93bmxvYWQ8T3B0aW9ucyBleHRlbmRzIHsgdHJhbnNmb3JtPzogVHJhbnNmb3JtT3B0aW9ucyB9PihcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IE9wdGlvbnNcbiAgKTogQmxvYkRvd25sb2FkQnVpbGRlciB7XG4gICAgY29uc3Qgd2FudHNUcmFuc2Zvcm1hdGlvbiA9IHR5cGVvZiBvcHRpb25zPy50cmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnXG4gICAgY29uc3QgcmVuZGVyUGF0aCA9IHdhbnRzVHJhbnNmb3JtYXRpb24gPyAncmVuZGVyL2ltYWdlL2F1dGhlbnRpY2F0ZWQnIDogJ29iamVjdCdcbiAgICBjb25zdCB0cmFuc2Zvcm1hdGlvblF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyhvcHRpb25zPy50cmFuc2Zvcm0gfHwge30pXG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSB0cmFuc2Zvcm1hdGlvblF1ZXJ5ID8gYD8ke3RyYW5zZm9ybWF0aW9uUXVlcnl9YCA6ICcnXG4gICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aClcbiAgICBjb25zdCBkb3dubG9hZEZuID0gKCkgPT5cbiAgICAgIGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vJHtyZW5kZXJQYXRofS8ke19wYXRofSR7cXVlcnlTdHJpbmd9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICB9KVxuICAgIHJldHVybiBuZXcgQmxvYkRvd25sb2FkQnVpbGRlcihkb3dubG9hZEZuLCB0aGlzLnNob3VsZFRocm93T25FcnJvcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgZmlsZS5cbiAgICpcbiAgICogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBmaWxlIG1ldGFkYXRhIG9yIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlIEdldCBmaWxlIGluZm9cbiAgICogYGBganNcbiAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICogICAuc3RvcmFnZVxuICAgKiAgIC5mcm9tKCdhdmF0YXJzJylcbiAgICogICAuaW5mbygnZm9sZGVyL2F2YXRhcjEucG5nJylcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBpbmZvKHBhdGg6IHN0cmluZyk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IENhbWVsaXplPEZpbGVPYmplY3RWMj5cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpXG5cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0L2luZm8vJHtfcGF0aH1gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiByZWN1cnNpdmVUb0NhbWVsKGRhdGEpIGFzIENhbWVsaXplPEZpbGVPYmplY3RWMj5cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgZXhpc3RlbmNlIG9mIGEgZmlsZS5cbiAgICpcbiAgICogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBib29sZWFuIGluZGljYXRpbmcgZmlsZSBleGlzdGVuY2Ugb3IgZXJyb3JcbiAgICpcbiAgICogQGV4YW1wbGUgQ2hlY2sgZmlsZSBleGlzdGVuY2VcbiAgICogYGBganNcbiAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICogICAuc3RvcmFnZVxuICAgKiAgIC5mcm9tKCdhdmF0YXJzJylcbiAgICogICAuZXhpc3RzKCdmb2xkZXIvYXZhdGFyMS5wbmcnKVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGV4aXN0cyhwYXRoOiBzdHJpbmcpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBib29sZWFuXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IGJvb2xlYW5cbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGhlYWQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC8ke19wYXRofWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHsgZGF0YTogdHJ1ZSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikgJiYgZXJyb3IgaW5zdGFuY2VvZiBTdG9yYWdlVW5rbm93bkVycm9yKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRXJyb3IgPSBlcnJvci5vcmlnaW5hbEVycm9yIGFzIHVua25vd24gYXMgeyBzdGF0dXM6IG51bWJlciB9XG5cbiAgICAgICAgaWYgKFs0MDAsIDQwNF0uaW5jbHVkZXMob3JpZ2luYWxFcnJvcj8uc3RhdHVzKSkge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IGZhbHNlLCBlcnJvciB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBzaW1wbGUgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldC4gSWYgeW91IGRvIG5vdCB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uLCB5b3UgY2FuIGNvbnN0cnVjdCB0aGUgcHVibGljIFVSTCBieSBjb25jYXRlbmF0aW5nIHRoZSBidWNrZXQgVVJMIHdpdGggdGhlIHBhdGggdG8gdGhlIGFzc2V0LlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHZlcmlmeSBpZiB0aGUgYnVja2V0IGlzIHB1YmxpYy4gSWYgYSBwdWJsaWMgVVJMIGlzIGNyZWF0ZWQgZm9yIGEgYnVja2V0IHdoaWNoIGlzIG5vdCBwdWJsaWMsIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkIHRoZSBhc3NldC5cbiAgICpcbiAgICogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBhbmQgbmFtZSBvZiB0aGUgZmlsZSB0byBnZW5lcmF0ZSB0aGUgcHVibGljIFVSTCBmb3IuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgVHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHB1YmxpYyBVUkxcbiAgICpcbiAgICogQGV4YW1wbGUgUmV0dXJucyB0aGUgVVJMIGZvciBhbiBhc3NldCBpbiBhIHB1YmxpYyBidWNrZXRcbiAgICogYGBganNcbiAgICogY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmZyb20oJ3B1YmxpYy1idWNrZXQnKVxuICAgKiAgIC5nZXRQdWJsaWNVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG4gICAqIGBgYFxuICAgKlxuICAgKiBSZXNwb25zZTpcbiAgICogYGBganNvblxuICAgKiB7XG4gICAqICAgXCJkYXRhXCI6IHtcbiAgICogICAgIFwicHVibGljVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3B1YmxpYy9wdWJsaWMtYnVja2V0L2ZvbGRlci9hdmF0YXIxLnBuZ1wiXG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldCB3aXRoIHRyYW5zZm9ybWF0aW9uc1xuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEgfSA9IHN1cGFiYXNlXG4gICAqICAgLnN0b3JhZ2VcbiAgICogICAuZnJvbSgncHVibGljLWJ1Y2tldCcpXG4gICAqICAgLmdldFB1YmxpY1VybCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuICAgKiAgICAgdHJhbnNmb3JtOiB7XG4gICAqICAgICAgIHdpZHRoOiAxMDAsXG4gICAqICAgICAgIGhlaWdodDogMTAwLFxuICAgKiAgICAgfVxuICAgKiAgIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgd2hpY2ggdHJpZ2dlcnMgdGhlIGRvd25sb2FkIG9mIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldFxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEgfSA9IHN1cGFiYXNlXG4gICAqICAgLnN0b3JhZ2VcbiAgICogICAuZnJvbSgncHVibGljLWJ1Y2tldCcpXG4gICAqICAgLmdldFB1YmxpY1VybCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuICAgKiAgICAgZG93bmxvYWQ6IHRydWUsXG4gICAqICAgfSlcbiAgICogYGBgXG4gICAqL1xuICBnZXRQdWJsaWNVcmwoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IGRvd25sb2FkPzogc3RyaW5nIHwgYm9vbGVhbjsgdHJhbnNmb3JtPzogVHJhbnNmb3JtT3B0aW9ucyB9XG4gICk6IHsgZGF0YTogeyBwdWJsaWNVcmw6IHN0cmluZyB9IH0ge1xuICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpXG4gICAgY29uc3QgX3F1ZXJ5U3RyaW5nOiBzdHJpbmdbXSA9IFtdXG5cbiAgICBjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSBvcHRpb25zPy5kb3dubG9hZFxuICAgICAgPyBgZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gJycgOiBvcHRpb25zLmRvd25sb2FkfWBcbiAgICAgIDogJydcblxuICAgIGlmIChkb3dubG9hZFF1ZXJ5UGFyYW0gIT09ICcnKSB7XG4gICAgICBfcXVlcnlTdHJpbmcucHVzaChkb3dubG9hZFF1ZXJ5UGFyYW0pXG4gICAgfVxuXG4gICAgY29uc3Qgd2FudHNUcmFuc2Zvcm1hdGlvbiA9IHR5cGVvZiBvcHRpb25zPy50cmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnXG4gICAgY29uc3QgcmVuZGVyUGF0aCA9IHdhbnRzVHJhbnNmb3JtYXRpb24gPyAncmVuZGVyL2ltYWdlJyA6ICdvYmplY3QnXG4gICAgY29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcob3B0aW9ucz8udHJhbnNmb3JtIHx8IHt9KVxuXG4gICAgaWYgKHRyYW5zZm9ybWF0aW9uUXVlcnkgIT09ICcnKSB7XG4gICAgICBfcXVlcnlTdHJpbmcucHVzaCh0cmFuc2Zvcm1hdGlvblF1ZXJ5KVxuICAgIH1cblxuICAgIGxldCBxdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5qb2luKCcmJylcbiAgICBpZiAocXVlcnlTdHJpbmcgIT09ICcnKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IGA/JHtxdWVyeVN0cmluZ31gXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHsgcHVibGljVXJsOiBlbmNvZGVVUkkoYCR7dGhpcy51cmx9LyR7cmVuZGVyUGF0aH0vcHVibGljLyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gKSB9LFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGZpbGVzIHdpdGhpbiB0aGUgc2FtZSBidWNrZXRcbiAgICpcbiAgICogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuICAgKiBAcGFyYW0gcGF0aHMgQW4gYXJyYXkgb2YgZmlsZXMgdG8gZGVsZXRlLCBpbmNsdWRpbmcgdGhlIHBhdGggYW5kIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgW2AnZm9sZGVyL2ltYWdlLnBuZydgXS5cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgZGVsZXRlZCBmaWxlIG9iamVjdHMgb3IgZXJyb3JcbiAgICpcbiAgICogQGV4YW1wbGUgRGVsZXRlIGZpbGVcbiAgICogYGBganNcbiAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICogICAuc3RvcmFnZVxuICAgKiAgIC5mcm9tKCdhdmF0YXJzJylcbiAgICogICAucmVtb3ZlKFsnZm9sZGVyL2F2YXRhcjEucG5nJ10pXG4gICAqIGBgYFxuICAgKlxuICAgKiBSZXNwb25zZTpcbiAgICogYGBganNvblxuICAgKiB7XG4gICAqICAgXCJkYXRhXCI6IFtdLFxuICAgKiAgIFwiZXJyb3JcIjogbnVsbFxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlKHBhdGhzOiBzdHJpbmdbXSk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IEZpbGVPYmplY3RbXVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCByZW1vdmUoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3QvJHt0aGlzLmJ1Y2tldElkfWAsXG4gICAgICAgIHsgcHJlZml4ZXM6IHBhdGhzIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmaWxlIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byByZXRyaWV2ZSBtZXRhZGF0YVxuICAgKi9cbiAgLy8gYXN5bmMgZ2V0TWV0YWRhdGEoXG4gIC8vICAgaWQ6IHN0cmluZ1xuICAvLyApOiBQcm9taXNlPFxuICAvLyAgIHwge1xuICAvLyAgICAgICBkYXRhOiBNZXRhZGF0YVxuICAvLyAgICAgICBlcnJvcjogbnVsbFxuICAvLyAgICAgfVxuICAvLyAgIHwge1xuICAvLyAgICAgICBkYXRhOiBudWxsXG4gIC8vICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgLy8gICAgIH1cbiAgLy8gPiB7XG4gIC8vICAgdHJ5IHtcbiAgLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L21ldGFkYXRhLyR7aWR9YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSlcbiAgLy8gICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgLy8gICB9IGNhdGNoIChlcnJvcikge1xuICAvLyAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAvLyAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gIC8vICAgICB9XG5cbiAgLy8gICAgIHRocm93IGVycm9yXG4gIC8vICAgfVxuICAvLyB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBmaWxlIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byB1cGRhdGUgbWV0YWRhdGFcbiAgICogQHBhcmFtIG1ldGEgdGhlIG5ldyBmaWxlIG1ldGFkYXRhXG4gICAqL1xuICAvLyBhc3luYyB1cGRhdGVNZXRhZGF0YShcbiAgLy8gICBpZDogc3RyaW5nLFxuICAvLyAgIG1ldGE6IE1ldGFkYXRhXG4gIC8vICk6IFByb21pc2U8XG4gIC8vICAgfCB7XG4gIC8vICAgICAgIGRhdGE6IE1ldGFkYXRhXG4gIC8vICAgICAgIGVycm9yOiBudWxsXG4gIC8vICAgICB9XG4gIC8vICAgfCB7XG4gIC8vICAgICAgIGRhdGE6IG51bGxcbiAgLy8gICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAvLyAgICAgfVxuICAvLyA+IHtcbiAgLy8gICB0cnkge1xuICAvLyAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gIC8vICAgICAgIHRoaXMuZmV0Y2gsXG4gIC8vICAgICAgIGAke3RoaXMudXJsfS9tZXRhZGF0YS8ke2lkfWAsXG4gIC8vICAgICAgIHsgLi4ubWV0YSB9LFxuICAvLyAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gIC8vICAgICApXG4gIC8vICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgLy8gICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgLy8gICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAvLyAgICAgfVxuXG4gIC8vICAgICB0aHJvdyBlcnJvclxuICAvLyAgIH1cbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgdGhlIGZpbGVzIGFuZCBmb2xkZXJzIHdpdGhpbiBhIHBhdGggb2YgdGhlIGJ1Y2tldC5cbiAgICpcbiAgICogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuICAgKiBAcGFyYW0gcGF0aCBUaGUgZm9sZGVyIHBhdGguXG4gICAqIEBwYXJhbSBvcHRpb25zIFNlYXJjaCBvcHRpb25zIGluY2x1ZGluZyBsaW1pdCAoZGVmYXVsdHMgdG8gMTAwKSwgb2Zmc2V0LCBzb3J0QnksIGFuZCBzZWFyY2hcbiAgICogQHBhcmFtIHBhcmFtZXRlcnMgT3B0aW9uYWwgZmV0Y2ggcGFyYW1ldGVycyBpbmNsdWRpbmcgc2lnbmFsIGZvciBjYW5jZWxsYXRpb25cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgZmlsZXMgb3IgZXJyb3JcbiAgICpcbiAgICogQGV4YW1wbGUgTGlzdCBmaWxlcyBpbiBhIGJ1Y2tldFxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmZyb20oJ2F2YXRhcnMnKVxuICAgKiAgIC5saXN0KCdmb2xkZXInLCB7XG4gICAqICAgICBsaW1pdDogMTAwLFxuICAgKiAgICAgb2Zmc2V0OiAwLFxuICAgKiAgICAgc29ydEJ5OiB7IGNvbHVtbjogJ25hbWUnLCBvcmRlcjogJ2FzYycgfSxcbiAgICogICB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogUmVzcG9uc2U6XG4gICAqIGBgYGpzb25cbiAgICoge1xuICAgKiAgIFwiZGF0YVwiOiBbXG4gICAqICAgICB7XG4gICAqICAgICAgIFwibmFtZVwiOiBcImF2YXRhcjEucG5nXCIsXG4gICAqICAgICAgIFwiaWRcIjogXCJlNjY4Y2Y3Zi04MjFiLTRhMmYtOWRjZS03ZGZhNWRkMWNmZDJcIixcbiAgICogICAgICAgXCJ1cGRhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMzowNjowNS41ODBaXCIsXG4gICAqICAgICAgIFwiY3JlYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjM6MDQ6MzQuNDQzWlwiLFxuICAgKiAgICAgICBcImxhc3RfYWNjZXNzZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA0OjM0LjQ0M1pcIixcbiAgICogICAgICAgXCJtZXRhZGF0YVwiOiB7XG4gICAqICAgICAgICAgXCJlVGFnXCI6IFwiXFxcImM1ZThjNTUzMjM1ZDlhZjMwZWY0ZjZlMjgwNzkwYjkyXFxcIlwiLFxuICAgKiAgICAgICAgIFwic2l6ZVwiOiAzMjE3NSxcbiAgICogICAgICAgICBcIm1pbWV0eXBlXCI6IFwiaW1hZ2UvcG5nXCIsXG4gICAqICAgICAgICAgXCJjYWNoZUNvbnRyb2xcIjogXCJtYXgtYWdlPTM2MDBcIixcbiAgICogICAgICAgICBcImxhc3RNb2RpZmllZFwiOiBcIjIwMjQtMDUtMjJUMjM6MDY6MDUuNTc0WlwiLFxuICAgKiAgICAgICAgIFwiY29udGVudExlbmd0aFwiOiAzMjE3NSxcbiAgICogICAgICAgICBcImh0dHBTdGF0dXNDb2RlXCI6IDIwMFxuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqICAgXSxcbiAgICogICBcImVycm9yXCI6IG51bGxcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgU2VhcmNoIGZpbGVzIGluIGEgYnVja2V0XG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAqICAgLnN0b3JhZ2VcbiAgICogICAuZnJvbSgnYXZhdGFycycpXG4gICAqICAgLmxpc3QoJ2ZvbGRlcicsIHtcbiAgICogICAgIGxpbWl0OiAxMDAsXG4gICAqICAgICBvZmZzZXQ6IDAsXG4gICAqICAgICBzb3J0Qnk6IHsgY29sdW1uOiAnbmFtZScsIG9yZGVyOiAnYXNjJyB9LFxuICAgKiAgICAgc2VhcmNoOiAnam9uJ1xuICAgKiAgIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgbGlzdChcbiAgICBwYXRoPzogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBTZWFyY2hPcHRpb25zLFxuICAgIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogRmlsZU9iamVjdFtdXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IHsgLi4uREVGQVVMVF9TRUFSQ0hfT1BUSU9OUywgLi4ub3B0aW9ucywgcHJlZml4OiBwYXRoIHx8ICcnIH1cbiAgICAgIHJldHVybiBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0L2xpc3QvJHt0aGlzLmJ1Y2tldElkfWAsXG4gICAgICAgIGJvZHksXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0sXG4gICAgICAgIHBhcmFtZXRlcnNcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBleHBlcmltZW50YWwgdGhpcyBtZXRob2Qgc2lnbmF0dXJlIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlXG4gICAqXG4gICAqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcbiAgICogQHBhcmFtIG9wdGlvbnMgc2VhcmNoIG9wdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGxpc3RWMihcbiAgICBvcHRpb25zPzogU2VhcmNoVjJPcHRpb25zLFxuICAgIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogU2VhcmNoVjJSZXN1bHRcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0geyAuLi5vcHRpb25zIH1cbiAgICAgIHJldHVybiBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0L2xpc3QtdjIvJHt0aGlzLmJ1Y2tldElkfWAsXG4gICAgICAgIGJvZHksXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0sXG4gICAgICAgIHBhcmFtZXRlcnNcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKVxuICB9XG5cbiAgdG9CYXNlNjQoZGF0YTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgfVxuICAgIHJldHVybiBidG9hKGRhdGEpXG4gIH1cblxuICBwcml2YXRlIF9nZXRGaW5hbFBhdGgocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuYnVja2V0SWR9LyR7cGF0aC5yZXBsYWNlKC9eXFwvKy8sICcnKX1gXG4gIH1cblxuICBwcml2YXRlIF9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXlxcL3xcXC8kL2csICcnKS5yZXBsYWNlKC9cXC8rL2csICcvJylcbiAgfVxuXG4gIHByaXZhdGUgdHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcodHJhbnNmb3JtOiBUcmFuc2Zvcm1PcHRpb25zKSB7XG4gICAgY29uc3QgcGFyYW1zOiBzdHJpbmdbXSA9IFtdXG4gICAgaWYgKHRyYW5zZm9ybS53aWR0aCkge1xuICAgICAgcGFyYW1zLnB1c2goYHdpZHRoPSR7dHJhbnNmb3JtLndpZHRofWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5oZWlnaHQpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGBoZWlnaHQ9JHt0cmFuc2Zvcm0uaGVpZ2h0fWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5yZXNpemUpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGByZXNpemU9JHt0cmFuc2Zvcm0ucmVzaXplfWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5mb3JtYXQpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGBmb3JtYXQ9JHt0cmFuc2Zvcm0uZm9ybWF0fWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5xdWFsaXR5KSB7XG4gICAgICBwYXJhbXMucHVzaChgcXVhbGl0eT0ke3RyYW5zZm9ybS5xdWFsaXR5fWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcy5qb2luKCcmJylcbiAgfVxufVxuIiwgIi8vIEdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyByZWxlYXNlcyBieSBzY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLWZpbGVzLnRzXG4vLyBUaGlzIGZpbGUgcHJvdmlkZXMgcnVudGltZSBhY2Nlc3MgdG8gdGhlIHBhY2thZ2UgdmVyc2lvbiBmb3I6XG4vLyAtIEhUVFAgcmVxdWVzdCBoZWFkZXJzIChlLmcuLCBYLUNsaWVudC1JbmZvIGhlYWRlciBmb3IgQVBJIHJlcXVlc3RzKVxuLy8gLSBEZWJ1Z2dpbmcgYW5kIHN1cHBvcnQgKGlkZW50aWZ5aW5nIHdoaWNoIHZlcnNpb24gaXMgcnVubmluZylcbi8vIC0gVGVsZW1ldHJ5IGFuZCBsb2dnaW5nICh2ZXJzaW9uIHJlcG9ydGluZyBpbiBlcnJvcnMvYW5hbHl0aWNzKVxuLy8gLSBFbnN1cmluZyBidWlsZCBhcnRpZmFjdHMgbWF0Y2ggdGhlIHB1Ymxpc2hlZCBwYWNrYWdlIHZlcnNpb25cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuOTMuMydcbiIsICJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJ1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHtcbiAgJ1gtQ2xpZW50LUluZm8nOiBgc3RvcmFnZS1qcy8ke3ZlcnNpb259YCxcbn1cbiIsICJpbXBvcnQgeyBERUZBVUxUX0hFQURFUlMgfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IHsgU3RvcmFnZUVycm9yIH0gZnJvbSAnLi4vbGliL2NvbW1vbi9lcnJvcnMnXG5pbXBvcnQgeyBGZXRjaCwgZ2V0LCBwb3N0LCBwdXQsIHJlbW92ZSB9IGZyb20gJy4uL2xpYi9jb21tb24vZmV0Y2gnXG5pbXBvcnQgQmFzZUFwaUNsaWVudCBmcm9tICcuLi9saWIvY29tbW9uL0Jhc2VBcGlDbGllbnQnXG5pbXBvcnQgeyBCdWNrZXQsIEJ1Y2tldFR5cGUsIExpc3RCdWNrZXRPcHRpb25zIH0gZnJvbSAnLi4vbGliL3R5cGVzJ1xuaW1wb3J0IHsgU3RvcmFnZUNsaWVudE9wdGlvbnMgfSBmcm9tICcuLi9TdG9yYWdlQ2xpZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdG9yYWdlQnVja2V0QXBpIGV4dGVuZHMgQmFzZUFwaUNsaWVudDxTdG9yYWdlRXJyb3I+IHtcbiAgY29uc3RydWN0b3IoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9LFxuICAgIGZldGNoPzogRmV0Y2gsXG4gICAgb3B0cz86IFN0b3JhZ2VDbGllbnRPcHRpb25zXG4gICkge1xuICAgIGNvbnN0IGJhc2VVcmwgPSBuZXcgVVJMKHVybClcblxuICAgIC8vIGlmIGxlZ2FjeSB1cmkgaXMgdXNlZCwgcmVwbGFjZSB3aXRoIG5ldyBzdG9yYWdlIGhvc3QgKGRpc2FibGVzIHJlcXVlc3QgYnVmZmVyaW5nIHRvIGFsbG93ID4gNTBHQiB1cGxvYWRzKVxuICAgIC8vIFwicHJvamVjdC1yZWYuc3VwYWJhc2UuY29cIiBiZWNvbWVzIFwicHJvamVjdC1yZWYuc3RvcmFnZS5zdXBhYmFzZS5jb1wiXG4gICAgaWYgKG9wdHM/LnVzZU5ld0hvc3RuYW1lKSB7XG4gICAgICBjb25zdCBpc1N1cGFiYXNlSG9zdCA9IC9zdXBhYmFzZVxcLihjb3xpbnxyZWQpJC8udGVzdChiYXNlVXJsLmhvc3RuYW1lKVxuICAgICAgaWYgKGlzU3VwYWJhc2VIb3N0ICYmICFiYXNlVXJsLmhvc3RuYW1lLmluY2x1ZGVzKCdzdG9yYWdlLnN1cGFiYXNlLicpKSB7XG4gICAgICAgIGJhc2VVcmwuaG9zdG5hbWUgPSBiYXNlVXJsLmhvc3RuYW1lLnJlcGxhY2UoJ3N1cGFiYXNlLicsICdzdG9yYWdlLnN1cGFiYXNlLicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmluYWxVcmwgPSBiYXNlVXJsLmhyZWYucmVwbGFjZSgvXFwvJC8sICcnKVxuICAgIGNvbnN0IGZpbmFsSGVhZGVycyA9IHsgLi4uREVGQVVMVF9IRUFERVJTLCAuLi5oZWFkZXJzIH1cblxuICAgIHN1cGVyKGZpbmFsVXJsLCBmaW5hbEhlYWRlcnMsIGZldGNoLCAnc3RvcmFnZScpXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFsbCBTdG9yYWdlIGJ1Y2tldHMgd2l0aGluIGFuIGV4aXN0aW5nIHByb2plY3QuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcbiAgICogQHBhcmFtIG9wdGlvbnMgUXVlcnkgcGFyYW1ldGVycyBmb3IgbGlzdGluZyBidWNrZXRzXG4gICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IE1heGltdW0gbnVtYmVyIG9mIGJ1Y2tldHMgdG8gcmV0dXJuXG4gICAqIEBwYXJhbSBvcHRpb25zLm9mZnNldCBOdW1iZXIgb2YgYnVja2V0cyB0byBza2lwXG4gICAqIEBwYXJhbSBvcHRpb25zLnNvcnRDb2x1bW4gQ29sdW1uIHRvIHNvcnQgYnkgKCdpZCcsICduYW1lJywgJ2NyZWF0ZWRfYXQnLCAndXBkYXRlZF9hdCcpXG4gICAqIEBwYXJhbSBvcHRpb25zLnNvcnRPcmRlciBTb3J0IG9yZGVyICgnYXNjJyBvciAnZGVzYycpXG4gICAqIEBwYXJhbSBvcHRpb25zLnNlYXJjaCBTZWFyY2ggdGVybSB0byBmaWx0ZXIgYnVja2V0IG5hbWVzXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGFycmF5IG9mIGJ1Y2tldHMgb3IgZXJyb3JcbiAgICpcbiAgICogQGV4YW1wbGUgTGlzdCBidWNrZXRzXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAqICAgLnN0b3JhZ2VcbiAgICogICAubGlzdEJ1Y2tldHMoKVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgTGlzdCBidWNrZXRzIHdpdGggb3B0aW9uc1xuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmxpc3RCdWNrZXRzKHtcbiAgICogICAgIGxpbWl0OiAxMCxcbiAgICogICAgIG9mZnNldDogMCxcbiAgICogICAgIHNvcnRDb2x1bW46ICdjcmVhdGVkX2F0JyxcbiAgICogICAgIHNvcnRPcmRlcjogJ2Rlc2MnLFxuICAgKiAgICAgc2VhcmNoOiAncHJvZCdcbiAgICogICB9KVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxpc3RCdWNrZXRzKG9wdGlvbnM/OiBMaXN0QnVja2V0T3B0aW9ucyk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IEJ1Y2tldFtdXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSB0aGlzLmxpc3RCdWNrZXRPcHRpb25zVG9RdWVyeVN0cmluZyhvcHRpb25zKVxuICAgICAgcmV0dXJuIGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0JHtxdWVyeVN0cmluZ31gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgU3RvcmFnZSBidWNrZXQuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcbiAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIHJldHJpZXZlLlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBidWNrZXQgZGV0YWlscyBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZSBHZXQgYnVja2V0XG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAqICAgLnN0b3JhZ2VcbiAgICogICAuZ2V0QnVja2V0KCdhdmF0YXJzJylcbiAgICogYGBgXG4gICAqXG4gICAqIFJlc3BvbnNlOlxuICAgKiBgYGBqc29uXG4gICAqIHtcbiAgICogICBcImRhdGFcIjoge1xuICAgKiAgICAgXCJpZFwiOiBcImF2YXRhcnNcIixcbiAgICogICAgIFwibmFtZVwiOiBcImF2YXRhcnNcIixcbiAgICogICAgIFwib3duZXJcIjogXCJcIixcbiAgICogICAgIFwicHVibGljXCI6IGZhbHNlLFxuICAgKiAgICAgXCJmaWxlX3NpemVfbGltaXRcIjogMTAyNCxcbiAgICogICAgIFwiYWxsb3dlZF9taW1lX3R5cGVzXCI6IFtcbiAgICogICAgICAgXCJpbWFnZS9wbmdcIlxuICAgKiAgICAgXSxcbiAgICogICAgIFwiY3JlYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiLFxuICAgKiAgICAgXCJ1cGRhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCJcbiAgICogICB9LFxuICAgKiAgIFwiZXJyb3JcIjogbnVsbFxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2V0QnVja2V0KGlkOiBzdHJpbmcpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBCdWNrZXRcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH1gLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTdG9yYWdlIGJ1Y2tldFxuICAgKlxuICAgKiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG4gICAqIEBwYXJhbSBpZCBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgY3JlYXRpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuIEJ5IGRlZmF1bHQsIGJ1Y2tldHMgYXJlIHByaXZhdGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLmZpbGVTaXplTGltaXQgc3BlY2lmaWVzIHRoZSBtYXggZmlsZSBzaXplIGluIGJ5dGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoaXMgYnVja2V0LlxuICAgKiBUaGUgZ2xvYmFsIGZpbGUgc2l6ZSBsaW1pdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyB2YWx1ZS5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cbiAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyBzcGVjaWZpZXMgdGhlIGFsbG93ZWQgbWltZSB0eXBlcyB0aGF0IHRoaXMgYnVja2V0IGNhbiBhY2NlcHQgZHVyaW5nIHVwbG9hZC5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggYWxsb3dzIGZpbGVzIHdpdGggYWxsIG1pbWUgdHlwZXMgdG8gYmUgdXBsb2FkZWQuXG4gICAqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLnR5cGUgKHByaXZhdGUtYmV0YSkgc3BlY2lmaWVzIHRoZSBidWNrZXQgdHlwZS4gc2VlIGBCdWNrZXRUeXBlYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKiAgIC0gZGVmYXVsdCBidWNrZXQgdHlwZSBpcyBgU1RBTkRBUkRgXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIG5ld2x5IGNyZWF0ZWQgYnVja2V0IG5hbWUgb3IgZXJyb3JcbiAgICpcbiAgICogQGV4YW1wbGUgQ3JlYXRlIGJ1Y2tldFxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmNyZWF0ZUJ1Y2tldCgnYXZhdGFycycsIHtcbiAgICogICAgIHB1YmxpYzogZmFsc2UsXG4gICAqICAgICBhbGxvd2VkTWltZVR5cGVzOiBbJ2ltYWdlL3BuZyddLFxuICAgKiAgICAgZmlsZVNpemVMaW1pdDogMTAyNFxuICAgKiAgIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBSZXNwb25zZTpcbiAgICogYGBganNvblxuICAgKiB7XG4gICAqICAgXCJkYXRhXCI6IHtcbiAgICogICAgIFwibmFtZVwiOiBcImF2YXRhcnNcIlxuICAgKiAgIH0sXG4gICAqICAgXCJlcnJvclwiOiBudWxsXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVCdWNrZXQoXG4gICAgaWQ6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwdWJsaWM6IGJvb2xlYW5cbiAgICAgIGZpbGVTaXplTGltaXQ/OiBudW1iZXIgfCBzdHJpbmcgfCBudWxsXG4gICAgICBhbGxvd2VkTWltZVR5cGVzPzogc3RyaW5nW10gfCBudWxsXG4gICAgICB0eXBlPzogQnVja2V0VHlwZVxuICAgIH0gPSB7XG4gICAgICBwdWJsaWM6IGZhbHNlLFxuICAgIH1cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogUGljazxCdWNrZXQsICduYW1lJz5cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L2J1Y2tldGAsXG4gICAgICAgIHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBuYW1lOiBpZCxcbiAgICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGUsXG4gICAgICAgICAgcHVibGljOiBvcHRpb25zLnB1YmxpYyxcbiAgICAgICAgICBmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcbiAgICAgICAgICBhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyxcbiAgICAgICAgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhIFN0b3JhZ2UgYnVja2V0XG4gICAqXG4gICAqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcbiAgICogQHBhcmFtIGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidWNrZXQgeW91IGFyZSB1cGRhdGluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMucHVibGljIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidWNrZXQuIFB1YmxpYyBidWNrZXRzIGRvbid0IHJlcXVpcmUgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiB0byBkb3dubG9hZCBvYmplY3RzLCBidXQgc3RpbGwgcmVxdWlyZSBhIHZhbGlkIHRva2VuIGZvciBhbGwgb3RoZXIgb3BlcmF0aW9ucy5cbiAgICogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG4gICAqIFRoZSBnbG9iYWwgZmlsZSBzaXplIGxpbWl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHZhbHVlLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBkb2Vzbid0IHNldCBhIHBlciBidWNrZXQgZmlsZSBzaXplIGxpbWl0LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBhbGxvd3MgZmlsZXMgd2l0aCBhbGwgbWltZSB0eXBlcyB0byBiZSB1cGxvYWRlZC5cbiAgICogRWFjaCBtaW1lIHR5cGUgc3BlY2lmaWVkIGNhbiBiZSBhIHdpbGRjYXJkLCBlLmcuIGltYWdlLyosIG9yIGEgc3BlY2lmaWMgbWltZSB0eXBlLCBlLmcuIGltYWdlL3BuZy5cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlIFVwZGF0ZSBidWNrZXRcbiAgICogYGBganNcbiAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICogICAuc3RvcmFnZVxuICAgKiAgIC51cGRhdGVCdWNrZXQoJ2F2YXRhcnMnLCB7XG4gICAqICAgICBwdWJsaWM6IGZhbHNlLFxuICAgKiAgICAgYWxsb3dlZE1pbWVUeXBlczogWydpbWFnZS9wbmcnXSxcbiAgICogICAgIGZpbGVTaXplTGltaXQ6IDEwMjRcbiAgICogICB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogUmVzcG9uc2U6XG4gICAqIGBgYGpzb25cbiAgICoge1xuICAgKiAgIFwiZGF0YVwiOiB7XG4gICAqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgdXBkYXRlZFwiXG4gICAqICAgfSxcbiAgICogICBcImVycm9yXCI6IG51bGxcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHVwZGF0ZUJ1Y2tldChcbiAgICBpZDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHB1YmxpYzogYm9vbGVhblxuICAgICAgZmlsZVNpemVMaW1pdD86IG51bWJlciB8IHN0cmluZyB8IG51bGxcbiAgICAgIGFsbG93ZWRNaW1lVHlwZXM/OiBzdHJpbmdbXSB8IG51bGxcbiAgICB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgcHV0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCxcbiAgICAgICAge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIG5hbWU6IGlkLFxuICAgICAgICAgIHB1YmxpYzogb3B0aW9ucy5wdWJsaWMsXG4gICAgICAgICAgZmlsZV9zaXplX2xpbWl0OiBvcHRpb25zLmZpbGVTaXplTGltaXQsXG4gICAgICAgICAgYWxsb3dlZF9taW1lX3R5cGVzOiBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIG9iamVjdHMgaW5zaWRlIGEgc2luZ2xlIGJ1Y2tldC5cbiAgICpcbiAgICogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuICAgKiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZW1wdHkuXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBzdWNjZXNzIG1lc3NhZ2Ugb3IgZXJyb3JcbiAgICpcbiAgICogQGV4YW1wbGUgRW1wdHkgYnVja2V0XG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAqICAgLnN0b3JhZ2VcbiAgICogICAuZW1wdHlCdWNrZXQoJ2F2YXRhcnMnKVxuICAgKiBgYGBcbiAgICpcbiAgICogUmVzcG9uc2U6XG4gICAqIGBgYGpzb25cbiAgICoge1xuICAgKiAgIFwiZGF0YVwiOiB7XG4gICAqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgZW1wdGllZFwiXG4gICAqICAgfSxcbiAgICogICBcImVycm9yXCI6IG51bGxcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGVtcHR5QnVja2V0KGlkOiBzdHJpbmcpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IG1lc3NhZ2U6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L2J1Y2tldC8ke2lkfS9lbXB0eWAsIHt9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBleGlzdGluZyBidWNrZXQuIEEgYnVja2V0IGNhbid0IGJlIGRlbGV0ZWQgd2l0aCBleGlzdGluZyBvYmplY3RzIGluc2lkZSBpdC5cbiAgICogWW91IG11c3QgZmlyc3QgYGVtcHR5KClgIHRoZSBidWNrZXQuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcbiAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGRlbGV0ZS5cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHN1Y2Nlc3MgbWVzc2FnZSBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZSBEZWxldGUgYnVja2V0XG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAqICAgLnN0b3JhZ2VcbiAgICogICAuZGVsZXRlQnVja2V0KCdhdmF0YXJzJylcbiAgICogYGBgXG4gICAqXG4gICAqIFJlc3BvbnNlOlxuICAgKiBgYGBqc29uXG4gICAqIHtcbiAgICogICBcImRhdGFcIjoge1xuICAgKiAgICAgXCJtZXNzYWdlXCI6IFwiU3VjY2Vzc2Z1bGx5IGRlbGV0ZWRcIlxuICAgKiAgIH0sXG4gICAqICAgXCJlcnJvclwiOiBudWxsXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBkZWxldGVCdWNrZXQoaWQ6IHN0cmluZyk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgcmVtb3ZlKHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH1gLCB7fSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSlcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBsaXN0QnVja2V0T3B0aW9uc1RvUXVlcnlTdHJpbmcob3B0aW9ucz86IExpc3RCdWNrZXRPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAoJ2xpbWl0JyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHBhcmFtcy5saW1pdCA9IFN0cmluZyhvcHRpb25zLmxpbWl0KVxuICAgICAgfVxuICAgICAgaWYgKCdvZmZzZXQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgcGFyYW1zLm9mZnNldCA9IFN0cmluZyhvcHRpb25zLm9mZnNldClcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNlYXJjaCkge1xuICAgICAgICBwYXJhbXMuc2VhcmNoID0gb3B0aW9ucy5zZWFyY2hcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNvcnRDb2x1bW4pIHtcbiAgICAgICAgcGFyYW1zLnNvcnRDb2x1bW4gPSBvcHRpb25zLnNvcnRDb2x1bW5cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNvcnRPcmRlcikge1xuICAgICAgICBwYXJhbXMuc29ydE9yZGVyID0gb3B0aW9ucy5zb3J0T3JkZXJcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID4gMCA/ICc/JyArIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKS50b1N0cmluZygpIDogJydcbiAgfVxufVxuIiwgImltcG9ydCB7IEljZWJlcmdSZXN0Q2F0YWxvZywgSWNlYmVyZ0Vycm9yIH0gZnJvbSAnaWNlYmVyZy1qcydcbmltcG9ydCB7IERFRkFVTFRfSEVBREVSUyB9IGZyb20gJy4uL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgeyBTdG9yYWdlRXJyb3IgfSBmcm9tICcuLi9saWIvY29tbW9uL2Vycm9ycydcbmltcG9ydCB7IEZldGNoLCBnZXQsIHBvc3QsIHJlbW92ZSB9IGZyb20gJy4uL2xpYi9jb21tb24vZmV0Y2gnXG5pbXBvcnQgeyBpc1ZhbGlkQnVja2V0TmFtZSB9IGZyb20gJy4uL2xpYi9jb21tb24vaGVscGVycydcbmltcG9ydCBCYXNlQXBpQ2xpZW50IGZyb20gJy4uL2xpYi9jb21tb24vQmFzZUFwaUNsaWVudCdcbmltcG9ydCB7IEFuYWx5dGljQnVja2V0IH0gZnJvbSAnLi4vbGliL3R5cGVzJ1xuXG50eXBlIFdyYXBBc3luY01ldGhvZDxUPiA9IFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgQSkgPT4gUHJvbWlzZTxpbmZlciBSPlxuICA/ICguLi5hcmdzOiBBKSA9PiBQcm9taXNlPHsgZGF0YTogUjsgZXJyb3I6IG51bGwgfSB8IHsgZGF0YTogbnVsbDsgZXJyb3I6IEljZWJlcmdFcnJvciB9PlxuICA6IFRcblxuZXhwb3J0IHR5cGUgV3JhcHBlZEljZWJlcmdSZXN0Q2F0YWxvZyA9IHtcbiAgW0sgaW4ga2V5b2YgSWNlYmVyZ1Jlc3RDYXRhbG9nXTogV3JhcEFzeW5jTWV0aG9kPEljZWJlcmdSZXN0Q2F0YWxvZ1tLXT5cbn1cblxuLyoqXG4gKiBDbGllbnQgY2xhc3MgZm9yIG1hbmFnaW5nIEFuYWx5dGljcyBCdWNrZXRzIHVzaW5nIEljZWJlcmcgdGFibGVzXG4gKiBQcm92aWRlcyBtZXRob2RzIGZvciBjcmVhdGluZywgbGlzdGluZywgYW5kIGRlbGV0aW5nIGFuYWx5dGljcyBidWNrZXRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VBbmFseXRpY3NDbGllbnQgZXh0ZW5kcyBCYXNlQXBpQ2xpZW50PFN0b3JhZ2VFcnJvcj4ge1xuICAvKipcbiAgICogQGFscGhhXG4gICAqXG4gICAqIENyZWF0ZXMgYSBuZXcgU3RvcmFnZUFuYWx5dGljc0NsaWVudCBpbnN0YW5jZVxuICAgKlxuICAgKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcbiAgICogQHBhcmFtIHVybCAtIFRoZSBiYXNlIFVSTCBmb3IgdGhlIHN0b3JhZ2UgQVBJXG4gICAqIEBwYXJhbSBoZWFkZXJzIC0gSFRUUCBoZWFkZXJzIHRvIGluY2x1ZGUgaW4gcmVxdWVzdHNcbiAgICogQHBhcmFtIGZldGNoIC0gT3B0aW9uYWwgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY2xpZW50ID0gbmV3IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQodXJsLCBoZWFkZXJzKVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nLCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge30sIGZldGNoPzogRmV0Y2gpIHtcbiAgICBjb25zdCBmaW5hbFVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgJycpXG4gICAgY29uc3QgZmluYWxIZWFkZXJzID0geyAuLi5ERUZBVUxUX0hFQURFUlMsIC4uLmhlYWRlcnMgfVxuICAgIHN1cGVyKGZpbmFsVXJsLCBmaW5hbEhlYWRlcnMsIGZldGNoLCAnc3RvcmFnZScpXG4gIH1cblxuICAvKipcbiAgICogQGFscGhhXG4gICAqXG4gICAqIENyZWF0ZXMgYSBuZXcgYW5hbHl0aWNzIGJ1Y2tldCB1c2luZyBJY2ViZXJnIHRhYmxlc1xuICAgKiBBbmFseXRpY3MgYnVja2V0cyBhcmUgb3B0aW1pemVkIGZvciBhbmFseXRpY2FsIHF1ZXJpZXMgYW5kIGRhdGEgcHJvY2Vzc2luZ1xuICAgKlxuICAgKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcbiAgICogQHBhcmFtIG5hbWUgQSB1bmlxdWUgbmFtZSBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIG5ld2x5IGNyZWF0ZWQgYW5hbHl0aWNzIGJ1Y2tldCBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZSBDcmVhdGUgYW5hbHl0aWNzIGJ1Y2tldFxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmFuYWx5dGljc1xuICAgKiAgIC5jcmVhdGVCdWNrZXQoJ2FuYWx5dGljcy1kYXRhJylcbiAgICogYGBgXG4gICAqXG4gICAqIFJlc3BvbnNlOlxuICAgKiBgYGBqc29uXG4gICAqIHtcbiAgICogICBcImRhdGFcIjoge1xuICAgKiAgICAgXCJuYW1lXCI6IFwiYW5hbHl0aWNzLWRhdGFcIixcbiAgICogICAgIFwidHlwZVwiOiBcIkFOQUxZVElDU1wiLFxuICAgKiAgICAgXCJmb3JtYXRcIjogXCJpY2ViZXJnXCIsXG4gICAqICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIixcbiAgICogICAgIFwidXBkYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiXG4gICAqICAgfSxcbiAgICogICBcImVycm9yXCI6IG51bGxcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUJ1Y2tldChuYW1lOiBzdHJpbmcpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBBbmFseXRpY0J1Y2tldFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXRgLCB7IG5hbWUgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBhbHBoYVxuICAgKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYWxsIEFuYWx5dGljcyBTdG9yYWdlIGJ1Y2tldHMgd2l0aGluIGFuIGV4aXN0aW5nIHByb2plY3RcbiAgICogT25seSByZXR1cm5zIGJ1Y2tldHMgb2YgdHlwZSAnQU5BTFlUSUNTJ1xuICAgKlxuICAgKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcbiAgICogQHBhcmFtIG9wdGlvbnMgUXVlcnkgcGFyYW1ldGVycyBmb3IgbGlzdGluZyBidWNrZXRzXG4gICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IE1heGltdW0gbnVtYmVyIG9mIGJ1Y2tldHMgdG8gcmV0dXJuXG4gICAqIEBwYXJhbSBvcHRpb25zLm9mZnNldCBOdW1iZXIgb2YgYnVja2V0cyB0byBza2lwXG4gICAqIEBwYXJhbSBvcHRpb25zLnNvcnRDb2x1bW4gQ29sdW1uIHRvIHNvcnQgYnkgKCduYW1lJywgJ2NyZWF0ZWRfYXQnLCAndXBkYXRlZF9hdCcpXG4gICAqIEBwYXJhbSBvcHRpb25zLnNvcnRPcmRlciBTb3J0IG9yZGVyICgnYXNjJyBvciAnZGVzYycpXG4gICAqIEBwYXJhbSBvcHRpb25zLnNlYXJjaCBTZWFyY2ggdGVybSB0byBmaWx0ZXIgYnVja2V0IG5hbWVzXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGFycmF5IG9mIGFuYWx5dGljcyBidWNrZXRzIG9yIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlIExpc3QgYW5hbHl0aWNzIGJ1Y2tldHNcbiAgICogYGBganNcbiAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICogICAuc3RvcmFnZVxuICAgKiAgIC5hbmFseXRpY3NcbiAgICogICAubGlzdEJ1Y2tldHMoe1xuICAgKiAgICAgbGltaXQ6IDEwLFxuICAgKiAgICAgb2Zmc2V0OiAwLFxuICAgKiAgICAgc29ydENvbHVtbjogJ2NyZWF0ZWRfYXQnLFxuICAgKiAgICAgc29ydE9yZGVyOiAnZGVzYydcbiAgICogICB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogUmVzcG9uc2U6XG4gICAqIGBgYGpzb25cbiAgICoge1xuICAgKiAgIFwiZGF0YVwiOiBbXG4gICAqICAgICB7XG4gICAqICAgICAgIFwibmFtZVwiOiBcImFuYWx5dGljcy1kYXRhXCIsXG4gICAqICAgICAgIFwidHlwZVwiOiBcIkFOQUxZVElDU1wiLFxuICAgKiAgICAgICBcImZvcm1hdFwiOiBcImljZWJlcmdcIixcbiAgICogICAgICAgXCJjcmVhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCIsXG4gICAqICAgICAgIFwidXBkYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiXG4gICAqICAgICB9XG4gICAqICAgXSxcbiAgICogICBcImVycm9yXCI6IG51bGxcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxpc3RCdWNrZXRzKG9wdGlvbnM/OiB7XG4gICAgbGltaXQ/OiBudW1iZXJcbiAgICBvZmZzZXQ/OiBudW1iZXJcbiAgICBzb3J0Q29sdW1uPzogJ25hbWUnIHwgJ2NyZWF0ZWRfYXQnIHwgJ3VwZGF0ZWRfYXQnXG4gICAgc29ydE9yZGVyPzogJ2FzYycgfCAnZGVzYydcbiAgICBzZWFyY2g/OiBzdHJpbmdcbiAgfSk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IEFuYWx5dGljQnVja2V0W11cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAvLyBCdWlsZCBxdWVyeSBzdHJpbmcgZnJvbSBvcHRpb25zXG4gICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuICAgICAgaWYgKG9wdGlvbnM/LmxpbWl0ICE9PSB1bmRlZmluZWQpIHF1ZXJ5UGFyYW1zLnNldCgnbGltaXQnLCBvcHRpb25zLmxpbWl0LnRvU3RyaW5nKCkpXG4gICAgICBpZiAob3B0aW9ucz8ub2Zmc2V0ICE9PSB1bmRlZmluZWQpIHF1ZXJ5UGFyYW1zLnNldCgnb2Zmc2V0Jywgb3B0aW9ucy5vZmZzZXQudG9TdHJpbmcoKSlcbiAgICAgIGlmIChvcHRpb25zPy5zb3J0Q29sdW1uKSBxdWVyeVBhcmFtcy5zZXQoJ3NvcnRDb2x1bW4nLCBvcHRpb25zLnNvcnRDb2x1bW4pXG4gICAgICBpZiAob3B0aW9ucz8uc29ydE9yZGVyKSBxdWVyeVBhcmFtcy5zZXQoJ3NvcnRPcmRlcicsIG9wdGlvbnMuc29ydE9yZGVyKVxuICAgICAgaWYgKG9wdGlvbnM/LnNlYXJjaCkgcXVlcnlQYXJhbXMuc2V0KCdzZWFyY2gnLCBvcHRpb25zLnNlYXJjaClcblxuICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSBxdWVyeVBhcmFtcy50b1N0cmluZygpXG4gICAgICBjb25zdCB1cmwgPSBxdWVyeVN0cmluZyA/IGAke3RoaXMudXJsfS9idWNrZXQ/JHtxdWVyeVN0cmluZ31gIDogYCR7dGhpcy51cmx9L2J1Y2tldGBcblxuICAgICAgcmV0dXJuIGF3YWl0IGdldCh0aGlzLmZldGNoLCB1cmwsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWxwaGFcbiAgICpcbiAgICogRGVsZXRlcyBhbiBleGlzdGluZyBhbmFseXRpY3MgYnVja2V0XG4gICAqIEEgYnVja2V0IGNhbid0IGJlIGRlbGV0ZWQgd2l0aCBleGlzdGluZyBvYmplY3RzIGluc2lkZSBpdFxuICAgKiBZb3UgbXVzdCBmaXJzdCBlbXB0eSB0aGUgYnVja2V0IGJlZm9yZSBkZWxldGlvblxuICAgKlxuICAgKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcbiAgICogQHBhcmFtIGJ1Y2tldE5hbWUgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHN1Y2Nlc3MgbWVzc2FnZSBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZSBEZWxldGUgYW5hbHl0aWNzIGJ1Y2tldFxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmFuYWx5dGljc1xuICAgKiAgIC5kZWxldGVCdWNrZXQoJ2FuYWx5dGljcy1kYXRhJylcbiAgICogYGBgXG4gICAqXG4gICAqIFJlc3BvbnNlOlxuICAgKiBgYGBqc29uXG4gICAqIHtcbiAgICogICBcImRhdGFcIjoge1xuICAgKiAgICAgXCJtZXNzYWdlXCI6IFwiU3VjY2Vzc2Z1bGx5IGRlbGV0ZWRcIlxuICAgKiAgIH0sXG4gICAqICAgXCJlcnJvclwiOiBudWxsXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBkZWxldGVCdWNrZXQoYnVja2V0TmFtZTogc3RyaW5nKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBtZXNzYWdlOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCByZW1vdmUoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9idWNrZXQvJHtidWNrZXROYW1lfWAsXG4gICAgICAgIHt9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWxwaGFcbiAgICpcbiAgICogR2V0IGFuIEljZWJlcmcgUkVTVCBDYXRhbG9nIGNsaWVudCBjb25maWd1cmVkIGZvciBhIHNwZWNpZmljIGFuYWx5dGljcyBidWNrZXRcbiAgICogVXNlIHRoaXMgdG8gcGVyZm9ybSBhZHZhbmNlZCB0YWJsZSBhbmQgbmFtZXNwYWNlIG9wZXJhdGlvbnMgd2l0aGluIHRoZSBidWNrZXRcbiAgICogVGhlIHJldHVybmVkIGNsaWVudCBwcm92aWRlcyBmdWxsIGFjY2VzcyB0byB0aGUgQXBhY2hlIEljZWJlcmcgUkVTVCBDYXRhbG9nIEFQSVxuICAgKiB3aXRoIHRoZSBTdXBhYmFzZSBgeyBkYXRhLCBlcnJvciB9YCBwYXR0ZXJuIGZvciBjb25zaXN0ZW50IGVycm9yIGhhbmRsaW5nIG9uIGFsbCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcbiAgICogQHBhcmFtIGJ1Y2tldE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYW5hbHl0aWNzIGJ1Y2tldCAod2FyZWhvdXNlKSB0byBjb25uZWN0IHRvXG4gICAqIEByZXR1cm5zIFRoZSB3cmFwcGVkIEljZWJlcmcgY2F0YWxvZyBjbGllbnRcbiAgICogQHRocm93cyB7U3RvcmFnZUVycm9yfSBJZiB0aGUgYnVja2V0IG5hbWUgaXMgaW52YWxpZFxuICAgKlxuICAgKiBAZXhhbXBsZSBHZXQgY2F0YWxvZyBhbmQgY3JlYXRlIHRhYmxlXG4gICAqIGBgYGpzXG4gICAqIC8vIEZpcnN0LCBjcmVhdGUgYW4gYW5hbHl0aWNzIGJ1Y2tldFxuICAgKiBjb25zdCB7IGRhdGE6IGJ1Y2tldCwgZXJyb3I6IGJ1Y2tldEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLmFuYWx5dGljc1xuICAgKiAgIC5jcmVhdGVCdWNrZXQoJ2FuYWx5dGljcy1kYXRhJylcbiAgICpcbiAgICogLy8gR2V0IHRoZSBJY2ViZXJnIGNhdGFsb2cgZm9yIHRoYXQgYnVja2V0XG4gICAqIGNvbnN0IGNhdGFsb2cgPSBzdXBhYmFzZS5zdG9yYWdlLmFuYWx5dGljcy5mcm9tKCdhbmFseXRpY3MtZGF0YScpXG4gICAqXG4gICAqIC8vIENyZWF0ZSBhIG5hbWVzcGFjZVxuICAgKiBjb25zdCB7IGVycm9yOiBuc0Vycm9yIH0gPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSlcbiAgICpcbiAgICogLy8gQ3JlYXRlIGEgdGFibGUgd2l0aCBzY2hlbWFcbiAgICogY29uc3QgeyBkYXRhOiB0YWJsZU1ldGFkYXRhLCBlcnJvcjogdGFibGVFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZShcbiAgICogICB7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSxcbiAgICogICB7XG4gICAqICAgICBuYW1lOiAnZXZlbnRzJyxcbiAgICogICAgIHNjaGVtYToge1xuICAgKiAgICAgICB0eXBlOiAnc3RydWN0JyxcbiAgICogICAgICAgZmllbGRzOiBbXG4gICAqICAgICAgICAgeyBpZDogMSwgbmFtZTogJ2lkJywgdHlwZTogJ2xvbmcnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgKiAgICAgICAgIHsgaWQ6IDIsIG5hbWU6ICd0aW1lc3RhbXAnLCB0eXBlOiAndGltZXN0YW1wJywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICogICAgICAgICB7IGlkOiAzLCBuYW1lOiAndXNlcl9pZCcsIHR5cGU6ICdzdHJpbmcnLCByZXF1aXJlZDogZmFsc2UgfVxuICAgKiAgICAgICBdLFxuICAgKiAgICAgICAnc2NoZW1hLWlkJzogMCxcbiAgICogICAgICAgJ2lkZW50aWZpZXItZmllbGQtaWRzJzogWzFdXG4gICAqICAgICB9LFxuICAgKiAgICAgJ3BhcnRpdGlvbi1zcGVjJzoge1xuICAgKiAgICAgICAnc3BlYy1pZCc6IDAsXG4gICAqICAgICAgIGZpZWxkczogW11cbiAgICogICAgIH0sXG4gICAqICAgICAnd3JpdGUtb3JkZXInOiB7XG4gICAqICAgICAgICdvcmRlci1pZCc6IDAsXG4gICAqICAgICAgIGZpZWxkczogW11cbiAgICogICAgIH0sXG4gICAqICAgICBwcm9wZXJ0aWVzOiB7XG4gICAqICAgICAgICd3cml0ZS5mb3JtYXQuZGVmYXVsdCc6ICdwYXJxdWV0J1xuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogKVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgTGlzdCB0YWJsZXMgaW4gbmFtZXNwYWNlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNhdGFsb2cgPSBzdXBhYmFzZS5zdG9yYWdlLmFuYWx5dGljcy5mcm9tKCdhbmFseXRpY3MtZGF0YScpXG4gICAqXG4gICAqIC8vIExpc3QgYWxsIHRhYmxlcyBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2VcbiAgICogY29uc3QgeyBkYXRhOiB0YWJsZXMsIGVycm9yOiBsaXN0RXJyb3IgfSA9IGF3YWl0IGNhdGFsb2cubGlzdFRhYmxlcyh7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSlcbiAgICogaWYgKGxpc3RFcnJvcikge1xuICAgKiAgIGlmIChsaXN0RXJyb3IuaXNOb3RGb3VuZCgpKSB7XG4gICAqICAgICBjb25zb2xlLmxvZygnTmFtZXNwYWNlIG5vdCBmb3VuZCcpXG4gICAqICAgfVxuICAgKiAgIHJldHVyblxuICAgKiB9XG4gICAqIGNvbnNvbGUubG9nKHRhYmxlcykgLy8gW3sgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSwgbmFtZTogJ2V2ZW50cycgfV1cbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIFdvcmtpbmcgd2l0aCBuYW1lc3BhY2VzXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNhdGFsb2cgPSBzdXBhYmFzZS5zdG9yYWdlLmFuYWx5dGljcy5mcm9tKCdhbmFseXRpY3MtZGF0YScpXG4gICAqXG4gICAqIC8vIExpc3QgYWxsIG5hbWVzcGFjZXNcbiAgICogY29uc3QgeyBkYXRhOiBuYW1lc3BhY2VzIH0gPSBhd2FpdCBjYXRhbG9nLmxpc3ROYW1lc3BhY2VzKClcbiAgICpcbiAgICogLy8gQ3JlYXRlIG5hbWVzcGFjZSB3aXRoIHByb3BlcnRpZXNcbiAgICogYXdhaXQgY2F0YWxvZy5jcmVhdGVOYW1lc3BhY2UoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsncHJvZHVjdGlvbiddIH0sXG4gICAqICAgeyBwcm9wZXJ0aWVzOiB7IG93bmVyOiAnZGF0YS10ZWFtJywgZW52OiAncHJvZCcgfSB9XG4gICAqIClcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIENsZWFudXAgb3BlcmF0aW9uc1xuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjYXRhbG9nID0gc3VwYWJhc2Uuc3RvcmFnZS5hbmFseXRpY3MuZnJvbSgnYW5hbHl0aWNzLWRhdGEnKVxuICAgKlxuICAgKiAvLyBEcm9wIHRhYmxlIHdpdGggcHVyZ2Ugb3B0aW9uIChyZW1vdmVzIGFsbCBkYXRhKVxuICAgKiBjb25zdCB7IGVycm9yOiBkcm9wRXJyb3IgfSA9IGF3YWl0IGNhdGFsb2cuZHJvcFRhYmxlKFxuICAgKiAgIHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSwgbmFtZTogJ2V2ZW50cycgfSxcbiAgICogICB7IHB1cmdlOiB0cnVlIH1cbiAgICogKVxuICAgKlxuICAgKiBpZiAoZHJvcEVycm9yPy5pc05vdEZvdW5kKCkpIHtcbiAgICogICBjb25zb2xlLmxvZygnVGFibGUgZG9lcyBub3QgZXhpc3QnKVxuICAgKiB9XG4gICAqXG4gICAqIC8vIERyb3AgbmFtZXNwYWNlIChtdXN0IGJlIGVtcHR5KVxuICAgKiBhd2FpdCBjYXRhbG9nLmRyb3BOYW1lc3BhY2UoeyBuYW1lc3BhY2U6IFsnZGVmYXVsdCddIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGlzIG1ldGhvZCBwcm92aWRlcyBhIGJyaWRnZSBiZXR3ZWVuIFN1cGFiYXNlJ3MgYnVja2V0IG1hbmFnZW1lbnQgYW5kIHRoZSBzdGFuZGFyZFxuICAgKiBBcGFjaGUgSWNlYmVyZyBSRVNUIENhdGFsb2cgQVBJLiBUaGUgYnVja2V0IG5hbWUgbWFwcyB0byB0aGUgSWNlYmVyZyB3YXJlaG91c2UgcGFyYW1ldGVyLlxuICAgKiBBbGwgYXV0aGVudGljYXRpb24gYW5kIGNvbmZpZ3VyYXRpb24gaXMgaGFuZGxlZCBhdXRvbWF0aWNhbGx5IHVzaW5nIHlvdXIgU3VwYWJhc2UgY3JlZGVudGlhbHMuXG4gICAqXG4gICAqICoqRXJyb3IgSGFuZGxpbmcqKjogSW52YWxpZCBidWNrZXQgbmFtZXMgdGhyb3cgaW1tZWRpYXRlbHkuIEFsbCBjYXRhbG9nXG4gICAqIG9wZXJhdGlvbnMgcmV0dXJuIGB7IGRhdGEsIGVycm9yIH1gIHdoZXJlIGVycm9ycyBhcmUgYEljZWJlcmdFcnJvcmAgaW5zdGFuY2VzIGZyb20gaWNlYmVyZy1qcy5cbiAgICogVXNlIGhlbHBlciBtZXRob2RzIGxpa2UgYGVycm9yLmlzTm90Rm91bmQoKWAgb3IgY2hlY2sgYGVycm9yLnN0YXR1c2AgZm9yIHNwZWNpZmljIGVycm9yIGhhbmRsaW5nLlxuICAgKiBVc2UgYC50aHJvd09uRXJyb3IoKWAgb24gdGhlIGFuYWx5dGljcyBjbGllbnQgaWYgeW91IHByZWZlciBleGNlcHRpb25zIGZvciBjYXRhbG9nIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqICoqQ2xlYW51cCBPcGVyYXRpb25zKio6IFdoZW4gdXNpbmcgYGRyb3BUYWJsZWAsIHRoZSBgcHVyZ2U6IHRydWVgIG9wdGlvbiBwZXJtYW5lbnRseVxuICAgKiBkZWxldGVzIGFsbCB0YWJsZSBkYXRhLiBXaXRob3V0IGl0LCB0aGUgdGFibGUgaXMgbWFya2VkIGFzIGRlbGV0ZWQgYnV0IGRhdGEgcmVtYWlucy5cbiAgICpcbiAgICogKipMaWJyYXJ5IERlcGVuZGVuY3kqKjogVGhlIHJldHVybmVkIGNhdGFsb2cgd3JhcHMgYEljZWJlcmdSZXN0Q2F0YWxvZ2AgZnJvbSBpY2ViZXJnLWpzLlxuICAgKiBGb3IgY29tcGxldGUgQVBJIGRvY3VtZW50YXRpb24gYW5kIGFkdmFuY2VkIHVzYWdlLCByZWZlciB0byB0aGVcbiAgICogW2ljZWJlcmctanMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9zdXBhYmFzZS5naXRodWIuaW8vaWNlYmVyZy1qcy8pLlxuICAgKi9cbiAgZnJvbShidWNrZXROYW1lOiBzdHJpbmcpOiBXcmFwcGVkSWNlYmVyZ1Jlc3RDYXRhbG9nIHtcbiAgICAvLyBWYWxpZGF0ZSBidWNrZXQgbmFtZSB1c2luZyBzYW1lIHJ1bGVzIGFzIFN1cGFiYXNlIFN0b3JhZ2UgQVBJIGJhY2tlbmRcbiAgICBpZiAoIWlzVmFsaWRCdWNrZXROYW1lKGJ1Y2tldE5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFxuICAgICAgICAnSW52YWxpZCBidWNrZXQgbmFtZTogRmlsZSwgZm9sZGVyLCBhbmQgYnVja2V0IG5hbWVzIG11c3QgZm9sbG93IEFXUyBvYmplY3Qga2V5IG5hbWluZyBndWlkZWxpbmVzICcgK1xuICAgICAgICAgICdhbmQgc2hvdWxkIGF2b2lkIHRoZSB1c2Ugb2YgYW55IG90aGVyIGNoYXJhY3RlcnMuJ1xuICAgICAgKVxuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCB0aGUgSWNlYmVyZyBSRVNUIENhdGFsb2cgVVJMXG4gICAgLy8gVGhlIGJhc2UgVVJMIGlzIC9zdG9yYWdlL3YxL2ljZWJlcmdcbiAgICAvLyBOb3RlOiBJY2ViZXJnUmVzdENhdGFsb2cgZnJvbSBpY2ViZXJnLWpzIGF1dG9tYXRpY2FsbHkgYWRkcyAvdjEvIHByZWZpeCB0byBBUEkgcGF0aHNcbiAgICAvLyBzbyB3ZSBzaG91bGQgTk9UIGFwcGVuZCAvdjEgaGVyZSAoaXQgd291bGQgY2F1c2UgZG91YmxlIC92MS92MS8gaW4gdGhlIFVSTClcbiAgICBjb25zdCBjYXRhbG9nID0gbmV3IEljZWJlcmdSZXN0Q2F0YWxvZyh7XG4gICAgICBiYXNlVXJsOiB0aGlzLnVybCxcbiAgICAgIGNhdGFsb2dOYW1lOiBidWNrZXROYW1lLCAvLyBNYXBzIHRvIHRoZSB3YXJlaG91c2UgcGFyYW1ldGVyIGluIFN1cGFiYXNlJ3MgaW1wbGVtZW50YXRpb25cbiAgICAgIGF1dGg6IHtcbiAgICAgICAgdHlwZTogJ2N1c3RvbScsXG4gICAgICAgIGdldEhlYWRlcnM6IGFzeW5jICgpID0+IHRoaXMuaGVhZGVycyxcbiAgICAgIH0sXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICB9KVxuXG4gICAgY29uc3Qgc2hvdWxkVGhyb3dPbkVycm9yID0gdGhpcy5zaG91bGRUaHJvd09uRXJyb3JcblxuICAgIGNvbnN0IHdyYXBwZWRDYXRhbG9nID0gbmV3IFByb3h5KGNhdGFsb2csIHtcbiAgICAgIGdldCh0YXJnZXQsIHByb3A6IGtleW9mIEljZWJlcmdSZXN0Q2F0YWxvZykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtwcm9wXVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXN5bmMgKC4uLmFyZ3M6IHVua25vd25bXSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgKHZhbHVlIGFzIEZ1bmN0aW9uKS5hcHBseSh0YXJnZXQsIGFyZ3MpXG4gICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBlcnJvciBhcyBJY2ViZXJnRXJyb3IgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KSBhcyB1bmtub3duIGFzIFdyYXBwZWRJY2ViZXJnUmVzdENhdGFsb2dcblxuICAgIHJldHVybiB3cmFwcGVkQ2F0YWxvZ1xuICB9XG59XG4iLCAiaW1wb3J0IHsgREVGQVVMVF9IRUFERVJTIH0gZnJvbSAnLi4vbGliL2NvbnN0YW50cydcbmltcG9ydCB7IFN0b3JhZ2VFcnJvciB9IGZyb20gJy4uL2xpYi9jb21tb24vZXJyb3JzJ1xuaW1wb3J0IHsgRmV0Y2gsIHZlY3RvcnNBcGkgfSBmcm9tICcuLi9saWIvY29tbW9uL2ZldGNoJ1xuaW1wb3J0IEJhc2VBcGlDbGllbnQgZnJvbSAnLi4vbGliL2NvbW1vbi9CYXNlQXBpQ2xpZW50J1xuaW1wb3J0IHtcbiAgQXBpUmVzcG9uc2UsXG4gIFZlY3RvckluZGV4LFxuICBMaXN0SW5kZXhlc09wdGlvbnMsXG4gIExpc3RJbmRleGVzUmVzcG9uc2UsXG4gIFZlY3RvckRhdGFUeXBlLFxuICBEaXN0YW5jZU1ldHJpYyxcbiAgTWV0YWRhdGFDb25maWd1cmF0aW9uLFxufSBmcm9tICcuLi9saWIvdHlwZXMnXG5cbi8qKlxuICogQGFscGhhXG4gKlxuICogT3B0aW9ucyBmb3IgY3JlYXRpbmcgYSB2ZWN0b3IgaW5kZXhcbiAqXG4gKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUluZGV4T3B0aW9ucyB7XG4gIHZlY3RvckJ1Y2tldE5hbWU6IHN0cmluZ1xuICBpbmRleE5hbWU6IHN0cmluZ1xuICBkYXRhVHlwZTogVmVjdG9yRGF0YVR5cGVcbiAgZGltZW5zaW9uOiBudW1iZXJcbiAgZGlzdGFuY2VNZXRyaWM6IERpc3RhbmNlTWV0cmljXG4gIG1ldGFkYXRhQ29uZmlndXJhdGlvbj86IE1ldGFkYXRhQ29uZmlndXJhdGlvblxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEJhc2UgaW1wbGVtZW50YXRpb24gZm9yIHZlY3RvciBpbmRleCBvcGVyYXRpb25zLlxuICogVXNlIHtAbGluayBWZWN0b3JCdWNrZXRTY29wZX0gdmlhIGBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnYnVja2V0JylgIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvckluZGV4QXBpIGV4dGVuZHMgQmFzZUFwaUNsaWVudDxTdG9yYWdlRXJyb3I+IHtcbiAgLyoqIENyZWF0ZXMgYSBuZXcgVmVjdG9ySW5kZXhBcGkgaW5zdGFuY2UgKi9cbiAgY29uc3RydWN0b3IodXJsOiBzdHJpbmcsIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSwgZmV0Y2g/OiBGZXRjaCkge1xuICAgIGNvbnN0IGZpbmFsVXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJylcbiAgICBjb25zdCBmaW5hbEhlYWRlcnMgPSB7IC4uLkRFRkFVTFRfSEVBREVSUywgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgLi4uaGVhZGVycyB9XG4gICAgc3VwZXIoZmluYWxVcmwsIGZpbmFsSGVhZGVycywgZmV0Y2gsICd2ZWN0b3JzJylcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIGEgbmV3IHZlY3RvciBpbmRleCB3aXRoaW4gYSBidWNrZXQgKi9cbiAgYXN5bmMgY3JlYXRlSW5kZXgob3B0aW9uczogQ3JlYXRlSW5kZXhPcHRpb25zKTogUHJvbWlzZTxBcGlSZXNwb25zZTx1bmRlZmluZWQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB2ZWN0b3JzQXBpLnBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L0NyZWF0ZUluZGV4YCwgb3B0aW9ucywge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGRhdGEgfHwge31cbiAgICB9KVxuICB9XG5cbiAgLyoqIFJldHJpZXZlcyBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyB2ZWN0b3IgaW5kZXggKi9cbiAgYXN5bmMgZ2V0SW5kZXgoXG4gICAgdmVjdG9yQnVja2V0TmFtZTogc3RyaW5nLFxuICAgIGluZGV4TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8QXBpUmVzcG9uc2U8eyBpbmRleDogVmVjdG9ySW5kZXggfT4+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHZlY3RvcnNBcGkucG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L0dldEluZGV4YCxcbiAgICAgICAgeyB2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICAvKiogTGlzdHMgdmVjdG9yIGluZGV4ZXMgd2l0aGluIGEgYnVja2V0IHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uICovXG4gIGFzeW5jIGxpc3RJbmRleGVzKG9wdGlvbnM6IExpc3RJbmRleGVzT3B0aW9ucyk6IFByb21pc2U8QXBpUmVzcG9uc2U8TGlzdEluZGV4ZXNSZXNwb25zZT4+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHZlY3RvcnNBcGkucG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vTGlzdEluZGV4ZXNgLCBvcHRpb25zLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKiBEZWxldGVzIGEgdmVjdG9yIGluZGV4IGFuZCBhbGwgaXRzIGRhdGEgKi9cbiAgYXN5bmMgZGVsZXRlSW5kZXgodmVjdG9yQnVja2V0TmFtZTogc3RyaW5nLCBpbmRleE5hbWU6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8dW5kZWZpbmVkPj4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vRGVsZXRlSW5kZXhgLFxuICAgICAgICB7IHZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4gZGF0YSB8fCB7fVxuICAgIH0pXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBERUZBVUxUX0hFQURFUlMgfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IHsgU3RvcmFnZUVycm9yIH0gZnJvbSAnLi4vbGliL2NvbW1vbi9lcnJvcnMnXG5pbXBvcnQgeyBGZXRjaCwgdmVjdG9yc0FwaSB9IGZyb20gJy4uL2xpYi9jb21tb24vZmV0Y2gnXG5pbXBvcnQgQmFzZUFwaUNsaWVudCBmcm9tICcuLi9saWIvY29tbW9uL0Jhc2VBcGlDbGllbnQnXG5pbXBvcnQge1xuICBBcGlSZXNwb25zZSxcbiAgUHV0VmVjdG9yc09wdGlvbnMsXG4gIEdldFZlY3RvcnNPcHRpb25zLFxuICBHZXRWZWN0b3JzUmVzcG9uc2UsXG4gIERlbGV0ZVZlY3RvcnNPcHRpb25zLFxuICBMaXN0VmVjdG9yc09wdGlvbnMsXG4gIExpc3RWZWN0b3JzUmVzcG9uc2UsXG4gIFF1ZXJ5VmVjdG9yc09wdGlvbnMsXG4gIFF1ZXJ5VmVjdG9yc1Jlc3BvbnNlLFxufSBmcm9tICcuLi9saWIvdHlwZXMnXG5cbi8qKlxuICogQGhpZGRlblxuICogQmFzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdmVjdG9yIGRhdGEgb3BlcmF0aW9ucy5cbiAqIFVzZSB7QGxpbmsgVmVjdG9ySW5kZXhTY29wZX0gdmlhIGBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnYnVja2V0JykuaW5kZXgoJ2lkeCcpYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3JEYXRhQXBpIGV4dGVuZHMgQmFzZUFwaUNsaWVudDxTdG9yYWdlRXJyb3I+IHtcbiAgLyoqIENyZWF0ZXMgYSBuZXcgVmVjdG9yRGF0YUFwaSBpbnN0YW5jZSAqL1xuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZywgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9LCBmZXRjaD86IEZldGNoKSB7XG4gICAgY29uc3QgZmluYWxVcmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sICcnKVxuICAgIGNvbnN0IGZpbmFsSGVhZGVycyA9IHsgLi4uREVGQVVMVF9IRUFERVJTLCAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCAuLi5oZWFkZXJzIH1cbiAgICBzdXBlcihmaW5hbFVybCwgZmluYWxIZWFkZXJzLCBmZXRjaCwgJ3ZlY3RvcnMnKVxuICB9XG5cbiAgLyoqIEluc2VydHMgb3IgdXBkYXRlcyB2ZWN0b3JzIGluIGJhdGNoICgxLTUwMCBwZXIgcmVxdWVzdCkgKi9cbiAgYXN5bmMgcHV0VmVjdG9ycyhvcHRpb25zOiBQdXRWZWN0b3JzT3B0aW9ucyk6IFByb21pc2U8QXBpUmVzcG9uc2U8dW5kZWZpbmVkPj4ge1xuICAgIC8vIFZhbGlkYXRlIGJhdGNoIHNpemVcbiAgICBpZiAob3B0aW9ucy52ZWN0b3JzLmxlbmd0aCA8IDEgfHwgb3B0aW9ucy52ZWN0b3JzLmxlbmd0aCA+IDUwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZWN0b3IgYmF0Y2ggc2l6ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNTAwIGl0ZW1zJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHZlY3RvcnNBcGkucG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vUHV0VmVjdG9yc2AsIG9wdGlvbnMsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgfSlcbiAgICAgIHJldHVybiBkYXRhIHx8IHt9XG4gICAgfSlcbiAgfVxuXG4gIC8qKiBSZXRyaWV2ZXMgdmVjdG9ycyBieSB0aGVpciBrZXlzIGluIGJhdGNoICovXG4gIGFzeW5jIGdldFZlY3RvcnMob3B0aW9uczogR2V0VmVjdG9yc09wdGlvbnMpOiBQcm9taXNlPEFwaVJlc3BvbnNlPEdldFZlY3RvcnNSZXNwb25zZT4+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHZlY3RvcnNBcGkucG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vR2V0VmVjdG9yc2AsIG9wdGlvbnMsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqIExpc3RzIHZlY3RvcnMgaW4gYW4gaW5kZXggd2l0aCBwYWdpbmF0aW9uICovXG4gIGFzeW5jIGxpc3RWZWN0b3JzKG9wdGlvbnM6IExpc3RWZWN0b3JzT3B0aW9ucyk6IFByb21pc2U8QXBpUmVzcG9uc2U8TGlzdFZlY3RvcnNSZXNwb25zZT4+IHtcbiAgICAvLyBWYWxpZGF0ZSBzZWdtZW50IGNvbmZpZ3VyYXRpb25cbiAgICBpZiAob3B0aW9ucy5zZWdtZW50Q291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9wdGlvbnMuc2VnbWVudENvdW50IDwgMSB8fCBvcHRpb25zLnNlZ21lbnRDb3VudCA+IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VnbWVudENvdW50IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAxNicpXG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zZWdtZW50SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5zZWdtZW50SW5kZXggPCAwIHx8IG9wdGlvbnMuc2VnbWVudEluZGV4ID49IG9wdGlvbnMuc2VnbWVudENvdW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzZWdtZW50SW5kZXggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kICR7b3B0aW9ucy5zZWdtZW50Q291bnQgLSAxfWApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHZlY3RvcnNBcGkucG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vTGlzdFZlY3RvcnNgLCBvcHRpb25zLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKiBRdWVyaWVzIGZvciBzaW1pbGFyIHZlY3RvcnMgdXNpbmcgYXBwcm94aW1hdGUgbmVhcmVzdCBuZWlnaGJvciBzZWFyY2ggKi9cbiAgYXN5bmMgcXVlcnlWZWN0b3JzKG9wdGlvbnM6IFF1ZXJ5VmVjdG9yc09wdGlvbnMpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFF1ZXJ5VmVjdG9yc1Jlc3BvbnNlPj4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9RdWVyeVZlY3RvcnNgLCBvcHRpb25zLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKiBEZWxldGVzIHZlY3RvcnMgYnkgdGhlaXIga2V5cyBpbiBiYXRjaCAoMS01MDAgcGVyIHJlcXVlc3QpICovXG4gIGFzeW5jIGRlbGV0ZVZlY3RvcnMob3B0aW9uczogRGVsZXRlVmVjdG9yc09wdGlvbnMpOiBQcm9taXNlPEFwaVJlc3BvbnNlPHVuZGVmaW5lZD4+IHtcbiAgICAvLyBWYWxpZGF0ZSBiYXRjaCBzaXplXG4gICAgaWYgKG9wdGlvbnMua2V5cy5sZW5ndGggPCAxIHx8IG9wdGlvbnMua2V5cy5sZW5ndGggPiA1MDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignS2V5cyBiYXRjaCBzaXplIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA1MDAgaXRlbXMnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9EZWxldGVWZWN0b3JzYCwgb3B0aW9ucywge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGRhdGEgfHwge31cbiAgICB9KVxuICB9XG59XG4iLCAiaW1wb3J0IHsgREVGQVVMVF9IRUFERVJTIH0gZnJvbSAnLi4vbGliL2NvbnN0YW50cydcbmltcG9ydCB7IFN0b3JhZ2VFcnJvciB9IGZyb20gJy4uL2xpYi9jb21tb24vZXJyb3JzJ1xuaW1wb3J0IHsgRmV0Y2gsIHZlY3RvcnNBcGkgfSBmcm9tICcuLi9saWIvY29tbW9uL2ZldGNoJ1xuaW1wb3J0IEJhc2VBcGlDbGllbnQgZnJvbSAnLi4vbGliL2NvbW1vbi9CYXNlQXBpQ2xpZW50J1xuaW1wb3J0IHtcbiAgQXBpUmVzcG9uc2UsXG4gIFZlY3RvckJ1Y2tldCxcbiAgTGlzdFZlY3RvckJ1Y2tldHNPcHRpb25zLFxuICBMaXN0VmVjdG9yQnVja2V0c1Jlc3BvbnNlLFxufSBmcm9tICcuLi9saWIvdHlwZXMnXG5cbi8qKlxuICogQGhpZGRlblxuICogQmFzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdmVjdG9yIGJ1Y2tldCBvcGVyYXRpb25zLlxuICogVXNlIHtAbGluayBTdG9yYWdlVmVjdG9yc0NsaWVudH0gdmlhIGBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnNgIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvckJ1Y2tldEFwaSBleHRlbmRzIEJhc2VBcGlDbGllbnQ8U3RvcmFnZUVycm9yPiB7XG4gIC8qKiBDcmVhdGVzIGEgbmV3IFZlY3RvckJ1Y2tldEFwaSBpbnN0YW5jZSAqL1xuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZywgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9LCBmZXRjaD86IEZldGNoKSB7XG4gICAgY29uc3QgZmluYWxVcmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sICcnKVxuICAgIGNvbnN0IGZpbmFsSGVhZGVycyA9IHsgLi4uREVGQVVMVF9IRUFERVJTLCAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCAuLi5oZWFkZXJzIH1cbiAgICBzdXBlcihmaW5hbFVybCwgZmluYWxIZWFkZXJzLCBmZXRjaCwgJ3ZlY3RvcnMnKVxuICB9XG5cbiAgLyoqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGJ1Y2tldCAqL1xuICBhc3luYyBjcmVhdGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZTogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTx1bmRlZmluZWQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB2ZWN0b3JzQXBpLnBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9DcmVhdGVWZWN0b3JCdWNrZXRgLFxuICAgICAgICB7IHZlY3RvckJ1Y2tldE5hbWUgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIGRhdGEgfHwge31cbiAgICB9KVxuICB9XG5cbiAgLyoqIFJldHJpZXZlcyBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyB2ZWN0b3IgYnVja2V0ICovXG4gIGFzeW5jIGdldEJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPHsgdmVjdG9yQnVja2V0OiBWZWN0b3JCdWNrZXQgfT4+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHZlY3RvcnNBcGkucG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L0dldFZlY3RvckJ1Y2tldGAsXG4gICAgICAgIHsgdmVjdG9yQnVja2V0TmFtZSB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8qKiBMaXN0cyB2ZWN0b3IgYnVja2V0cyB3aXRoIG9wdGlvbmFsIGZpbHRlcmluZyBhbmQgcGFnaW5hdGlvbiAqL1xuICBhc3luYyBsaXN0QnVja2V0cyhcbiAgICBvcHRpb25zOiBMaXN0VmVjdG9yQnVja2V0c09wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPEFwaVJlc3BvbnNlPExpc3RWZWN0b3JCdWNrZXRzUmVzcG9uc2U+PiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB2ZWN0b3JzQXBpLnBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L0xpc3RWZWN0b3JCdWNrZXRzYCwgb3B0aW9ucywge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKiogRGVsZXRlcyBhIHZlY3RvciBidWNrZXQgKG11c3QgYmUgZW1wdHkgZmlyc3QpICovXG4gIGFzeW5jIGRlbGV0ZUJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPHVuZGVmaW5lZD4+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHZlY3RvcnNBcGkucG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L0RlbGV0ZVZlY3RvckJ1Y2tldGAsXG4gICAgICAgIHsgdmVjdG9yQnVja2V0TmFtZSB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4gZGF0YSB8fCB7fVxuICAgIH0pXG4gIH1cbn1cbiIsICJpbXBvcnQgVmVjdG9ySW5kZXhBcGksIHsgQ3JlYXRlSW5kZXhPcHRpb25zIH0gZnJvbSAnLi9WZWN0b3JJbmRleEFwaSdcbmltcG9ydCBWZWN0b3JEYXRhQXBpIGZyb20gJy4vVmVjdG9yRGF0YUFwaSdcbmltcG9ydCB7IEZldGNoIH0gZnJvbSAnLi4vbGliL2NvbW1vbi9mZXRjaCdcbmltcG9ydCBWZWN0b3JCdWNrZXRBcGkgZnJvbSAnLi9WZWN0b3JCdWNrZXRBcGknXG5pbXBvcnQge1xuICBBcGlSZXNwb25zZSxcbiAgRGVsZXRlVmVjdG9yc09wdGlvbnMsXG4gIEdldFZlY3RvcnNPcHRpb25zLFxuICBMaXN0SW5kZXhlc09wdGlvbnMsXG4gIExpc3RWZWN0b3JzT3B0aW9ucyxcbiAgTGlzdFZlY3RvckJ1Y2tldHNPcHRpb25zLFxuICBMaXN0VmVjdG9yQnVja2V0c1Jlc3BvbnNlLFxuICBQdXRWZWN0b3JzT3B0aW9ucyxcbiAgUXVlcnlWZWN0b3JzT3B0aW9ucyxcbiAgVmVjdG9yQnVja2V0LFxufSBmcm9tICcuLi9saWIvdHlwZXMnXG5cbi8qKlxuICpcbiAqIEBhbHBoYVxuICpcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIFN0b3JhZ2UgVmVjdG9ycyBjbGllbnRcbiAqXG4gKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0b3JhZ2VWZWN0b3JzQ2xpZW50T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBDdXN0b20gaGVhZGVycyB0byBpbmNsdWRlIGluIGFsbCByZXF1ZXN0c1xuICAgKi9cbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgLyoqXG4gICAqIEN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvbiAob3B0aW9uYWwpXG4gICAqIFVzZWZ1bCBmb3IgdGVzdGluZyBvciBjdXN0b20gcmVxdWVzdCBoYW5kbGluZ1xuICAgKi9cbiAgZmV0Y2g/OiBGZXRjaFxufVxuXG4vKipcbiAqXG4gKiBAYWxwaGFcbiAqXG4gKiBNYWluIGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBTMyBWZWN0b3JzIEFQSVxuICogUHJvdmlkZXMgYWNjZXNzIHRvIGJ1Y2tldCwgaW5kZXgsIGFuZCB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zXG4gKlxuICogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbiAqXG4gKiAqKlVzYWdlIFBhdHRlcm5zOioqXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAqICAuc3RvcmFnZVxuICogIC52ZWN0b3JzXG4gKiAgLmNyZWF0ZUJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJylcbiAqXG4gKiAvLyBBY2Nlc3MgaW5kZXggb3BlcmF0aW9ucyB2aWEgYnVja2V0c1xuICogY29uc3QgYnVja2V0ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpXG4gKiBhd2FpdCBidWNrZXQuY3JlYXRlSW5kZXgoe1xuICogICBpbmRleE5hbWU6ICdkb2N1bWVudHMnLFxuICogICBkYXRhVHlwZTogJ2Zsb2F0MzInLFxuICogICBkaW1lbnNpb246IDE1MzYsXG4gKiAgIGRpc3RhbmNlTWV0cmljOiAnY29zaW5lJ1xuICogfSlcbiAqXG4gKiAvLyBBY2Nlc3MgdmVjdG9yIG9wZXJhdGlvbnMgdmlhIGluZGV4XG4gKiBjb25zdCBpbmRleCA9IGJ1Y2tldC5pbmRleCgnZG9jdW1lbnRzJylcbiAqIGF3YWl0IGluZGV4LnB1dFZlY3RvcnMoe1xuICogICB2ZWN0b3JzOiBbXG4gKiAgICAgeyBrZXk6ICdkb2MtMScsIGRhdGE6IHsgZmxvYXQzMjogWy4uLl0gfSwgbWV0YWRhdGE6IHsgdGl0bGU6ICdJbnRybycgfSB9XG4gKiAgIF1cbiAqIH0pXG4gKlxuICogLy8gUXVlcnkgc2ltaWxhciB2ZWN0b3JzXG4gKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LnF1ZXJ5VmVjdG9ycyh7XG4gKiAgIHF1ZXJ5VmVjdG9yOiB7IGZsb2F0MzI6IFsuLi5dIH0sXG4gKiAgIHRvcEs6IDUsXG4gKiAgIHJldHVybkRpc3RhbmNlOiB0cnVlXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTdG9yYWdlVmVjdG9yc0NsaWVudCBleHRlbmRzIFZlY3RvckJ1Y2tldEFwaSB7XG4gIC8qKlxuICAgKiBAYWxwaGFcbiAgICpcbiAgICogQ3JlYXRlcyBhIFN0b3JhZ2VWZWN0b3JzQ2xpZW50IHRoYXQgY2FuIG1hbmFnZSBidWNrZXRzLCBpbmRleGVzLCBhbmQgdmVjdG9ycy5cbiAgICpcbiAgICogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbiAgICpcbiAgICogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG4gICAqIEBwYXJhbSB1cmwgLSBCYXNlIFVSTCBvZiB0aGUgU3RvcmFnZSBWZWN0b3JzIFJFU1QgQVBJLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIC0gT3B0aW9uYWwgaGVhZGVycyAoZm9yIGV4YW1wbGUgYEF1dGhvcml6YXRpb25gKSBhcHBsaWVkIHRvIGV2ZXJ5IHJlcXVlc3QuXG4gICAqIEBwYXJhbSBvcHRpb25zLmZldGNoIC0gT3B0aW9uYWwgY3VzdG9tIGBmZXRjaGAgaW1wbGVtZW50YXRpb24gZm9yIG5vbi1icm93c2VyIHJ1bnRpbWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGNsaWVudCA9IG5ldyBTdG9yYWdlVmVjdG9yc0NsaWVudCh1cmwsIG9wdGlvbnMpXG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IodXJsOiBzdHJpbmcsIG9wdGlvbnM6IFN0b3JhZ2VWZWN0b3JzQ2xpZW50T3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodXJsLCBvcHRpb25zLmhlYWRlcnMgfHwge30sIG9wdGlvbnMuZmV0Y2gpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGFscGhhXG4gICAqXG4gICAqIEFjY2VzcyBvcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIHZlY3RvciBidWNrZXRcbiAgICogUmV0dXJucyBhIHNjb3BlZCBjbGllbnQgZm9yIGluZGV4IGFuZCB2ZWN0b3Igb3BlcmF0aW9ucyB3aXRoaW4gdGhlIGJ1Y2tldFxuICAgKlxuICAgKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcbiAgICogQHBhcmFtIHZlY3RvckJ1Y2tldE5hbWUgLSBOYW1lIG9mIHRoZSB2ZWN0b3IgYnVja2V0XG4gICAqIEByZXR1cm5zIEJ1Y2tldC1zY29wZWQgY2xpZW50IHdpdGggaW5kZXggYW5kIHZlY3RvciBvcGVyYXRpb25zXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgYnVja2V0ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpXG4gICAqIGBgYFxuICAgKi9cbiAgZnJvbSh2ZWN0b3JCdWNrZXROYW1lOiBzdHJpbmcpOiBWZWN0b3JCdWNrZXRTY29wZSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3JCdWNrZXRTY29wZSh0aGlzLnVybCwgdGhpcy5oZWFkZXJzLCB2ZWN0b3JCdWNrZXROYW1lLCB0aGlzLmZldGNoKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBhbHBoYVxuICAgKlxuICAgKiBDcmVhdGVzIGEgbmV3IHZlY3RvciBidWNrZXRcbiAgICogVmVjdG9yIGJ1Y2tldHMgYXJlIGNvbnRhaW5lcnMgZm9yIHZlY3RvciBpbmRleGVzIGFuZCB0aGVpciBkYXRhXG4gICAqXG4gICAqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuICAgKiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIFVuaXF1ZSBuYW1lIGZvciB0aGUgdmVjdG9yIGJ1Y2tldFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAqICAgLnN0b3JhZ2VcbiAgICogICAudmVjdG9yc1xuICAgKiAgIC5jcmVhdGVCdWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQnVja2V0KHZlY3RvckJ1Y2tldE5hbWU6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8dW5kZWZpbmVkPj4ge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAYWxwaGFcbiAgICpcbiAgICogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIHZlY3RvciBidWNrZXRcbiAgICpcbiAgICogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbiAgICpcbiAgICogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG4gICAqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgdmVjdG9yIGJ1Y2tldFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggYnVja2V0IG1ldGFkYXRhIG9yIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICogICAuc3RvcmFnZVxuICAgKiAgIC52ZWN0b3JzXG4gICAqICAgLmdldEJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJylcbiAgICpcbiAgICogY29uc29sZS5sb2coJ0J1Y2tldCBjcmVhdGVkOicsIGRhdGE/LnZlY3RvckJ1Y2tldC5jcmVhdGlvblRpbWUpXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2V0QnVja2V0KHZlY3RvckJ1Y2tldE5hbWU6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8eyB2ZWN0b3JCdWNrZXQ6IFZlY3RvckJ1Y2tldCB9Pj4ge1xuICAgIHJldHVybiBzdXBlci5nZXRCdWNrZXQodmVjdG9yQnVja2V0TmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAYWxwaGFcbiAgICpcbiAgICogTGlzdHMgYWxsIHZlY3RvciBidWNrZXRzIHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uXG4gICAqXG4gICAqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGZpbHRlcnMgKHByZWZpeCwgbWF4UmVzdWx0cywgbmV4dFRva2VuKVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggbGlzdCBvZiBidWNrZXRzIG9yIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICogICAuc3RvcmFnZVxuICAgKiAgIC52ZWN0b3JzXG4gICAqICAgLmxpc3RCdWNrZXRzKHsgcHJlZml4OiAnZW1iZWRkaW5ncy0nIH0pXG4gICAqXG4gICAqIGRhdGE/LnZlY3RvckJ1Y2tldHMuZm9yRWFjaChidWNrZXQgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKGJ1Y2tldC52ZWN0b3JCdWNrZXROYW1lKVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxpc3RCdWNrZXRzKFxuICAgIG9wdGlvbnM6IExpc3RWZWN0b3JCdWNrZXRzT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8QXBpUmVzcG9uc2U8TGlzdFZlY3RvckJ1Y2tldHNSZXNwb25zZT4+IHtcbiAgICByZXR1cm4gc3VwZXIubGlzdEJ1Y2tldHMob3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAYWxwaGFcbiAgICpcbiAgICogRGVsZXRlcyBhIHZlY3RvciBidWNrZXQgKGJ1Y2tldCBtdXN0IGJlIGVtcHR5KVxuICAgKiBBbGwgaW5kZXhlcyBtdXN0IGJlIGRlbGV0ZWQgYmVmb3JlIGRlbGV0aW5nIHRoZSBidWNrZXRcbiAgICpcbiAgICogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbiAgICpcbiAgICogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG4gICAqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgdmVjdG9yIGJ1Y2tldCB0byBkZWxldGVcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3JcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgKiAgIC5zdG9yYWdlXG4gICAqICAgLnZlY3RvcnNcbiAgICogICAuZGVsZXRlQnVja2V0KCdlbWJlZGRpbmdzLW9sZCcpXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZGVsZXRlQnVja2V0KHZlY3RvckJ1Y2tldE5hbWU6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8dW5kZWZpbmVkPj4ge1xuICAgIHJldHVybiBzdXBlci5kZWxldGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSlcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAYWxwaGFcbiAqXG4gKiBTY29wZWQgY2xpZW50IGZvciBvcGVyYXRpb25zIHdpdGhpbiBhIHNwZWNpZmljIHZlY3RvciBidWNrZXRcbiAqIFByb3ZpZGVzIGluZGV4IG1hbmFnZW1lbnQgYW5kIGFjY2VzcyB0byB2ZWN0b3Igb3BlcmF0aW9uc1xuICpcbiAqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBWZWN0b3JCdWNrZXRTY29wZSBleHRlbmRzIFZlY3RvckluZGV4QXBpIHtcbiAgcHJpdmF0ZSB2ZWN0b3JCdWNrZXROYW1lOiBzdHJpbmdcblxuICAvKipcbiAgICogQGFscGhhXG4gICAqXG4gICAqIENyZWF0ZXMgYSBoZWxwZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHNjb3BlcyBhbGwgaW5kZXggb3BlcmF0aW9ucyB0byB0aGUgcHJvdmlkZWQgYnVja2V0LlxuICAgKlxuICAgKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB1cmw6IHN0cmluZyxcbiAgICBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LFxuICAgIHZlY3RvckJ1Y2tldE5hbWU6IHN0cmluZyxcbiAgICBmZXRjaD86IEZldGNoXG4gICkge1xuICAgIHN1cGVyKHVybCwgaGVhZGVycywgZmV0Y2gpXG4gICAgdGhpcy52ZWN0b3JCdWNrZXROYW1lID0gdmVjdG9yQnVja2V0TmFtZVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBhbHBoYVxuICAgKlxuICAgKiBDcmVhdGVzIGEgbmV3IHZlY3RvciBpbmRleCBpbiB0aGlzIGJ1Y2tldFxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIHRoZSBidWNrZXQgbmFtZVxuICAgKlxuICAgKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBJbmRleCBjb25maWd1cmF0aW9uICh2ZWN0b3JCdWNrZXROYW1lIGlzIGF1dG9tYXRpY2FsbHkgc2V0KVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuICAgKiBhd2FpdCBidWNrZXQuY3JlYXRlSW5kZXgoe1xuICAgKiAgIGluZGV4TmFtZTogJ2RvY3VtZW50cy1vcGVuYWknLFxuICAgKiAgIGRhdGFUeXBlOiAnZmxvYXQzMicsXG4gICAqICAgZGltZW5zaW9uOiAxNTM2LFxuICAgKiAgIGRpc3RhbmNlTWV0cmljOiAnY29zaW5lJyxcbiAgICogICBtZXRhZGF0YUNvbmZpZ3VyYXRpb246IHtcbiAgICogICAgIG5vbkZpbHRlcmFibGVNZXRhZGF0YUtleXM6IFsncmF3X3RleHQnXVxuICAgKiAgIH1cbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBvdmVycmlkZSBhc3luYyBjcmVhdGVJbmRleChvcHRpb25zOiBPbWl0PENyZWF0ZUluZGV4T3B0aW9ucywgJ3ZlY3RvckJ1Y2tldE5hbWUnPikge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVJbmRleCh7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdmVjdG9yQnVja2V0TmFtZTogdGhpcy52ZWN0b3JCdWNrZXROYW1lLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGFscGhhXG4gICAqXG4gICAqIExpc3RzIGluZGV4ZXMgaW4gdGhpcyBidWNrZXRcbiAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcbiAgICpcbiAgICogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbiAgICpcbiAgICogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTGlzdGluZyBvcHRpb25zICh2ZWN0b3JCdWNrZXROYW1lIGlzIGF1dG9tYXRpY2FsbHkgc2V0KVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBpbmRleGVzIGFycmF5IGFuZCBwYWdpbmF0aW9uIHRva2VuIG9yIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgYnVja2V0ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpXG4gICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYnVja2V0Lmxpc3RJbmRleGVzKHsgcHJlZml4OiAnZG9jdW1lbnRzLScgfSlcbiAgICogYGBgXG4gICAqL1xuICBvdmVycmlkZSBhc3luYyBsaXN0SW5kZXhlcyhvcHRpb25zOiBPbWl0PExpc3RJbmRleGVzT3B0aW9ucywgJ3ZlY3RvckJ1Y2tldE5hbWUnPiA9IHt9KSB7XG4gICAgcmV0dXJuIHN1cGVyLmxpc3RJbmRleGVzKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB2ZWN0b3JCdWNrZXROYW1lOiB0aGlzLnZlY3RvckJ1Y2tldE5hbWUsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAYWxwaGFcbiAgICpcbiAgICogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIGluZGV4IGluIHRoaXMgYnVja2V0XG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgdGhlIGJ1Y2tldCBuYW1lXG4gICAqXG4gICAqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuICAgKiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXggdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGluZGV4IG1ldGFkYXRhIG9yIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgYnVja2V0ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpXG4gICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYnVja2V0LmdldEluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcbiAgICogY29uc29sZS5sb2coJ0RpbWVuc2lvbjonLCBkYXRhPy5pbmRleC5kaW1lbnNpb24pXG4gICAqIGBgYFxuICAgKi9cbiAgb3ZlcnJpZGUgYXN5bmMgZ2V0SW5kZXgoaW5kZXhOYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0SW5kZXgodGhpcy52ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGFscGhhXG4gICAqXG4gICAqIERlbGV0ZXMgYW4gaW5kZXggZnJvbSB0aGlzIGJ1Y2tldFxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIHRoZSBidWNrZXQgbmFtZVxuICAgKlxuICAgKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcbiAgICogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIGRlbGV0ZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuICAgKiBhd2FpdCBidWNrZXQuZGVsZXRlSW5kZXgoJ29sZC1pbmRleCcpXG4gICAqIGBgYFxuICAgKi9cbiAgb3ZlcnJpZGUgYXN5bmMgZGVsZXRlSW5kZXgoaW5kZXhOYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVsZXRlSW5kZXgodGhpcy52ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGFscGhhXG4gICAqXG4gICAqIEFjY2VzcyBvcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIGluZGV4IHdpdGhpbiB0aGlzIGJ1Y2tldFxuICAgKiBSZXR1cm5zIGEgc2NvcGVkIGNsaWVudCBmb3IgdmVjdG9yIGRhdGEgb3BlcmF0aW9uc1xuICAgKlxuICAgKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcbiAgICogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4XG4gICAqIEByZXR1cm5zIEluZGV4LXNjb3BlZCBjbGllbnQgd2l0aCB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuICAgKlxuICAgKiAvLyBJbnNlcnQgdmVjdG9yc1xuICAgKiBhd2FpdCBpbmRleC5wdXRWZWN0b3JzKHtcbiAgICogICB2ZWN0b3JzOiBbXG4gICAqICAgICB7IGtleTogJ2RvYy0xJywgZGF0YTogeyBmbG9hdDMyOiBbLi4uXSB9LCBtZXRhZGF0YTogeyB0aXRsZTogJ0ludHJvJyB9IH1cbiAgICogICBdXG4gICAqIH0pXG4gICAqXG4gICAqIC8vIFF1ZXJ5IHNpbWlsYXIgdmVjdG9yc1xuICAgKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LnF1ZXJ5VmVjdG9ycyh7XG4gICAqICAgcXVlcnlWZWN0b3I6IHsgZmxvYXQzMjogWy4uLl0gfSxcbiAgICogICB0b3BLOiA1XG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgaW5kZXgoaW5kZXhOYW1lOiBzdHJpbmcpOiBWZWN0b3JJbmRleFNjb3BlIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvckluZGV4U2NvcGUoXG4gICAgICB0aGlzLnVybCxcbiAgICAgIHRoaXMuaGVhZGVycyxcbiAgICAgIHRoaXMudmVjdG9yQnVja2V0TmFtZSxcbiAgICAgIGluZGV4TmFtZSxcbiAgICAgIHRoaXMuZmV0Y2hcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKlxuICogQGFscGhhXG4gKlxuICogU2NvcGVkIGNsaWVudCBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gYSBzcGVjaWZpYyB2ZWN0b3IgaW5kZXhcbiAqIFByb3ZpZGVzIHZlY3RvciBkYXRhIG9wZXJhdGlvbnMgKHB1dCwgZ2V0LCBsaXN0LCBxdWVyeSwgZGVsZXRlKVxuICpcbiAqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBWZWN0b3JJbmRleFNjb3BlIGV4dGVuZHMgVmVjdG9yRGF0YUFwaSB7XG4gIHByaXZhdGUgdmVjdG9yQnVja2V0TmFtZTogc3RyaW5nXG4gIHByaXZhdGUgaW5kZXhOYW1lOiBzdHJpbmdcblxuICAvKipcbiAgICpcbiAgICogQGFscGhhXG4gICAqXG4gICAqIENyZWF0ZXMgYSBoZWxwZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHNjb3BlcyBhbGwgdmVjdG9yIG9wZXJhdGlvbnMgdG8gdGhlIHByb3ZpZGVkIGJ1Y2tldC9pbmRleCBuYW1lcy5cbiAgICpcbiAgICogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbiAgICpcbiAgICogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sXG4gICAgdmVjdG9yQnVja2V0TmFtZTogc3RyaW5nLFxuICAgIGluZGV4TmFtZTogc3RyaW5nLFxuICAgIGZldGNoPzogRmV0Y2hcbiAgKSB7XG4gICAgc3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaClcbiAgICB0aGlzLnZlY3RvckJ1Y2tldE5hbWUgPSB2ZWN0b3JCdWNrZXROYW1lXG4gICAgdGhpcy5pbmRleE5hbWUgPSBpbmRleE5hbWVcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAYWxwaGFcbiAgICpcbiAgICogSW5zZXJ0cyBvciB1cGRhdGVzIHZlY3RvcnMgaW4gdGhpcyBpbmRleFxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcbiAgICpcbiAgICogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbiAgICpcbiAgICogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVmVjdG9yIGluc2VydGlvbiBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcbiAgICogYXdhaXQgaW5kZXgucHV0VmVjdG9ycyh7XG4gICAqICAgdmVjdG9yczogW1xuICAgKiAgICAge1xuICAgKiAgICAgICBrZXk6ICdkb2MtMScsXG4gICAqICAgICAgIGRhdGE6IHsgZmxvYXQzMjogWzAuMSwgMC4yLCAuLi5dIH0sXG4gICAqICAgICAgIG1ldGFkYXRhOiB7IHRpdGxlOiAnSW50cm9kdWN0aW9uJywgcGFnZTogMSB9XG4gICAqICAgICB9XG4gICAqICAgXVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIG92ZXJyaWRlIGFzeW5jIHB1dFZlY3RvcnMob3B0aW9uczogT21pdDxQdXRWZWN0b3JzT3B0aW9ucywgJ3ZlY3RvckJ1Y2tldE5hbWUnIHwgJ2luZGV4TmFtZSc+KSB7XG4gICAgcmV0dXJuIHN1cGVyLnB1dFZlY3RvcnMoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHZlY3RvckJ1Y2tldE5hbWU6IHRoaXMudmVjdG9yQnVja2V0TmFtZSxcbiAgICAgIGluZGV4TmFtZTogdGhpcy5pbmRleE5hbWUsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAYWxwaGFcbiAgICpcbiAgICogUmV0cmlldmVzIHZlY3RvcnMgYnkga2V5cyBmcm9tIHRoaXMgaW5kZXhcbiAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG4gICAqXG4gICAqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFZlY3RvciByZXRyaWV2YWwgb3B0aW9ucyAoYnVja2V0IGFuZCBpbmRleCBuYW1lcyBhdXRvbWF0aWNhbGx5IHNldClcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgdmVjdG9ycyBhcnJheSBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBpbmRleC5nZXRWZWN0b3JzKHtcbiAgICogICBrZXlzOiBbJ2RvYy0xJywgJ2RvYy0yJ10sXG4gICAqICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBvdmVycmlkZSBhc3luYyBnZXRWZWN0b3JzKG9wdGlvbnM6IE9taXQ8R2V0VmVjdG9yc09wdGlvbnMsICd2ZWN0b3JCdWNrZXROYW1lJyB8ICdpbmRleE5hbWUnPikge1xuICAgIHJldHVybiBzdXBlci5nZXRWZWN0b3JzKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB2ZWN0b3JCdWNrZXROYW1lOiB0aGlzLnZlY3RvckJ1Y2tldE5hbWUsXG4gICAgICBpbmRleE5hbWU6IHRoaXMuaW5kZXhOYW1lLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGFscGhhXG4gICAqXG4gICAqIExpc3RzIHZlY3RvcnMgaW4gdGhpcyBpbmRleCB3aXRoIHBhZ2luYXRpb25cbiAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG4gICAqXG4gICAqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuICAgKiBAcGFyYW0gb3B0aW9ucyAtIExpc3Rpbmcgb3B0aW9ucyAoYnVja2V0IGFuZCBpbmRleCBuYW1lcyBhdXRvbWF0aWNhbGx5IHNldClcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgdmVjdG9ycyBhcnJheSBhbmQgcGFnaW5hdGlvbiB0b2tlbiBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBpbmRleC5saXN0VmVjdG9ycyh7XG4gICAqICAgbWF4UmVzdWx0czogNTAwLFxuICAgKiAgIHJldHVybk1ldGFkYXRhOiB0cnVlXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgb3ZlcnJpZGUgYXN5bmMgbGlzdFZlY3RvcnMoXG4gICAgb3B0aW9uczogT21pdDxMaXN0VmVjdG9yc09wdGlvbnMsICd2ZWN0b3JCdWNrZXROYW1lJyB8ICdpbmRleE5hbWUnPiA9IHt9XG4gICkge1xuICAgIHJldHVybiBzdXBlci5saXN0VmVjdG9ycyh7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdmVjdG9yQnVja2V0TmFtZTogdGhpcy52ZWN0b3JCdWNrZXROYW1lLFxuICAgICAgaW5kZXhOYW1lOiB0aGlzLmluZGV4TmFtZSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBhbHBoYVxuICAgKlxuICAgKiBRdWVyaWVzIGZvciBzaW1pbGFyIHZlY3RvcnMgaW4gdGhpcyBpbmRleFxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcbiAgICpcbiAgICogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbiAgICpcbiAgICogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUXVlcnkgb3B0aW9ucyAoYnVja2V0IGFuZCBpbmRleCBuYW1lcyBhdXRvbWF0aWNhbGx5IHNldClcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgbWF0Y2hlcyBhcnJheSBvZiBzaW1pbGFyIHZlY3RvcnMgb3JkZXJlZCBieSBkaXN0YW5jZSBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBpbmRleC5xdWVyeVZlY3RvcnMoe1xuICAgKiAgIHF1ZXJ5VmVjdG9yOiB7IGZsb2F0MzI6IFswLjEsIDAuMiwgLi4uXSB9LFxuICAgKiAgIHRvcEs6IDUsXG4gICAqICAgZmlsdGVyOiB7IGNhdGVnb3J5OiAndGVjaG5pY2FsJyB9LFxuICAgKiAgIHJldHVybkRpc3RhbmNlOiB0cnVlLFxuICAgKiAgIHJldHVybk1ldGFkYXRhOiB0cnVlXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgb3ZlcnJpZGUgYXN5bmMgcXVlcnlWZWN0b3JzKFxuICAgIG9wdGlvbnM6IE9taXQ8UXVlcnlWZWN0b3JzT3B0aW9ucywgJ3ZlY3RvckJ1Y2tldE5hbWUnIHwgJ2luZGV4TmFtZSc+XG4gICkge1xuICAgIHJldHVybiBzdXBlci5xdWVyeVZlY3RvcnMoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHZlY3RvckJ1Y2tldE5hbWU6IHRoaXMudmVjdG9yQnVja2V0TmFtZSxcbiAgICAgIGluZGV4TmFtZTogdGhpcy5pbmRleE5hbWUsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAYWxwaGFcbiAgICpcbiAgICogRGVsZXRlcyB2ZWN0b3JzIGJ5IGtleXMgZnJvbSB0aGlzIGluZGV4XG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYnVja2V0IGFuZCBpbmRleCBuYW1lc1xuICAgKlxuICAgKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBEZWxldGlvbiBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcbiAgICogYXdhaXQgaW5kZXguZGVsZXRlVmVjdG9ycyh7XG4gICAqICAga2V5czogWydkb2MtMScsICdkb2MtMicsICdkb2MtMyddXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgb3ZlcnJpZGUgYXN5bmMgZGVsZXRlVmVjdG9ycyhcbiAgICBvcHRpb25zOiBPbWl0PERlbGV0ZVZlY3RvcnNPcHRpb25zLCAndmVjdG9yQnVja2V0TmFtZScgfCAnaW5kZXhOYW1lJz5cbiAgKSB7XG4gICAgcmV0dXJuIHN1cGVyLmRlbGV0ZVZlY3RvcnMoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHZlY3RvckJ1Y2tldE5hbWU6IHRoaXMudmVjdG9yQnVja2V0TmFtZSxcbiAgICAgIGluZGV4TmFtZTogdGhpcy5pbmRleE5hbWUsXG4gICAgfSlcbiAgfVxufVxuIiwgImltcG9ydCBTdG9yYWdlRmlsZUFwaSBmcm9tICcuL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpJ1xuaW1wb3J0IFN0b3JhZ2VCdWNrZXRBcGkgZnJvbSAnLi9wYWNrYWdlcy9TdG9yYWdlQnVja2V0QXBpJ1xuaW1wb3J0IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQgZnJvbSAnLi9wYWNrYWdlcy9TdG9yYWdlQW5hbHl0aWNzQ2xpZW50J1xuaW1wb3J0IHsgRmV0Y2ggfSBmcm9tICcuL2xpYi9jb21tb24vZmV0Y2gnXG5pbXBvcnQgeyBTdG9yYWdlVmVjdG9yc0NsaWVudCB9IGZyb20gJy4vcGFja2FnZXMvU3RvcmFnZVZlY3RvcnNDbGllbnQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RvcmFnZUNsaWVudE9wdGlvbnMge1xuICB1c2VOZXdIb3N0bmFtZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VDbGllbnQgZXh0ZW5kcyBTdG9yYWdlQnVja2V0QXBpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbGllbnQgZm9yIFN0b3JhZ2UgYnVja2V0cywgZmlsZXMsIGFuYWx5dGljcywgYW5kIHZlY3RvcnMuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgU3RvcmFnZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdG9yYWdlLWpzJ1xuICAgKlxuICAgKiBjb25zdCBzdG9yYWdlID0gbmV3IFN0b3JhZ2VDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9zdG9yYWdlL3YxJywge1xuICAgKiAgIGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScsXG4gICAqIH0pXG4gICAqIGNvbnN0IGF2YXRhcnMgPSBzdG9yYWdlLmZyb20oJ2F2YXRhcnMnKVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSxcbiAgICBmZXRjaD86IEZldGNoLFxuICAgIG9wdHM/OiBTdG9yYWdlQ2xpZW50T3B0aW9uc1xuICApIHtcbiAgICBzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoLCBvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gZmlsZSBvcGVyYXRpb24gaW4gYSBidWNrZXQuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcbiAgICogQHBhcmFtIGlkIFRoZSBidWNrZXQgaWQgdG8gb3BlcmF0ZSBvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBhdmF0YXJzID0gc3VwYWJhc2Uuc3RvcmFnZS5mcm9tKCdhdmF0YXJzJylcbiAgICogYGBgXG4gICAqL1xuICBmcm9tKGlkOiBzdHJpbmcpOiBTdG9yYWdlRmlsZUFwaSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRmlsZUFwaSh0aGlzLnVybCwgdGhpcy5oZWFkZXJzLCBpZCwgdGhpcy5mZXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAYWxwaGFcbiAgICpcbiAgICogQWNjZXNzIHZlY3RvciBzdG9yYWdlIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuICAgKiBAcmV0dXJucyBBIFN0b3JhZ2VWZWN0b3JzQ2xpZW50IGluc3RhbmNlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgY3VycmVudCBzdG9yYWdlIHNldHRpbmdzLlxuICAgKi9cbiAgZ2V0IHZlY3RvcnMoKTogU3RvcmFnZVZlY3RvcnNDbGllbnQge1xuICAgIHJldHVybiBuZXcgU3RvcmFnZVZlY3RvcnNDbGllbnQodGhpcy51cmwgKyAnL3ZlY3RvcicsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGFscGhhXG4gICAqXG4gICAqIEFjY2VzcyBhbmFseXRpY3Mgc3RvcmFnZSBvcGVyYXRpb25zIHVzaW5nIEljZWJlcmcgdGFibGVzLlxuICAgKlxuICAgKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcbiAgICogQHJldHVybnMgQSBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50IGluc3RhbmNlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgY3VycmVudCBzdG9yYWdlIHNldHRpbmdzLlxuICAgKi9cbiAgZ2V0IGFuYWx5dGljcygpOiBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50IHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQodGhpcy51cmwgKyAnL2ljZWJlcmcnLCB0aGlzLmhlYWRlcnMsIHRoaXMuZmV0Y2gpXG4gIH1cbn1cbiIsICIvLyBHZW5lcmF0ZWQgYXV0b21hdGljYWxseSBkdXJpbmcgcmVsZWFzZXMgYnkgc2NyaXB0cy91cGRhdGUtdmVyc2lvbi1maWxlcy50c1xuLy8gVGhpcyBmaWxlIHByb3ZpZGVzIHJ1bnRpbWUgYWNjZXNzIHRvIHRoZSBwYWNrYWdlIHZlcnNpb24gZm9yOlxuLy8gLSBIVFRQIHJlcXVlc3QgaGVhZGVycyAoZS5nLiwgWC1DbGllbnQtSW5mbyBoZWFkZXIgZm9yIEFQSSByZXF1ZXN0cylcbi8vIC0gRGVidWdnaW5nIGFuZCBzdXBwb3J0IChpZGVudGlmeWluZyB3aGljaCB2ZXJzaW9uIGlzIHJ1bm5pbmcpXG4vLyAtIFRlbGVtZXRyeSBhbmQgbG9nZ2luZyAodmVyc2lvbiByZXBvcnRpbmcgaW4gZXJyb3JzL2FuYWx5dGljcylcbi8vIC0gRW5zdXJpbmcgYnVpbGQgYXJ0aWZhY3RzIG1hdGNoIHRoZSBwdWJsaXNoZWQgcGFja2FnZSB2ZXJzaW9uXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjkzLjMnXG4iLCAiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbidcblxuLyoqIEN1cnJlbnQgc2Vzc2lvbiB3aWxsIGJlIGNoZWNrZWQgZm9yIHJlZnJlc2ggYXQgdGhpcyBpbnRlcnZhbC4gKi9cbmV4cG9ydCBjb25zdCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUyA9IDMwICogMTAwMFxuXG4vKipcbiAqIEEgdG9rZW4gcmVmcmVzaCB3aWxsIGJlIGF0dGVtcHRlZCB0aGlzIG1hbnkgdGlja3MgYmVmb3JlIHRoZSBjdXJyZW50IHNlc3Npb24gZXhwaXJlcy4gKi9cbmV4cG9ydCBjb25zdCBBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQgPSAzXG5cbi8qXG4gKiBFYXJsaWVzdCB0aW1lIGJlZm9yZSBhbiBhY2Nlc3MgdG9rZW4gZXhwaXJlcyB0aGF0IHRoZSBzZXNzaW9uIHNob3VsZCBiZSByZWZyZXNoZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBFWFBJUllfTUFSR0lOX01TID0gQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEICogQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVNcblxuZXhwb3J0IGNvbnN0IEdPVFJVRV9VUkwgPSAnaHR0cDovL2xvY2FsaG9zdDo5OTk5J1xuZXhwb3J0IGNvbnN0IFNUT1JBR0VfS0VZID0gJ3N1cGFiYXNlLmF1dGgudG9rZW4nXG5leHBvcnQgY29uc3QgQVVESUVOQ0UgPSAnJ1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgZ290cnVlLWpzLyR7dmVyc2lvbn1gIH1cbmV4cG9ydCBjb25zdCBORVRXT1JLX0ZBSUxVUkUgPSB7XG4gIE1BWF9SRVRSSUVTOiAxMCxcbiAgUkVUUllfSU5URVJWQUw6IDIsIC8vIGluIGRlY2lzZWNvbmRzXG59XG5cbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSA9ICdYLVN1cGFiYXNlLUFwaS1WZXJzaW9uJ1xuZXhwb3J0IGNvbnN0IEFQSV9WRVJTSU9OUyA9IHtcbiAgJzIwMjQtMDEtMDEnOiB7XG4gICAgdGltZXN0YW1wOiBEYXRlLnBhcnNlKCcyMDI0LTAxLTAxVDAwOjAwOjAwLjBaJyksXG4gICAgbmFtZTogJzIwMjQtMDEtMDEnLFxuICB9LFxufVxuXG5leHBvcnQgY29uc3QgQkFTRTY0VVJMX1JFR0VYID0gL14oW2EtejAtOV8tXXs0fSkqKCR8W2EtejAtOV8tXXszfSR8W2EtejAtOV8tXXsyfSQpJC9pXG5cbmV4cG9ydCBjb25zdCBKV0tTX1RUTCA9IDEwICogNjAgKiAxMDAwIC8vIDEwIG1pbnV0ZXNcbiIsICJpbXBvcnQgeyBXZWFrUGFzc3dvcmRSZWFzb25zIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IEVycm9yQ29kZSB9IGZyb20gJy4vZXJyb3ItY29kZXMnXG5cbi8qKlxuICogQmFzZSBlcnJvciB0aHJvd24gYnkgU3VwYWJhc2UgQXV0aCBoZWxwZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhFcnJvcignVW5leHBlY3RlZCBhdXRoIGVycm9yJywgNTAwLCAndW5leHBlY3RlZCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIEVycm9yIGNvZGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBlcnJvci4gTW9zdCBlcnJvcnMgY29taW5nIGZyb21cbiAgICogSFRUUCByZXNwb25zZXMgd2lsbCBoYXZlIGEgY29kZSwgdGhvdWdoIHNvbWUgZXJyb3JzIHRoYXQgb2NjdXJcbiAgICogYmVmb3JlIGEgcmVzcG9uc2UgaXMgcmVjZWl2ZWQgd2lsbCBub3QgaGF2ZSBvbmUgcHJlc2VudC4gSW4gdGhhdFxuICAgKiBjYXNlIHtAbGluayAjc3RhdHVzfSB3aWxsIGFsc28gYmUgdW5kZWZpbmVkLlxuICAgKi9cbiAgY29kZTogRXJyb3JDb2RlIHwgKHN0cmluZyAmIHt9KSB8IHVuZGVmaW5lZFxuXG4gIC8qKiBIVFRQIHN0YXR1cyBjb2RlIHRoYXQgY2F1c2VkIHRoZSBlcnJvci4gKi9cbiAgc3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWRcblxuICBwcm90ZWN0ZWQgX19pc0F1dGhFcnJvciA9IHRydWVcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1cz86IG51bWJlciwgY29kZT86IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0F1dGhFcnJvcidcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c1xuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBBdXRoRXJyb3Ige1xuICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc0F1dGhFcnJvcicgaW4gZXJyb3Jcbn1cblxuLyoqXG4gKiBFcnJvciByZXR1cm5lZCBkaXJlY3RseSBmcm9tIHRoZSBHb1RydWUgUkVTVCBBUEkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoQXBpRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aEFwaUVycm9yKCdJbnZhbGlkIGNyZWRlbnRpYWxzJywgNDAwLCAnaW52YWxpZF9jcmVkZW50aWFscycpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhBcGlFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gIHN0YXR1czogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXM6IG51bWJlciwgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgc3RhdHVzLCBjb2RlKVxuICAgIHRoaXMubmFtZSA9ICdBdXRoQXBpRXJyb3InXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEFwaUVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgQXV0aEFwaUVycm9yIHtcbiAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aEFwaUVycm9yJ1xufVxuXG4vKipcbiAqIFdyYXBzIG5vbi1zdGFuZGFyZCBlcnJvcnMgc28gY2FsbGVycyBjYW4gaW5zcGVjdCB0aGUgcm9vdCBjYXVzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhVbmtub3duRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0cnkge1xuICogICBhd2FpdCBzb21lQXV0aENhbGwoKVxuICogfSBjYXRjaCAoZXJyKSB7XG4gKiAgIHRocm93IG5ldyBBdXRoVW5rbm93bkVycm9yKCdBdXRoIGZhaWxlZCcsIGVycilcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aFVua25vd25FcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gIG9yaWdpbmFsRXJyb3I6IHVua25vd25cblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9yaWdpbmFsRXJyb3I6IHVua25vd24pIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdBdXRoVW5rbm93bkVycm9yJ1xuICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIEZsZXhpYmxlIGVycm9yIGNsYXNzIHVzZWQgdG8gY3JlYXRlIG5hbWVkIGF1dGggZXJyb3JzIGF0IHJ1bnRpbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDdXN0b21BdXRoRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQ3VzdG9tQXV0aEVycm9yKCdNeSBjdXN0b20gYXV0aCBlcnJvcicsICdNeUF1dGhFcnJvcicsIDQwMCwgJ2N1c3RvbV9jb2RlJylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ3VzdG9tQXV0aEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXR1czogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUpXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzXG4gIH1cbn1cblxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gcmVxdWlyZXMgYSBzZXNzaW9uIGJ1dCBub25lIGlzIHByZXNlbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ0F1dGggc2Vzc2lvbiBtaXNzaW5nIScsICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcicsIDQwMCwgdW5kZWZpbmVkKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKGVycm9yOiBhbnkpOiBlcnJvciBpcyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciB7XG4gIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yJ1xufVxuXG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSB0b2tlbiByZXNwb25zZSBpcyBtYWxmb3JtZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ0F1dGggc2Vzc2lvbiBvciB1c2VyIG1pc3NpbmcnLCAnQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3InLCA1MDAsIHVuZGVmaW5lZClcbiAgfVxufVxuXG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGVtYWlsL3Bhc3N3b3JkIGNyZWRlbnRpYWxzIGFyZSBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcignRW1haWwgb3IgcGFzc3dvcmQgaXMgaW5jb3JyZWN0JylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcicsIDQwMCwgdW5kZWZpbmVkKVxuICB9XG59XG5cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gaW1wbGljaXQgZ3JhbnQgcmVkaXJlY3RzIGNvbnRhaW4gYW4gZXJyb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdPQXV0aCByZWRpcmVjdCBmYWlsZWQnLCB7XG4gKiAgIGVycm9yOiAnYWNjZXNzX2RlbmllZCcsXG4gKiAgIGNvZGU6ICdvYXV0aF9lcnJvcicsXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICBkZXRhaWxzOiB7IGVycm9yOiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGxcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBkZXRhaWxzOiB7IGVycm9yOiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGwpIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yJywgNTAwLCB1bmRlZmluZWQpXG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlsc1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoXG4gIGVycm9yOiBhbnlcbik6IGVycm9yIGlzIEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciB7XG4gIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcidcbn1cblxuLyoqXG4gKiBFcnJvciB0aHJvd24gZHVyaW5nIFBLQ0UgY29kZSBleGNoYW5nZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yKCdQS0NFIGV4Y2hhbmdlIGZhaWxlZCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIGRldGFpbHM6IHsgZXJyb3I6IHN0cmluZzsgY29kZTogc3RyaW5nIH0gfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgZGV0YWlsczogeyBlcnJvcjogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKVxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHNcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgUEtDRSBjb2RlIHZlcmlmaWVyIGlzIG5vdCBmb3VuZCBpbiBzdG9yYWdlLlxuICogVGhpcyB0eXBpY2FsbHkgaGFwcGVucyB3aGVuIHRoZSBhdXRoIGZsb3cgd2FzIGluaXRpYXRlZCBpbiBhIGRpZmZlcmVudFxuICogYnJvd3NlciwgZGV2aWNlLCBvciB0aGUgc3RvcmFnZSB3YXMgY2xlYXJlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yKClcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcbiAgICAgICdQS0NFIGNvZGUgdmVyaWZpZXIgbm90IGZvdW5kIGluIHN0b3JhZ2UuICcgK1xuICAgICAgICAnVGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBhdXRoIGZsb3cgd2FzIGluaXRpYXRlZCBpbiBhIGRpZmZlcmVudCBicm93c2VyIG9yIGRldmljZSwgJyArXG4gICAgICAgICdvciBpZiB0aGUgc3RvcmFnZSB3YXMgY2xlYXJlZC4gRm9yIFNTUiBmcmFtZXdvcmtzIChOZXh0LmpzLCBTdmVsdGVLaXQsIGV0Yy4pLCAnICtcbiAgICAgICAgJ3VzZSBAc3VwYWJhc2Uvc3NyIG9uIGJvdGggdGhlIHNlcnZlciBhbmQgY2xpZW50IHRvIHN0b3JlIHRoZSBjb2RlIHZlcmlmaWVyIGluIGNvb2tpZXMuJyxcbiAgICAgICdBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvcicsXG4gICAgICA0MDAsXG4gICAgICAncGtjZV9jb2RlX3ZlcmlmaWVyX25vdF9mb3VuZCdcbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IoXG4gIGVycm9yOiB1bmtub3duXG4pOiBlcnJvciBpcyBBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvciB7XG4gIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yJ1xufVxuXG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGEgdHJhbnNpZW50IGZldGNoIGlzc3VlIG9jY3Vycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKCdTZXJ2aWNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlJywgNTAzKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzOiBudW1iZXIpIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFJldHJ5YWJsZUZldGNoRXJyb3InLCBzdGF0dXMsIHVuZGVmaW5lZClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEF1dGhSZXRyeWFibGVGZXRjaEVycm9yIHtcbiAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFJldHJ5YWJsZUZldGNoRXJyb3InXG59XG5cbi8qKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gb24gY2VydGFpbiBtZXRob2RzIHdoZW4gdGhlIHBhc3N3b3JkIHVzZWQgaXMgZGVlbWVkXG4gKiB3ZWFrLiBJbnNwZWN0IHRoZSByZWFzb25zIHRvIGlkZW50aWZ5IHdoYXQgcGFzc3dvcmQgc3RyZW5ndGggcnVsZXMgYXJlXG4gKiBpbmFkZXF1YXRlLlxuICovXG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGEgc3VwcGxpZWQgcGFzc3dvcmQgaXMgY29uc2lkZXJlZCB3ZWFrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aFdlYWtQYXNzd29yZEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcignUGFzc3dvcmQgdG9vIHNob3J0JywgNDAwLCBbJ21pbl9sZW5ndGgnXSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aFdlYWtQYXNzd29yZEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgLyoqXG4gICAqIFJlYXNvbnMgd2h5IHRoZSBwYXNzd29yZCBpcyBkZWVtZWQgd2Vhay5cbiAgICovXG4gIHJlYXNvbnM6IFdlYWtQYXNzd29yZFJlYXNvbnNbXVxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzOiBudW1iZXIsIHJlYXNvbnM6IFdlYWtQYXNzd29yZFJlYXNvbnNbXSkge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InLCBzdGF0dXMsICd3ZWFrX3Bhc3N3b3JkJylcblxuICAgIHRoaXMucmVhc29ucyA9IHJlYXNvbnNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3Ige1xuICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InXG59XG5cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gYSBKV1QgY2Fubm90IGJlIHZlcmlmaWVkIG9yIHBhcnNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhJbnZhbGlkSnd0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aEludmFsaWRKd3RFcnJvcignVG9rZW4gc2lnbmF0dXJlIGlzIGludmFsaWQnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZEp3dEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbnZhbGlkSnd0RXJyb3InLCA0MDAsICdpbnZhbGlkX2p3dCcpXG4gIH1cbn1cbiIsICIvKipcbiAqIEF2b2lkIG1vZGlmeWluZyB0aGlzIGZpbGUuIEl0J3MgcGFydCBvZlxuICogaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlLWNvbW11bml0eS9iYXNlNjR1cmwtanMuICBTdWJtaXQgYWxsIGZpeGVzIG9uXG4gKiB0aGF0IHJlcG8hXG4gKi9cblxuaW1wb3J0IHsgVWludDhBcnJheV8gfSBmcm9tICcuL3dlYmF1dGhuLmRvbSdcblxuLyoqXG4gKiBBbiBhcnJheSBvZiBjaGFyYWN0ZXJzIHRoYXQgZW5jb2RlIDYgYml0cyBpbnRvIGEgQmFzZTY0LVVSTCBhbHBoYWJldFxuICogY2hhcmFjdGVyLlxuICovXG5jb25zdCBUT19CQVNFNjRVUkwgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycuc3BsaXQoJycpXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGNhbiBhcHBlYXIgaW4gYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGJ1dFxuICogc2hvdWxkIGJlIGlnbm9yZWQuXG4gKi9cbmNvbnN0IElHTk9SRV9CQVNFNjRVUkwgPSAnIFxcdFxcblxccj0nLnNwbGl0KCcnKVxuXG4vKipcbiAqIEFuIGFycmF5IG9mIDEyOCBudW1iZXJzIHRoYXQgbWFwIGEgQmFzZTY0LVVSTCBjaGFyYWN0ZXIgdG8gNiBiaXRzLCBvciBpZiAtMlxuICogdXNlZCB0byBza2lwIHRoZSBjaGFyYWN0ZXIsIG9yIGlmIC0xIHVzZWQgdG8gZXJyb3Igb3V0LlxuICovXG5jb25zdCBGUk9NX0JBU0U2NFVSTCA9ICgoKSA9PiB7XG4gIGNvbnN0IGNoYXJNYXA6IG51bWJlcltdID0gbmV3IEFycmF5KDEyOClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJNYXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjaGFyTWFwW2ldID0gLTFcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSUdOT1JFX0JBU0U2NFVSTC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNoYXJNYXBbSUdOT1JFX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IC0yXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IFRPX0JBU0U2NFVSTC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNoYXJNYXBbVE9fQkFTRTY0VVJMW2ldLmNoYXJDb2RlQXQoMCldID0gaVxuICB9XG5cbiAgcmV0dXJuIGNoYXJNYXBcbn0pKClcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ5dGUgdG8gYSBCYXNlNjQtVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYnl0ZSBUaGUgYnl0ZSB0byBjb252ZXJ0LCBvciBudWxsIHRvIGZsdXNoIGF0IHRoZSBlbmQgb2YgdGhlIGJ5dGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIEJhc2U2NCBjb252ZXJzaW9uIHN0YXRlLiBQYXNzIGFuIGluaXRpYWwgdmFsdWUgb2YgYHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfWAuXG4gKiBAcGFyYW0gZW1pdCBBIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSBuZXh0IEJhc2U2NCBjaGFyYWN0ZXIgd2hlbiByZWFkeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVUb0Jhc2U2NFVSTChcbiAgYnl0ZTogbnVtYmVyIHwgbnVsbCxcbiAgc3RhdGU6IHsgcXVldWU6IG51bWJlcjsgcXVldWVkQml0czogbnVtYmVyIH0sXG4gIGVtaXQ6IChjaGFyOiBzdHJpbmcpID0+IHZvaWRcbikge1xuICBpZiAoYnl0ZSAhPT0gbnVsbCkge1xuICAgIHN0YXRlLnF1ZXVlID0gKHN0YXRlLnF1ZXVlIDw8IDgpIHwgYnl0ZVxuICAgIHN0YXRlLnF1ZXVlZEJpdHMgKz0gOFxuXG4gICAgd2hpbGUgKHN0YXRlLnF1ZXVlZEJpdHMgPj0gNikge1xuICAgICAgY29uc3QgcG9zID0gKHN0YXRlLnF1ZXVlID4+IChzdGF0ZS5xdWV1ZWRCaXRzIC0gNikpICYgNjNcbiAgICAgIGVtaXQoVE9fQkFTRTY0VVJMW3Bvc10pXG4gICAgICBzdGF0ZS5xdWV1ZWRCaXRzIC09IDZcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdGUucXVldWVkQml0cyA+IDApIHtcbiAgICBzdGF0ZS5xdWV1ZSA9IHN0YXRlLnF1ZXVlIDw8ICg2IC0gc3RhdGUucXVldWVkQml0cylcbiAgICBzdGF0ZS5xdWV1ZWRCaXRzID0gNlxuXG4gICAgd2hpbGUgKHN0YXRlLnF1ZXVlZEJpdHMgPj0gNikge1xuICAgICAgY29uc3QgcG9zID0gKHN0YXRlLnF1ZXVlID4+IChzdGF0ZS5xdWV1ZWRCaXRzIC0gNikpICYgNjNcbiAgICAgIGVtaXQoVE9fQkFTRTY0VVJMW3Bvc10pXG4gICAgICBzdGF0ZS5xdWV1ZWRCaXRzIC09IDZcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFN0cmluZyBjaGFyIGNvZGUgKGV4dHJhY3RlZCB1c2luZyBgc3RyaW5nLmNoYXJDb2RlQXQocG9zaXRpb24pYCkgdG8gYSBzZXF1ZW5jZSBvZiBCYXNlNjQtVVJMIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGNoYXJDb2RlIFRoZSBjaGFyIGNvZGUgb2YgdGhlIEphdmFTY3JpcHQgc3RyaW5nLlxuICogQHBhcmFtIHN0YXRlIFRoZSBCYXNlNjQgc3RhdGUuIFBhc3MgYW4gaW5pdGlhbCB2YWx1ZSBvZiBgeyBxdWV1ZTogMCwgcXVldWVkQml0czogMCB9YC5cbiAqIEBwYXJhbSBlbWl0IEEgZnVuY3Rpb24gY2FsbGVkIHdpdGggdGhlIG5leHQgYnl0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVGcm9tQmFzZTY0VVJMKFxuICBjaGFyQ29kZTogbnVtYmVyLFxuICBzdGF0ZTogeyBxdWV1ZTogbnVtYmVyOyBxdWV1ZWRCaXRzOiBudW1iZXIgfSxcbiAgZW1pdDogKGJ5dGU6IG51bWJlcikgPT4gdm9pZFxuKSB7XG4gIGNvbnN0IGJpdHMgPSBGUk9NX0JBU0U2NFVSTFtjaGFyQ29kZV1cblxuICBpZiAoYml0cyA+IC0xKSB7XG4gICAgLy8gdmFsaWQgQmFzZTY0LVVSTCBjaGFyYWN0ZXJcbiAgICBzdGF0ZS5xdWV1ZSA9IChzdGF0ZS5xdWV1ZSA8PCA2KSB8IGJpdHNcbiAgICBzdGF0ZS5xdWV1ZWRCaXRzICs9IDZcblxuICAgIHdoaWxlIChzdGF0ZS5xdWV1ZWRCaXRzID49IDgpIHtcbiAgICAgIGVtaXQoKHN0YXRlLnF1ZXVlID4+IChzdGF0ZS5xdWV1ZWRCaXRzIC0gOCkpICYgMHhmZilcbiAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgLT0gOFxuICAgIH1cbiAgfSBlbHNlIGlmIChiaXRzID09PSAtMikge1xuICAgIC8vIGlnbm9yZSBzcGFjZXMsIHRhYnMsIG5ld2xpbmVzLCA9XG4gICAgcmV0dXJuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEJhc2U2NC1VUkwgY2hhcmFjdGVyIFwiJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKX1cImApXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgc3RyaW5nICh3aGljaCBtYXkgaW5jbHVkZSBhbnkgdmFsaWQgY2hhcmFjdGVyKSBpbnRvIGFcbiAqIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcuIFRoZSBzdHJpbmcgaXMgZmlyc3QgZW5jb2RlZCBpbiBVVEYtOCB3aGljaCBpc1xuICogdGhlbiBlbmNvZGVkIGFzIEJhc2U2NC1VUkwuXG4gKlxuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0Jhc2U2NFVSTChzdHI6IHN0cmluZykge1xuICBjb25zdCBiYXNlNjQ6IHN0cmluZ1tdID0gW11cblxuICBjb25zdCBlbWl0dGVyID0gKGNoYXI6IHN0cmluZykgPT4ge1xuICAgIGJhc2U2NC5wdXNoKGNoYXIpXG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfVxuXG4gIHN0cmluZ1RvVVRGOChzdHIsIChieXRlOiBudW1iZXIpID0+IHtcbiAgICBieXRlVG9CYXNlNjRVUkwoYnl0ZSwgc3RhdGUsIGVtaXR0ZXIpXG4gIH0pXG5cbiAgYnl0ZVRvQmFzZTY0VVJMKG51bGwsIHN0YXRlLCBlbWl0dGVyKVxuXG4gIHJldHVybiBiYXNlNjQuam9pbignJylcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcgaW50byBhIEphdmFTY3JpcHQgc3RyaW5nLiBJdCBpcyBhc3N1bWVkXG4gKiB0aGF0IHRoZSB1bmRlcmx5aW5nIHN0cmluZyBoYXMgYmVlbiBlbmNvZGVkIGFzIFVURi04LlxuICpcbiAqIEBwYXJhbSBzdHIgVGhlIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdGcm9tQmFzZTY0VVJMKHN0cjogc3RyaW5nKSB7XG4gIGNvbnN0IGNvbnY6IHN0cmluZ1tdID0gW11cblxuICBjb25zdCB1dGY4RW1pdCA9IChjb2RlcG9pbnQ6IG51bWJlcikgPT4ge1xuICAgIGNvbnYucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlcG9pbnQpKVxuICB9XG5cbiAgY29uc3QgdXRmOFN0YXRlID0ge1xuICAgIHV0ZjhzZXE6IDAsXG4gICAgY29kZXBvaW50OiAwLFxuICB9XG5cbiAgY29uc3QgYjY0U3RhdGUgPSB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH1cblxuICBjb25zdCBieXRlRW1pdCA9IChieXRlOiBudW1iZXIpID0+IHtcbiAgICBzdHJpbmdGcm9tVVRGOChieXRlLCB1dGY4U3RhdGUsIHV0ZjhFbWl0KVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBieXRlRnJvbUJhc2U2NFVSTChzdHIuY2hhckNvZGVBdChpKSwgYjY0U3RhdGUsIGJ5dGVFbWl0KVxuICB9XG5cbiAgcmV0dXJuIGNvbnYuam9pbignJylcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgY29kZXBvaW50IHRvIGEgbXVsdGktYnl0ZSBVVEYtOCBzZXF1ZW5jZS5cbiAqXG4gKiBAcGFyYW0gY29kZXBvaW50IFRoZSBVbmljb2RlIGNvZGVwb2ludC5cbiAqIEBwYXJhbSBlbWl0ICAgICAgRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggVVRGLTggYnl0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvZGVwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvZGVwb2ludFRvVVRGOChjb2RlcG9pbnQ6IG51bWJlciwgZW1pdDogKGJ5dGU6IG51bWJlcikgPT4gdm9pZCkge1xuICBpZiAoY29kZXBvaW50IDw9IDB4N2YpIHtcbiAgICBlbWl0KGNvZGVwb2ludClcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHg3ZmYpIHtcbiAgICBlbWl0KDB4YzAgfCAoY29kZXBvaW50ID4+IDYpKVxuICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSlcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgZW1pdCgweGUwIHwgKGNvZGVwb2ludCA+PiAxMikpXG4gICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gNikgJiAweDNmKSlcbiAgICBlbWl0KDB4ODAgfCAoY29kZXBvaW50ICYgMHgzZikpXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4MTBmZmZmKSB7XG4gICAgZW1pdCgweGYwIHwgKGNvZGVwb2ludCA+PiAxOCkpXG4gICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gMTIpICYgMHgzZikpXG4gICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gNikgJiAweDNmKSlcbiAgICBlbWl0KDB4ODAgfCAoY29kZXBvaW50ICYgMHgzZikpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBVbmljb2RlIGNvZGVwb2ludDogJHtjb2RlcG9pbnQudG9TdHJpbmcoMTYpfWApXG59XG5cbi8qKlxuICogQ29udmVydHMgYSBKYXZhU2NyaXB0IHN0cmluZyB0byBhIHNlcXVlbmNlIG9mIFVURi04IGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzdHIgIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBVVEYtOC5cbiAqIEBwYXJhbSBlbWl0IEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIFVURi04IGJ5dGUgb2YgdGhlIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHI6IHN0cmluZywgZW1pdDogKGJ5dGU6IG51bWJlcikgPT4gdm9pZCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGxldCBjb2RlcG9pbnQgPSBzdHIuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKGNvZGVwb2ludCA+IDB4ZDdmZiAmJiBjb2RlcG9pbnQgPD0gMHhkYmZmKSB7XG4gICAgICAvLyBtb3N0IFVURi0xNiBjb2RlcG9pbnRzIGFyZSBVbmljb2RlIGNvZGVwb2ludHMsIGV4Y2VwdCB2YWx1ZXMgaW4gdGhpc1xuICAgICAgLy8gcmFuZ2Ugd2hlcmUgdGhlIG5leHQgVVRGLTE2IGNvZGVwb2ludCBuZWVkcyB0byBiZSBjb21iaW5lZCB3aXRoIHRoZVxuICAgICAgLy8gY3VycmVudCBvbmUgdG8gZ2V0IHRoZSBVbmljb2RlIGNvZGVwb2ludFxuICAgICAgY29uc3QgaGlnaFN1cnJvZ2F0ZSA9ICgoY29kZXBvaW50IC0gMHhkODAwKSAqIDB4NDAwKSAmIDB4ZmZmZlxuICAgICAgY29uc3QgbG93U3Vycm9nYXRlID0gKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAtIDB4ZGMwMCkgJiAweGZmZmZcbiAgICAgIGNvZGVwb2ludCA9IChsb3dTdXJyb2dhdGUgfCBoaWdoU3Vycm9nYXRlKSArIDB4MTAwMDBcbiAgICAgIGkgKz0gMVxuICAgIH1cblxuICAgIGNvZGVwb2ludFRvVVRGOChjb2RlcG9pbnQsIGVtaXQpXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVURi04IGJ5dGUgdG8gYSBVbmljb2RlIGNvZGVwb2ludC5cbiAqXG4gKiBAcGFyYW0gYnl0ZSAgVGhlIFVURi04IGJ5dGUgbmV4dCBpbiB0aGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIFVURi04IGJ5dGVzIGluIHRoZVxuICogICAgICAgICAgICAgIHNlcXVlbmNlLCBhbiBvYmplY3Qgd2l0aCB0aGUgc2hhcGUgYHsgdXRmOHNlcTogMCwgY29kZXBvaW50OiAwIH1gLlxuICogQHBhcmFtIGVtaXQgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGNvZGVwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0Zyb21VVEY4KFxuICBieXRlOiBudW1iZXIsXG4gIHN0YXRlOiB7IHV0ZjhzZXE6IG51bWJlcjsgY29kZXBvaW50OiBudW1iZXIgfSxcbiAgZW1pdDogKGNvZGVwb2ludDogbnVtYmVyKSA9PiB2b2lkXG4pIHtcbiAgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDApIHtcbiAgICBpZiAoYnl0ZSA8PSAweDdmKSB7XG4gICAgICBlbWl0KGJ5dGUpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIDEgbGVhZGluZyBiaXRzIHVudGlsIHlvdSByZWFjaCAwXG4gICAgZm9yIChsZXQgbGVhZGluZ0JpdCA9IDE7IGxlYWRpbmdCaXQgPCA2OyBsZWFkaW5nQml0ICs9IDEpIHtcbiAgICAgIGlmICgoKGJ5dGUgPj4gKDcgLSBsZWFkaW5nQml0KSkgJiAxKSA9PT0gMCkge1xuICAgICAgICBzdGF0ZS51dGY4c2VxID0gbGVhZGluZ0JpdFxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS51dGY4c2VxID09PSAyKSB7XG4gICAgICBzdGF0ZS5jb2RlcG9pbnQgPSBieXRlICYgMzFcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDMpIHtcbiAgICAgIHN0YXRlLmNvZGVwb2ludCA9IGJ5dGUgJiAxNVxuICAgIH0gZWxzZSBpZiAoc3RhdGUudXRmOHNlcSA9PT0gNCkge1xuICAgICAgc3RhdGUuY29kZXBvaW50ID0gYnl0ZSAmIDdcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVURi04IHNlcXVlbmNlJylcbiAgICB9XG5cbiAgICBzdGF0ZS51dGY4c2VxIC09IDFcbiAgfSBlbHNlIGlmIChzdGF0ZS51dGY4c2VxID4gMCkge1xuICAgIGlmIChieXRlIDw9IDB4N2YpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVVEYtOCBzZXF1ZW5jZScpXG4gICAgfVxuXG4gICAgc3RhdGUuY29kZXBvaW50ID0gKHN0YXRlLmNvZGVwb2ludCA8PCA2KSB8IChieXRlICYgNjMpXG4gICAgc3RhdGUudXRmOHNlcSAtPSAxXG5cbiAgICBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMCkge1xuICAgICAgZW1pdChzdGF0ZS5jb2RlcG9pbnQpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGRpZmZlcmVudCB0eXBlcyBvZiBzdHJpbmdzIHRvIFVpbnQ4QXJyYXlcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VXJsVG9VaW50OEFycmF5KHN0cjogc3RyaW5nKTogVWludDhBcnJheV8ge1xuICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW11cbiAgY29uc3Qgc3RhdGUgPSB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH1cblxuICBjb25zdCBvbkJ5dGUgPSAoYnl0ZTogbnVtYmVyKSA9PiB7XG4gICAgcmVzdWx0LnB1c2goYnl0ZSlcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnl0ZUZyb21CYXNlNjRVUkwoc3RyLmNoYXJDb2RlQXQoaSksIHN0YXRlLCBvbkJ5dGUpXG4gIH1cblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9VaW50OEFycmF5KHN0cjogc3RyaW5nKTogVWludDhBcnJheV8ge1xuICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW11cbiAgc3RyaW5nVG9VVEY4KHN0ciwgKGJ5dGU6IG51bWJlcikgPT4gcmVzdWx0LnB1c2goYnl0ZSkpXG4gIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvQmFzZTY0VVJMKGJ5dGVzOiBVaW50OEFycmF5KSB7XG4gIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXVxuICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfVxuXG4gIGNvbnN0IG9uQ2hhciA9IChjaGFyOiBzdHJpbmcpID0+IHtcbiAgICByZXN1bHQucHVzaChjaGFyKVxuICB9XG5cbiAgYnl0ZXMuZm9yRWFjaCgoYnl0ZSkgPT4gYnl0ZVRvQmFzZTY0VVJMKGJ5dGUsIHN0YXRlLCBvbkNoYXIpKVxuXG4gIC8vIGFsd2F5cyBjYWxsIHdpdGggYG51bGxgIGFmdGVyIHByb2Nlc3NpbmcgYWxsIGJ5dGVzXG4gIGJ5dGVUb0Jhc2U2NFVSTChudWxsLCBzdGF0ZSwgb25DaGFyKVxuXG4gIHJldHVybiByZXN1bHQuam9pbignJylcbn1cbiIsICJpbXBvcnQgeyBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSwgQkFTRTY0VVJMX1JFR0VYIH0gZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQgeyBBdXRoSW52YWxpZEp3dEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnXG5pbXBvcnQgeyBiYXNlNjRVcmxUb1VpbnQ4QXJyYXksIHN0cmluZ0Zyb21CYXNlNjRVUkwgfSBmcm9tICcuL2Jhc2U2NHVybCdcbmltcG9ydCB7IEp3dEhlYWRlciwgSnd0UGF5bG9hZCwgU3VwcG9ydGVkU3RvcmFnZSwgVXNlciB9IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgeyBVaW50OEFycmF5XyB9IGZyb20gJy4vd2ViYXV0aG4uZG9tJ1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwaXJlc0F0KGV4cGlyZXNJbjogbnVtYmVyKSB7XG4gIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKVxuICByZXR1cm4gdGltZU5vdyArIGV4cGlyZXNJblxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciBpbnRlcm5hbCBjYWxsYmFjayBzdWJzY3JpcHRpb25zLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdXNlcyBKYXZhU2NyaXB0IFN5bWJvbHMgdG8gY3JlYXRlIGd1YXJhbnRlZWQtdW5pcXVlIGlkZW50aWZpZXJzXG4gKiBmb3IgYXV0aCBzdGF0ZSBjaGFuZ2UgY2FsbGJhY2tzLiBTeW1ib2xzIGFyZSBpZGVhbCBmb3IgdGhpcyB1c2UgY2FzZSBiZWNhdXNlOlxuICogLSBUaGV5IGFyZSBndWFyYW50ZWVkIHVuaXF1ZSBieSB0aGUgSmF2YVNjcmlwdCBydW50aW1lXG4gKiAtIFRoZXkgd29yayBpbiBhbGwgZW52aXJvbm1lbnRzIChicm93c2VyLCBTU1IsIE5vZGUuanMpXG4gKiAtIFRoZXkgYXZvaWQgaXNzdWVzIHdpdGggTmV4dC5qcyAxNiBkZXRlcm1pbmlzdGljIHJlbmRlcmluZyByZXF1aXJlbWVudHNcbiAqIC0gVGhleSBhcmUgcGVyZmVjdCBmb3IgaW50ZXJuYWwsIG5vbi1zZXJpYWxpemFibGUgaWRlbnRpZmllcnNcbiAqXG4gKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCBmb3IgaW50ZXJuYWwgc3Vic2NyaXB0aW9uIG1hbmFnZW1lbnQsXG4gKiBub3QgZm9yIHNlY3VyaXR5LWNyaXRpY2FsIG9wZXJhdGlvbnMgbGlrZSBzZXNzaW9uIHRva2Vucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ2FsbGJhY2tJZCgpOiBzeW1ib2wge1xuICByZXR1cm4gU3ltYm9sKCdhdXRoLWNhbGxiYWNrJylcbn1cblxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuY29uc3QgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cyA9IHtcbiAgdGVzdGVkOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGxvY2FsU3RvcmFnZSBpcyBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLlxuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNMb2NhbFN0b3JhZ2UgPSAoKSA9PiB7XG4gIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIERPTSBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmcgYGxvY2FsU3RvcmFnZWBcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlXG4gIH1cblxuICBjb25zdCByYW5kb21LZXkgPSBgbHN3dC0ke01hdGgucmFuZG9tKCl9JHtNYXRoLnJhbmRvbSgpfWBcblxuICB0cnkge1xuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0ocmFuZG9tS2V5LCByYW5kb21LZXkpXG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShyYW5kb21LZXkpXG5cbiAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWVcbiAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlID0gdHJ1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gbG9jYWxTdG9yYWdlIGNhbid0IGJlIHdyaXR0ZW4gdG9cbiAgICAvLyBodHRwczovL3d3dy5jaHJvbWl1bS5vcmcvZm9yLXRlc3RlcnMvYnVnLXJlcG9ydGluZy1ndWlkZWxpbmVzL3VuY2F1Z2h0LXNlY3VyaXR5ZXJyb3ItZmFpbGVkLXRvLXJlYWQtdGhlLWxvY2Fsc3RvcmFnZS1wcm9wZXJ0eS1mcm9tLXdpbmRvdy1hY2Nlc3MtaXMtZGVuaWVkLWZvci10aGlzLWRvY3VtZW50XG5cbiAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWVcbiAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlID0gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlXG59XG5cbi8qKlxuICogRXh0cmFjdHMgcGFyYW1ldGVycyBlbmNvZGVkIGluIHRoZSBVUkwgYm90aCBpbiB0aGUgcXVlcnkgYW5kIGZyYWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTChocmVmOiBzdHJpbmcpIHtcbiAgY29uc3QgcmVzdWx0OiB7IFtwYXJhbWV0ZXI6IHN0cmluZ106IHN0cmluZyB9ID0ge31cblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKGhyZWYpXG5cbiAgaWYgKHVybC5oYXNoICYmIHVybC5oYXNoWzBdID09PSAnIycpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGFzaFNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsLmhhc2guc3Vic3RyaW5nKDEpKVxuICAgICAgaGFzaFNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAvLyBoYXNoIGlzIG5vdCBhIHF1ZXJ5IHN0cmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIHNlYXJjaCBwYXJhbWV0ZXJzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGhhc2ggcGFyYW1ldGVyc1xuICB1cmwuc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gIH0pXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG50eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBjdXN0b21GZXRjaCguLi5hcmdzKVxuICB9XG4gIHJldHVybiAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncylcbn1cblxuZXhwb3J0IGNvbnN0IGxvb2tzTGlrZUZldGNoUmVzcG9uc2UgPSAobWF5YmVSZXNwb25zZTogdW5rbm93bik6IG1heWJlUmVzcG9uc2UgaXMgUmVzcG9uc2UgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBtYXliZVJlc3BvbnNlID09PSAnb2JqZWN0JyAmJlxuICAgIG1heWJlUmVzcG9uc2UgIT09IG51bGwgJiZcbiAgICAnc3RhdHVzJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgJ29rJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgJ2pzb24nIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICB0eXBlb2YgKG1heWJlUmVzcG9uc2UgYXMgYW55KS5qc29uID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuLy8gU3RvcmFnZSBoZWxwZXJzXG5leHBvcnQgY29uc3Qgc2V0SXRlbUFzeW5jID0gYXN5bmMgKFxuICBzdG9yYWdlOiBTdXBwb3J0ZWRTdG9yYWdlLFxuICBrZXk6IHN0cmluZyxcbiAgZGF0YTogYW55XG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgYXdhaXQgc3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRJdGVtQXN5bmMgPSBhc3luYyAoc3RvcmFnZTogU3VwcG9ydGVkU3RvcmFnZSwga2V5OiBzdHJpbmcpOiBQcm9taXNlPHVua25vd24+ID0+IHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBzdG9yYWdlLmdldEl0ZW0oa2V5KVxuXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlbW92ZUl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlOiBTdXBwb3J0ZWRTdG9yYWdlLCBrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBhd2FpdCBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxufVxuXG4vKipcbiAqIEEgZGVmZXJyZWQgcmVwcmVzZW50cyBzb21lIGFzeW5jaHJvbm91cyB3b3JrIHRoYXQgaXMgbm90IHlldCBmaW5pc2hlZCwgd2hpY2hcbiAqIG1heSBvciBtYXkgbm90IGN1bG1pbmF0ZSBpbiBhIHZhbHVlLlxuICogVGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL21pa2Utbm9ydGgvdHlwZXMvYmxvYi9tYXN0ZXIvc3JjL2FzeW5jLnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZlcnJlZDxUID0gYW55PiB7XG4gIHB1YmxpYyBzdGF0aWMgcHJvbWlzZUNvbnN0cnVjdG9yOiBQcm9taXNlQ29uc3RydWN0b3IgPSBQcm9taXNlXG5cbiAgcHVibGljIHJlYWRvbmx5IHByb21pc2UhOiBQcm9taXNlTGlrZTxUPlxuXG4gIHB1YmxpYyByZWFkb25seSByZXNvbHZlITogKHZhbHVlPzogVCB8IFByb21pc2VMaWtlPFQ+KSA9PiB2b2lkXG5cbiAgcHVibGljIHJlYWRvbmx5IHJlamVjdCE6IChyZWFzb24/OiBhbnkpID0+IGFueVxuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICA7KHRoaXMgYXMgYW55KS5wcm9taXNlID0gbmV3IERlZmVycmVkLnByb21pc2VDb25zdHJ1Y3RvcigocmVzLCByZWopID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgOyh0aGlzIGFzIGFueSkucmVzb2x2ZSA9IHJlc1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgICA7KHRoaXMgYXMgYW55KS5yZWplY3QgPSByZWpcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVKV1QodG9rZW46IHN0cmluZyk6IHtcbiAgaGVhZGVyOiBKd3RIZWFkZXJcbiAgcGF5bG9hZDogSnd0UGF5bG9hZFxuICBzaWduYXR1cmU6IFVpbnQ4QXJyYXlfXG4gIHJhdzoge1xuICAgIGhlYWRlcjogc3RyaW5nXG4gICAgcGF5bG9hZDogc3RyaW5nXG4gIH1cbn0ge1xuICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJylcblxuICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkSnd0RXJyb3IoJ0ludmFsaWQgSldUIHN0cnVjdHVyZScpXG4gIH1cblxuICAvLyBSZWdleCBjaGVja3MgZm9yIGJhc2U2NHVybCBmb3JtYXRcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghQkFTRTY0VVJMX1JFR0VYLnRlc3QocGFydHNbaV0gYXMgc3RyaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkSnd0RXJyb3IoJ0pXVCBub3QgaW4gYmFzZTY0dXJsIGZvcm1hdCcpXG4gICAgfVxuICB9XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgLy8gdXNpbmcgYmFzZTY0dXJsIGxpYlxuICAgIGhlYWRlcjogSlNPTi5wYXJzZShzdHJpbmdGcm9tQmFzZTY0VVJMKHBhcnRzWzBdKSksXG4gICAgcGF5bG9hZDogSlNPTi5wYXJzZShzdHJpbmdGcm9tQmFzZTY0VVJMKHBhcnRzWzFdKSksXG4gICAgc2lnbmF0dXJlOiBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkocGFydHNbMl0pLFxuICAgIHJhdzoge1xuICAgICAgaGVhZGVyOiBwYXJ0c1swXSxcbiAgICAgIHBheWxvYWQ6IHBhcnRzWzFdLFxuICAgIH0sXG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG51bGwgYWZ0ZXIgc29tZSB0aW1lLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2xlZXAodGltZTogbnVtYmVyKTogUHJvbWlzZTxudWxsPiB7XG4gIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgoYWNjZXB0KSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiBhY2NlcHQobnVsbCksIHRpbWUpXG4gIH0pXG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHByb3ZpZGVkIGFzeW5jIGZ1bmN0aW9uIGludG8gYSByZXRyeWFibGUgZnVuY3Rpb24uIEVhY2ggcmVzdWx0XG4gKiBvciB0aHJvd24gZXJyb3IgaXMgc2VudCB0byB0aGUgaXNSZXRyeWFibGUgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIHJldHVybiB0cnVlXG4gKiBpZiB0aGUgZnVuY3Rpb24gc2hvdWxkIHJ1biBhZ2Fpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHJ5YWJsZTxUPihcbiAgZm46IChhdHRlbXB0OiBudW1iZXIpID0+IFByb21pc2U8VD4sXG4gIGlzUmV0cnlhYmxlOiAoYXR0ZW1wdDogbnVtYmVyLCBlcnJvcjogYW55IHwgbnVsbCwgcmVzdWx0PzogVCkgPT4gYm9vbGVhblxuKTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxUPigoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICA7KGFzeW5jICgpID0+IHtcbiAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgSW5maW5pdHk7IGF0dGVtcHQrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKGF0dGVtcHQpXG5cbiAgICAgICAgICBpZiAoIWlzUmV0cnlhYmxlKGF0dGVtcHQsIG51bGwsIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGFjY2VwdChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgIGlmICghaXNSZXRyeWFibGUoYXR0ZW1wdCwgZSkpIHtcbiAgICAgICAgICAgIHJlamVjdChlKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkoKVxuICB9KVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIGRlYzJoZXgoZGVjOiBudW1iZXIpIHtcbiAgcmV0dXJuICgnMCcgKyBkZWMudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTIpXG59XG5cbi8vIEZ1bmN0aW9ucyBiZWxvdyB0YWtlbiBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MzMwOTQwOS9jcmVhdGluZy1hLWNvZGUtdmVyaWZpZXItYW5kLWNoYWxsZW5nZS1mb3ItcGtjZS1hdXRoLW9uLXNwb3RpZnktYXBpLWluLXJlYWN0anNcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBLQ0VWZXJpZmllcigpIHtcbiAgY29uc3QgdmVyaWZpZXJMZW5ndGggPSA1NlxuICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheSh2ZXJpZmllckxlbmd0aClcbiAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgY2hhclNldCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS0uX34nXG4gICAgY29uc3QgY2hhclNldExlbiA9IGNoYXJTZXQubGVuZ3RoXG4gICAgbGV0IHZlcmlmaWVyID0gJydcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcmlmaWVyTGVuZ3RoOyBpKyspIHtcbiAgICAgIHZlcmlmaWVyICs9IGNoYXJTZXQuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJTZXRMZW4pKVxuICAgIH1cbiAgICByZXR1cm4gdmVyaWZpZXJcbiAgfVxuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KVxuICByZXR1cm4gQXJyYXkuZnJvbShhcnJheSwgZGVjMmhleCkuam9pbignJylcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2hhMjU2KHJhbmRvbVN0cmluZzogc3RyaW5nKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuICBjb25zdCBlbmNvZGVkRGF0YSA9IGVuY29kZXIuZW5jb2RlKHJhbmRvbVN0cmluZylcbiAgY29uc3QgaGFzaCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZW5jb2RlZERhdGEpXG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaGFzaClcblxuICByZXR1cm4gQXJyYXkuZnJvbShieXRlcylcbiAgICAubWFwKChjKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKVxuICAgIC5qb2luKCcnKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlKHZlcmlmaWVyOiBzdHJpbmcpIHtcbiAgY29uc3QgaGFzQ3J5cHRvU3VwcG9ydCA9XG4gICAgdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY3J5cHRvLnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnXG5cbiAgaWYgKCFoYXNDcnlwdG9TdXBwb3J0KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dlYkNyeXB0byBBUEkgaXMgbm90IHN1cHBvcnRlZC4gQ29kZSBjaGFsbGVuZ2UgbWV0aG9kIHdpbGwgZGVmYXVsdCB0byB1c2UgcGxhaW4gaW5zdGVhZCBvZiBzaGEyNTYuJ1xuICAgIClcbiAgICByZXR1cm4gdmVyaWZpZXJcbiAgfVxuICBjb25zdCBoYXNoZWQgPSBhd2FpdCBzaGEyNTYodmVyaWZpZXIpXG4gIHJldHVybiBidG9hKGhhc2hlZCkucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvPSskLywgJycpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICBzdG9yYWdlOiBTdXBwb3J0ZWRTdG9yYWdlLFxuICBzdG9yYWdlS2V5OiBzdHJpbmcsXG4gIGlzUGFzc3dvcmRSZWNvdmVyeSA9IGZhbHNlXG4pIHtcbiAgY29uc3QgY29kZVZlcmlmaWVyID0gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKVxuICBsZXQgc3RvcmVkQ29kZVZlcmlmaWVyID0gY29kZVZlcmlmaWVyXG4gIGlmIChpc1Bhc3N3b3JkUmVjb3ZlcnkpIHtcbiAgICBzdG9yZWRDb2RlVmVyaWZpZXIgKz0gJy9QQVNTV09SRF9SRUNPVkVSWSdcbiAgfVxuICBhd2FpdCBzZXRJdGVtQXN5bmMoc3RvcmFnZSwgYCR7c3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmAsIHN0b3JlZENvZGVWZXJpZmllcilcbiAgY29uc3QgY29kZUNoYWxsZW5nZSA9IGF3YWl0IGdlbmVyYXRlUEtDRUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpXG4gIGNvbnN0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBjb2RlVmVyaWZpZXIgPT09IGNvZGVDaGFsbGVuZ2UgPyAncGxhaW4nIDogJ3MyNTYnXG4gIHJldHVybiBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF1cbn1cblxuLyoqIFBhcnNlcyB0aGUgQVBJIHZlcnNpb24gd2hpY2ggaXMgMllZWS1NTS1ERC4gKi9cbmNvbnN0IEFQSV9WRVJTSU9OX1JFR0VYID0gL14yWzAtOV17M30tKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVswLTldfDJbMC05XXwzWzAtMV0pJC9pXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbihyZXNwb25zZTogUmVzcG9uc2UpIHtcbiAgY29uc3QgYXBpVmVyc2lvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FKVxuXG4gIGlmICghYXBpVmVyc2lvbikge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAoIWFwaVZlcnNpb24ubWF0Y2goQVBJX1ZFUlNJT05fUkVHRVgpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke2FwaVZlcnNpb259VDAwOjAwOjAwLjBaYClcbiAgICByZXR1cm4gZGF0ZVxuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUV4cChleHA6IG51bWJlcikge1xuICBpZiAoIWV4cCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBleHAgY2xhaW0nKVxuICB9XG4gIGNvbnN0IHRpbWVOb3cgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKVxuICBpZiAoZXhwIDw9IHRpbWVOb3cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBoYXMgZXhwaXJlZCcpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsZ29yaXRobShcbiAgYWxnOiAnSFMyNTYnIHwgJ1JTMjU2JyB8ICdFUzI1Nidcbik6IFJzYUhhc2hlZEltcG9ydFBhcmFtcyB8IEVjS2V5SW1wb3J0UGFyYW1zIHtcbiAgc3dpdGNoIChhbGcpIHtcbiAgICBjYXNlICdSUzI1Nic6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgICBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9LFxuICAgICAgfVxuICAgIGNhc2UgJ0VTMjU2JzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdFQ0RTQScsXG4gICAgICAgIG5hbWVkQ3VydmU6ICdQLTI1NicsXG4gICAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0sXG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhbGcgY2xhaW0nKVxuICB9XG59XG5cbmNvbnN0IFVVSURfUkVHRVggPSAvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezEyfSQvXG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVVSUQoc3RyOiBzdHJpbmcpIHtcbiAgaWYgKCFVVUlEX1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IEV4cGVjdGVkIHBhcmFtZXRlciB0byBiZSBVVUlEIGJ1dCBpcyBub3QnKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VyTm90QXZhaWxhYmxlUHJveHkoKTogVXNlciB7XG4gIGNvbnN0IHByb3h5VGFyZ2V0ID0ge30gYXMgVXNlclxuXG4gIHJldHVybiBuZXcgUHJveHkocHJveHlUYXJnZXQsIHtcbiAgICBnZXQ6ICh0YXJnZXQ6IGFueSwgcHJvcDogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAocHJvcCA9PT0gJ19faXNVc2VyTm90QXZhaWxhYmxlUHJveHknKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50YXRpdmUgY2hlY2sgZm9yIGNvbW1vbiBwcm9ibGVtYXRpYyBzeW1ib2xzIGR1cmluZyBjbG9uaW5nL2luc3BlY3Rpb25cbiAgICAgIC8vIFRoZXNlIHN5bWJvbHMgbWlnaHQgYmUgYWNjZXNzZWQgYnkgc3RydWN0dXJlZENsb25lIG9yIG90aGVyIGludGVybmFsIG1lY2hhbmlzbXMuXG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIGNvbnN0IHNQcm9wID0gKHByb3AgYXMgc3ltYm9sKS50b1N0cmluZygpXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzUHJvcCA9PT0gJ1N5bWJvbChTeW1ib2wudG9QcmltaXRpdmUpJyB8fFxuICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1N0cmluZ1RhZyknIHx8XG4gICAgICAgICAgc1Byb3AgPT09ICdTeW1ib2wodXRpbC5pbnNwZWN0LmN1c3RvbSknXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIE5vZGUuanMgdXRpbC5pbnNwZWN0XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBAc3VwYWJhc2UvYXV0aC1qczogY2xpZW50IHdhcyBjcmVhdGVkIHdpdGggdXNlclN0b3JhZ2Ugb3B0aW9uIGFuZCB0aGVyZSB3YXMgbm8gdXNlciBzdG9yZWQgaW4gdGhlIHVzZXIgc3RvcmFnZS4gQWNjZXNzaW5nIHRoZSBcIiR7cHJvcH1cIiBwcm9wZXJ0eSBvZiB0aGUgc2Vzc2lvbiBvYmplY3QgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSBnZXRVc2VyKCkgaW5zdGVhZC5gXG4gICAgICApXG4gICAgfSxcbiAgICBzZXQ6IChfdGFyZ2V0OiBhbnksIHByb3A6IHN0cmluZykgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQHN1cGFiYXNlL2F1dGgtanM6IGNsaWVudCB3YXMgY3JlYXRlZCB3aXRoIHVzZXJTdG9yYWdlIG9wdGlvbiBhbmQgdGhlcmUgd2FzIG5vIHVzZXIgc3RvcmVkIGluIHRoZSB1c2VyIHN0b3JhZ2UuIFNldHRpbmcgdGhlIFwiJHtwcm9wfVwiIHByb3BlcnR5IG9mIHRoZSBzZXNzaW9uIG9iamVjdCBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGdldFVzZXIoKSB0byBmZXRjaCBhIHVzZXIgb2JqZWN0IHlvdSBjYW4gbWFuaXB1bGF0ZS5gXG4gICAgICApXG4gICAgfSxcbiAgICBkZWxldGVQcm9wZXJ0eTogKF90YXJnZXQ6IGFueSwgcHJvcDogc3RyaW5nKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBAc3VwYWJhc2UvYXV0aC1qczogY2xpZW50IHdhcyBjcmVhdGVkIHdpdGggdXNlclN0b3JhZ2Ugb3B0aW9uIGFuZCB0aGVyZSB3YXMgbm8gdXNlciBzdG9yZWQgaW4gdGhlIHVzZXIgc3RvcmFnZS4gRGVsZXRpbmcgdGhlIFwiJHtwcm9wfVwiIHByb3BlcnR5IG9mIHRoZSBzZXNzaW9uIG9iamVjdCBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGdldFVzZXIoKSB0byBmZXRjaCBhIHVzZXIgb2JqZWN0IHlvdSBjYW4gbWFuaXB1bGF0ZS5gXG4gICAgICApXG4gICAgfSxcbiAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcHJveHkgYXJvdW5kIGEgdXNlciBvYmplY3QgdGhhdCB3YXJucyB3aGVuIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkIG9uIHRoZSBzZXJ2ZXIuXG4gKiBUaGlzIGlzIHVzZWQgdG8gYWxlcnQgZGV2ZWxvcGVycyB0aGF0IHVzaW5nIHVzZXIgZGF0YSBmcm9tIGdldFNlc3Npb24oKSBvbiB0aGUgc2VydmVyIGlzIGluc2VjdXJlLlxuICpcbiAqIEBwYXJhbSB1c2VyIFRoZSBhY3R1YWwgdXNlciBvYmplY3QgdG8gd3JhcFxuICogQHBhcmFtIHN1cHByZXNzV2FybmluZ1JlZiBBbiBvYmplY3Qgd2l0aCBhICd2YWx1ZScgcHJvcGVydHkgdGhhdCBjb250cm9scyB3YXJuaW5nIHN1cHByZXNzaW9uXG4gKiBAcmV0dXJucyBBIHByb3hpZWQgdXNlciBvYmplY3QgdGhhdCB3YXJucyBvbiBwcm9wZXJ0eSBhY2Nlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VjdXJlVXNlcldhcm5pbmdQcm94eSh1c2VyOiBVc2VyLCBzdXBwcmVzc1dhcm5pbmdSZWY6IHsgdmFsdWU6IGJvb2xlYW4gfSk6IFVzZXIge1xuICByZXR1cm4gbmV3IFByb3h5KHVzZXIsIHtcbiAgICBnZXQ6ICh0YXJnZXQ6IGFueSwgcHJvcDogc3RyaW5nIHwgc3ltYm9sLCByZWNlaXZlcjogYW55KSA9PiB7XG4gICAgICAvLyBBbGxvdyBpbnRlcm5hbCBjaGVja3Mgd2l0aG91dCB3YXJuaW5nXG4gICAgICBpZiAocHJvcCA9PT0gJ19faXNJbnNlY3VyZVVzZXJXYXJuaW5nUHJveHknKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnRhdGl2ZSBjaGVjayBmb3IgY29tbW9uIHByb2JsZW1hdGljIHN5bWJvbHMgZHVyaW5nIGNsb25pbmcvaW5zcGVjdGlvblxuICAgICAgLy8gVGhlc2Ugc3ltYm9scyBtaWdodCBiZSBhY2Nlc3NlZCBieSBzdHJ1Y3R1cmVkQ2xvbmUgb3Igb3RoZXIgaW50ZXJuYWwgbWVjaGFuaXNtc1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3ltYm9sJykge1xuICAgICAgICBjb25zdCBzUHJvcCA9IHByb3AudG9TdHJpbmcoKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgc1Byb3AgPT09ICdTeW1ib2woU3ltYm9sLnRvUHJpbWl0aXZlKScgfHxcbiAgICAgICAgICBzUHJvcCA9PT0gJ1N5bWJvbChTeW1ib2wudG9TdHJpbmdUYWcpJyB8fFxuICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKHV0aWwuaW5zcGVjdC5jdXN0b20pJyB8fFxuICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKG5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tKSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBhY3R1YWwgdmFsdWUgZm9yIHRoZXNlIHN5bWJvbHMgdG8gYWxsb3cgcHJvcGVyIGluc3BlY3Rpb25cbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBFbWl0IHdhcm5pbmcgb24gZmlyc3QgcHJvcGVydHkgYWNjZXNzXG4gICAgICBpZiAoIXN1cHByZXNzV2FybmluZ1JlZi52YWx1ZSAmJiB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdVc2luZyB0aGUgdXNlciBvYmplY3QgYXMgcmV0dXJuZWQgZnJvbSBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKSBvciBmcm9tIHNvbWUgc3VwYWJhc2UuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZSgpIGV2ZW50cyBjb3VsZCBiZSBpbnNlY3VyZSEgVGhpcyB2YWx1ZSBjb21lcyBkaXJlY3RseSBmcm9tIHRoZSBzdG9yYWdlIG1lZGl1bSAodXN1YWxseSBjb29raWVzIG9uIHRoZSBzZXJ2ZXIpIGFuZCBtYXkgbm90IGJlIGF1dGhlbnRpYy4gVXNlIHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpIGluc3RlYWQgd2hpY2ggYXV0aGVudGljYXRlcyB0aGUgZGF0YSBieSBjb250YWN0aW5nIHRoZSBTdXBhYmFzZSBBdXRoIHNlcnZlci4nXG4gICAgICAgIClcbiAgICAgICAgc3VwcHJlc3NXYXJuaW5nUmVmLnZhbHVlID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIERlZXAgY2xvbmVzIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IHVzaW5nIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkuXG4gKiBOb3RlOiBPbmx5IHdvcmtzIGZvciBKU09OLXNhZmUgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDbG9uZTxUPihvYmo6IFQpOiBUIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSlcbn1cbiIsICJpbXBvcnQgeyBBUElfVkVSU0lPTlMsIEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIH0gZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQgeyBleHBpcmVzQXQsIGxvb2tzTGlrZUZldGNoUmVzcG9uc2UsIHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uIH0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHtcbiAgQXV0aFJlc3BvbnNlLFxuICBBdXRoUmVzcG9uc2VQYXNzd29yZCxcbiAgU1NPUmVzcG9uc2UsXG4gIEdlbmVyYXRlTGlua1Byb3BlcnRpZXMsXG4gIEdlbmVyYXRlTGlua1Jlc3BvbnNlLFxuICBVc2VyLFxuICBVc2VyUmVzcG9uc2UsXG59IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQge1xuICBBdXRoQXBpRXJyb3IsXG4gIEF1dGhSZXRyeWFibGVGZXRjaEVycm9yLFxuICBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IsXG4gIEF1dGhVbmtub3duRXJyb3IsXG4gIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLFxufSBmcm9tICcuL2Vycm9ycydcblxuZXhwb3J0IHR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IGludGVyZmFjZSBGZXRjaE9wdGlvbnMge1xuICBoZWFkZXJzPzoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG4gIG5vUmVzb2x2ZUpzb24/OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hQYXJhbWV0ZXJzIHtcbiAgc2lnbmFsPzogQWJvcnRTaWduYWxcbn1cblxuZXhwb3J0IHR5cGUgUmVxdWVzdE1ldGhvZFR5cGUgPSAnR0VUJyB8ICdQT1NUJyB8ICdQVVQnIHwgJ0RFTEVURSdcblxuY29uc3QgX2dldEVycm9yTWVzc2FnZSA9IChlcnI6IGFueSk6IHN0cmluZyA9PlxuICBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCBlcnIuZXJyb3IgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKVxuXG5jb25zdCBORVRXT1JLX0VSUk9SX0NPREVTID0gWzUwMiwgNTAzLCA1MDRdXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcjogdW5rbm93bikge1xuICBpZiAoIWxvb2tzTGlrZUZldGNoUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCAwKVxuICB9XG5cbiAgaWYgKE5FVFdPUktfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgIC8vIHN0YXR1cyBpbiA1MDAuLi41OTkgcmFuZ2UgLSBzZXJ2ZXIgaGFkIGFuIGVycm9yLCByZXF1ZXN0IG1pZ2h0IGJlIHJldHJ5ZWQuXG4gICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvci5zdGF0dXMpXG4gIH1cblxuICBsZXQgZGF0YTogYW55XG4gIHRyeSB7XG4gICAgZGF0YSA9IGF3YWl0IGVycm9yLmpzb24oKVxuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICB0aHJvdyBuZXcgQXV0aFVua25vd25FcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGUpLCBlKVxuICB9XG5cbiAgbGV0IGVycm9yQ29kZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG5cbiAgY29uc3QgcmVzcG9uc2VBUElWZXJzaW9uID0gcGFyc2VSZXNwb25zZUFQSVZlcnNpb24oZXJyb3IpXG4gIGlmIChcbiAgICByZXNwb25zZUFQSVZlcnNpb24gJiZcbiAgICByZXNwb25zZUFQSVZlcnNpb24uZ2V0VGltZSgpID49IEFQSV9WRVJTSU9OU1snMjAyNC0wMS0wMSddLnRpbWVzdGFtcCAmJlxuICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgIGRhdGEgJiZcbiAgICB0eXBlb2YgZGF0YS5jb2RlID09PSAnc3RyaW5nJ1xuICApIHtcbiAgICBlcnJvckNvZGUgPSBkYXRhLmNvZGVcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YSAmJiB0eXBlb2YgZGF0YS5lcnJvcl9jb2RlID09PSAnc3RyaW5nJykge1xuICAgIGVycm9yQ29kZSA9IGRhdGEuZXJyb3JfY29kZVxuICB9XG5cbiAgaWYgKCFlcnJvckNvZGUpIHtcbiAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3Igd2VhayBwYXNzd29yZCBlcnJvcnMsIHdoZW4gdGhlcmUgd2VyZSBubyBlcnJvciBjb2Rlc1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgZGF0YSAmJlxuICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIGRhdGEud2Vha19wYXNzd29yZCAmJlxuICAgICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLmxlbmd0aCAmJlxuICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhOiBib29sZWFuLCBpOiBhbnkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcihcbiAgICAgICAgX2dldEVycm9yTWVzc2FnZShkYXRhKSxcbiAgICAgICAgZXJyb3Iuc3RhdHVzLFxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29uc1xuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09ICd3ZWFrX3Bhc3N3b3JkJykge1xuICAgIHRocm93IG5ldyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoXG4gICAgICBfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLFxuICAgICAgZXJyb3Iuc3RhdHVzLFxuICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkPy5yZWFzb25zIHx8IFtdXG4gICAgKVxuICB9IGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gJ3Nlc3Npb25fbm90X2ZvdW5kJykge1xuICAgIC8vIFRoZSBgc2Vzc2lvbl9pZGAgaW5zaWRlIHRoZSBKV1QgZG9lcyBub3QgY29ycmVzcG9uZCB0byBhIHJvdyBpbiB0aGVcbiAgICAvLyBgc2Vzc2lvbnNgIHRhYmxlLiBUaGlzIHVzdWFsbHkgbWVhbnMgdGhlIHVzZXIgaGFzIHNpZ25lZCBvdXQsIGhhcyBiZWVuXG4gICAgLy8gZGVsZXRlZCwgb3IgdGhlaXIgc2Vzc2lvbiBoYXMgc29tZWhvdyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAgfVxuXG4gIHRocm93IG5ldyBBdXRoQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShkYXRhKSwgZXJyb3Iuc3RhdHVzIHx8IDUwMCwgZXJyb3JDb2RlKVxufVxuXG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChcbiAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kVHlwZSxcbiAgb3B0aW9ucz86IEZldGNoT3B0aW9ucyxcbiAgcGFyYW1ldGVycz86IEZldGNoUGFyYW1ldGVycyxcbiAgYm9keT86IG9iamVjdFxuKSA9PiB7XG4gIGNvbnN0IHBhcmFtczogeyBbazogc3RyaW5nXTogYW55IH0gPSB7IG1ldGhvZCwgaGVhZGVyczogb3B0aW9ucz8uaGVhZGVycyB8fCB7fSB9XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICByZXR1cm4gcGFyYW1zXG4gIH1cblxuICBwYXJhbXMuaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9VVRGLTgnLCAuLi5vcHRpb25zPy5oZWFkZXJzIH1cbiAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KVxuICByZXR1cm4geyAuLi5wYXJhbXMsIC4uLnBhcmFtZXRlcnMgfVxufVxuXG5pbnRlcmZhY2UgR290cnVlUmVxdWVzdE9wdGlvbnMgZXh0ZW5kcyBGZXRjaE9wdGlvbnMge1xuICBqd3Q/OiBzdHJpbmdcbiAgcmVkaXJlY3RUbz86IHN0cmluZ1xuICBib2R5Pzogb2JqZWN0XG4gIHF1ZXJ5PzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIGFwaSByZXNwb25zZSBmcm9tIGdvdHJ1ZSBpbnRvIGEgZGVzaXJhYmxlIC8gc3RhbmRhcmRpc2VkIGZvcm1hdFxuICAgKi9cbiAgeGZvcm0/OiAoZGF0YTogYW55KSA9PiBhbnlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9yZXF1ZXN0KFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kVHlwZSxcbiAgdXJsOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBHb3RydWVSZXF1ZXN0T3B0aW9uc1xuKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgfVxuXG4gIGlmICghaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0pIHtcbiAgICBoZWFkZXJzW0FQSV9WRVJTSU9OX0hFQURFUl9OQU1FXSA9IEFQSV9WRVJTSU9OU1snMjAyNC0wMS0wMSddLm5hbWVcbiAgfVxuXG4gIGlmIChvcHRpb25zPy5qd3QpIHtcbiAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7b3B0aW9ucy5qd3R9YFxuICB9XG5cbiAgY29uc3QgcXMgPSBvcHRpb25zPy5xdWVyeSA/PyB7fVxuICBpZiAob3B0aW9ucz8ucmVkaXJlY3RUbykge1xuICAgIHFzWydyZWRpcmVjdF90byddID0gb3B0aW9ucy5yZWRpcmVjdFRvXG4gIH1cblxuICBjb25zdCBxdWVyeVN0cmluZyA9IE9iamVjdC5rZXlzKHFzKS5sZW5ndGggPyAnPycgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHFzKS50b1N0cmluZygpIDogJydcbiAgY29uc3QgZGF0YSA9IGF3YWl0IF9oYW5kbGVSZXF1ZXN0KFxuICAgIGZldGNoZXIsXG4gICAgbWV0aG9kLFxuICAgIHVybCArIHF1ZXJ5U3RyaW5nLFxuICAgIHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBub1Jlc29sdmVKc29uOiBvcHRpb25zPy5ub1Jlc29sdmVKc29uLFxuICAgIH0sXG4gICAge30sXG4gICAgb3B0aW9ucz8uYm9keVxuICApXG4gIHJldHVybiBvcHRpb25zPy54Zm9ybSA/IG9wdGlvbnM/Lnhmb3JtKGRhdGEpIDogeyBkYXRhOiB7IC4uLmRhdGEgfSwgZXJyb3I6IG51bGwgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfaGFuZGxlUmVxdWVzdChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIG1ldGhvZDogUmVxdWVzdE1ldGhvZFR5cGUsXG4gIHVybDogc3RyaW5nLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzLFxuICBib2R5Pzogb2JqZWN0XG4pOiBQcm9taXNlPGFueT4ge1xuICBjb25zdCByZXF1ZXN0UGFyYW1zID0gX2dldFJlcXVlc3RQYXJhbXMobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KVxuXG4gIGxldCByZXN1bHQ6IGFueVxuXG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hlcih1cmwsIHtcbiAgICAgIC4uLnJlcXVlc3RQYXJhbXMsXG4gICAgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoZSlcblxuICAgIC8vIGZldGNoIGZhaWxlZCwgbGlrZWx5IGR1ZSB0byBhIG5ldHdvcmsgb3IgQ09SUyBlcnJvclxuICAgIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGUpLCAwKVxuICB9XG5cbiAgaWYgKCFyZXN1bHQub2spIHtcbiAgICBhd2FpdCBoYW5kbGVFcnJvcihyZXN1bHQpXG4gIH1cblxuICBpZiAob3B0aW9ucz8ubm9SZXNvbHZlSnNvbikge1xuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3VsdC5qc29uKClcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgYXdhaXQgaGFuZGxlRXJyb3IoZSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZShkYXRhOiBhbnkpOiBBdXRoUmVzcG9uc2Uge1xuICBsZXQgc2Vzc2lvbiA9IG51bGxcbiAgaWYgKGhhc1Nlc3Npb24oZGF0YSkpIHtcbiAgICBzZXNzaW9uID0geyAuLi5kYXRhIH1cblxuICAgIGlmICghZGF0YS5leHBpcmVzX2F0KSB7XG4gICAgICBzZXNzaW9uLmV4cGlyZXNfYXQgPSBleHBpcmVzQXQoZGF0YS5leHBpcmVzX2luKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVzZXI6IFVzZXIgPSBkYXRhLnVzZXIgPz8gKGRhdGEgYXMgVXNlcilcbiAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uLCB1c2VyIH0sIGVycm9yOiBudWxsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZChkYXRhOiBhbnkpOiBBdXRoUmVzcG9uc2VQYXNzd29yZCB7XG4gIGNvbnN0IHJlc3BvbnNlID0gX3Nlc3Npb25SZXNwb25zZShkYXRhKSBhcyBBdXRoUmVzcG9uc2VQYXNzd29yZFxuXG4gIGlmIChcbiAgICAhcmVzcG9uc2UuZXJyb3IgJiZcbiAgICBkYXRhLndlYWtfcGFzc3dvcmQgJiZcbiAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgIEFycmF5LmlzQXJyYXkoZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMpICYmXG4gICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgZGF0YS53ZWFrX3Bhc3N3b3JkLm1lc3NhZ2UgJiZcbiAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmXG4gICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhOiBib29sZWFuLCBpOiBhbnkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKVxuICApIHtcbiAgICByZXNwb25zZS5kYXRhLndlYWtfcGFzc3dvcmQgPSBkYXRhLndlYWtfcGFzc3dvcmRcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX3VzZXJSZXNwb25zZShkYXRhOiBhbnkpOiBVc2VyUmVzcG9uc2Uge1xuICBjb25zdCB1c2VyOiBVc2VyID0gZGF0YS51c2VyID8/IChkYXRhIGFzIFVzZXIpXG4gIHJldHVybiB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogbnVsbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfc3NvUmVzcG9uc2UoZGF0YTogYW55KTogU1NPUmVzcG9uc2Uge1xuICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UoZGF0YTogYW55KTogR2VuZXJhdGVMaW5rUmVzcG9uc2Uge1xuICBjb25zdCB7IGFjdGlvbl9saW5rLCBlbWFpbF9vdHAsIGhhc2hlZF90b2tlbiwgcmVkaXJlY3RfdG8sIHZlcmlmaWNhdGlvbl90eXBlLCAuLi5yZXN0IH0gPSBkYXRhXG5cbiAgY29uc3QgcHJvcGVydGllczogR2VuZXJhdGVMaW5rUHJvcGVydGllcyA9IHtcbiAgICBhY3Rpb25fbGluayxcbiAgICBlbWFpbF9vdHAsXG4gICAgaGFzaGVkX3Rva2VuLFxuICAgIHJlZGlyZWN0X3RvLFxuICAgIHZlcmlmaWNhdGlvbl90eXBlLFxuICB9XG5cbiAgY29uc3QgdXNlcjogVXNlciA9IHsgLi4ucmVzdCB9XG4gIHJldHVybiB7XG4gICAgZGF0YToge1xuICAgICAgcHJvcGVydGllcyxcbiAgICAgIHVzZXIsXG4gICAgfSxcbiAgICBlcnJvcjogbnVsbCxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX25vUmVzb2x2ZUpzb25SZXNwb25zZShkYXRhOiBhbnkpOiBSZXNwb25zZSB7XG4gIHJldHVybiBkYXRhXG59XG5cbi8qKlxuICogaGFzU2Vzc2lvbiBjaGVja3MgaWYgdGhlIHJlc3BvbnNlIG9iamVjdCBjb250YWlucyBhIHZhbGlkIHNlc3Npb25cbiAqIEBwYXJhbSBkYXRhIEEgcmVzcG9uc2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgc2Vzc2lvbiBpcyBpbiB0aGUgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gaGFzU2Vzc2lvbihkYXRhOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIGRhdGEuYWNjZXNzX3Rva2VuICYmIGRhdGEucmVmcmVzaF90b2tlbiAmJiBkYXRhLmV4cGlyZXNfaW5cbn1cbiIsICJpbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tICcuL2Vycm9ycydcbmltcG9ydCB7IEZldGNoIH0gZnJvbSAnLi9mZXRjaCdcbmltcG9ydCB7IEVJUDExOTNQcm92aWRlciwgRXRoZXJldW1TaWduSW5JbnB1dCwgSGV4IH0gZnJvbSAnLi93ZWIzL2V0aGVyZXVtJ1xuaW1wb3J0IHR5cGUgeyBTb2xhbmFTaWduSW5JbnB1dCwgU29sYW5hU2lnbkluT3V0cHV0IH0gZnJvbSAnLi93ZWIzL3NvbGFuYSdcbmltcG9ydCB7XG4gIFNlcnZlckNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMsXG4gIFNlcnZlckNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyxcbiAgV2ViQXV0aG5BcGksXG59IGZyb20gJy4vd2ViYXV0aG4nXG5pbXBvcnQge1xuICBBdXRoZW50aWNhdGlvbkNyZWRlbnRpYWwsXG4gIFB1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmUsXG4gIFB1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZSxcbiAgUmVnaXN0cmF0aW9uQ3JlZGVudGlhbCxcbn0gZnJvbSAnLi93ZWJhdXRobi5kb20nXG5cbi8qKiBPbmUgb2YgdGhlIHByb3ZpZGVycyBzdXBwb3J0ZWQgYnkgR29UcnVlLiAqL1xuZXhwb3J0IHR5cGUgUHJvdmlkZXIgPVxuICB8ICdhcHBsZSdcbiAgfCAnYXp1cmUnXG4gIHwgJ2JpdGJ1Y2tldCdcbiAgfCAnZGlzY29yZCdcbiAgfCAnZmFjZWJvb2snXG4gIHwgJ2ZpZ21hJ1xuICB8ICdnaXRodWInXG4gIHwgJ2dpdGxhYidcbiAgfCAnZ29vZ2xlJ1xuICB8ICdrYWthbydcbiAgfCAna2V5Y2xvYWsnXG4gIHwgJ2xpbmtlZGluJ1xuICB8ICdsaW5rZWRpbl9vaWRjJ1xuICB8ICdub3Rpb24nXG4gIHwgJ3NsYWNrJ1xuICB8ICdzbGFja19vaWRjJ1xuICB8ICdzcG90aWZ5J1xuICB8ICd0d2l0Y2gnXG4gIC8qKiBVc2VzIE9BdXRoIDEuMGEgKi9cbiAgfCAndHdpdHRlcidcbiAgLyoqIFVzZXMgT0F1dGggMi4wICovXG4gIHwgJ3gnXG4gIHwgJ3dvcmtvcydcbiAgfCAnem9vbSdcbiAgfCAnZmx5J1xuXG5leHBvcnQgdHlwZSBBdXRoQ2hhbmdlRXZlbnRNRkEgPSAnTUZBX0NIQUxMRU5HRV9WRVJJRklFRCdcblxuZXhwb3J0IHR5cGUgQXV0aENoYW5nZUV2ZW50ID1cbiAgfCAnSU5JVElBTF9TRVNTSU9OJ1xuICB8ICdQQVNTV09SRF9SRUNPVkVSWSdcbiAgfCAnU0lHTkVEX0lOJ1xuICB8ICdTSUdORURfT1VUJ1xuICB8ICdUT0tFTl9SRUZSRVNIRUQnXG4gIHwgJ1VTRVJfVVBEQVRFRCdcbiAgfCBBdXRoQ2hhbmdlRXZlbnRNRkFcblxuLyoqXG4gKiBQcm92aWRlIHlvdXIgb3duIGdsb2JhbCBsb2NrIGltcGxlbWVudGF0aW9uIGluc3RlYWQgb2YgdGhlIGRlZmF1bHRcbiAqIGltcGxlbWVudGF0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIGFjcXVpcmUgYSBsb2NrIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlXG4gKiBgZm5gIGFzeW5jIGZ1bmN0aW9uLCBzdWNoIHRoYXQgbm8gb3RoZXIgY2xpZW50IGluc3RhbmNlcyB3aWxsIGJlIGFibGUgdG9cbiAqIGhvbGQgaXQgYXQgdGhlIHNhbWUgdGltZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbG9jayB0byBiZSBhY3F1aXJlZC5cbiAqIEBwYXJhbSBhY3F1aXJlVGltZW91dCBJZiBuZWdhdGl2ZSwgbm8gdGltZW91dCBzaG91bGQgb2NjdXIuIElmIHBvc2l0aXZlIGl0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIHRocm93IGFuIEVycm9yIHdpdGggYW4gYGlzQWNxdWlyZVRpbWVvdXRgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgc2V0IHRvIHRydWUgaWYgdGhlIG9wZXJhdGlvbiBmYWlscyB0byBiZVxuICogICAgICAgICAgICAgICAgICAgICAgIGFjcXVpcmVkIGFmdGVyIHRoaXMgbXVjaCB0aW1lIChtcykuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGxvY2sgaXMgYWNxdWlyZWQuXG4gKi9cbmV4cG9ydCB0eXBlIExvY2tGdW5jID0gPFI+KG5hbWU6IHN0cmluZywgYWNxdWlyZVRpbWVvdXQ6IG51bWJlciwgZm46ICgpID0+IFByb21pc2U8Uj4pID0+IFByb21pc2U8Uj5cblxuZXhwb3J0IHR5cGUgR29UcnVlQ2xpZW50T3B0aW9ucyA9IHtcbiAgLyogVGhlIFVSTCBvZiB0aGUgR29UcnVlIHNlcnZlci4gKi9cbiAgdXJsPzogc3RyaW5nXG4gIC8qIEFueSBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gc2VuZCB0byB0aGUgR29UcnVlIHNlcnZlci4gKi9cbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgLyogT3B0aW9uYWwga2V5IG5hbWUgdXNlZCBmb3Igc3RvcmluZyB0b2tlbnMgaW4gbG9jYWwgc3RvcmFnZS4gKi9cbiAgc3RvcmFnZUtleT86IHN0cmluZ1xuICAvKipcbiAgICogU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IE9BdXRoIGdyYW50cyBpbiB0aGUgVVJMIGFuZCBzaWduIGluIHRoZSB1c2VyLlxuICAgKiBTZXQgdG8gXCJmYWxzZVwiIHRvIGRpc2FibGUgYXV0b21hdGljIGRldGVjdGlvbi5cbiAgICogU2V0IHRvIGEgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gbG9naWMgZm9yIGRldGVybWluaW5nIGlmIGEgVVJMIGNvbnRhaW5zIGEgU3VwYWJhc2UgYXV0aCBjYWxsYmFjay5cbiAgICogVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBjdXJyZW50IFVSTCBhbmQgcGFyc2VkIHBhcmFtZXRlcnMsIGFuZCBzaG91bGQgcmV0dXJuIHRydWUgaWYgdGhlIFVSTFxuICAgKiBzaG91bGQgYmUgcHJvY2Vzc2VkIGFzIGEgU3VwYWJhc2UgYXV0aCBjYWxsYmFjaywgb3IgZmFsc2UgdG8gaWdub3JlIGl0LlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdXIgYXBwIHVzZXMgb3RoZXIgT0F1dGggcHJvdmlkZXJzIChlLmcuLCBGYWNlYm9vayBMb2dpbikgdGhhdCBhbHNvIHJldHVyblxuICAgKiBhY2Nlc3NfdG9rZW4gaW4gdGhlIFVSTCBmcmFnbWVudCwgd2hpY2ggd291bGQgb3RoZXJ3aXNlIGJlIGluY29ycmVjdGx5IGludGVyY2VwdGVkIGJ5IFN1cGFiYXNlIEF1dGguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGRldGVjdFNlc3Npb25JblVybDogKHVybCwgcGFyYW1zKSA9PiB7XG4gICAqICAgLy8gSWdub3JlIEZhY2Vib29rIE9BdXRoIHJlZGlyZWN0c1xuICAgKiAgIGlmICh1cmwucGF0aG5hbWUgPT09ICcvZmFjZWJvb2svcmVkaXJlY3QnKSByZXR1cm4gZmFsc2VcbiAgICogICAvLyBVc2UgZGVmYXVsdCBkZXRlY3Rpb24gZm9yIG90aGVyIFVSTHNcbiAgICogICByZXR1cm4gQm9vbGVhbihwYXJhbXMuYWNjZXNzX3Rva2VuIHx8IHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbilcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGRldGVjdFNlc3Npb25JblVybD86IGJvb2xlYW4gfCAoKHVybDogVVJMLCBwYXJhbXM6IHsgW3BhcmFtZXRlcjogc3RyaW5nXTogc3RyaW5nIH0pID0+IGJvb2xlYW4pXG4gIC8qIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggdGhlIHRva2VuIGJlZm9yZSBleHBpcmluZy4gKi9cbiAgYXV0b1JlZnJlc2hUb2tlbj86IGJvb2xlYW5cbiAgLyogU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgc2F2ZSB0aGUgdXNlciBzZXNzaW9uIGludG8gbG9jYWwgc3RvcmFnZS4gSWYgc2V0IHRvIGZhbHNlLCBzZXNzaW9uIHdpbGwganVzdCBiZSBzYXZlZCBpbiBtZW1vcnkuICovXG4gIHBlcnNpc3RTZXNzaW9uPzogYm9vbGVhblxuICAvKiBQcm92aWRlIHlvdXIgb3duIGxvY2FsIHN0b3JhZ2UgaW1wbGVtZW50YXRpb24gdG8gdXNlIGluc3RlYWQgb2YgdGhlIGJyb3dzZXIncyBsb2NhbCBzdG9yYWdlLiAqL1xuICBzdG9yYWdlPzogU3VwcG9ydGVkU3RvcmFnZVxuICAvKipcbiAgICogU3RvcmVzIHRoZSB1c2VyIG9iamVjdCBpbiBhIHNlcGFyYXRlIHN0b3JhZ2UgbG9jYXRpb24gZnJvbSB0aGUgcmVzdCBvZiB0aGUgc2Vzc2lvbiBkYXRhLiBXaGVuIG5vbi1udWxsLCBgc3RvcmFnZWAgd2lsbCBvbmx5IHN0b3JlIGEgSlNPTiBvYmplY3QgY29udGFpbmluZyB0aGUgYWNjZXNzIGFuZCByZWZyZXNoIHRva2VuIGFuZCBzb21lIGFkamFjZW50IG1ldGFkYXRhLCB3aGlsZSBgdXNlclN0b3JhZ2VgIHdpbGwgb25seSBjb250YWluIHRoZSB1c2VyIG9iamVjdCB1bmRlciB0aGUga2V5IGBzdG9yYWdlS2V5ICsgJy11c2VyJ2AuXG4gICAqXG4gICAqIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0IGFuZCBjb29raWUgc3RvcmFnZSBpcyB1c2VkLCBgZ2V0U2Vzc2lvbigpYCBhbmQgb3RoZXIgZnVuY3Rpb25zIHRoYXQgbG9hZCBhIHNlc3Npb24gZnJvbSB0aGUgY29va2llIHN0b3JlIG1pZ2h0IG5vdCByZXR1cm4gYmFjayBhIHVzZXIuIEl0J3MgdmVyeSBpbXBvcnRhbnQgdG8gYWx3YXlzIHVzZSBgZ2V0VXNlcigpYCB0byBmZXRjaCBhIHVzZXIgb2JqZWN0IGluIHRob3NlIHNjZW5hcmlvcy5cbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgdXNlclN0b3JhZ2U/OiBTdXBwb3J0ZWRTdG9yYWdlXG4gIC8qIEEgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uLiAqL1xuICBmZXRjaD86IEZldGNoXG4gIC8qIElmIHNldCB0byAncGtjZScgUEtDRSBmbG93LiBEZWZhdWx0cyB0byB0aGUgJ2ltcGxpY2l0JyBmbG93IG90aGVyd2lzZSAqL1xuICBmbG93VHlwZT86IEF1dGhGbG93VHlwZVxuICAvKiBJZiBkZWJ1ZyBtZXNzYWdlcyBhcmUgZW1pdHRlZC4gQ2FuIGJlIHVzZWQgdG8gaW5zcGVjdCB0aGUgYmVoYXZpb3Igb2YgdGhlIGxpYnJhcnkuIElmIHNldCB0byBhIGZ1bmN0aW9uLCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgYGNvbnNvbGUubG9nKClgIHRvIHBlcmZvcm0gdGhlIGxvZ2dpbmcuICovXG4gIGRlYnVnPzogYm9vbGVhbiB8ICgobWVzc2FnZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZClcbiAgLyoqXG4gICAqIFByb3ZpZGUgeW91ciBvd24gbG9ja2luZyBtZWNoYW5pc20gYmFzZWQgb24gdGhlIGVudmlyb25tZW50LiBCeSBkZWZhdWx0IG5vIGxvY2tpbmcgaXMgZG9uZSBhdCB0aGlzIHRpbWUuXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIGxvY2s/OiBMb2NrRnVuY1xuICAvKipcbiAgICogU2V0IHRvIFwidHJ1ZVwiIGlmIHRoZXJlIGlzIGEgY3VzdG9tIGF1dGhvcml6YXRpb24gaGVhZGVyIHNldCBnbG9iYWxseS5cbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcj86IGJvb2xlYW5cbiAgLyoqXG4gICAqIElmIHRoZXJlIGlzIGFuIGVycm9yIHdpdGggdGhlIHF1ZXJ5LCB0aHJvd09uRXJyb3Igd2lsbCByZWplY3QgdGhlIHByb21pc2UgYnlcbiAgICogdGhyb3dpbmcgdGhlIGVycm9yIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGFzIHBhcnQgb2YgYSBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgKi9cbiAgdGhyb3dPbkVycm9yPzogYm9vbGVhblxuICAvKipcbiAgICogVGhlIG1heGltdW0gdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgYWNxdWlyaW5nIGEgY3Jvc3MtdGFiIHN5bmNocm9uaXphdGlvbiBsb2NrLlxuICAgKlxuICAgKiBXaGVuIG11bHRpcGxlIGJyb3dzZXIgdGFicyBvciB3aW5kb3dzIHVzZSB0aGUgYXV0aCBjbGllbnQgc2ltdWx0YW5lb3VzbHksIHRoZXkgY29vcmRpbmF0ZVxuICAgKiB2aWEgdGhlIFdlYiBMb2NrcyBBUEkgdG8gcHJldmVudCByYWNlIGNvbmRpdGlvbnMgZHVyaW5nIHNlc3Npb24gcmVmcmVzaCBhbmQgb3RoZXIgb3BlcmF0aW9ucy5cbiAgICogVGhpcyB0aW1lb3V0IGNvbnRyb2xzIGhvdyBsb25nIHRvIHdhaXQgZm9yIHRoZSBsb2NrIGJlZm9yZSBmYWlsaW5nLlxuICAgKlxuICAgKiBJZiB0aGUgbG9jayBjYW5ub3QgYmUgYWNxdWlyZWQgd2l0aGluIHRoaXMgdGltZSwgYSBgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3JgIGlzIHRocm93bi5cbiAgICogWW91IGNhbiBjYXRjaCB0aGlzIGJ5IGNoZWNraW5nIGBlcnJvci5pc0FjcXVpcmVUaW1lb3V0ID09PSB0cnVlYC5cbiAgICpcbiAgICogLSAqKlBvc2l0aXZlIHZhbHVlKio6IFdhaXQgdXAgdG8gdGhpcyBtYW55IG1pbGxpc2Vjb25kcyBiZWZvcmUgdGltaW5nIG91dFxuICAgKiAtICoqWmVybyAoMCkqKjogRmFpbCBpbW1lZGlhdGVseSBpZiB0aGUgbG9jayBpcyB1bmF2YWlsYWJsZVxuICAgKiAtICoqTmVnYXRpdmUgdmFsdWUqKjogV2FpdCBpbmRlZmluaXRlbHkgKG5vdCByZWNvbW1lbmRlZCAtIGNhbiBjYXVzZSBkZWFkbG9ja3MpXG4gICAqXG4gICAqIEBkZWZhdWx0IDEwMDAwXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IGNsaWVudCA9IGNyZWF0ZUNsaWVudCh1cmwsIGtleSwge1xuICAgKiAgIGF1dGg6IHtcbiAgICogICAgIGxvY2tBY3F1aXJlVGltZW91dDogMTAwMDAsIC8vIDEwIHNlY29uZHNcbiAgICogICB9LFxuICAgKiB9KVxuICAgKlxuICAgKiB0cnkge1xuICAgKiAgIGF3YWl0IGNsaWVudC5hdXRoLmdldFNlc3Npb24oKVxuICAgKiB9IGNhdGNoIChlcnJvcikge1xuICAgKiAgIGlmIChlcnJvci5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAqICAgICAvLyBMb2NrIGhlbGQgYnkgYW5vdGhlciB0YWIvaW5zdGFuY2UsIG9yIGEgcHJldmlvdXMgb3BlcmF0aW9uIGlzIHN0dWNrLlxuICAgKiAgICAgLy8gQ29uc2lkZXI6IGNsb3Npbmcgb3RoZXIgdGFicywgaW5jcmVhc2luZyB0aW1lb3V0LCBvciByZXN0YXJ0aW5nIHRoZSBicm93c2VyLlxuICAgKiAgICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IGFjcXVpcmUgbG9jayB3aXRoaW4gdGltZW91dCBwZXJpb2QuJylcbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBsb2NrQWNxdWlyZVRpbWVvdXQ/OiBudW1iZXJcbn1cblxuY29uc3QgV2Vha1Bhc3N3b3JkUmVhc29ucyA9IFsnbGVuZ3RoJywgJ2NoYXJhY3RlcnMnLCAncHduZWQnXSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBXZWFrUGFzc3dvcmRSZWFzb25zID0gKHR5cGVvZiBXZWFrUGFzc3dvcmRSZWFzb25zKVtudW1iZXJdXG5leHBvcnQgdHlwZSBXZWFrUGFzc3dvcmQgPSB7XG4gIHJlYXNvbnM6IFdlYWtQYXNzd29yZFJlYXNvbnNbXVxuICBtZXNzYWdlOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBSZXNvbHZlIG1hcHBlZCB0eXBlcyBhbmQgc2hvdyB0aGUgZGVyaXZlZCBrZXlzIGFuZCB0aGVpciB0eXBlcyB3aGVuIGhvdmVyaW5nIGluXG4gKiBWUyBDb2RlLCBpbnN0ZWFkIG9mIGp1c3Qgc2hvd2luZyB0aGUgbmFtZXMgdGhvc2UgbWFwcGVkIHR5cGVzIGFyZSBkZWZpbmVkIHdpdGguXG4gKi9cbmV4cG9ydCB0eXBlIFByZXR0aWZ5PFQ+ID0gVCBleHRlbmRzIEZ1bmN0aW9uID8gVCA6IHsgW0sgaW4ga2V5b2YgVF06IFRbS10gfVxuXG4vKipcbiAqIEEgc3RyaWN0ZXIgdmVyc2lvbiBvZiBUeXBlU2NyaXB0J3MgT21pdCB0aGF0IG9ubHkgYWxsb3dzIG9taXR0aW5nIGtleXMgdGhhdCBhY3R1YWxseSBleGlzdC5cbiAqIFRoaXMgcHJldmVudHMgdHlwb3MgYW5kIGVuc3VyZXMgdHlwZSBzYWZldHkgYXQgY29tcGlsZSB0aW1lLlxuICogVW5saWtlIHJlZ3VsYXIgT21pdCwgdGhpcyB3aWxsIGVycm9yIGlmIHlvdSB0cnkgdG8gb21pdCBhIG5vbi1leGlzdGVudCBrZXkuXG4gKi9cbmV4cG9ydCB0eXBlIFN0cmljdE9taXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gT21pdDxULCBLPlxuXG4vKipcbiAqIGEgc2hhcmVkIHJlc3VsdCB0eXBlIHRoYXQgZW5jYXBzdWxhdGVzIGVycm9ycyBpbnN0ZWFkIG9mIHRocm93aW5nIHRoZW0sIGFsbG93cyB5b3UgdG8gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBFcnJvclR5cGVcbiAqL1xuZXhwb3J0IHR5cGUgUmVxdWVzdFJlc3VsdDxULCBFcnJvclR5cGUgZXh0ZW5kcyBFcnJvciA9IEF1dGhFcnJvcj4gPVxuICB8IHtcbiAgICAgIGRhdGE6IFRcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfVxuICB8IHtcbiAgICAgIGRhdGE6IG51bGxcbiAgICAgIGVycm9yOiBFcnJvciBleHRlbmRzIEF1dGhFcnJvciA/IEF1dGhFcnJvciA6IEVycm9yVHlwZVxuICAgIH1cblxuLyoqXG4gKiBzaW1pbGFyIHRvIFJlcXVlc3RSZXN1bHQgZXhjZXB0IGl0IGFsbG93cyB5b3UgdG8gZGVzdHJ1Y3R1cmUgdGhlIHBvc3NpYmxlIHNoYXBlIG9mIHRoZSBzdWNjZXNzIHJlc3BvbnNlXG4gKiAge0BzZWUgUmVxdWVzdFJlc3VsdH1cbiAqL1xuZXhwb3J0IHR5cGUgUmVxdWVzdFJlc3VsdFNhZmVEZXN0cnVjdHVyZTxUPiA9XG4gIHwgeyBkYXRhOiBUOyBlcnJvcjogbnVsbCB9XG4gIHwge1xuICAgICAgZGF0YTogVCBleHRlbmRzIG9iamVjdCA/IHsgW0sgaW4ga2V5b2YgVF06IG51bGwgfSA6IG51bGxcbiAgICAgIGVycm9yOiBBdXRoRXJyb3JcbiAgICB9XG5cbmV4cG9ydCB0eXBlIEF1dGhSZXNwb25zZSA9IFJlcXVlc3RSZXN1bHRTYWZlRGVzdHJ1Y3R1cmU8e1xuICB1c2VyOiBVc2VyIHwgbnVsbFxuICBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbFxufT5cblxuZXhwb3J0IHR5cGUgQXV0aFJlc3BvbnNlUGFzc3dvcmQgPSBSZXF1ZXN0UmVzdWx0U2FmZURlc3RydWN0dXJlPHtcbiAgdXNlcjogVXNlciB8IG51bGxcbiAgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGxcbiAgd2Vha19wYXNzd29yZD86IFdlYWtQYXNzd29yZCB8IG51bGxcbn0+XG5cbi8qKlxuICogQXV0aE90cFJlc3BvbnNlIGlzIHJldHVybmVkIHdoZW4gT1RQIGlzIHVzZWQuXG4gKlxuICoge0BzZWUgQXV0aFJlc3BvbnNlfVxuICovXG5leHBvcnQgdHlwZSBBdXRoT3RwUmVzcG9uc2UgPSBSZXF1ZXN0UmVzdWx0U2FmZURlc3RydWN0dXJlPHtcbiAgdXNlcjogbnVsbFxuICBzZXNzaW9uOiBudWxsXG4gIG1lc3NhZ2VJZD86IHN0cmluZyB8IG51bGxcbn0+XG5cbmV4cG9ydCB0eXBlIEF1dGhUb2tlblJlc3BvbnNlID0gUmVxdWVzdFJlc3VsdFNhZmVEZXN0cnVjdHVyZTx7XG4gIHVzZXI6IFVzZXJcbiAgc2Vzc2lvbjogU2Vzc2lvblxufT5cblxuZXhwb3J0IHR5cGUgQXV0aFRva2VuUmVzcG9uc2VQYXNzd29yZCA9IFJlcXVlc3RSZXN1bHRTYWZlRGVzdHJ1Y3R1cmU8e1xuICB1c2VyOiBVc2VyXG4gIHNlc3Npb246IFNlc3Npb25cbiAgd2Vha1Bhc3N3b3JkPzogV2Vha1Bhc3N3b3JkXG59PlxuXG5leHBvcnQgdHlwZSBPQXV0aFJlc3BvbnNlID1cbiAgfCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHByb3ZpZGVyOiBQcm92aWRlclxuICAgICAgICB1cmw6IHN0cmluZ1xuICAgICAgfVxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9XG4gIHwge1xuICAgICAgZGF0YToge1xuICAgICAgICBwcm92aWRlcjogUHJvdmlkZXJcbiAgICAgICAgdXJsOiBudWxsXG4gICAgICB9XG4gICAgICBlcnJvcjogQXV0aEVycm9yXG4gICAgfVxuXG5leHBvcnQgdHlwZSBTU09SZXNwb25zZSA9IFJlcXVlc3RSZXN1bHQ8e1xuICAvKipcbiAgICogVVJMIHRvIG9wZW4gaW4gYSBicm93c2VyIHdoaWNoIHdpbGwgY29tcGxldGUgdGhlIHNpZ24taW4gZmxvdyBieVxuICAgKiB0YWtpbmcgdGhlIHVzZXIgdG8gdGhlIGlkZW50aXR5IHByb3ZpZGVyJ3MgYXV0aGVudGljYXRpb24gZmxvdy5cbiAgICpcbiAgICogT24gYnJvd3NlcnMgeW91IGNhbiBzZXQgdGhlIFVSTCB0byBgd2luZG93LmxvY2F0aW9uLmhyZWZgIHRvIHRha2VcbiAgICogdGhlIHVzZXIgdG8gdGhlIGF1dGhlbnRpY2F0aW9uIGZsb3cuXG4gICAqL1xuICB1cmw6IHN0cmluZ1xufT5cblxuZXhwb3J0IHR5cGUgVXNlclJlc3BvbnNlID0gUmVxdWVzdFJlc3VsdFNhZmVEZXN0cnVjdHVyZTx7XG4gIHVzZXI6IFVzZXJcbn0+XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbiB7XG4gIC8qKlxuICAgKiBUaGUgb2F1dGggcHJvdmlkZXIgdG9rZW4uIElmIHByZXNlbnQsIHRoaXMgY2FuIGJlIHVzZWQgdG8gbWFrZSBleHRlcm5hbCBBUEkgcmVxdWVzdHMgdG8gdGhlIG9hdXRoIHByb3ZpZGVyIHVzZWQuXG4gICAqL1xuICBwcm92aWRlcl90b2tlbj86IHN0cmluZyB8IG51bGxcbiAgLyoqXG4gICAqIFRoZSBvYXV0aCBwcm92aWRlciByZWZyZXNoIHRva2VuLiBJZiBwcmVzZW50LCB0aGlzIGNhbiBiZSB1c2VkIHRvIHJlZnJlc2ggdGhlIHByb3ZpZGVyX3Rva2VuIHZpYSB0aGUgb2F1dGggcHJvdmlkZXIncyBBUEkuXG4gICAqIE5vdCBhbGwgb2F1dGggcHJvdmlkZXJzIHJldHVybiBhIHByb3ZpZGVyIHJlZnJlc2ggdG9rZW4uIElmIHRoZSBwcm92aWRlcl9yZWZyZXNoX3Rva2VuIGlzIG1pc3NpbmcsIHBsZWFzZSByZWZlciB0byB0aGUgb2F1dGggcHJvdmlkZXIncyBkb2N1bWVudGF0aW9uIGZvciBpbmZvcm1hdGlvbiBvbiBob3cgdG8gb2J0YWluIHRoZSBwcm92aWRlciByZWZyZXNoIHRva2VuLlxuICAgKi9cbiAgcHJvdmlkZXJfcmVmcmVzaF90b2tlbj86IHN0cmluZyB8IG51bGxcbiAgLyoqXG4gICAqIFRoZSBhY2Nlc3MgdG9rZW4gand0LiBJdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgdGhlIEpXVF9FWFBJUlkgdG8gYSBzaG9ydGVyIGV4cGlyeSB2YWx1ZS5cbiAgICovXG4gIGFjY2Vzc190b2tlbjogc3RyaW5nXG4gIC8qKlxuICAgKiBBIG9uZS10aW1lIHVzZWQgcmVmcmVzaCB0b2tlbiB0aGF0IG5ldmVyIGV4cGlyZXMuXG4gICAqL1xuICByZWZyZXNoX3Rva2VuOiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgdG9rZW4gZXhwaXJlcyAoc2luY2UgaXQgd2FzIGlzc3VlZCkuIFJldHVybmVkIHdoZW4gYSBsb2dpbiBpcyBjb25maXJtZWQuXG4gICAqL1xuICBleHBpcmVzX2luOiBudW1iZXJcbiAgLyoqXG4gICAqIEEgdGltZXN0YW1wIG9mIHdoZW4gdGhlIHRva2VuIHdpbGwgZXhwaXJlLiBSZXR1cm5lZCB3aGVuIGEgbG9naW4gaXMgY29uZmlybWVkLlxuICAgKi9cbiAgZXhwaXJlc19hdD86IG51bWJlclxuICB0b2tlbl90eXBlOiAnYmVhcmVyJ1xuXG4gIC8qKlxuICAgKiBXaGVuIHVzaW5nIGEgc2VwYXJhdGUgdXNlciBzdG9yYWdlLCBhY2Nlc3NpbmcgcHJvcGVydGllcyBvZiB0aGlzIG9iamVjdCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgKi9cbiAgdXNlcjogVXNlclxufVxuXG5jb25zdCBBTVJNZXRob2RzID0gW1xuICAncGFzc3dvcmQnLFxuICAnb3RwJyxcbiAgJ29hdXRoJyxcbiAgJ3RvdHAnLFxuICAnbWZhL3RvdHAnLFxuICAnbWZhL3Bob25lJyxcbiAgJ21mYS93ZWJhdXRobicsXG4gICdhbm9ueW1vdXMnLFxuICAnc3NvL3NhbWwnLFxuICAnbWFnaWNsaW5rJyxcbiAgJ3dlYjMnLFxuICAnb2F1dGhfcHJvdmlkZXIvYXV0aG9yaXphdGlvbl9jb2RlJyxcbl0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgQU1STWV0aG9kID0gKHR5cGVvZiBBTVJNZXRob2RzKVtudW1iZXJdIHwgKHN0cmluZyAmIHt9KVxuXG4vKipcbiAqIEFuIGF1dGhlbnRpY2F0aW9uIG1ldGhvZCByZWZlcmVuY2UgKEFNUikgZW50cnkuXG4gKlxuICogQW4gZW50cnkgZGVzaWduYXRlcyB3aGF0IG1ldGhvZCB3YXMgdXNlZCBieSB0aGUgdXNlciB0byB2ZXJpZnkgdGhlaXJcbiAqIGlkZW50aXR5IGFuZCBhdCB3aGF0IHRpbWUuXG4gKlxuICogTm90ZTogQ3VzdG9tIGFjY2VzcyB0b2tlbiBob29rcyBjYW4gcmV0dXJuIEFNUiBjbGFpbXMgYXMgZWl0aGVyOlxuICogLSBBbiBhcnJheSBvZiBBTVJFbnRyeSBvYmplY3RzIChkZXRhaWxlZCBmb3JtYXQgd2l0aCB0aW1lc3RhbXBzKVxuICogLSBBbiBhcnJheSBvZiBzdHJpbmdzIChSRkMtODE3NiBjb21wbGlhbnQgZm9ybWF0KVxuICpcbiAqIEBzZWUge0BsaW5rIEdvVHJ1ZU1GQUFwaSNnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWx9LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFNUkVudHJ5IHtcbiAgLyoqIEF1dGhlbnRpY2F0aW9uIG1ldGhvZCBuYW1lLiAqL1xuICBtZXRob2Q6IEFNUk1ldGhvZFxuXG4gIC8qKlxuICAgKiBUaW1lc3RhbXAgd2hlbiB0aGUgbWV0aG9kIHdhcyBzdWNjZXNzZnVsbHkgdXNlZC4gUmVwcmVzZW50cyBudW1iZXIgb2ZcbiAgICogc2Vjb25kcyBzaW5jZSAxc3QgSmFudWFyeSAxOTcwIChVTklYIGVwb2NoKSBpbiBVVEMuXG4gICAqL1xuICB0aW1lc3RhbXA6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJJZGVudGl0eSB7XG4gIGlkOiBzdHJpbmdcbiAgdXNlcl9pZDogc3RyaW5nXG4gIGlkZW50aXR5X2RhdGE/OiB7XG4gICAgW2tleTogc3RyaW5nXTogYW55XG4gIH1cbiAgaWRlbnRpdHlfaWQ6IHN0cmluZ1xuICBwcm92aWRlcjogc3RyaW5nXG4gIGNyZWF0ZWRfYXQ/OiBzdHJpbmdcbiAgbGFzdF9zaWduX2luX2F0Pzogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ/OiBzdHJpbmdcbn1cblxuY29uc3QgRmFjdG9yVHlwZXMgPSBbJ3RvdHAnLCAncGhvbmUnLCAnd2ViYXV0aG4nXSBhcyBjb25zdFxuXG4vKipcbiAqIFR5cGUgb2YgZmFjdG9yLiBgdG90cGAgYW5kIGBwaG9uZWAgc3VwcG9ydGVkIHdpdGggdGhpcyB2ZXJzaW9uXG4gKi9cbmV4cG9ydCB0eXBlIEZhY3RvclR5cGUgPSAodHlwZW9mIEZhY3RvclR5cGVzKVtudW1iZXJdXG5cbmNvbnN0IEZhY3RvclZlcmlmaWNhdGlvblN0YXR1c2VzID0gWyd2ZXJpZmllZCcsICd1bnZlcmlmaWVkJ10gYXMgY29uc3RcblxuLyoqXG4gKiBUaGUgdmVyaWZpY2F0aW9uIHN0YXR1cyBvZiB0aGUgZmFjdG9yLCBkZWZhdWx0IGlzIGB1bnZlcmlmaWVkYCBhZnRlciBgLmVucm9sbCgpYCwgdGhlbiBgdmVyaWZpZWRgIGFmdGVyIHRoZSB1c2VyIHZlcmlmaWVzIGl0IHdpdGggYC52ZXJpZnkoKWBcbiAqL1xudHlwZSBGYWN0b3JWZXJpZmljYXRpb25TdGF0dXMgPSAodHlwZW9mIEZhY3RvclZlcmlmaWNhdGlvblN0YXR1c2VzKVtudW1iZXJdXG5cbi8qKlxuICogQSBNRkEgZmFjdG9yLlxuICpcbiAqIEBzZWUge0BsaW5rIEdvVHJ1ZU1GQUFwaSNlbnJvbGx9XG4gKiBAc2VlIHtAbGluayBHb1RydWVNRkFBcGkjbGlzdEZhY3RvcnN9XG4gKiBAc2VlIHtAbGluayBHb1RydWVNRkFBZG1pbkFwaSNsaXN0RmFjdG9yc31cbiAqL1xuZXhwb3J0IHR5cGUgRmFjdG9yPFxuICBUeXBlIGV4dGVuZHMgRmFjdG9yVHlwZSA9IEZhY3RvclR5cGUsXG4gIFN0YXR1cyBleHRlbmRzIEZhY3RvclZlcmlmaWNhdGlvblN0YXR1cyA9ICh0eXBlb2YgRmFjdG9yVmVyaWZpY2F0aW9uU3RhdHVzZXMpW251bWJlcl0sXG4+ID0ge1xuICAvKiogSUQgb2YgdGhlIGZhY3Rvci4gKi9cbiAgaWQ6IHN0cmluZ1xuXG4gIC8qKiBGcmllbmRseSBuYW1lIG9mIHRoZSBmYWN0b3IsIHVzZWZ1bCB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlbiBtdWx0aXBsZSBmYWN0b3JzLiAqL1xuICBmcmllbmRseV9uYW1lPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgZmFjdG9yLiBgdG90cGAgYW5kIGBwaG9uZWAgc3VwcG9ydGVkIHdpdGggdGhpcyB2ZXJzaW9uXG4gICAqL1xuICBmYWN0b3JfdHlwZTogVHlwZVxuXG4gIC8qKlxuICAgKiBUaGUgdmVyaWZpY2F0aW9uIHN0YXR1cyBvZiB0aGUgZmFjdG9yLCBkZWZhdWx0IGlzIGB1bnZlcmlmaWVkYCBhZnRlciBgLmVucm9sbCgpYCwgdGhlbiBgdmVyaWZpZWRgIGFmdGVyIHRoZSB1c2VyIHZlcmlmaWVzIGl0IHdpdGggYC52ZXJpZnkoKWBcbiAgICovXG4gIHN0YXR1czogU3RhdHVzXG5cbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xuICBsYXN0X2NoYWxsZW5nZWRfYXQ/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyQXBwTWV0YWRhdGEge1xuICAvKipcbiAgICogVGhlIGZpcnN0IHByb3ZpZGVyIHRoYXQgdGhlIHVzZXIgdXNlZCB0byBzaWduIHVwIHdpdGguXG4gICAqL1xuICBwcm92aWRlcj86IHN0cmluZ1xuICAvKipcbiAgICogQSBsaXN0IG9mIGFsbCBwcm92aWRlcnMgdGhhdCB0aGUgdXNlciBoYXMgbGlua2VkIHRvIHRoZWlyIGFjY291bnQuXG4gICAqL1xuICBwcm92aWRlcnM/OiBzdHJpbmdbXVxuICBba2V5OiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyTWV0YWRhdGEge1xuICBba2V5OiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZ1xuICBhcHBfbWV0YWRhdGE6IFVzZXJBcHBNZXRhZGF0YVxuICB1c2VyX21ldGFkYXRhOiBVc2VyTWV0YWRhdGFcbiAgYXVkOiBzdHJpbmdcbiAgY29uZmlybWF0aW9uX3NlbnRfYXQ/OiBzdHJpbmdcbiAgcmVjb3Zlcnlfc2VudF9hdD86IHN0cmluZ1xuICBlbWFpbF9jaGFuZ2Vfc2VudF9hdD86IHN0cmluZ1xuICBuZXdfZW1haWw/OiBzdHJpbmdcbiAgbmV3X3Bob25lPzogc3RyaW5nXG4gIGludml0ZWRfYXQ/OiBzdHJpbmdcbiAgYWN0aW9uX2xpbms/OiBzdHJpbmdcbiAgZW1haWw/OiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIGNvbmZpcm1lZF9hdD86IHN0cmluZ1xuICBlbWFpbF9jb25maXJtZWRfYXQ/OiBzdHJpbmdcbiAgcGhvbmVfY29uZmlybWVkX2F0Pzogc3RyaW5nXG4gIGxhc3Rfc2lnbl9pbl9hdD86IHN0cmluZ1xuICByb2xlPzogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ/OiBzdHJpbmdcbiAgaWRlbnRpdGllcz86IFVzZXJJZGVudGl0eVtdXG4gIGlzX2Fub255bW91cz86IGJvb2xlYW5cbiAgaXNfc3NvX3VzZXI/OiBib29sZWFuXG4gIGZhY3RvcnM/OiAoRmFjdG9yPEZhY3RvclR5cGUsICd2ZXJpZmllZCc+IHwgRmFjdG9yPEZhY3RvclR5cGUsICd1bnZlcmlmaWVkJz4pW11cbiAgZGVsZXRlZF9hdD86IHN0cmluZ1xuICBiYW5uZWRfdW50aWw/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyQXR0cmlidXRlcyB7XG4gIC8qKlxuICAgKiBUaGUgdXNlcidzIGVtYWlsLlxuICAgKi9cbiAgZW1haWw/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHVzZXIncyBwaG9uZS5cbiAgICovXG4gIHBob25lPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSB1c2VyJ3MgcGFzc3dvcmQuXG4gICAqL1xuICBwYXNzd29yZD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgbm9uY2Ugc2VudCBmb3IgcmVhdXRoZW50aWNhdGlvbiBpZiB0aGUgdXNlcidzIHBhc3N3b3JkIGlzIHRvIGJlIHVwZGF0ZWQuXG4gICAqXG4gICAqIENhbGwgcmVhdXRoZW50aWNhdGUoKSB0byBvYnRhaW4gdGhlIG5vbmNlIGZpcnN0LlxuICAgKi9cbiAgbm9uY2U/OiBzdHJpbmdcblxuICAvKipcbiAgICogQSBjdXN0b20gZGF0YSBvYmplY3QgdG8gc3RvcmUgdGhlIHVzZXIncyBtZXRhZGF0YS4gVGhpcyBtYXBzIHRvIHRoZSBgYXV0aC51c2Vycy5yYXdfdXNlcl9tZXRhX2RhdGFgIGNvbHVtbi5cbiAgICpcbiAgICogVGhlIGBkYXRhYCBzaG91bGQgYmUgYSBKU09OIG9iamVjdCB0aGF0IGluY2x1ZGVzIHVzZXItc3BlY2lmaWMgaW5mbywgc3VjaCBhcyB0aGVpciBmaXJzdCBhbmQgbGFzdCBuYW1lLlxuICAgKlxuICAgKi9cbiAgZGF0YT86IG9iamVjdFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkbWluVXNlckF0dHJpYnV0ZXMgZXh0ZW5kcyBPbWl0PFVzZXJBdHRyaWJ1dGVzLCAnZGF0YSc+IHtcbiAgLyoqXG4gICAqIEEgY3VzdG9tIGRhdGEgb2JqZWN0IHRvIHN0b3JlIHRoZSB1c2VyJ3MgbWV0YWRhdGEuIFRoaXMgbWFwcyB0byB0aGUgYGF1dGgudXNlcnMucmF3X3VzZXJfbWV0YV9kYXRhYCBjb2x1bW4uXG4gICAqXG4gICAqXG4gICAqIFRoZSBgdXNlcl9tZXRhZGF0YWAgc2hvdWxkIGJlIGEgSlNPTiBvYmplY3QgdGhhdCBpbmNsdWRlcyB1c2VyLXNwZWNpZmljIGluZm8sIHN1Y2ggYXMgdGhlaXIgZmlyc3QgYW5kIGxhc3QgbmFtZS5cbiAgICpcbiAgICogTm90ZTogV2hlbiB1c2luZyB0aGUgR29UcnVlQWRtaW5BcGkgYW5kIHdhbnRpbmcgdG8gbW9kaWZ5IGEgdXNlcidzIG1ldGFkYXRhLFxuICAgKiB0aGlzIGF0dHJpYnV0ZSBpcyB1c2VkIGluc3RlYWQgb2YgVXNlckF0dHJpYnV0ZXMgZGF0YS5cbiAgICpcbiAgICovXG4gIHVzZXJfbWV0YWRhdGE/OiBvYmplY3RcblxuICAvKipcbiAgICogQSBjdXN0b20gZGF0YSBvYmplY3QgdG8gc3RvcmUgdGhlIHVzZXIncyBhcHBsaWNhdGlvbiBzcGVjaWZpYyBtZXRhZGF0YS4gVGhpcyBtYXBzIHRvIHRoZSBgYXV0aC51c2Vycy5hcHBfbWV0YWRhdGFgIGNvbHVtbi5cbiAgICpcbiAgICogT25seSBhIHNlcnZpY2Ugcm9sZSBjYW4gbW9kaWZ5LlxuICAgKlxuICAgKiBUaGUgYGFwcF9tZXRhZGF0YWAgc2hvdWxkIGJlIGEgSlNPTiBvYmplY3QgdGhhdCBpbmNsdWRlcyBhcHAtc3BlY2lmaWMgaW5mbywgc3VjaCBhcyBpZGVudGl0eSBwcm92aWRlcnMsIHJvbGVzLCBhbmQgb3RoZXJcbiAgICogYWNjZXNzIGNvbnRyb2wgaW5mb3JtYXRpb24uXG4gICAqL1xuICBhcHBfbWV0YWRhdGE/OiBvYmplY3RcblxuICAvKipcbiAgICogU2V0cyB0aGUgdXNlcidzIGVtYWlsIGFzIGNvbmZpcm1lZCB3aGVuIHRydWUsIG9yIHVuY29uZmlybWVkIHdoZW4gZmFsc2UuXG4gICAqXG4gICAqIE9ubHkgYSBzZXJ2aWNlIHJvbGUgY2FuIG1vZGlmeS5cbiAgICovXG4gIGVtYWlsX2NvbmZpcm0/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHVzZXIncyBwaG9uZSBhcyBjb25maXJtZWQgd2hlbiB0cnVlLCBvciB1bmNvbmZpcm1lZCB3aGVuIGZhbHNlLlxuICAgKlxuICAgKiBPbmx5IGEgc2VydmljZSByb2xlIGNhbiBtb2RpZnkuXG4gICAqL1xuICBwaG9uZV9jb25maXJtPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGhvdyBsb25nIGEgdXNlciBpcyBiYW5uZWQgZm9yLlxuICAgKlxuICAgKiBUaGUgZm9ybWF0IGZvciB0aGUgYmFuIGR1cmF0aW9uIGZvbGxvd3MgYSBzdHJpY3Qgc2VxdWVuY2Ugb2YgZGVjaW1hbCBudW1iZXJzIHdpdGggYSB1bml0IHN1ZmZpeC5cbiAgICogVmFsaWQgdGltZSB1bml0cyBhcmUgXCJuc1wiLCBcInVzXCIgKG9yIFwiXHUwMEI1c1wiKSwgXCJtc1wiLCBcInNcIiwgXCJtXCIsIFwiaFwiLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgc29tZSBwb3NzaWJsZSBkdXJhdGlvbnMgaW5jbHVkZTogJzMwMG1zJywgJzJoNDVtJy5cbiAgICpcbiAgICogU2V0dGluZyB0aGUgYmFuIGR1cmF0aW9uIHRvICdub25lJyBsaWZ0cyB0aGUgYmFuIG9uIHRoZSB1c2VyLlxuICAgKi9cbiAgYmFuX2R1cmF0aW9uPzogc3RyaW5nIHwgJ25vbmUnXG5cbiAgLyoqXG4gICAqIFRoZSBgcm9sZWAgY2xhaW0gc2V0IGluIHRoZSB1c2VyJ3MgYWNjZXNzIHRva2VuIEpXVC5cbiAgICpcbiAgICogV2hlbiBhIHVzZXIgc2lnbnMgdXAsIHRoaXMgcm9sZSBpcyBzZXQgdG8gYGF1dGhlbnRpY2F0ZWRgIGJ5IGRlZmF1bHQuIFlvdSBzaG91bGQgb25seSBtb2RpZnkgdGhlIGByb2xlYCBpZiB5b3UgbmVlZCB0byBwcm92aXNpb24gc2V2ZXJhbCBsZXZlbHMgb2YgYWRtaW4gYWNjZXNzIHRoYXQgaGF2ZSBkaWZmZXJlbnQgcGVybWlzc2lvbnMgb24gaW5kaXZpZHVhbCBjb2x1bW5zIGluIHlvdXIgZGF0YWJhc2UuXG4gICAqXG4gICAqIFNldHRpbmcgdGhpcyByb2xlIHRvIGBzZXJ2aWNlX3JvbGVgIGlzIG5vdCByZWNvbW1lbmRlZCBhcyBpdCBncmFudHMgdGhlIHVzZXIgYWRtaW4gcHJpdmlsZWdlcy5cbiAgICovXG4gIHJvbGU/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIGBwYXNzd29yZF9oYXNoYCBmb3IgdGhlIHVzZXIncyBwYXNzd29yZC5cbiAgICpcbiAgICogQWxsb3dzIHlvdSB0byBzcGVjaWZ5IGEgcGFzc3dvcmQgaGFzaCBmb3IgdGhlIHVzZXIuIFRoaXMgaXMgdXNlZnVsIGZvciBtaWdyYXRpbmcgYSB1c2VyJ3MgcGFzc3dvcmQgaGFzaCBmcm9tIGFub3RoZXIgc2VydmljZS5cbiAgICpcbiAgICogU3VwcG9ydHMgYmNyeXB0LCBzY3J5cHQgKGZpcmViYXNlKSwgYW5kIGFyZ29uMiBwYXNzd29yZCBoYXNoZXMuXG4gICAqL1xuICBwYXNzd29yZF9oYXNoPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBgaWRgIGZvciB0aGUgdXNlci5cbiAgICpcbiAgICogQWxsb3dzIHlvdSB0byBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgYGlkYCBzZXQgZm9yIHRoZSB1c2VyLlxuICAgKi9cbiAgaWQ/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpcHRpb24ge1xuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBzdWJzY3JpcHRpb24sIHNldCBieSB0aGUgY2xpZW50LlxuICAgKiBUaGlzIGlzIGFuIGludGVybmFsIGlkZW50aWZpZXIgdXNlZCBmb3IgbWFuYWdpbmcgY2FsbGJhY2tzIGFuZCBzaG91bGQgbm90IGJlXG4gICAqIHJlbGllZCB1cG9uIGJ5IGFwcGxpY2F0aW9uIGNvZGUuIFVzZSB0aGUgdW5zdWJzY3JpYmUoKSBtZXRob2QgdG8gcmVtb3ZlIGxpc3RlbmVycy5cbiAgICovXG4gIGlkOiBzdHJpbmcgfCBzeW1ib2xcbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbiB0byBjYWxsIGV2ZXJ5IHRpbWUgdGhlcmUgaXMgYW4gZXZlbnQuIGVnOiAoZXZlbnROYW1lKSA9PiB7fVxuICAgKi9cbiAgY2FsbGJhY2s6IChldmVudDogQXV0aENoYW5nZUV2ZW50LCBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCkgPT4gdm9pZFxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICB1bnN1YnNjcmliZTogKCkgPT4gdm9pZFxufVxuXG5leHBvcnQgdHlwZSBTaWduSW5Bbm9ueW1vdXNseUNyZWRlbnRpYWxzID0ge1xuICBvcHRpb25zPzoge1xuICAgIC8qKlxuICAgICAqIEEgY3VzdG9tIGRhdGEgb2JqZWN0IHRvIHN0b3JlIHRoZSB1c2VyJ3MgbWV0YWRhdGEuIFRoaXMgbWFwcyB0byB0aGUgYGF1dGgudXNlcnMucmF3X3VzZXJfbWV0YV9kYXRhYCBjb2x1bW4uXG4gICAgICpcbiAgICAgKiBUaGUgYGRhdGFgIHNob3VsZCBiZSBhIEpTT04gb2JqZWN0IHRoYXQgaW5jbHVkZXMgdXNlci1zcGVjaWZpYyBpbmZvLCBzdWNoIGFzIHRoZWlyIGZpcnN0IGFuZCBsYXN0IG5hbWUuXG4gICAgICovXG4gICAgZGF0YT86IG9iamVjdFxuICAgIC8qKiBWZXJpZmljYXRpb24gdG9rZW4gcmVjZWl2ZWQgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIGNhcHRjaGEgb24gdGhlIHNpdGUuICovXG4gICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgU2lnblVwV2l0aFBhc3N3b3JkQ3JlZGVudGlhbHMgPSBQcmV0dGlmeTxcbiAgUGFzc3dvcmRDcmVkZW50aWFsc0Jhc2UgJiB7XG4gICAgb3B0aW9ucz86IHtcbiAgICAgIGVtYWlsUmVkaXJlY3RUbz86IHN0cmluZyAvLyBvbmx5IGZvciBlbWFpbFxuICAgICAgZGF0YT86IG9iamVjdFxuICAgICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gICAgICBjaGFubmVsPzogJ3NtcycgfCAnd2hhdHNhcHAnIC8vIG9ubHkgZm9yIHBob25lXG4gICAgfVxuICB9XG4+XG5cbnR5cGUgUGFzc3dvcmRDcmVkZW50aWFsc0Jhc2UgPVxuICB8IHsgZW1haWw6IHN0cmluZzsgcGFzc3dvcmQ6IHN0cmluZyB9XG4gIHwgeyBwaG9uZTogc3RyaW5nOyBwYXNzd29yZDogc3RyaW5nIH1cblxuZXhwb3J0IHR5cGUgU2lnbkluV2l0aFBhc3N3b3JkQ3JlZGVudGlhbHMgPSBQYXNzd29yZENyZWRlbnRpYWxzQmFzZSAmIHtcbiAgb3B0aW9ucz86IHtcbiAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBTaWduSW5XaXRoUGFzc3dvcmRsZXNzQ3JlZGVudGlhbHMgPVxuICB8IHtcbiAgICAgIC8qKiBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuICovXG4gICAgICBlbWFpbDogc3RyaW5nXG4gICAgICBvcHRpb25zPzoge1xuICAgICAgICAvKiogVGhlIHJlZGlyZWN0IHVybCBlbWJlZGRlZCBpbiB0aGUgZW1haWwgbGluayAqL1xuICAgICAgICBlbWFpbFJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgICAgICAgLyoqIElmIHNldCB0byBmYWxzZSwgdGhpcyBtZXRob2Qgd2lsbCBub3QgY3JlYXRlIGEgbmV3IHVzZXIuIERlZmF1bHRzIHRvIHRydWUuICovXG4gICAgICAgIHNob3VsZENyZWF0ZVVzZXI/OiBib29sZWFuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGN1c3RvbSBkYXRhIG9iamVjdCB0byBzdG9yZSB0aGUgdXNlcidzIG1ldGFkYXRhLiBUaGlzIG1hcHMgdG8gdGhlIGBhdXRoLnVzZXJzLnJhd191c2VyX21ldGFfZGF0YWAgY29sdW1uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYGRhdGFgIHNob3VsZCBiZSBhIEpTT04gb2JqZWN0IHRoYXQgaW5jbHVkZXMgdXNlci1zcGVjaWZpYyBpbmZvLCBzdWNoIGFzIHRoZWlyIGZpcnN0IGFuZCBsYXN0IG5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhPzogb2JqZWN0XG4gICAgICAgIC8qKiBWZXJpZmljYXRpb24gdG9rZW4gcmVjZWl2ZWQgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIGNhcHRjaGEgb24gdGhlIHNpdGUuICovXG4gICAgICAgIGNhcHRjaGFUb2tlbj86IHN0cmluZ1xuICAgICAgfVxuICAgIH1cbiAgfCB7XG4gICAgICAvKiogVGhlIHVzZXIncyBwaG9uZSBudW1iZXIuICovXG4gICAgICBwaG9uZTogc3RyaW5nXG4gICAgICBvcHRpb25zPzoge1xuICAgICAgICAvKiogSWYgc2V0IHRvIGZhbHNlLCB0aGlzIG1ldGhvZCB3aWxsIG5vdCBjcmVhdGUgYSBuZXcgdXNlci4gRGVmYXVsdHMgdG8gdHJ1ZS4gKi9cbiAgICAgICAgc2hvdWxkQ3JlYXRlVXNlcj86IGJvb2xlYW5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY3VzdG9tIGRhdGEgb2JqZWN0IHRvIHN0b3JlIHRoZSB1c2VyJ3MgbWV0YWRhdGEuIFRoaXMgbWFwcyB0byB0aGUgYGF1dGgudXNlcnMucmF3X3VzZXJfbWV0YV9kYXRhYCBjb2x1bW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBgZGF0YWAgc2hvdWxkIGJlIGEgSlNPTiBvYmplY3QgdGhhdCBpbmNsdWRlcyB1c2VyLXNwZWNpZmljIGluZm8sIHN1Y2ggYXMgdGhlaXIgZmlyc3QgYW5kIGxhc3QgbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIGRhdGE/OiBvYmplY3RcbiAgICAgICAgLyoqIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS4gKi9cbiAgICAgICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gICAgICAgIC8qKiBNZXNzYWdpbmcgY2hhbm5lbCB0byB1c2UgKGUuZy4gd2hhdHNhcHAgb3Igc21zKSAqL1xuICAgICAgICBjaGFubmVsPzogJ3NtcycgfCAnd2hhdHNhcHAnXG4gICAgICB9XG4gICAgfVxuXG5leHBvcnQgdHlwZSBBdXRoRmxvd1R5cGUgPSAnaW1wbGljaXQnIHwgJ3BrY2UnXG5leHBvcnQgdHlwZSBTaWduSW5XaXRoT0F1dGhDcmVkZW50aWFscyA9IHtcbiAgLyoqIE9uZSBvZiB0aGUgcHJvdmlkZXJzIHN1cHBvcnRlZCBieSBHb1RydWUuICovXG4gIHByb3ZpZGVyOiBQcm92aWRlclxuICBvcHRpb25zPzoge1xuICAgIC8qKiBBIFVSTCB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgYXJlIGNvbmZpcm1lZC4gKi9cbiAgICByZWRpcmVjdFRvPzogc3RyaW5nXG4gICAgLyoqIEEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2Ygc2NvcGVzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLiAqL1xuICAgIHNjb3Blcz86IHN0cmluZ1xuICAgIC8qKiBBbiBvYmplY3Qgb2YgcXVlcnkgcGFyYW1zICovXG4gICAgcXVlcnlQYXJhbXM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gICAgLyoqIElmIHNldCB0byB0cnVlIGRvZXMgbm90IGltbWVkaWF0ZWx5IHJlZGlyZWN0IHRoZSBjdXJyZW50IGJyb3dzZXIgY29udGV4dCB0byB2aXNpdCB0aGUgT0F1dGggYXV0aG9yaXphdGlvbiBwYWdlIGZvciB0aGUgcHJvdmlkZXIuICovXG4gICAgc2tpcEJyb3dzZXJSZWRpcmVjdD86IGJvb2xlYW5cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBTaWduSW5XaXRoSWRUb2tlbkNyZWRlbnRpYWxzID0ge1xuICAvKiogUHJvdmlkZXIgbmFtZSBvciBPSURDIGBpc3NgIHZhbHVlIGlkZW50aWZ5aW5nIHdoaWNoIHByb3ZpZGVyIHNob3VsZCBiZSB1c2VkIHRvIHZlcmlmeSB0aGUgcHJvdmlkZWQgdG9rZW4uIFN1cHBvcnRlZCBuYW1lczogYGdvb2dsZWAsIGBhcHBsZWAsIGBhenVyZWAsIGBmYWNlYm9va2AsIGBrYWthb2AsIGBrZXljbG9ha2AgKGRlcHJlY2F0ZWQpLiAqL1xuICBwcm92aWRlcjogJ2dvb2dsZScgfCAnYXBwbGUnIHwgJ2F6dXJlJyB8ICdmYWNlYm9vaycgfCAna2FrYW8nIHwgKHN0cmluZyAmIHt9KVxuICAvKiogT0lEQyBJRCB0b2tlbiBpc3N1ZWQgYnkgdGhlIHNwZWNpZmllZCBwcm92aWRlci4gVGhlIGBpc3NgIGNsYWltIGluIHRoZSBJRCB0b2tlbiBtdXN0IG1hdGNoIHRoZSBzdXBwbGllZCBwcm92aWRlci4gU29tZSBJRCB0b2tlbnMgY29udGFpbiBhbiBgYXRfaGFzaGAgd2hpY2ggcmVxdWlyZSB0aGF0IHlvdSBwcm92aWRlIGFuIGBhY2Nlc3NfdG9rZW5gIHZhbHVlIHRvIGJlIGFjY2VwdGVkIHByb3Blcmx5LiBJZiB0aGUgdG9rZW4gY29udGFpbnMgYSBgbm9uY2VgIGNsYWltIHlvdSBtdXN0IHN1cHBseSB0aGUgbm9uY2UgdXNlZCB0byBvYnRhaW4gdGhlIElEIHRva2VuLiAqL1xuICB0b2tlbjogc3RyaW5nXG4gIC8qKiBJZiB0aGUgSUQgdG9rZW4gY29udGFpbnMgYW4gYGF0X2hhc2hgIGNsYWltLCB0aGVuIHRoZSBoYXNoIG9mIHRoaXMgdmFsdWUgaXMgY29tcGFyZWQgdG8gdGhlIHZhbHVlIGluIHRoZSBJRCB0b2tlbi4gKi9cbiAgYWNjZXNzX3Rva2VuPzogc3RyaW5nXG4gIC8qKiBJZiB0aGUgSUQgdG9rZW4gY29udGFpbnMgYSBgbm9uY2VgIGNsYWltLCB0aGVuIHRoZSBoYXNoIG9mIHRoaXMgdmFsdWUgaXMgY29tcGFyZWQgdG8gdGhlIHZhbHVlIGluIHRoZSBJRCB0b2tlbi4gKi9cbiAgbm9uY2U/OiBzdHJpbmdcbiAgb3B0aW9ucz86IHtcbiAgICAvKiogVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLiAqL1xuICAgIGNhcHRjaGFUb2tlbj86IHN0cmluZ1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFNvbGFuYVdhbGxldCA9IHtcbiAgc2lnbkluPzogKC4uLmlucHV0czogU29sYW5hU2lnbkluSW5wdXRbXSkgPT4gUHJvbWlzZTxTb2xhbmFTaWduSW5PdXRwdXQgfCBTb2xhbmFTaWduSW5PdXRwdXRbXT5cbiAgcHVibGljS2V5Pzoge1xuICAgIHRvQmFzZTU4OiAoKSA9PiBzdHJpbmdcbiAgfSB8IG51bGxcblxuICBzaWduTWVzc2FnZT86IChtZXNzYWdlOiBVaW50OEFycmF5LCBlbmNvZGluZz86ICd1dGY4JyB8IHN0cmluZykgPT4gUHJvbWlzZTxVaW50OEFycmF5PiB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgdHlwZSBTb2xhbmFXZWIzQ3JlZGVudGlhbHMgPVxuICB8IHtcbiAgICAgIGNoYWluOiAnc29sYW5hJ1xuXG4gICAgICAvKiogV2FsbGV0IGludGVyZmFjZSB0byB1c2UuIElmIG5vdCBzcGVjaWZpZWQgd2lsbCBkZWZhdWx0IHRvIGB3aW5kb3cuc29sYW5hYC4gKi9cbiAgICAgIHdhbGxldD86IFNvbGFuYVdhbGxldFxuXG4gICAgICAvKiogT3B0aW9uYWwgc3RhdGVtZW50IHRvIGluY2x1ZGUgaW4gdGhlIFNpZ24gaW4gd2l0aCBTb2xhbmEgbWVzc2FnZS4gTXVzdCBub3QgaW5jbHVkZSBuZXcgbGluZSBjaGFyYWN0ZXJzLiBNb3N0IHdhbGxldHMgbGlrZSBQaGFudG9tICoqcmVxdWlyZSBzcGVjaWZ5aW5nIGEgc3RhdGVtZW50ISoqICovXG4gICAgICBzdGF0ZW1lbnQ/OiBzdHJpbmdcblxuICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgLyoqIFVSTCB0byB1c2Ugd2l0aCB0aGUgd2FsbGV0IGludGVyZmFjZS4gU29tZSB3YWxsZXRzIGRvIG5vdCBhbGxvdyBzaWduaW5nIGEgbWVzc2FnZSBmb3IgVVJMcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBwYWdlLiAqL1xuICAgICAgICB1cmw/OiBzdHJpbmdcblxuICAgICAgICAvKiogVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLiAqL1xuICAgICAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcblxuICAgICAgICBzaWduSW5XaXRoU29sYW5hPzogUGFydGlhbDxcbiAgICAgICAgICBPbWl0PFNvbGFuYVNpZ25JbklucHV0LCAndmVyc2lvbicgfCAnY2hhaW4nIHwgJ2RvbWFpbicgfCAndXJpJyB8ICdzdGF0ZW1lbnQnPlxuICAgICAgICA+XG4gICAgICB9XG4gICAgfVxuICB8IHtcbiAgICAgIGNoYWluOiAnc29sYW5hJ1xuXG4gICAgICAvKiogU2lnbiBpbiB3aXRoIFNvbGFuYSBjb21wYXRpYmxlIG1lc3NhZ2UuIE11c3QgaW5jbHVkZSBgSXNzdWVkIEF0YCwgYFVSSWAgYW5kIGBWZXJzaW9uYC4gKi9cbiAgICAgIG1lc3NhZ2U6IHN0cmluZ1xuXG4gICAgICAvKiogRWQyNTUxOSBzaWduYXR1cmUgb2YgdGhlIG1lc3NhZ2UuICovXG4gICAgICBzaWduYXR1cmU6IFVpbnQ4QXJyYXlcblxuICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgLyoqIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS4gKi9cbiAgICAgICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gICAgICB9XG4gICAgfVxuXG5leHBvcnQgdHlwZSBFdGhlcmV1bVdhbGxldCA9IEVJUDExOTNQcm92aWRlclxuXG5leHBvcnQgdHlwZSBFdGhlcmV1bVdlYjNDcmVkZW50aWFscyA9XG4gIHwge1xuICAgICAgY2hhaW46ICdldGhlcmV1bSdcblxuICAgICAgLyoqIFdhbGxldCBpbnRlcmZhY2UgdG8gdXNlLiBJZiBub3Qgc3BlY2lmaWVkIHdpbGwgZGVmYXVsdCB0byBgd2luZG93LmV0aGVyZXVtYC4gKi9cbiAgICAgIHdhbGxldD86IEV0aGVyZXVtV2FsbGV0XG5cbiAgICAgIC8qKiBPcHRpb25hbCBzdGF0ZW1lbnQgdG8gaW5jbHVkZSBpbiB0aGUgU2lnbiBpbiB3aXRoIEV0aGVyZXVtIG1lc3NhZ2UuIE11c3Qgbm90IGluY2x1ZGUgbmV3IGxpbmUgY2hhcmFjdGVycy4gTW9zdCB3YWxsZXRzIGxpa2UgUGhhbnRvbSAqKnJlcXVpcmUgc3BlY2lmeWluZyBhIHN0YXRlbWVudCEqKiAqL1xuICAgICAgc3RhdGVtZW50Pzogc3RyaW5nXG5cbiAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgIC8qKiBVUkwgdG8gdXNlIHdpdGggdGhlIHdhbGxldCBpbnRlcmZhY2UuIFNvbWUgd2FsbGV0cyBkbyBub3QgYWxsb3cgc2lnbmluZyBhIG1lc3NhZ2UgZm9yIFVSTHMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgcGFnZS4gKi9cbiAgICAgICAgdXJsPzogc3RyaW5nXG5cbiAgICAgICAgLyoqIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS4gKi9cbiAgICAgICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG5cbiAgICAgICAgc2lnbkluV2l0aEV0aGVyZXVtPzogUGFydGlhbDxcbiAgICAgICAgICBPbWl0PEV0aGVyZXVtU2lnbkluSW5wdXQsICd2ZXJzaW9uJyB8ICdkb21haW4nIHwgJ3VyaScgfCAnc3RhdGVtZW50Jz5cbiAgICAgICAgPlxuICAgICAgfVxuICAgIH1cbiAgfCB7XG4gICAgICBjaGFpbjogJ2V0aGVyZXVtJ1xuXG4gICAgICAvKiogU2lnbiBpbiB3aXRoIEV0aGVyZXVtIGNvbXBhdGlibGUgbWVzc2FnZS4gTXVzdCBpbmNsdWRlIGBJc3N1ZWQgQXRgLCBgVVJJYCBhbmQgYFZlcnNpb25gLiAqL1xuICAgICAgbWVzc2FnZTogc3RyaW5nXG5cbiAgICAgIC8qKiBFdGhlcmV1bSBjdXJ2ZSAoc2VjcDI1NmsxKSBzaWduYXR1cmUgb2YgdGhlIG1lc3NhZ2UuICovXG4gICAgICBzaWduYXR1cmU6IEhleFxuXG4gICAgICBvcHRpb25zPzoge1xuICAgICAgICAvKiogVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLiAqL1xuICAgICAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgICAgIH1cbiAgICB9XG5cbmV4cG9ydCB0eXBlIFdlYjNDcmVkZW50aWFscyA9IFNvbGFuYVdlYjNDcmVkZW50aWFscyB8IEV0aGVyZXVtV2ViM0NyZWRlbnRpYWxzXG5cbmV4cG9ydCB0eXBlIFZlcmlmeU90cFBhcmFtcyA9IFZlcmlmeU1vYmlsZU90cFBhcmFtcyB8IFZlcmlmeUVtYWlsT3RwUGFyYW1zIHwgVmVyaWZ5VG9rZW5IYXNoUGFyYW1zXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeU1vYmlsZU90cFBhcmFtcyB7XG4gIC8qKiBUaGUgdXNlcidzIHBob25lIG51bWJlci4gKi9cbiAgcGhvbmU6IHN0cmluZ1xuICAvKiogVGhlIG90cCBzZW50IHRvIHRoZSB1c2VyJ3MgcGhvbmUgbnVtYmVyLiAqL1xuICB0b2tlbjogc3RyaW5nXG4gIC8qKiBUaGUgdXNlcidzIHZlcmlmaWNhdGlvbiB0eXBlLiAqL1xuICB0eXBlOiBNb2JpbGVPdHBUeXBlXG4gIG9wdGlvbnM/OiB7XG4gICAgLyoqIEEgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBhcmUgY29uZmlybWVkLiAqL1xuICAgIHJlZGlyZWN0VG8/OiBzdHJpbmdcblxuICAgIC8qKlxuICAgICAqIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5RW1haWxPdHBQYXJhbXMge1xuICAvKiogVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLiAqL1xuICBlbWFpbDogc3RyaW5nXG4gIC8qKiBUaGUgb3RwIHNlbnQgdG8gdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLiAqL1xuICB0b2tlbjogc3RyaW5nXG4gIC8qKiBUaGUgdXNlcidzIHZlcmlmaWNhdGlvbiB0eXBlLiAqL1xuICB0eXBlOiBFbWFpbE90cFR5cGVcbiAgb3B0aW9ucz86IHtcbiAgICAvKiogQSBVUkwgdG8gc2VuZCB0aGUgdXNlciB0byBhZnRlciB0aGV5IGFyZSBjb25maXJtZWQuICovXG4gICAgcmVkaXJlY3RUbz86IHN0cmluZ1xuXG4gICAgLyoqIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlUb2tlbkhhc2hQYXJhbXMge1xuICAvKiogVGhlIHRva2VuIGhhc2ggdXNlZCBpbiBhbiBlbWFpbCBsaW5rICovXG4gIHRva2VuX2hhc2g6IHN0cmluZ1xuXG4gIC8qKiBUaGUgdXNlcidzIHZlcmlmaWNhdGlvbiB0eXBlLiAqL1xuICB0eXBlOiBFbWFpbE90cFR5cGVcbn1cblxuZXhwb3J0IHR5cGUgTW9iaWxlT3RwVHlwZSA9ICdzbXMnIHwgJ3Bob25lX2NoYW5nZSdcbmV4cG9ydCB0eXBlIEVtYWlsT3RwVHlwZSA9ICdzaWdudXAnIHwgJ2ludml0ZScgfCAnbWFnaWNsaW5rJyB8ICdyZWNvdmVyeScgfCAnZW1haWxfY2hhbmdlJyB8ICdlbWFpbCdcblxuZXhwb3J0IHR5cGUgUmVzZW5kUGFyYW1zID1cbiAgfCB7XG4gICAgICB0eXBlOiBFeHRyYWN0PEVtYWlsT3RwVHlwZSwgJ3NpZ251cCcgfCAnZW1haWxfY2hhbmdlJz5cbiAgICAgIGVtYWlsOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgIC8qKiBBIFVSTCB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgaGF2ZSBzaWduZWQtaW4uICovXG4gICAgICAgIGVtYWlsUmVkaXJlY3RUbz86IHN0cmluZ1xuICAgICAgICAvKiogVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLiAqL1xuICAgICAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgICAgIH1cbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogRXh0cmFjdDxNb2JpbGVPdHBUeXBlLCAnc21zJyB8ICdwaG9uZV9jaGFuZ2UnPlxuICAgICAgcGhvbmU6IHN0cmluZ1xuICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgLyoqIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS4gKi9cbiAgICAgICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gICAgICB9XG4gICAgfVxuXG5leHBvcnQgdHlwZSBTaWduSW5XaXRoU1NPID1cbiAgfCB7XG4gICAgICAvKiogVVVJRCBvZiB0aGUgU1NPIHByb3ZpZGVyIHRvIGludm9rZSBzaW5nbGUtc2lnbiBvbiB0by4gKi9cbiAgICAgIHByb3ZpZGVySWQ6IHN0cmluZ1xuXG4gICAgICBvcHRpb25zPzoge1xuICAgICAgICAvKiogQSBVUkwgdG8gc2VuZCB0aGUgdXNlciB0byBhZnRlciB0aGV5IGhhdmUgc2lnbmVkLWluLiAqL1xuICAgICAgICByZWRpcmVjdFRvPzogc3RyaW5nXG4gICAgICAgIC8qKiBWZXJpZmljYXRpb24gdG9rZW4gcmVjZWl2ZWQgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIGNhcHRjaGEgb24gdGhlIHNpdGUuICovXG4gICAgICAgIGNhcHRjaGFUb2tlbj86IHN0cmluZ1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSByZWRpcmVjdCB3aWxsIG5vdCBoYXBwZW4gb24gdGhlIGNsaWVudCBzaWRlLlxuICAgICAgICAgKiBUaGlzIHBhcmFtZXRlciBpcyB1c2VkIHdoZW4geW91IHdpc2ggdG8gaGFuZGxlIHRoZSByZWRpcmVjdCB5b3Vyc2VsZi5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBza2lwQnJvd3NlclJlZGlyZWN0PzogYm9vbGVhblxuICAgICAgfVxuICAgIH1cbiAgfCB7XG4gICAgICAvKiogRG9tYWluIG5hbWUgb2YgdGhlIG9yZ2FuaXphdGlvbiBmb3Igd2hpY2ggdG8gaW52b2tlIHNpbmdsZS1zaWduIG9uLiAqL1xuICAgICAgZG9tYWluOiBzdHJpbmdcblxuICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgLyoqIEEgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBoYXZlIHNpZ25lZC1pbi4gKi9cbiAgICAgICAgcmVkaXJlY3RUbz86IHN0cmluZ1xuICAgICAgICAvKiogVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLiAqL1xuICAgICAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgcmVkaXJlY3Qgd2lsbCBub3QgaGFwcGVuIG9uIHRoZSBjbGllbnQgc2lkZS5cbiAgICAgICAgICogVGhpcyBwYXJhbWV0ZXIgaXMgdXNlZCB3aGVuIHlvdSB3aXNoIHRvIGhhbmRsZSB0aGUgcmVkaXJlY3QgeW91cnNlbGYuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2tpcEJyb3dzZXJSZWRpcmVjdD86IGJvb2xlYW5cbiAgICAgIH1cbiAgICB9XG5cbmV4cG9ydCB0eXBlIEdlbmVyYXRlU2lnbnVwTGlua1BhcmFtcyA9IHtcbiAgdHlwZTogJ3NpZ251cCdcbiAgZW1haWw6IHN0cmluZ1xuICBwYXNzd29yZDogc3RyaW5nXG4gIG9wdGlvbnM/OiBQaWNrPEdlbmVyYXRlTGlua09wdGlvbnMsICdkYXRhJyB8ICdyZWRpcmVjdFRvJz5cbn1cblxuZXhwb3J0IHR5cGUgR2VuZXJhdGVJbnZpdGVPck1hZ2ljbGlua1BhcmFtcyA9IHtcbiAgdHlwZTogJ2ludml0ZScgfCAnbWFnaWNsaW5rJ1xuICAvKiogVGhlIHVzZXIncyBlbWFpbCAqL1xuICBlbWFpbDogc3RyaW5nXG4gIG9wdGlvbnM/OiBQaWNrPEdlbmVyYXRlTGlua09wdGlvbnMsICdkYXRhJyB8ICdyZWRpcmVjdFRvJz5cbn1cblxuZXhwb3J0IHR5cGUgR2VuZXJhdGVSZWNvdmVyeUxpbmtQYXJhbXMgPSB7XG4gIHR5cGU6ICdyZWNvdmVyeSdcbiAgLyoqIFRoZSB1c2VyJ3MgZW1haWwgKi9cbiAgZW1haWw6IHN0cmluZ1xuICBvcHRpb25zPzogUGljazxHZW5lcmF0ZUxpbmtPcHRpb25zLCAncmVkaXJlY3RUbyc+XG59XG5cbmV4cG9ydCB0eXBlIEdlbmVyYXRlRW1haWxDaGFuZ2VMaW5rUGFyYW1zID0ge1xuICB0eXBlOiAnZW1haWxfY2hhbmdlX2N1cnJlbnQnIHwgJ2VtYWlsX2NoYW5nZV9uZXcnXG4gIC8qKiBUaGUgdXNlcidzIGVtYWlsICovXG4gIGVtYWlsOiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSB1c2VyJ3MgbmV3IGVtYWlsLiBPbmx5IHJlcXVpcmVkIGlmIHR5cGUgaXMgJ2VtYWlsX2NoYW5nZV9jdXJyZW50JyBvciAnZW1haWxfY2hhbmdlX25ldycuXG4gICAqL1xuICBuZXdFbWFpbDogc3RyaW5nXG4gIG9wdGlvbnM/OiBQaWNrPEdlbmVyYXRlTGlua09wdGlvbnMsICdyZWRpcmVjdFRvJz5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmF0ZUxpbmtPcHRpb25zIHtcbiAgLyoqXG4gICAqIEEgY3VzdG9tIGRhdGEgb2JqZWN0IHRvIHN0b3JlIHRoZSB1c2VyJ3MgbWV0YWRhdGEuIFRoaXMgbWFwcyB0byB0aGUgYGF1dGgudXNlcnMucmF3X3VzZXJfbWV0YV9kYXRhYCBjb2x1bW4uXG4gICAqXG4gICAqIFRoZSBgZGF0YWAgc2hvdWxkIGJlIGEgSlNPTiBvYmplY3QgdGhhdCBpbmNsdWRlcyB1c2VyLXNwZWNpZmljIGluZm8sIHN1Y2ggYXMgdGhlaXIgZmlyc3QgYW5kIGxhc3QgbmFtZS5cbiAgICovXG4gIGRhdGE/OiBvYmplY3RcbiAgLyoqIFRoZSBVUkwgd2hpY2ggd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW1haWwgbGluayBnZW5lcmF0ZWQuICovXG4gIHJlZGlyZWN0VG8/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgR2VuZXJhdGVMaW5rUGFyYW1zID1cbiAgfCBHZW5lcmF0ZVNpZ251cExpbmtQYXJhbXNcbiAgfCBHZW5lcmF0ZUludml0ZU9yTWFnaWNsaW5rUGFyYW1zXG4gIHwgR2VuZXJhdGVSZWNvdmVyeUxpbmtQYXJhbXNcbiAgfCBHZW5lcmF0ZUVtYWlsQ2hhbmdlTGlua1BhcmFtc1xuXG5leHBvcnQgdHlwZSBHZW5lcmF0ZUxpbmtSZXNwb25zZSA9IFJlcXVlc3RSZXN1bHRTYWZlRGVzdHJ1Y3R1cmU8e1xuICBwcm9wZXJ0aWVzOiBHZW5lcmF0ZUxpbmtQcm9wZXJ0aWVzXG4gIHVzZXI6IFVzZXJcbn0+XG5cbi8qKiBUaGUgcHJvcGVydGllcyByZWxhdGVkIHRvIHRoZSBlbWFpbCBsaW5rIGdlbmVyYXRlZCAgKi9cbmV4cG9ydCB0eXBlIEdlbmVyYXRlTGlua1Byb3BlcnRpZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgZW1haWwgbGluayB0byBzZW5kIHRvIHRoZSB1c2VyLlxuICAgKiBUaGUgYWN0aW9uX2xpbmsgZm9sbG93cyB0aGUgZm9sbG93aW5nIGZvcm1hdDogYXV0aC92MS92ZXJpZnk/dHlwZT17dmVyaWZpY2F0aW9uX3R5cGV9JnRva2VuPXtoYXNoZWRfdG9rZW59JnJlZGlyZWN0X3RvPXtyZWRpcmVjdF90b31cbiAgICogKi9cbiAgYWN0aW9uX2xpbms6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIHJhdyBlbWFpbCBPVFAuXG4gICAqIFlvdSBzaG91bGQgc2VuZCB0aGlzIGluIHRoZSBlbWFpbCBpZiB5b3Ugd2FudCB5b3VyIHVzZXJzIHRvIHZlcmlmeSB1c2luZyBhbiBPVFAgaW5zdGVhZCBvZiB0aGUgYWN0aW9uIGxpbmsuXG4gICAqICovXG4gIGVtYWlsX290cDogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgaGFzaGVkIHRva2VuIGFwcGVuZGVkIHRvIHRoZSBhY3Rpb24gbGluay5cbiAgICogKi9cbiAgaGFzaGVkX3Rva2VuOiBzdHJpbmdcbiAgLyoqIFRoZSBVUkwgYXBwZW5kZWQgdG8gdGhlIGFjdGlvbiBsaW5rLiAqL1xuICByZWRpcmVjdF90bzogc3RyaW5nXG4gIC8qKiBUaGUgdmVyaWZpY2F0aW9uIHR5cGUgdGhhdCB0aGUgZW1haWwgbGluayBpcyBhc3NvY2lhdGVkIHRvLiAqL1xuICB2ZXJpZmljYXRpb25fdHlwZTogR2VuZXJhdGVMaW5rVHlwZVxufVxuXG5leHBvcnQgdHlwZSBHZW5lcmF0ZUxpbmtUeXBlID1cbiAgfCAnc2lnbnVwJ1xuICB8ICdpbnZpdGUnXG4gIHwgJ21hZ2ljbGluaydcbiAgfCAncmVjb3ZlcnknXG4gIHwgJ2VtYWlsX2NoYW5nZV9jdXJyZW50J1xuICB8ICdlbWFpbF9jaGFuZ2VfbmV3J1xuXG5leHBvcnQgdHlwZSBNRkFFbnJvbGxQYXJhbXMgPSBNRkFFbnJvbGxUT1RQUGFyYW1zIHwgTUZBRW5yb2xsUGhvbmVQYXJhbXMgfCBNRkFFbnJvbGxXZWJhdXRoblBhcmFtc1xuXG5leHBvcnQgdHlwZSBNRkFVbmVucm9sbFBhcmFtcyA9IHtcbiAgLyoqIElEIG9mIHRoZSBmYWN0b3IgYmVpbmcgdW5lbnJvbGxlZC4gKi9cbiAgZmFjdG9ySWQ6IHN0cmluZ1xufVxuXG50eXBlIE1GQVZlcmlmeVBhcmFtc0Jhc2UgPSB7XG4gIC8qKiBJRCBvZiB0aGUgZmFjdG9yIGJlaW5nIHZlcmlmaWVkLiBSZXR1cm5lZCBpbiBlbnJvbGwoKS4gKi9cbiAgZmFjdG9ySWQ6IHN0cmluZ1xuICAvKiogSUQgb2YgdGhlIGNoYWxsZW5nZSBiZWluZyB2ZXJpZmllZC4gUmV0dXJuZWQgaW4gY2hhbGxlbmdlKCkuICovXG4gIGNoYWxsZW5nZUlkOiBzdHJpbmdcbn1cblxudHlwZSBNRkFWZXJpZnlUT1RQUGFyYW1GaWVsZHMgPSB7XG4gIC8qKiBWZXJpZmljYXRpb24gY29kZSBwcm92aWRlZCBieSB0aGUgdXNlci4gKi9cbiAgY29kZTogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIE1GQVZlcmlmeVRPVFBQYXJhbXMgPSBQcmV0dGlmeTxNRkFWZXJpZnlQYXJhbXNCYXNlICYgTUZBVmVyaWZ5VE9UUFBhcmFtRmllbGRzPlxuXG50eXBlIE1GQVZlcmlmeVBob25lUGFyYW1GaWVsZHMgPSBNRkFWZXJpZnlUT1RQUGFyYW1GaWVsZHNcblxuZXhwb3J0IHR5cGUgTUZBVmVyaWZ5UGhvbmVQYXJhbXMgPSBQcmV0dGlmeTxNRkFWZXJpZnlQYXJhbXNCYXNlICYgTUZBVmVyaWZ5UGhvbmVQYXJhbUZpZWxkcz5cblxudHlwZSBNRkFWZXJpZnlXZWJhdXRoblBhcmFtRmllbGRzQmFzZSA9IHtcbiAgLyoqIFJlbHlpbmcgcGFydHkgSUQgKi9cbiAgcnBJZDogc3RyaW5nXG4gIC8qKiBSZWx5aW5nIHBhcnR5IG9yaWdpbnMgKi9cbiAgcnBPcmlnaW5zPzogc3RyaW5nW11cbn1cblxudHlwZSBNRkFWZXJpZnlXZWJhdXRobkNyZWRlbnRpYWxQYXJhbUZpZWxkczxUIGV4dGVuZHMgJ2NyZWF0ZScgfCAncmVxdWVzdCcgPSAnY3JlYXRlJyB8ICdyZXF1ZXN0Jz4gPVxuICB7XG4gICAgLyoqIE9wZXJhdGlvbiB0eXBlICovXG4gICAgdHlwZTogVFxuICAgIC8qKiBDcmVhdGlvbiByZXNwb25zZSBmcm9tIHRoZSBhdXRoZW50aWNhdG9yIChmb3IgZW5yb2xsbWVudC91bnZlcmlmaWVkIGZhY3RvcnMpICovXG4gICAgY3JlZGVudGlhbF9yZXNwb25zZTogVCBleHRlbmRzICdjcmVhdGUnID8gUmVnaXN0cmF0aW9uQ3JlZGVudGlhbCA6IEF1dGhlbnRpY2F0aW9uQ3JlZGVudGlhbFxuICB9XG5cbi8qKlxuICogV2ViQXV0aG4tc3BlY2lmaWMgZmllbGRzIGZvciBNRkEgdmVyaWZpY2F0aW9uLlxuICogU3VwcG9ydHMgYm90aCBjcmVkZW50aWFsIGNyZWF0aW9uIChyZWdpc3RyYXRpb24pIGFuZCByZXF1ZXN0IChhdXRoZW50aWNhdGlvbikgZmxvd3MuXG4gKiBAdGVtcGxhdGUgVCAtIFR5cGUgb2YgV2ViQXV0aG4gb3BlcmF0aW9uOiAnY3JlYXRlJyBmb3IgcmVnaXN0cmF0aW9uLCAncmVxdWVzdCcgZm9yIGF1dGhlbnRpY2F0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIE1GQVZlcmlmeVdlYmF1dGhuUGFyYW1GaWVsZHM8VCBleHRlbmRzICdjcmVhdGUnIHwgJ3JlcXVlc3QnID0gJ2NyZWF0ZScgfCAncmVxdWVzdCc+ID0ge1xuICB3ZWJhdXRobjogTUZBVmVyaWZ5V2ViYXV0aG5QYXJhbUZpZWxkc0Jhc2UgJiBNRkFWZXJpZnlXZWJhdXRobkNyZWRlbnRpYWxQYXJhbUZpZWxkczxUPlxufVxuXG4vKipcbiAqIFBhcmFtZXRlcnMgZm9yIFdlYkF1dGhuIE1GQSB2ZXJpZmljYXRpb24uXG4gKiBVc2VkIHRvIHZlcmlmeSBXZWJBdXRobiBjcmVkZW50aWFscyBhZnRlciBjaGFsbGVuZ2UuXG4gKiBAdGVtcGxhdGUgVCAtIFR5cGUgb2YgV2ViQXV0aG4gb3BlcmF0aW9uOiAnY3JlYXRlJyBmb3IgcmVnaXN0cmF0aW9uLCAncmVxdWVzdCcgZm9yIGF1dGhlbnRpY2F0aW9uXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tdmVyaWZ5aW5nLWFzc2VydGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIFZlcmlmeWluZyBhbiBBdXRoZW50aWNhdGlvbiBBc3NlcnRpb259XG4gKi9cbmV4cG9ydCB0eXBlIE1GQVZlcmlmeVdlYmF1dGhuUGFyYW1zPFQgZXh0ZW5kcyAnY3JlYXRlJyB8ICdyZXF1ZXN0JyA9ICdjcmVhdGUnIHwgJ3JlcXVlc3QnPiA9XG4gIFByZXR0aWZ5PE1GQVZlcmlmeVBhcmFtc0Jhc2UgJiBNRkFWZXJpZnlXZWJhdXRoblBhcmFtRmllbGRzPFQ+PlxuXG5leHBvcnQgdHlwZSBNRkFWZXJpZnlQYXJhbXMgPSBNRkFWZXJpZnlUT1RQUGFyYW1zIHwgTUZBVmVyaWZ5UGhvbmVQYXJhbXMgfCBNRkFWZXJpZnlXZWJhdXRoblBhcmFtc1xuXG50eXBlIE1GQUNoYWxsZW5nZVBhcmFtc0Jhc2UgPSB7XG4gIC8qKiBJRCBvZiB0aGUgZmFjdG9yIHRvIGJlIGNoYWxsZW5nZWQuIFJldHVybmVkIGluIGVucm9sbCgpLiAqL1xuICBmYWN0b3JJZDogc3RyaW5nXG59XG5cbmNvbnN0IE1GQVRPVFBDaGFubmVscyA9IFsnc21zJywgJ3doYXRzYXBwJ10gYXMgY29uc3RcbmV4cG9ydCB0eXBlIE1GQVRPVFBDaGFubmVsID0gKHR5cGVvZiBNRkFUT1RQQ2hhbm5lbHMpW251bWJlcl1cblxuZXhwb3J0IHR5cGUgTUZBQ2hhbGxlbmdlVE9UUFBhcmFtcyA9IFByZXR0aWZ5PE1GQUNoYWxsZW5nZVBhcmFtc0Jhc2U+XG5cbnR5cGUgTUZBQ2hhbGxlbmdlUGhvbmVQYXJhbUZpZWxkczxDaGFubmVsIGV4dGVuZHMgTUZBVE9UUENoYW5uZWwgPSBNRkFUT1RQQ2hhbm5lbD4gPSB7XG4gIC8qKiBNZXNzYWdpbmcgY2hhbm5lbCB0byB1c2UgKGUuZy4gd2hhdHNhcHAgb3Igc21zKS4gT25seSByZWxldmFudCBmb3IgcGhvbmUgZmFjdG9ycyAqL1xuICBjaGFubmVsOiBDaGFubmVsXG59XG5cbmV4cG9ydCB0eXBlIE1GQUNoYWxsZW5nZVBob25lUGFyYW1zID0gUHJldHRpZnk8XG4gIE1GQUNoYWxsZW5nZVBhcmFtc0Jhc2UgJiBNRkFDaGFsbGVuZ2VQaG9uZVBhcmFtRmllbGRzXG4+XG5cbi8qKiBXZWJBdXRobiBwYXJhbWV0ZXJzIGZvciBXZWJBdXRobiBmYWN0b3IgY2hhbGxlbmdlICovXG50eXBlIE1GQUNoYWxsZW5nZVdlYmF1dGhuUGFyYW1GaWVsZHMgPSB7XG4gIHdlYmF1dGhuOiB7XG4gICAgLyoqIFJlbHlpbmcgcGFydHkgSUQgKi9cbiAgICBycElkOiBzdHJpbmdcbiAgICAvKiogUmVseWluZyBwYXJ0eSBvcmlnaW5zKi9cbiAgICBycE9yaWdpbnM/OiBzdHJpbmdbXVxuICB9XG59XG5cbi8qKlxuICogUGFyYW1ldGVycyBmb3IgaW5pdGlhdGluZyBhIFdlYkF1dGhuIE1GQSBjaGFsbGVuZ2UuXG4gKiBJbmNsdWRlcyBSZWx5aW5nIFBhcnR5IGluZm9ybWF0aW9uIG5lZWRlZCBmb3IgV2ViQXV0aG4gY2VyZW1vbmllcy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1ycC1vcGVyYXRpb25zIFczQyBXZWJBdXRobiBTcGVjIC0gUmVseWluZyBQYXJ0eSBPcGVyYXRpb25zfVxuICovXG5leHBvcnQgdHlwZSBNRkFDaGFsbGVuZ2VXZWJhdXRoblBhcmFtcyA9IFByZXR0aWZ5PFxuICBNRkFDaGFsbGVuZ2VQYXJhbXNCYXNlICYgTUZBQ2hhbGxlbmdlV2ViYXV0aG5QYXJhbUZpZWxkc1xuPlxuXG5leHBvcnQgdHlwZSBNRkFDaGFsbGVuZ2VQYXJhbXMgPVxuICB8IE1GQUNoYWxsZW5nZVRPVFBQYXJhbXNcbiAgfCBNRkFDaGFsbGVuZ2VQaG9uZVBhcmFtc1xuICB8IE1GQUNoYWxsZW5nZVdlYmF1dGhuUGFyYW1zXG5cbnR5cGUgTUZBQ2hhbGxlbmdlQW5kVmVyaWZ5UGFyYW1zQmFzZSA9IE9taXQ8TUZBVmVyaWZ5UGFyYW1zQmFzZSwgJ2NoYWxsZW5nZUlkJz5cblxudHlwZSBNRkFDaGFsbGVuZ2VBbmRWZXJpZnlUT1RQUGFyYW1GaWVsZHMgPSBNRkFWZXJpZnlUT1RQUGFyYW1GaWVsZHNcblxudHlwZSBNRkFDaGFsbGVuZ2VBbmRWZXJpZnlUT1RQUGFyYW1zID0gUHJldHRpZnk8XG4gIE1GQUNoYWxsZW5nZUFuZFZlcmlmeVBhcmFtc0Jhc2UgJiBNRkFDaGFsbGVuZ2VBbmRWZXJpZnlUT1RQUGFyYW1GaWVsZHNcbj5cblxuZXhwb3J0IHR5cGUgTUZBQ2hhbGxlbmdlQW5kVmVyaWZ5UGFyYW1zID0gTUZBQ2hhbGxlbmdlQW5kVmVyaWZ5VE9UUFBhcmFtc1xuXG4vKipcbiAqIERhdGEgcmV0dXJuZWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBNRkEgdmVyaWZpY2F0aW9uLlxuICogQ29udGFpbnMgbmV3IHNlc3Npb24gdG9rZW5zIGFuZCB1cGRhdGVkIHVzZXIgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCB0eXBlIEF1dGhNRkFWZXJpZnlSZXNwb25zZURhdGEgPSB7XG4gIC8qKiBOZXcgYWNjZXNzIHRva2VuIChKV1QpIGFmdGVyIHN1Y2Nlc3NmdWwgdmVyaWZpY2F0aW9uLiAqL1xuICBhY2Nlc3NfdG9rZW46IHN0cmluZ1xuXG4gIC8qKiBUeXBlIG9mIHRva2VuLCBhbHdheXMgYGJlYXJlcmAuICovXG4gIHRva2VuX3R5cGU6ICdiZWFyZXInXG5cbiAgLyoqIE51bWJlciBvZiBzZWNvbmRzIGluIHdoaWNoIHRoZSBhY2Nlc3MgdG9rZW4gd2lsbCBleHBpcmUuICovXG4gIGV4cGlyZXNfaW46IG51bWJlclxuXG4gIC8qKiBSZWZyZXNoIHRva2VuIHlvdSBjYW4gdXNlIHRvIG9idGFpbiBuZXcgYWNjZXNzIHRva2VucyB3aGVuIGV4cGlyZWQuICovXG4gIHJlZnJlc2hfdG9rZW46IHN0cmluZ1xuXG4gIC8qKiBVcGRhdGVkIHVzZXIgcHJvZmlsZS4gKi9cbiAgdXNlcjogVXNlclxufVxuXG4vKipcbiAqIFJlc3BvbnNlIHR5cGUgZm9yIE1GQSB2ZXJpZmljYXRpb24gb3BlcmF0aW9ucy5cbiAqIFJldHVybnMgc2Vzc2lvbiB0b2tlbnMgb24gc3VjY2Vzc2Z1bCB2ZXJpZmljYXRpb24uXG4gKi9cbmV4cG9ydCB0eXBlIEF1dGhNRkFWZXJpZnlSZXNwb25zZSA9IFJlcXVlc3RSZXN1bHQ8QXV0aE1GQVZlcmlmeVJlc3BvbnNlRGF0YT5cblxuZXhwb3J0IHR5cGUgQXV0aE1GQUVucm9sbFJlc3BvbnNlID1cbiAgfCBBdXRoTUZBRW5yb2xsVE9UUFJlc3BvbnNlXG4gIHwgQXV0aE1GQUVucm9sbFBob25lUmVzcG9uc2VcbiAgfCBBdXRoTUZBRW5yb2xsV2ViYXV0aG5SZXNwb25zZVxuXG5leHBvcnQgdHlwZSBBdXRoTUZBVW5lbnJvbGxSZXNwb25zZSA9IFJlcXVlc3RSZXN1bHQ8e1xuICAvKiogSUQgb2YgdGhlIGZhY3RvciB0aGF0IHdhcyBzdWNjZXNzZnVsbHkgdW5lbnJvbGxlZC4gKi9cbiAgaWQ6IHN0cmluZ1xufT5cblxudHlwZSBBdXRoTUZBQ2hhbGxlbmdlUmVzcG9uc2VCYXNlPFQgZXh0ZW5kcyBGYWN0b3JUeXBlPiA9IHtcbiAgLyoqIElEIG9mIHRoZSBuZXdseSBjcmVhdGVkIGNoYWxsZW5nZS4gKi9cbiAgaWQ6IHN0cmluZ1xuXG4gIC8qKiBGYWN0b3IgVHlwZSB3aGljaCBnZW5lcmF0ZWQgdGhlIGNoYWxsZW5nZSAqL1xuICB0eXBlOiBUXG5cbiAgLyoqIFRpbWVzdGFtcCBpbiBVTklYIHNlY29uZHMgd2hlbiB0aGlzIGNoYWxsZW5nZSB3aWxsIG5vIGxvbmdlciBiZSB1c2FibGUuICovXG4gIGV4cGlyZXNfYXQ6IG51bWJlclxufVxuXG50eXBlIEF1dGhNRkFDaGFsbGVuZ2VUT1RQUmVzcG9uc2VGaWVsZHMgPSB7XG4gIC8qKiBubyBleHRyYSBmaWVsZHMgZm9yIG5vdywga2VwdCBmb3IgY29uc2lzdGVuY3kgYW5kIGZvciBwb3NzaWJsZSBmdXR1cmUgY2hhbmdlcyAgKi9cbn1cblxuZXhwb3J0IHR5cGUgQXV0aE1GQUNoYWxsZW5nZVRPVFBSZXNwb25zZSA9IFJlcXVlc3RSZXN1bHQ8XG4gIFByZXR0aWZ5PEF1dGhNRkFDaGFsbGVuZ2VSZXNwb25zZUJhc2U8J3RvdHAnPiAmIEF1dGhNRkFDaGFsbGVuZ2VUT1RQUmVzcG9uc2VGaWVsZHM+XG4+XG5cbnR5cGUgQXV0aE1GQUNoYWxsZW5nZVBob25lUmVzcG9uc2VGaWVsZHMgPSB7XG4gIC8qKiBubyBleHRyYSBmaWVsZHMgZm9yIG5vdywga2VwdCBmb3IgY29uc2lzdGVuY3kgYW5kIGZvciBwb3NzaWJsZSBmdXR1cmUgY2hhbmdlcyAgKi9cbn1cblxuZXhwb3J0IHR5cGUgQXV0aE1GQUNoYWxsZW5nZVBob25lUmVzcG9uc2UgPSBSZXF1ZXN0UmVzdWx0PFxuICBQcmV0dGlmeTxBdXRoTUZBQ2hhbGxlbmdlUmVzcG9uc2VCYXNlPCdwaG9uZSc+ICYgQXV0aE1GQUNoYWxsZW5nZVBob25lUmVzcG9uc2VGaWVsZHM+XG4+XG5cbnR5cGUgQXV0aE1GQUNoYWxsZW5nZVdlYmF1dGhuUmVzcG9uc2VGaWVsZHMgPSB7XG4gIHdlYmF1dGhuOlxuICAgIHwge1xuICAgICAgICB0eXBlOiAnY3JlYXRlJ1xuICAgICAgICBjcmVkZW50aWFsX29wdGlvbnM6IHsgcHVibGljS2V5OiBQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlIH1cbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgdHlwZTogJ3JlcXVlc3QnXG4gICAgICAgIGNyZWRlbnRpYWxfb3B0aW9uczogeyBwdWJsaWNLZXk6IFB1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZSB9XG4gICAgICB9XG59XG5cbi8qKlxuICogUmVzcG9uc2UgdHlwZSBmb3IgV2ViQXV0aG4gTUZBIGNoYWxsZW5nZS5cbiAqIENvbnRhaW5zIGNyZWRlbnRpYWwgY3JlYXRpb24gb3IgcmVxdWVzdCBvcHRpb25zIGZyb20gdGhlIHNlcnZlci5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1jcmVkZW50aWFsLWNyZWF0aW9uIFczQyBXZWJBdXRobiBTcGVjIC0gQ3JlZGVudGlhbCBDcmVhdGlvbn1cbiAqL1xuZXhwb3J0IHR5cGUgQXV0aE1GQUNoYWxsZW5nZVdlYmF1dGhuUmVzcG9uc2UgPSBSZXF1ZXN0UmVzdWx0PFxuICBQcmV0dGlmeTxBdXRoTUZBQ2hhbGxlbmdlUmVzcG9uc2VCYXNlPCd3ZWJhdXRobic+ICYgQXV0aE1GQUNoYWxsZW5nZVdlYmF1dGhuUmVzcG9uc2VGaWVsZHM+XG4+XG5cbnR5cGUgQXV0aE1GQUNoYWxsZW5nZVdlYmF1dGhuUmVzcG9uc2VGaWVsZHNKU09OID0ge1xuICB3ZWJhdXRobjpcbiAgICB8IHtcbiAgICAgICAgdHlwZTogJ2NyZWF0ZSdcbiAgICAgICAgY3JlZGVudGlhbF9vcHRpb25zOiB7IHB1YmxpY0tleTogU2VydmVyQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyB9XG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIHR5cGU6ICdyZXF1ZXN0J1xuICAgICAgICBjcmVkZW50aWFsX29wdGlvbnM6IHsgcHVibGljS2V5OiBTZXJ2ZXJDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMgfVxuICAgICAgfVxufVxuXG4vKipcbiAqIEpTT04tc2VyaWFsaXphYmxlIHZlcnNpb24gb2YgV2ViQXV0aG4gY2hhbGxlbmdlIHJlc3BvbnNlLlxuICogVXNlZCBmb3Igc2VydmVyIGNvbW11bmljYXRpb24gd2l0aCBiYXNlNjR1cmwtZW5jb2RlZCBiaW5hcnkgZmllbGRzLlxuICovXG5leHBvcnQgdHlwZSBBdXRoTUZBQ2hhbGxlbmdlV2ViYXV0aG5SZXNwb25zZURhdGFKU09OID0gUHJldHRpZnk8XG4gIEF1dGhNRkFDaGFsbGVuZ2VSZXNwb25zZUJhc2U8J3dlYmF1dGhuJz4gJiBBdXRoTUZBQ2hhbGxlbmdlV2ViYXV0aG5SZXNwb25zZUZpZWxkc0pTT05cbj5cblxuLyoqXG4gKiBTZXJ2ZXIgcmVzcG9uc2UgdHlwZSBmb3IgV2ViQXV0aG4gTUZBIGNoYWxsZW5nZS5cbiAqIENvbnRhaW5zIEpTT04tZm9ybWF0dGVkIFdlYkF1dGhuIG9wdGlvbnMgcmVhZHkgZm9yIGJyb3dzZXIgQVBJLlxuICovXG5leHBvcnQgdHlwZSBBdXRoTUZBQ2hhbGxlbmdlV2ViYXV0aG5TZXJ2ZXJSZXNwb25zZSA9XG4gIFJlcXVlc3RSZXN1bHQ8QXV0aE1GQUNoYWxsZW5nZVdlYmF1dGhuUmVzcG9uc2VEYXRhSlNPTj5cblxuZXhwb3J0IHR5cGUgQXV0aE1GQUNoYWxsZW5nZVJlc3BvbnNlID1cbiAgfCBBdXRoTUZBQ2hhbGxlbmdlVE9UUFJlc3BvbnNlXG4gIHwgQXV0aE1GQUNoYWxsZW5nZVBob25lUmVzcG9uc2VcbiAgfCBBdXRoTUZBQ2hhbGxlbmdlV2ViYXV0aG5SZXNwb25zZVxuXG4vKiogcmVzcG9uc2Ugb2YgTGlzdEZhY3RvcnMsIHdoaWNoIHNob3VsZCBjb250YWluIGFsbCB0aGUgdHlwZXMgb2YgZmFjdG9ycyB0aGF0IGFyZSBhdmFpbGFibGUsIHRoaXMgZW5zdXJlcyB3ZSBhbHdheXMgaW5jbHVkZSBhbGwgKi9cbmV4cG9ydCB0eXBlIEF1dGhNRkFMaXN0RmFjdG9yc1Jlc3BvbnNlPFQgZXh0ZW5kcyB0eXBlb2YgRmFjdG9yVHlwZXMgPSB0eXBlb2YgRmFjdG9yVHlwZXM+ID1cbiAgUmVxdWVzdFJlc3VsdDxcbiAgICB7XG4gICAgICAvKiogQWxsIGF2YWlsYWJsZSBmYWN0b3JzICh2ZXJpZmllZCBhbmQgdW52ZXJpZmllZCkuICovXG4gICAgICBhbGw6IFByZXR0aWZ5PEZhY3Rvcj5bXVxuXG4gICAgICAvLyBEeW5hbWljYWxseSBjcmVhdGUgYSBwcm9wZXJ0eSBmb3IgZWFjaCBmYWN0b3IgdHlwZSB3aXRoIG9ubHkgdmVyaWZpZWQgZmFjdG9yc1xuICAgIH0gJiB7XG4gICAgICBbSyBpbiBUW251bWJlcl1dOiBQcmV0dGlmeTxGYWN0b3I8SywgJ3ZlcmlmaWVkJz4+W11cbiAgICB9XG4gID5cblxuZXhwb3J0IHR5cGUgQXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVscyA9ICdhYWwxJyB8ICdhYWwyJ1xuXG5leHBvcnQgdHlwZSBBdXRoTUZBR2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsUmVzcG9uc2UgPSBSZXF1ZXN0UmVzdWx0PHtcbiAgLyoqIEN1cnJlbnQgQUFMIGxldmVsIG9mIHRoZSBzZXNzaW9uLiAqL1xuICBjdXJyZW50TGV2ZWw6IEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbHMgfCBudWxsXG5cbiAgLyoqXG4gICAqIE5leHQgcG9zc2libGUgQUFMIGxldmVsIGZvciB0aGUgc2Vzc2lvbi4gSWYgdGhlIG5leHQgbGV2ZWwgaXMgaGlnaGVyXG4gICAqIHRoYW4gdGhlIGN1cnJlbnQgb25lLCB0aGUgdXNlciBzaG91bGQgZ28gdGhyb3VnaCBNRkEuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIEdvVHJ1ZU1GQUFwaSNjaGFsbGVuZ2V9XG4gICAqL1xuICBuZXh0TGV2ZWw6IEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbHMgfCBudWxsXG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBhbGwgYXV0aGVudGljYXRpb24gbWV0aG9kcyBhdHRhY2hlZCB0byB0aGlzIHNlc3Npb24uIFVzZVxuICAgKiB0aGUgaW5mb3JtYXRpb24gaGVyZSB0byBkZXRlY3QgdGhlIGxhc3QgdGltZSBhIHVzZXIgdmVyaWZpZWQgYVxuICAgKiBmYWN0b3IsIGZvciBleGFtcGxlIGlmIGltcGxlbWVudGluZyBhIHN0ZXAtdXAgc2NlbmFyaW8uXG4gICAqXG4gICAqIFN1cHBvcnRzIGJvdGggUkZDLTgxNzYgY29tcGxpYW50IGZvcm1hdCAoc3RyaW5nW10pIGFuZCBkZXRhaWxlZCBmb3JtYXQgKEFNUkVudHJ5W10pLlxuICAgKiAtIFN0cmluZyBmb3JtYXQ6IFsncGFzc3dvcmQnLCAnb3RwJ10gLSBSRkMtODE3NiBjb21wbGlhbnRcbiAgICogLSBPYmplY3QgZm9ybWF0OiBbeyBtZXRob2Q6ICdwYXNzd29yZCcsIHRpbWVzdGFtcDogMTIzNDU2Nzg5MCB9XSAtIGluY2x1ZGVzIHRpbWVzdGFtcHNcbiAgICovXG4gIGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHM6IEFNUkVudHJ5W10gfCBzdHJpbmdbXVxufT5cblxuLyoqXG4gKiBDb250YWlucyB0aGUgZnVsbCBtdWx0aS1mYWN0b3IgYXV0aGVudGljYXRpb24gQVBJLlxuICpcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHb1RydWVNRkFBcGkge1xuICAvKipcbiAgICogU3RhcnRzIHRoZSBlbnJvbGxtZW50IHByb2Nlc3MgZm9yIGEgbmV3IE11bHRpLUZhY3RvciBBdXRoZW50aWNhdGlvbiAoTUZBKVxuICAgKiBmYWN0b3IuIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgYHVudmVyaWZpZWRgIGZhY3Rvci5cbiAgICogVG8gdmVyaWZ5IGEgZmFjdG9yLCBwcmVzZW50IHRoZSBRUiBjb2RlIG9yIHNlY3JldCB0byB0aGUgdXNlciBhbmQgYXNrIHRoZW0gdG8gYWRkIGl0IHRvIHRoZWlyXG4gICAqIGF1dGhlbnRpY2F0b3IgYXBwLlxuICAgKiBUaGUgdXNlciBoYXMgdG8gZW50ZXIgdGhlIGNvZGUgZnJvbSB0aGVpciBhdXRoZW50aWNhdG9yIGFwcCB0byB2ZXJpZnkgaXQuXG4gICAqXG4gICAqIFVwb24gdmVyaWZ5aW5nIGEgZmFjdG9yLCBhbGwgb3RoZXIgc2Vzc2lvbnMgYXJlIGxvZ2dlZCBvdXQgYW5kIHRoZSBjdXJyZW50IHNlc3Npb24ncyBhdXRoZW50aWNhdG9yIGxldmVsIGlzIHByb21vdGVkIHRvIGBhYWwyYC5cbiAgICovXG4gIGVucm9sbChwYXJhbXM6IE1GQUVucm9sbFRPVFBQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFFbnJvbGxUT1RQUmVzcG9uc2U+XG4gIGVucm9sbChwYXJhbXM6IE1GQUVucm9sbFBob25lUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBRW5yb2xsUGhvbmVSZXNwb25zZT5cbiAgZW5yb2xsKHBhcmFtczogTUZBRW5yb2xsV2ViYXV0aG5QYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFFbnJvbGxXZWJhdXRoblJlc3BvbnNlPlxuICBlbnJvbGwocGFyYW1zOiBNRkFFbnJvbGxQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFFbnJvbGxSZXNwb25zZT5cblxuICAvKipcbiAgICogUHJlcGFyZXMgYSBjaGFsbGVuZ2UgdXNlZCB0byB2ZXJpZnkgdGhhdCBhIHVzZXIgaGFzIGFjY2VzcyB0byBhIE1GQVxuICAgKiBmYWN0b3IuXG4gICAqL1xuICBjaGFsbGVuZ2UocGFyYW1zOiBNRkFDaGFsbGVuZ2VUT1RQUGFyYW1zKTogUHJvbWlzZTxQcmV0dGlmeTxBdXRoTUZBQ2hhbGxlbmdlVE9UUFJlc3BvbnNlPj5cbiAgY2hhbGxlbmdlKHBhcmFtczogTUZBQ2hhbGxlbmdlUGhvbmVQYXJhbXMpOiBQcm9taXNlPFByZXR0aWZ5PEF1dGhNRkFDaGFsbGVuZ2VQaG9uZVJlc3BvbnNlPj5cbiAgY2hhbGxlbmdlKHBhcmFtczogTUZBQ2hhbGxlbmdlV2ViYXV0aG5QYXJhbXMpOiBQcm9taXNlPFByZXR0aWZ5PEF1dGhNRkFDaGFsbGVuZ2VXZWJhdXRoblJlc3BvbnNlPj5cbiAgY2hhbGxlbmdlKHBhcmFtczogTUZBQ2hhbGxlbmdlUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBQ2hhbGxlbmdlUmVzcG9uc2U+XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIGEgY29kZSBhZ2FpbnN0IGEgY2hhbGxlbmdlLiBUaGUgdmVyaWZpY2F0aW9uIGNvZGUgaXNcbiAgICogcHJvdmlkZWQgYnkgdGhlIHVzZXIgYnkgZW50ZXJpbmcgYSBjb2RlIHNlZW4gaW4gdGhlaXIgYXV0aGVudGljYXRvciBhcHAuXG4gICAqL1xuICB2ZXJpZnkocGFyYW1zOiBNRkFWZXJpZnlUT1RQUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBVmVyaWZ5UmVzcG9uc2U+XG4gIHZlcmlmeShwYXJhbXM6IE1GQVZlcmlmeVBob25lUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBVmVyaWZ5UmVzcG9uc2U+XG4gIHZlcmlmeShwYXJhbXM6IE1GQVZlcmlmeVdlYmF1dGhuUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBVmVyaWZ5UmVzcG9uc2U+XG4gIHZlcmlmeShwYXJhbXM6IE1GQVZlcmlmeVBhcmFtcyk6IFByb21pc2U8QXV0aE1GQVZlcmlmeVJlc3BvbnNlPlxuXG4gIC8qKlxuICAgKiBVbmVucm9sbCByZW1vdmVzIGEgTUZBIGZhY3Rvci5cbiAgICogQSB1c2VyIGhhcyB0byBoYXZlIGFuIGBhYWwyYCBhdXRoZW50aWNhdG9yIGxldmVsIGluIG9yZGVyIHRvIHVuZW5yb2xsIGEgYHZlcmlmaWVkYCBmYWN0b3IuXG4gICAqL1xuICB1bmVucm9sbChwYXJhbXM6IE1GQVVuZW5yb2xsUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBVW5lbnJvbGxSZXNwb25zZT5cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB3aGljaCBjcmVhdGVzIGEgY2hhbGxlbmdlIGFuZCBpbW1lZGlhdGVseSB1c2VzIHRoZSBnaXZlbiBjb2RlIHRvIHZlcmlmeSBhZ2FpbnN0IGl0IHRoZXJlYWZ0ZXIuIFRoZSB2ZXJpZmljYXRpb24gY29kZSBpc1xuICAgKiBwcm92aWRlZCBieSB0aGUgdXNlciBieSBlbnRlcmluZyBhIGNvZGUgc2VlbiBpbiB0aGVpciBhdXRoZW50aWNhdG9yIGFwcC5cbiAgICovXG4gIGNoYWxsZW5nZUFuZFZlcmlmeShwYXJhbXM6IE1GQUNoYWxsZW5nZUFuZFZlcmlmeVBhcmFtcyk6IFByb21pc2U8QXV0aE1GQVZlcmlmeVJlc3BvbnNlPlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIE1GQSBmYWN0b3JzIGVuYWJsZWQgZm9yIHRoaXMgdXNlci5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgR29UcnVlTUZBQXBpI2Vucm9sbH1cbiAgICogQHNlZSB7QGxpbmsgR29UcnVlTUZBQXBpI2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbH1cbiAgICogQHNlZSB7QGxpbmsgR29UcnVlQ2xpZW50I2dldFVzZXJ9XG4gICAqXG4gICAqL1xuICBsaXN0RmFjdG9ycygpOiBQcm9taXNlPEF1dGhNRkFMaXN0RmFjdG9yc1Jlc3BvbnNlPlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBBdXRoZW50aWNhdG9yIEFzc3VyYW5jZSBMZXZlbCAoQUFMKSBmb3IgdGhlIGFjdGl2ZSBzZXNzaW9uLlxuICAgKlxuICAgKiAtIGBhYWwxYCAob3IgYG51bGxgKSBtZWFucyB0aGF0IHRoZSB1c2VyJ3MgaWRlbnRpdHkgaGFzIGJlZW4gdmVyaWZpZWQgb25seVxuICAgKiB3aXRoIGEgY29udmVudGlvbmFsIGxvZ2luIChlbWFpbCtwYXNzd29yZCwgT1RQLCBtYWdpYyBsaW5rLCBzb2NpYWwgbG9naW4sXG4gICAqIGV0Yy4pLlxuICAgKiAtIGBhYWwyYCBtZWFucyB0aGF0IHRoZSB1c2VyJ3MgaWRlbnRpdHkgaGFzIGJlZW4gdmVyaWZpZWQgYm90aCB3aXRoIGEgY29udmVudGlvbmFsIGxvZ2luIGFuZCBhdCBsZWFzdCBvbmUgTUZBIGZhY3Rvci5cbiAgICpcbiAgICogV2hlbiBjYWxsZWQgd2l0aG91dCBhIEpXVCBwYXJhbWV0ZXIsIHRoaXMgbWV0aG9kIGlzIGZhaXJseSBxdWljayAobWljcm9zZWNvbmRzKVxuICAgKiBhbmQgcmFyZWx5IHVzZXMgdGhlIG5ldHdvcmsuIFdoZW4gYSBKV1QgaXMgcHJvdmlkZWQgKHVzZWZ1bCBpbiBzZXJ2ZXItc2lkZVxuICAgKiBlbnZpcm9ubWVudHMgbGlrZSBFZGdlIEZ1bmN0aW9ucyB3aGVyZSBubyBzZXNzaW9uIGlzIHN0b3JlZCksIHRoaXMgbWV0aG9kXG4gICAqIHdpbGwgbWFrZSBhIG5ldHdvcmsgcmVxdWVzdCB0byB2YWxpZGF0ZSB0aGUgdXNlciBhbmQgZmV0Y2ggdGhlaXIgTUZBIGZhY3RvcnMuXG4gICAqXG4gICAqIEBwYXJhbSBqd3QgVGFrZXMgaW4gYW4gb3B0aW9uYWwgYWNjZXNzIHRva2VuIEpXVC4gSWYgbm8gSldUIGlzIHByb3ZpZGVkLCB0aGUgSldUIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyB1c2VkLlxuICAgKi9cbiAgZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsKFxuICAgIGp3dD86IHN0cmluZ1xuICApOiBQcm9taXNlPEF1dGhNRkFHZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxSZXNwb25zZT5cblxuICAvLyBuYW1lc3BhY2UgZm9yIHRoZSB3ZWJhdXRobiBtZXRob2RzXG4gIHdlYmF1dGhuOiBXZWJBdXRobkFwaVxufVxuXG4vKipcbiAqIEBleHBlcm1lbnRhbFxuICovXG5leHBvcnQgdHlwZSBBdXRoTUZBQWRtaW5EZWxldGVGYWN0b3JSZXNwb25zZSA9IFJlcXVlc3RSZXN1bHQ8e1xuICAvKiogSUQgb2YgdGhlIGZhY3RvciB0aGF0IHdhcyBzdWNjZXNzZnVsbHkgZGVsZXRlZC4gKi9cbiAgaWQ6IHN0cmluZ1xufT5cbi8qKlxuICogQGV4cGVybWVudGFsXG4gKi9cbmV4cG9ydCB0eXBlIEF1dGhNRkFBZG1pbkRlbGV0ZUZhY3RvclBhcmFtcyA9IHtcbiAgLyoqIElEIG9mIHRoZSBNRkEgZmFjdG9yIHRvIGRlbGV0ZS4gKi9cbiAgaWQ6IHN0cmluZ1xuXG4gIC8qKiBJRCBvZiB0aGUgdXNlciB3aG9zZSBmYWN0b3IgaXMgYmVpbmcgZGVsZXRlZC4gKi9cbiAgdXNlcklkOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBAZXhwZXJtZW50YWxcbiAqL1xuZXhwb3J0IHR5cGUgQXV0aE1GQUFkbWluTGlzdEZhY3RvcnNSZXNwb25zZSA9IFJlcXVlc3RSZXN1bHQ8e1xuICAvKiogQWxsIGZhY3RvcnMgYXR0YWNoZWQgdG8gdGhlIHVzZXIuICovXG4gIGZhY3RvcnM6IEZhY3RvcltdXG59PlxuXG4vKipcbiAqIEBleHBlcm1lbnRhbFxuICovXG5leHBvcnQgdHlwZSBBdXRoTUZBQWRtaW5MaXN0RmFjdG9yc1BhcmFtcyA9IHtcbiAgLyoqIElEIG9mIHRoZSB1c2VyLiAqL1xuICB1c2VySWQ6IHN0cmluZ1xufVxuXG4vKipcbiAqIENvbnRhaW5zIHRoZSBmdWxsIG11bHRpLWZhY3RvciBhdXRoZW50aWNhdGlvbiBhZG1pbmlzdHJhdGlvbiBBUEkuXG4gKlxuICogQGV4cGVybWVudGFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR29UcnVlQWRtaW5NRkFBcGkge1xuICAvKipcbiAgICogTGlzdHMgYWxsIGZhY3RvcnMgYXNzb2NpYXRlZCB0byBhIHVzZXIuXG4gICAqXG4gICAqL1xuICBsaXN0RmFjdG9ycyhwYXJhbXM6IEF1dGhNRkFBZG1pbkxpc3RGYWN0b3JzUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBQWRtaW5MaXN0RmFjdG9yc1Jlc3BvbnNlPlxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgZmFjdG9yIG9uIGEgdXNlci4gVGhpcyB3aWxsIGxvZyB0aGUgdXNlciBvdXQgb2YgYWxsIGFjdGl2ZVxuICAgKiBzZXNzaW9ucyBpZiB0aGUgZGVsZXRlZCBmYWN0b3Igd2FzIHZlcmlmaWVkLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBHb1RydWVNRkFBcGkjdW5lbnJvbGx9XG4gICAqXG4gICAqIEBleHBlcm1lbnRhbFxuICAgKi9cbiAgZGVsZXRlRmFjdG9yKHBhcmFtczogQXV0aE1GQUFkbWluRGVsZXRlRmFjdG9yUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBQWRtaW5EZWxldGVGYWN0b3JSZXNwb25zZT5cbn1cblxudHlwZSBBbnlGdW5jdGlvbiA9ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55XG50eXBlIE1heWJlUHJvbWlzaWZ5PFQ+ID0gVCB8IFByb21pc2U8VD5cblxudHlwZSBQcm9taXNpZnlNZXRob2RzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXTogVFtLXSBleHRlbmRzIEFueUZ1bmN0aW9uXG4gICAgPyAoLi4uYXJnczogUGFyYW1ldGVyczxUW0tdPikgPT4gTWF5YmVQcm9taXNpZnk8UmV0dXJuVHlwZTxUW0tdPj5cbiAgICA6IFRbS11cbn1cblxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkU3RvcmFnZSA9IFByb21pc2lmeU1ldGhvZHM8XG4gIFBpY2s8U3RvcmFnZSwgJ2dldEl0ZW0nIHwgJ3NldEl0ZW0nIHwgJ3JlbW92ZUl0ZW0nPlxuPiAmIHtcbiAgLyoqXG4gICAqIElmIHNldCB0byBgdHJ1ZWAgc2lnbmFscyB0byB0aGUgbGlicmFyeSB0aGF0IHRoZSBzdG9yYWdlIG1lZGl1bSBpcyB1c2VkXG4gICAqIG9uIGEgc2VydmVyIGFuZCB0aGUgdmFsdWVzIG1heSBub3QgYmUgYXV0aGVudGljLCBzdWNoIGFzIHJlYWRpbmcgZnJvbVxuICAgKiByZXF1ZXN0IGNvb2tpZXMuIEltcGxlbWVudGF0aW9ucyBzaG91bGQgbm90IHNldCB0aGlzIHRvIHRydWUgaWYgdGhlIGNsaWVudFxuICAgKiBpcyB1c2VkIG9uIGEgc2VydmVyIHRoYXQgcmVhZHMgc3RvcmFnZSBpbmZvcm1hdGlvbiBmcm9tIGF1dGhlbnRpY2F0ZWRcbiAgICogc291cmNlcywgc3VjaCBhcyBhIHNlY3VyZSBkYXRhYmFzZSBvciBmaWxlLlxuICAgKi9cbiAgaXNTZXJ2ZXI/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIEluaXRpYWxpemVSZXN1bHQgPSB7IGVycm9yOiBBdXRoRXJyb3IgfCBudWxsIH1cblxuZXhwb3J0IHR5cGUgQ2FsbFJlZnJlc2hUb2tlblJlc3VsdCA9IFJlcXVlc3RSZXN1bHQ8U2Vzc2lvbj5cblxuZXhwb3J0IHR5cGUgUGFnaW5hdGlvbiA9IHtcbiAgW2tleTogc3RyaW5nXTogYW55XG4gIG5leHRQYWdlOiBudW1iZXIgfCBudWxsXG4gIGxhc3RQYWdlOiBudW1iZXJcbiAgdG90YWw6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBQYWdlUGFyYW1zID0ge1xuICAvKiogVGhlIHBhZ2UgbnVtYmVyICovXG4gIHBhZ2U/OiBudW1iZXJcbiAgLyoqIE51bWJlciBvZiBpdGVtcyByZXR1cm5lZCBwZXIgcGFnZSAqL1xuICBwZXJQYWdlPzogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFNpZ25PdXQgPSB7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoaWNoIHNlc3Npb25zIHNob3VsZCBiZVxuICAgKiBsb2dnZWQgb3V0LiBHbG9iYWwgbWVhbnMgYWxsXG4gICAqIHNlc3Npb25zIGJ5IHRoaXMgYWNjb3VudC4gTG9jYWxcbiAgICogbWVhbnMgb25seSB0aGlzIHNlc3Npb24uIE90aGVyc1xuICAgKiBtZWFucyBhbGwgb3RoZXIgc2Vzc2lvbnMgZXhjZXB0IHRoZVxuICAgKiBjdXJyZW50IG9uZS4gV2hlbiB1c2luZyBvdGhlcnMsXG4gICAqIHRoZXJlIGlzIG5vIHNpZ24tb3V0IGV2ZW50IGZpcmVkIG9uXG4gICAqIHRoZSBjdXJyZW50IHNlc3Npb24hXG4gICAqL1xuICBzY29wZT86ICdnbG9iYWwnIHwgJ2xvY2FsJyB8ICdvdGhlcnMnXG59XG5cbnR5cGUgTUZBRW5yb2xsUGFyYW1zQmFzZTxUIGV4dGVuZHMgRmFjdG9yVHlwZT4gPSB7XG4gIC8qKiBUaGUgdHlwZSBvZiBmYWN0b3IgYmVpbmcgZW5yb2xsZWQuICovXG4gIGZhY3RvclR5cGU6IFRcbiAgLyoqIEh1bWFuIHJlYWRhYmxlIG5hbWUgYXNzaWduZWQgdG8gdGhlIGZhY3Rvci4gKi9cbiAgZnJpZW5kbHlOYW1lPzogc3RyaW5nXG59XG5cbnR5cGUgTUZBRW5yb2xsVE9UUFBhcmFtRmllbGRzID0ge1xuICAvKiogRG9tYWluIHdoaWNoIHRoZSB1c2VyIGlzIGVucm9sbGVkIHdpdGguICovXG4gIGlzc3Vlcj86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBNRkFFbnJvbGxUT1RQUGFyYW1zID0gUHJldHRpZnk8TUZBRW5yb2xsUGFyYW1zQmFzZTwndG90cCc+ICYgTUZBRW5yb2xsVE9UUFBhcmFtRmllbGRzPlxuXG50eXBlIE1GQUVucm9sbFBob25lUGFyYW1GaWVsZHMgPSB7XG4gIC8qKiBQaG9uZSBudW1iZXIgYXNzb2NpYXRlZCB3aXRoIGEgZmFjdG9yLiBOdW1iZXIgc2hvdWxkIGNvbmZvcm0gdG8gRS4xNjQgZm9ybWF0ICovXG4gIHBob25lOiBzdHJpbmdcbn1cbmV4cG9ydCB0eXBlIE1GQUVucm9sbFBob25lUGFyYW1zID0gUHJldHRpZnk8XG4gIE1GQUVucm9sbFBhcmFtc0Jhc2U8J3Bob25lJz4gJiBNRkFFbnJvbGxQaG9uZVBhcmFtRmllbGRzXG4+XG5cbnR5cGUgTUZBRW5yb2xsV2ViYXV0aG5GaWVsZHMgPSB7XG4gIC8qKiBubyBleHRyYSBmaWVsZHMgZm9yIG5vdywga2VwdCBmb3IgY29uc2lzdGVuY3kgYW5kIGZvciBwb3NzaWJsZSBmdXR1cmUgY2hhbmdlcyAgKi9cbn1cblxuLyoqXG4gKiBQYXJhbWV0ZXJzIGZvciBlbnJvbGxpbmcgYSBXZWJBdXRobiBmYWN0b3IuXG4gKiBDcmVhdGVzIGFuIHVudmVyaWZpZWQgV2ViQXV0aG4gZmFjdG9yIHRoYXQgbXVzdCBiZSB2ZXJpZmllZCB3aXRoIGEgY3JlZGVudGlhbC5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1yZWdpc3RlcmluZy1hLW5ldy1jcmVkZW50aWFsIFczQyBXZWJBdXRobiBTcGVjIC0gUmVnaXN0ZXJpbmcgYSBOZXcgQ3JlZGVudGlhbH1cbiAqL1xuZXhwb3J0IHR5cGUgTUZBRW5yb2xsV2ViYXV0aG5QYXJhbXMgPSBQcmV0dGlmeTxcbiAgTUZBRW5yb2xsUGFyYW1zQmFzZTwnd2ViYXV0aG4nPiAmIE1GQUVucm9sbFdlYmF1dGhuRmllbGRzXG4+XG5cbnR5cGUgQXV0aE1GQUVucm9sbFJlc3BvbnNlQmFzZTxUIGV4dGVuZHMgRmFjdG9yVHlwZT4gPSB7XG4gIC8qKiBJRCBvZiB0aGUgZmFjdG9yIHRoYXQgd2FzIGp1c3QgZW5yb2xsZWQgKGluIGFuIHVudmVyaWZpZWQgc3RhdGUpLiAqL1xuICBpZDogc3RyaW5nXG5cbiAgLyoqIFR5cGUgb2YgTUZBIGZhY3Rvci4qL1xuICB0eXBlOiBUXG5cbiAgLyoqIEZyaWVuZGx5IG5hbWUgb2YgdGhlIGZhY3RvciwgdXNlZnVsIGZvciBkaXN0aW5ndWlzaGluZyBiZXR3ZWVuIGZhY3RvcnMgKiovXG4gIGZyaWVuZGx5X25hbWU/OiBzdHJpbmdcbn1cblxudHlwZSBBdXRoTUZBRW5yb2xsVE9UUFJlc3BvbnNlRmllbGRzID0ge1xuICAvKiogVE9UUCBlbnJvbGxtZW50IGluZm9ybWF0aW9uLiAqL1xuICB0b3RwOiB7XG4gICAgLyoqIENvbnRhaW5zIGEgUVIgY29kZSBlbmNvZGluZyB0aGUgYXV0aGVudGljYXRvciBVUkkuIFlvdSBjYW5cbiAgICAgKiBjb252ZXJ0IGl0IHRvIGEgVVJMIGJ5IHByZXBlbmRpbmcgYGRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGYtOCxgIHRvXG4gICAgICogdGhlIHZhbHVlLiBBdm9pZCBsb2dnaW5nIHRoaXMgdmFsdWUgdG8gdGhlIGNvbnNvbGUuICovXG4gICAgcXJfY29kZTogc3RyaW5nXG5cbiAgICAvKiogVGhlIFRPVFAgc2VjcmV0IChhbHNvIGVuY29kZWQgaW4gdGhlIFFSIGNvZGUpLiBTaG93IHRoaXMgc2VjcmV0XG4gICAgICogaW4gYSBwYXNzd29yZC1zdHlsZSBmaWVsZCB0byB0aGUgdXNlciwgaW4gY2FzZSB0aGV5IGFyZSB1bmFibGUgdG9cbiAgICAgKiBzY2FuIHRoZSBRUiBjb2RlLiBBdm9pZCBsb2dnaW5nIHRoaXMgdmFsdWUgdG8gdGhlIGNvbnNvbGUuICovXG4gICAgc2VjcmV0OiBzdHJpbmdcblxuICAgIC8qKiBUaGUgYXV0aGVudGljYXRvciBVUkkgZW5jb2RlZCB3aXRoaW4gdGhlIFFSIGNvZGUsIHNob3VsZCB5b3UgbmVlZFxuICAgICAqIHRvIHVzZSBpdC4gQXZvaWQgbG9nZ2luIHRoaXMgdmFsdWUgdG8gdGhlIGNvbnNvbGUuICovXG4gICAgdXJpOiBzdHJpbmdcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBBdXRoTUZBRW5yb2xsVE9UUFJlc3BvbnNlID0gUmVxdWVzdFJlc3VsdDxcbiAgUHJldHRpZnk8QXV0aE1GQUVucm9sbFJlc3BvbnNlQmFzZTwndG90cCc+ICYgQXV0aE1GQUVucm9sbFRPVFBSZXNwb25zZUZpZWxkcz5cbj5cblxudHlwZSBBdXRoTUZBRW5yb2xsUGhvbmVSZXNwb25zZUZpZWxkcyA9IHtcbiAgLyoqIFBob25lIG51bWJlciBvZiB0aGUgTUZBIGZhY3RvciBpbiBFLjE2NCBmb3JtYXQuIFVzZWQgdG8gc2VuZCBtZXNzYWdlcyAgKi9cbiAgcGhvbmU6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBBdXRoTUZBRW5yb2xsUGhvbmVSZXNwb25zZSA9IFJlcXVlc3RSZXN1bHQ8XG4gIFByZXR0aWZ5PEF1dGhNRkFFbnJvbGxSZXNwb25zZUJhc2U8J3Bob25lJz4gJiBBdXRoTUZBRW5yb2xsUGhvbmVSZXNwb25zZUZpZWxkcz5cbj5cblxudHlwZSBBdXRoTUZBRW5yb2xsV2ViYXV0aG5GaWVsZHMgPSB7XG4gIC8qKiBubyBleHRyYSBmaWVsZHMgZm9yIG5vdywga2VwdCBmb3IgY29uc2lzdGVuY3kgYW5kIGZvciBwb3NzaWJsZSBmdXR1cmUgY2hhbmdlcyAgKi9cbn1cblxuLyoqXG4gKiBSZXNwb25zZSB0eXBlIGZvciBXZWJBdXRobiBmYWN0b3IgZW5yb2xsbWVudC5cbiAqIFJldHVybnMgdGhlIGVucm9sbGVkIGZhY3RvciBJRCBhbmQgbWV0YWRhdGEuXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tcmVnaXN0ZXJpbmctYS1uZXctY3JlZGVudGlhbCBXM0MgV2ViQXV0aG4gU3BlYyAtIFJlZ2lzdGVyaW5nIGEgTmV3IENyZWRlbnRpYWx9XG4gKi9cbmV4cG9ydCB0eXBlIEF1dGhNRkFFbnJvbGxXZWJhdXRoblJlc3BvbnNlID0gUmVxdWVzdFJlc3VsdDxcbiAgUHJldHRpZnk8QXV0aE1GQUVucm9sbFJlc3BvbnNlQmFzZTwnd2ViYXV0aG4nPiAmIEF1dGhNRkFFbnJvbGxXZWJhdXRobkZpZWxkcz5cbj5cblxuZXhwb3J0IHR5cGUgSnd0SGVhZGVyID0ge1xuICBhbGc6ICdSUzI1NicgfCAnRVMyNTYnIHwgJ0hTMjU2J1xuICBraWQ6IHN0cmluZ1xuICB0eXA6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBSZXF1aXJlZENsYWltcyA9IHtcbiAgaXNzOiBzdHJpbmdcbiAgc3ViOiBzdHJpbmdcbiAgYXVkOiBzdHJpbmcgfCBzdHJpbmdbXVxuICBleHA6IG51bWJlclxuICBpYXQ6IG51bWJlclxuICByb2xlOiBzdHJpbmdcbiAgYWFsOiBBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxzXG4gIHNlc3Npb25faWQ6IHN0cmluZ1xufVxuXG4vKipcbiAqIEpXVCBQYXlsb2FkIGNvbnRhaW5pbmcgY2xhaW1zIGZvciBTdXBhYmFzZSBhdXRoZW50aWNhdGlvbiB0b2tlbnMuXG4gKlxuICogUmVxdWlyZWQgY2xhaW1zIChpc3MsIGF1ZCwgZXhwLCBpYXQsIHN1Yiwgcm9sZSwgYWFsLCBzZXNzaW9uX2lkKSBhcmUgaW5oZXJpdGVkIGZyb20gUmVxdWlyZWRDbGFpbXMuXG4gKiBBbGwgb3RoZXIgY2xhaW1zIGFyZSBvcHRpb25hbCBhcyB0aGV5IGNhbiBiZSBjdXN0b21pemVkIHZpYSBDdXN0b20gQWNjZXNzIFRva2VuIEhvb2tzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9ndWlkZXMvYXV0aC9qd3QtZmllbGRzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSnd0UGF5bG9hZCBleHRlbmRzIFJlcXVpcmVkQ2xhaW1zIHtcbiAgLy8gU3RhbmRhcmQgb3B0aW9uYWwgY2xhaW1zIChjYW4gYmUgY3VzdG9taXplZCB2aWEgY3VzdG9tIGFjY2VzcyB0b2tlbiBob29rcylcbiAgZW1haWw/OiBzdHJpbmdcbiAgcGhvbmU/OiBzdHJpbmdcbiAgaXNfYW5vbnltb3VzPzogYm9vbGVhblxuXG4gIC8vIE9wdGlvbmFsIGNsYWltc1xuICBqdGk/OiBzdHJpbmdcbiAgbmJmPzogbnVtYmVyXG4gIGFwcF9tZXRhZGF0YT86IFVzZXJBcHBNZXRhZGF0YVxuICB1c2VyX21ldGFkYXRhPzogVXNlck1ldGFkYXRhXG4gIC8qKlxuICAgKiBBdXRoZW50aWNhdGlvbiBNZXRob2QgUmVmZXJlbmNlcy5cbiAgICogU3VwcG9ydHMgYm90aCBSRkMtODE3NiBjb21wbGlhbnQgZm9ybWF0IChzdHJpbmdbXSkgYW5kIGRldGFpbGVkIGZvcm1hdCAoQU1SRW50cnlbXSkuXG4gICAqIC0gU3RyaW5nIGZvcm1hdDogWydwYXNzd29yZCcsICdvdHAnXSAtIFJGQy04MTc2IGNvbXBsaWFudFxuICAgKiAtIE9iamVjdCBmb3JtYXQ6IFt7IG1ldGhvZDogJ3Bhc3N3b3JkJywgdGltZXN0YW1wOiAxMjM0NTY3ODkwIH1dIC0gaW5jbHVkZXMgdGltZXN0YW1wc1xuICAgKi9cbiAgYW1yPzogQU1SRW50cnlbXSB8IHN0cmluZ1tdXG5cbiAgLy8gU3BlY2lhbCBjbGFpbXMgKG9ubHkgaW4gYW5vbi9zZXJ2aWNlIHJvbGUgdG9rZW5zKVxuICByZWY/OiBzdHJpbmdcblxuICAvLyBBbGxvdyBjdXN0b20gY2xhaW1zIHZpYSBjdXN0b20gYWNjZXNzIHRva2VuIGhvb2tzXG4gIFtrZXk6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEpXSyB7XG4gIGt0eTogJ1JTQScgfCAnRUMnIHwgJ29jdCdcbiAga2V5X29wczogc3RyaW5nW11cbiAgYWxnPzogc3RyaW5nXG4gIGtpZD86IHN0cmluZ1xuICBba2V5OiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IGNvbnN0IFNJR05fT1VUX1NDT1BFUyA9IFsnZ2xvYmFsJywgJ2xvY2FsJywgJ290aGVycyddIGFzIGNvbnN0XG5leHBvcnQgdHlwZSBTaWduT3V0U2NvcGUgPSAodHlwZW9mIFNJR05fT1VUX1NDT1BFUylbbnVtYmVyXVxuXG4vKipcbiAqIE9BdXRoIGNsaWVudCBncmFudCB0eXBlcyBzdXBwb3J0ZWQgYnkgdGhlIE9BdXRoIDIuMSBzZXJ2ZXIuXG4gKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICovXG5leHBvcnQgdHlwZSBPQXV0aENsaWVudEdyYW50VHlwZSA9ICdhdXRob3JpemF0aW9uX2NvZGUnIHwgJ3JlZnJlc2hfdG9rZW4nXG5cbi8qKlxuICogT0F1dGggY2xpZW50IHJlc3BvbnNlIHR5cGVzIHN1cHBvcnRlZCBieSB0aGUgT0F1dGggMi4xIHNlcnZlci5cbiAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gKi9cbmV4cG9ydCB0eXBlIE9BdXRoQ2xpZW50UmVzcG9uc2VUeXBlID0gJ2NvZGUnXG5cbi8qKlxuICogT0F1dGggY2xpZW50IHR5cGUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjbGllbnQgY2FuIGtlZXAgY3JlZGVudGlhbHMgY29uZmlkZW50aWFsLlxuICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAqL1xuZXhwb3J0IHR5cGUgT0F1dGhDbGllbnRUeXBlID0gJ3B1YmxpYycgfCAnY29uZmlkZW50aWFsJ1xuXG4vKipcbiAqIE9BdXRoIGNsaWVudCByZWdpc3RyYXRpb24gdHlwZS5cbiAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gKi9cbmV4cG9ydCB0eXBlIE9BdXRoQ2xpZW50UmVnaXN0cmF0aW9uVHlwZSA9ICdkeW5hbWljJyB8ICdtYW51YWwnXG5cbi8qKlxuICogT0F1dGggY2xpZW50IG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSBPQXV0aCAyLjEgc2VydmVyLlxuICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAqL1xuZXhwb3J0IHR5cGUgT0F1dGhDbGllbnQgPSB7XG4gIC8qKiBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIE9BdXRoIGNsaWVudCAqL1xuICBjbGllbnRfaWQ6IHN0cmluZ1xuICAvKiogSHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgT0F1dGggY2xpZW50ICovXG4gIGNsaWVudF9uYW1lOiBzdHJpbmdcbiAgLyoqIENsaWVudCBzZWNyZXQgKG9ubHkgcmV0dXJuZWQgb24gcmVnaXN0cmF0aW9uIGFuZCByZWdlbmVyYXRpb24pICovXG4gIGNsaWVudF9zZWNyZXQ/OiBzdHJpbmdcbiAgLyoqIFR5cGUgb2YgT0F1dGggY2xpZW50ICovXG4gIGNsaWVudF90eXBlOiBPQXV0aENsaWVudFR5cGVcbiAgLyoqIFRva2VuIGVuZHBvaW50IGF1dGhlbnRpY2F0aW9uIG1ldGhvZCAqL1xuICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDogc3RyaW5nXG4gIC8qKiBSZWdpc3RyYXRpb24gdHlwZSBvZiB0aGUgY2xpZW50ICovXG4gIHJlZ2lzdHJhdGlvbl90eXBlOiBPQXV0aENsaWVudFJlZ2lzdHJhdGlvblR5cGVcbiAgLyoqIFVSSSBvZiB0aGUgT0F1dGggY2xpZW50ICovXG4gIGNsaWVudF91cmk/OiBzdHJpbmdcbiAgLyoqIFVSSSBvZiB0aGUgT0F1dGggY2xpZW50J3MgbG9nbyAqL1xuICBsb2dvX3VyaT86IHN0cmluZ1xuICAvKiogQXJyYXkgb2YgYWxsb3dlZCByZWRpcmVjdCBVUklzICovXG4gIHJlZGlyZWN0X3VyaXM6IHN0cmluZ1tdXG4gIC8qKiBBcnJheSBvZiBhbGxvd2VkIGdyYW50IHR5cGVzICovXG4gIGdyYW50X3R5cGVzOiBPQXV0aENsaWVudEdyYW50VHlwZVtdXG4gIC8qKiBBcnJheSBvZiBhbGxvd2VkIHJlc3BvbnNlIHR5cGVzICovXG4gIHJlc3BvbnNlX3R5cGVzOiBPQXV0aENsaWVudFJlc3BvbnNlVHlwZVtdXG4gIC8qKiBTY29wZSBvZiB0aGUgT0F1dGggY2xpZW50ICovXG4gIHNjb3BlPzogc3RyaW5nXG4gIC8qKiBUaW1lc3RhbXAgd2hlbiB0aGUgY2xpZW50IHdhcyBjcmVhdGVkICovXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xuICAvKiogVGltZXN0YW1wIHdoZW4gdGhlIGNsaWVudCB3YXMgbGFzdCB1cGRhdGVkICovXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xufVxuXG4vKipcbiAqIFBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIGEgbmV3IE9BdXRoIGNsaWVudC5cbiAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gKi9cbmV4cG9ydCB0eXBlIENyZWF0ZU9BdXRoQ2xpZW50UGFyYW1zID0ge1xuICAvKiogSHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgT0F1dGggY2xpZW50ICovXG4gIGNsaWVudF9uYW1lOiBzdHJpbmdcbiAgLyoqIFVSSSBvZiB0aGUgT0F1dGggY2xpZW50ICovXG4gIGNsaWVudF91cmk/OiBzdHJpbmdcbiAgLyoqIEFycmF5IG9mIGFsbG93ZWQgcmVkaXJlY3QgVVJJcyAqL1xuICByZWRpcmVjdF91cmlzOiBzdHJpbmdbXVxuICAvKiogQXJyYXkgb2YgYWxsb3dlZCBncmFudCB0eXBlcyAob3B0aW9uYWwsIGRlZmF1bHRzIHRvIGF1dGhvcml6YXRpb25fY29kZSBhbmQgcmVmcmVzaF90b2tlbikgKi9cbiAgZ3JhbnRfdHlwZXM/OiBPQXV0aENsaWVudEdyYW50VHlwZVtdXG4gIC8qKiBBcnJheSBvZiBhbGxvd2VkIHJlc3BvbnNlIHR5cGVzIChvcHRpb25hbCwgZGVmYXVsdHMgdG8gY29kZSkgKi9cbiAgcmVzcG9uc2VfdHlwZXM/OiBPQXV0aENsaWVudFJlc3BvbnNlVHlwZVtdXG4gIC8qKiBTY29wZSBvZiB0aGUgT0F1dGggY2xpZW50ICovXG4gIHNjb3BlPzogc3RyaW5nXG59XG5cbi8qKlxuICogUGFyYW1ldGVycyBmb3IgdXBkYXRpbmcgYW4gZXhpc3RpbmcgT0F1dGggY2xpZW50LlxuICogQWxsIGZpZWxkcyBhcmUgb3B0aW9uYWwuIE9ubHkgcHJvdmlkZWQgZmllbGRzIHdpbGwgYmUgdXBkYXRlZC5cbiAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gKi9cbmV4cG9ydCB0eXBlIFVwZGF0ZU9BdXRoQ2xpZW50UGFyYW1zID0ge1xuICAvKiogSHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgT0F1dGggY2xpZW50ICovXG4gIGNsaWVudF9uYW1lPzogc3RyaW5nXG4gIC8qKiBVUkkgb2YgdGhlIE9BdXRoIGNsaWVudCAqL1xuICBjbGllbnRfdXJpPzogc3RyaW5nXG4gIC8qKiBVUkkgb2YgdGhlIE9BdXRoIGNsaWVudCdzIGxvZ28gKi9cbiAgbG9nb191cmk/OiBzdHJpbmdcbiAgLyoqIEFycmF5IG9mIGFsbG93ZWQgcmVkaXJlY3QgVVJJcyAqL1xuICByZWRpcmVjdF91cmlzPzogc3RyaW5nW11cbiAgLyoqIEFycmF5IG9mIGFsbG93ZWQgZ3JhbnQgdHlwZXMgKi9cbiAgZ3JhbnRfdHlwZXM/OiBPQXV0aENsaWVudEdyYW50VHlwZVtdXG59XG5cbi8qKlxuICogUmVzcG9uc2UgdHlwZSBmb3IgT0F1dGggY2xpZW50IG9wZXJhdGlvbnMuXG4gKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICovXG5leHBvcnQgdHlwZSBPQXV0aENsaWVudFJlc3BvbnNlID0gUmVxdWVzdFJlc3VsdDxPQXV0aENsaWVudD5cblxuLyoqXG4gKiBSZXNwb25zZSB0eXBlIGZvciBsaXN0aW5nIE9BdXRoIGNsaWVudHMuXG4gKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICovXG5leHBvcnQgdHlwZSBPQXV0aENsaWVudExpc3RSZXNwb25zZSA9XG4gIHwge1xuICAgICAgZGF0YTogeyBjbGllbnRzOiBPQXV0aENsaWVudFtdOyBhdWQ6IHN0cmluZyB9ICYgUGFnaW5hdGlvblxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9XG4gIHwge1xuICAgICAgZGF0YTogeyBjbGllbnRzOiBbXSB9XG4gICAgICBlcnJvcjogQXV0aEVycm9yXG4gICAgfVxuXG4vKipcbiAqIENvbnRhaW5zIGFsbCBPQXV0aCBjbGllbnQgYWRtaW5pc3RyYXRpb24gbWV0aG9kcy5cbiAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR29UcnVlQWRtaW5PQXV0aEFwaSB7XG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgT0F1dGggY2xpZW50cyB3aXRoIG9wdGlvbmFsIHBhZ2luYXRpb24uXG4gICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBsaXN0Q2xpZW50cyhwYXJhbXM/OiBQYWdlUGFyYW1zKTogUHJvbWlzZTxPQXV0aENsaWVudExpc3RSZXNwb25zZT5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBPQXV0aCBjbGllbnQuXG4gICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBjcmVhdGVDbGllbnQocGFyYW1zOiBDcmVhdGVPQXV0aENsaWVudFBhcmFtcyk6IFByb21pc2U8T0F1dGhDbGllbnRSZXNwb25zZT5cblxuICAvKipcbiAgICogR2V0cyBkZXRhaWxzIG9mIGEgc3BlY2lmaWMgT0F1dGggY2xpZW50LlxuICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgZ2V0Q2xpZW50KGNsaWVudElkOiBzdHJpbmcpOiBQcm9taXNlPE9BdXRoQ2xpZW50UmVzcG9uc2U+XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgT0F1dGggY2xpZW50LlxuICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgdXBkYXRlQ2xpZW50KGNsaWVudElkOiBzdHJpbmcsIHBhcmFtczogVXBkYXRlT0F1dGhDbGllbnRQYXJhbXMpOiBQcm9taXNlPE9BdXRoQ2xpZW50UmVzcG9uc2U+XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gT0F1dGggY2xpZW50LlxuICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgZGVsZXRlQ2xpZW50KGNsaWVudElkOiBzdHJpbmcpOiBQcm9taXNlPHsgZGF0YTogbnVsbDsgZXJyb3I6IEF1dGhFcnJvciB8IG51bGwgfT5cblxuICAvKipcbiAgICogUmVnZW5lcmF0ZXMgdGhlIHNlY3JldCBmb3IgYW4gT0F1dGggY2xpZW50LlxuICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgcmVnZW5lcmF0ZUNsaWVudFNlY3JldChjbGllbnRJZDogc3RyaW5nKTogUHJvbWlzZTxPQXV0aENsaWVudFJlc3BvbnNlPlxufVxuXG4vKipcbiAqIE9BdXRoIGNsaWVudCBkZXRhaWxzIGluIGFuIGF1dGhvcml6YXRpb24gcmVxdWVzdC5cbiAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gKi9cbmV4cG9ydCB0eXBlIE9BdXRoQXV0aG9yaXphdGlvbkNsaWVudCA9IHtcbiAgLyoqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgT0F1dGggY2xpZW50IChVVUlEKSAqL1xuICBpZDogc3RyaW5nXG4gIC8qKiBIdW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBPQXV0aCBjbGllbnQgKi9cbiAgbmFtZTogc3RyaW5nXG4gIC8qKiBVUkkgb2YgdGhlIE9BdXRoIGNsaWVudCdzIHdlYnNpdGUgKi9cbiAgdXJpOiBzdHJpbmdcbiAgLyoqIFVSSSBvZiB0aGUgT0F1dGggY2xpZW50J3MgbG9nbyAqL1xuICBsb2dvX3VyaTogc3RyaW5nXG59XG5cbi8qKlxuICogT0F1dGggYXV0aG9yaXphdGlvbiBkZXRhaWxzIGZvciB0aGUgY29uc2VudCBmbG93LlxuICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAqL1xuZXhwb3J0IHR5cGUgT0F1dGhBdXRob3JpemF0aW9uRGV0YWlscyA9IHtcbiAgLyoqIFRoZSBhdXRob3JpemF0aW9uIElEICovXG4gIGF1dGhvcml6YXRpb25faWQ6IHN0cmluZ1xuICAvKiogUmVkaXJlY3QgVVJMIC0gcHJlc2VudCBpZiB1c2VyIGFscmVhZHkgY29uc2VudGVkIChjYW4gYmUgdXNlZCB0byB0cmlnZ2VyIGltbWVkaWF0ZSByZWRpcmVjdCkgKi9cbiAgcmVkaXJlY3RfdXJsPzogc3RyaW5nXG4gIC8qKiBPQXV0aCBjbGllbnQgcmVxdWVzdGluZyBhdXRob3JpemF0aW9uICovXG4gIGNsaWVudDogT0F1dGhBdXRob3JpemF0aW9uQ2xpZW50XG4gIC8qKiBVc2VyIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIGF1dGhvcml6YXRpb24gKi9cbiAgdXNlcjoge1xuICAgIC8qKiBVc2VyIElEIChVVUlEKSAqL1xuICAgIGlkOiBzdHJpbmdcbiAgICAvKiogVXNlciBlbWFpbCAqL1xuICAgIGVtYWlsOiBzdHJpbmdcbiAgfVxuICAvKiogU3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgcmVxdWVzdGVkIHNjb3BlcyAqL1xuICBzY29wZTogc3RyaW5nXG59XG5cbi8qKlxuICogUmVzcG9uc2UgdHlwZSBmb3IgZ2V0dGluZyBPQXV0aCBhdXRob3JpemF0aW9uIGRldGFpbHMuXG4gKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICovXG5leHBvcnQgdHlwZSBBdXRoT0F1dGhBdXRob3JpemF0aW9uRGV0YWlsc1Jlc3BvbnNlID0gUmVxdWVzdFJlc3VsdDxPQXV0aEF1dGhvcml6YXRpb25EZXRhaWxzPlxuXG4vKipcbiAqIFJlc3BvbnNlIHR5cGUgZm9yIE9BdXRoIGNvbnNlbnQgZGVjaXNpb24gKGFwcHJvdmUvZGVueSkuXG4gKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICovXG5leHBvcnQgdHlwZSBBdXRoT0F1dGhDb25zZW50UmVzcG9uc2UgPSBSZXF1ZXN0UmVzdWx0PHtcbiAgLyoqIFVSTCB0byByZWRpcmVjdCB0aGUgdXNlciBiYWNrIHRvIHRoZSBPQXV0aCBjbGllbnQgKi9cbiAgcmVkaXJlY3RfdXJsOiBzdHJpbmdcbn0+XG5cbi8qKlxuICogQW4gT0F1dGggZ3JhbnQgcmVwcmVzZW50aW5nIGEgdXNlcidzIGF1dGhvcml6YXRpb24gb2YgYW4gT0F1dGggY2xpZW50LlxuICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAqL1xuZXhwb3J0IHR5cGUgT0F1dGhHcmFudCA9IHtcbiAgLyoqIE9BdXRoIGNsaWVudCBpbmZvcm1hdGlvbiAqL1xuICBjbGllbnQ6IE9BdXRoQXV0aG9yaXphdGlvbkNsaWVudFxuICAvKiogQXJyYXkgb2Ygc2NvcGVzIGdyYW50ZWQgdG8gdGhpcyBjbGllbnQgKi9cbiAgc2NvcGVzOiBzdHJpbmdbXVxuICAvKiogVGltZXN0YW1wIHdoZW4gdGhlIGdyYW50IHdhcyBjcmVhdGVkIChJU08gODYwMSBkYXRlLXRpbWUpICovXG4gIGdyYW50ZWRfYXQ6IHN0cmluZ1xufVxuXG4vKipcbiAqIFJlc3BvbnNlIHR5cGUgZm9yIGxpc3RpbmcgdXNlcidzIE9BdXRoIGdyYW50cy5cbiAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gKi9cbmV4cG9ydCB0eXBlIEF1dGhPQXV0aEdyYW50c1Jlc3BvbnNlID0gUmVxdWVzdFJlc3VsdDxPQXV0aEdyYW50W10+XG5cbi8qKlxuICogUmVzcG9uc2UgdHlwZSBmb3IgcmV2b2tpbmcgYW4gT0F1dGggZ3JhbnQuXG4gKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICovXG5leHBvcnQgdHlwZSBBdXRoT0F1dGhSZXZva2VHcmFudFJlc3BvbnNlID0gUmVxdWVzdFJlc3VsdDx7fT5cblxuLyoqXG4gKiBDb250YWlucyBhbGwgT0F1dGggMi4xIGF1dGhvcml6YXRpb24gc2VydmVyIHVzZXItZmFjaW5nIG1ldGhvZHMuXG4gKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICpcbiAqIFRoZXNlIG1ldGhvZHMgYXJlIHVzZWQgdG8gaW1wbGVtZW50IHRoZSBjb25zZW50IHBhZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aE9BdXRoU2VydmVyQXBpIHtcbiAgLyoqXG4gICAqIFJldHJpZXZlcyBkZXRhaWxzIGFib3V0IGFuIE9BdXRoIGF1dGhvcml6YXRpb24gcmVxdWVzdC5cbiAgICogVXNlZCB0byBkaXNwbGF5IGNvbnNlbnQgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIuXG4gICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYXV0aG9yaXphdGlvbiBkZXRhaWxzIGluY2x1ZGluZyBjbGllbnQgaW5mbywgc2NvcGVzLCBhbmQgdXNlciBpbmZvcm1hdGlvbi5cbiAgICogSWYgdGhlIHJlc3BvbnNlIGluY2x1ZGVzIGEgcmVkaXJlY3RfdXJpLCBpdCBtZWFucyBjb25zZW50IHdhcyBhbHJlYWR5IGdpdmVuIC0gdGhlIGNhbGxlclxuICAgKiBzaG91bGQgaGFuZGxlIHRoZSByZWRpcmVjdCBtYW51YWxseSBpZiBuZWVkZWQuXG4gICAqXG4gICAqIEBwYXJhbSBhdXRob3JpemF0aW9uSWQgLSBUaGUgYXV0aG9yaXphdGlvbiBJRCBmcm9tIHRoZSBhdXRob3JpemF0aW9uIHJlcXVlc3RcbiAgICogQHJldHVybnMgQXV0aG9yaXphdGlvbiBkZXRhaWxzIGluY2x1ZGluZyBjbGllbnQgaW5mbyBhbmQgcmVxdWVzdGVkIHNjb3Blc1xuICAgKi9cbiAgZ2V0QXV0aG9yaXphdGlvbkRldGFpbHMoYXV0aG9yaXphdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPEF1dGhPQXV0aEF1dGhvcml6YXRpb25EZXRhaWxzUmVzcG9uc2U+XG5cbiAgLyoqXG4gICAqIEFwcHJvdmVzIGFuIE9BdXRoIGF1dGhvcml6YXRpb24gcmVxdWVzdC5cbiAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICpcbiAgICogQHBhcmFtIGF1dGhvcml6YXRpb25JZCAtIFRoZSBhdXRob3JpemF0aW9uIElEIHRvIGFwcHJvdmVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIGluY2x1ZGluZyBza2lwQnJvd3NlclJlZGlyZWN0XG4gICAqIEByZXR1cm5zIFJlZGlyZWN0IFVSTCB0byBzZW5kIHRoZSB1c2VyIGJhY2sgdG8gdGhlIE9BdXRoIGNsaWVudFxuICAgKi9cbiAgYXBwcm92ZUF1dGhvcml6YXRpb24oXG4gICAgYXV0aG9yaXphdGlvbklkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgc2tpcEJyb3dzZXJSZWRpcmVjdD86IGJvb2xlYW4gfVxuICApOiBQcm9taXNlPEF1dGhPQXV0aENvbnNlbnRSZXNwb25zZT5cblxuICAvKipcbiAgICogRGVuaWVzIGFuIE9BdXRoIGF1dGhvcml6YXRpb24gcmVxdWVzdC5cbiAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICpcbiAgICogQHBhcmFtIGF1dGhvcml6YXRpb25JZCAtIFRoZSBhdXRob3JpemF0aW9uIElEIHRvIGRlbnlcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIGluY2x1ZGluZyBza2lwQnJvd3NlclJlZGlyZWN0XG4gICAqIEByZXR1cm5zIFJlZGlyZWN0IFVSTCB0byBzZW5kIHRoZSB1c2VyIGJhY2sgdG8gdGhlIE9BdXRoIGNsaWVudFxuICAgKi9cbiAgZGVueUF1dGhvcml6YXRpb24oXG4gICAgYXV0aG9yaXphdGlvbklkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgc2tpcEJyb3dzZXJSZWRpcmVjdD86IGJvb2xlYW4gfVxuICApOiBQcm9taXNlPEF1dGhPQXV0aENvbnNlbnRSZXNwb25zZT5cblxuICAvKipcbiAgICogTGlzdHMgYWxsIE9BdXRoIGdyYW50cyB0aGF0IHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgaGFzIGF1dGhvcml6ZWQuXG4gICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAqXG4gICAqIEByZXR1cm5zIFJlc3BvbnNlIHdpdGggYXJyYXkgb2YgT0F1dGggZ3JhbnRzIHdpdGggY2xpZW50IGluZm9ybWF0aW9uIGFuZCBncmFudGVkIHNjb3Blc1xuICAgKi9cbiAgbGlzdEdyYW50cygpOiBQcm9taXNlPEF1dGhPQXV0aEdyYW50c1Jlc3BvbnNlPlxuXG4gIC8qKlxuICAgKiBSZXZva2VzIGEgdXNlcidzIE9BdXRoIGdyYW50IGZvciBhIHNwZWNpZmljIGNsaWVudC5cbiAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICpcbiAgICogUmV2b2NhdGlvbiBtYXJrcyBjb25zZW50IGFzIHJldm9rZWQsIGRlbGV0ZXMgYWN0aXZlIHNlc3Npb25zIGZvciB0aGF0IE9BdXRoIGNsaWVudCxcbiAgICogYW5kIGludmFsaWRhdGVzIGFzc29jaWF0ZWQgcmVmcmVzaCB0b2tlbnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmV2b2NhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLmNsaWVudElkIC0gVGhlIE9BdXRoIGNsaWVudCBpZGVudGlmaWVyIChVVUlEKSB0byByZXZva2UgYWNjZXNzIGZvclxuICAgKiBAcmV0dXJucyBFbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzZnVsIHJldm9jYXRpb25cbiAgICovXG4gIHJldm9rZUdyYW50KG9wdGlvbnM6IHsgY2xpZW50SWQ6IHN0cmluZyB9KTogUHJvbWlzZTxBdXRoT0F1dGhSZXZva2VHcmFudFJlc3BvbnNlPlxufVxuIiwgImltcG9ydCB7XG4gIEZldGNoLFxuICBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gIF9ub1Jlc29sdmVKc29uUmVzcG9uc2UsXG4gIF9yZXF1ZXN0LFxuICBfdXNlclJlc3BvbnNlLFxufSBmcm9tICcuL2xpYi9mZXRjaCdcbmltcG9ydCB7IHJlc29sdmVGZXRjaCwgdmFsaWRhdGVVVUlEIH0gZnJvbSAnLi9saWIvaGVscGVycydcbmltcG9ydCB7XG4gIEFkbWluVXNlckF0dHJpYnV0ZXMsXG4gIEdlbmVyYXRlTGlua1BhcmFtcyxcbiAgR2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gIFBhZ2luYXRpb24sXG4gIFVzZXIsXG4gIFVzZXJSZXNwb25zZSxcbiAgR29UcnVlQWRtaW5NRkFBcGksXG4gIEF1dGhNRkFBZG1pbkRlbGV0ZUZhY3RvclBhcmFtcyxcbiAgQXV0aE1GQUFkbWluRGVsZXRlRmFjdG9yUmVzcG9uc2UsXG4gIEF1dGhNRkFBZG1pbkxpc3RGYWN0b3JzUGFyYW1zLFxuICBBdXRoTUZBQWRtaW5MaXN0RmFjdG9yc1Jlc3BvbnNlLFxuICBQYWdlUGFyYW1zLFxuICBTSUdOX09VVF9TQ09QRVMsXG4gIFNpZ25PdXRTY29wZSxcbiAgR29UcnVlQWRtaW5PQXV0aEFwaSxcbiAgQ3JlYXRlT0F1dGhDbGllbnRQYXJhbXMsXG4gIFVwZGF0ZU9BdXRoQ2xpZW50UGFyYW1zLFxuICBPQXV0aENsaWVudFJlc3BvbnNlLFxuICBPQXV0aENsaWVudExpc3RSZXNwb25zZSxcbn0gZnJvbSAnLi9saWIvdHlwZXMnXG5pbXBvcnQgeyBBdXRoRXJyb3IsIGlzQXV0aEVycm9yIH0gZnJvbSAnLi9saWIvZXJyb3JzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb1RydWVBZG1pbkFwaSB7XG4gIC8qKiBDb250YWlucyBhbGwgTUZBIGFkbWluaXN0cmF0aW9uIG1ldGhvZHMuICovXG4gIG1mYTogR29UcnVlQWRtaW5NRkFBcGlcblxuICAvKipcbiAgICogQ29udGFpbnMgYWxsIE9BdXRoIGNsaWVudCBhZG1pbmlzdHJhdGlvbiBtZXRob2RzLlxuICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgKi9cbiAgb2F1dGg6IEdvVHJ1ZUFkbWluT0F1dGhBcGlcblxuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYWRtaW4gQVBJIGNsaWVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIG1hbmFnZSB1c2VycyBhbmQgT0F1dGggY2xpZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgR29UcnVlQWRtaW5BcGkgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAgICpcbiAgICogY29uc3QgYWRtaW4gPSBuZXcgR29UcnVlQWRtaW5BcGkoe1xuICAgKiAgIHVybDogJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9hdXRoL3YxJyxcbiAgICogICBoZWFkZXJzOiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZfWAgfSxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXJsID0gJycsXG4gICAgaGVhZGVycyA9IHt9LFxuICAgIGZldGNoLFxuICB9OiB7XG4gICAgdXJsOiBzdHJpbmdcbiAgICBoZWFkZXJzPzoge1xuICAgICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gICAgfVxuICAgIGZldGNoPzogRmV0Y2hcbiAgfSkge1xuICAgIHRoaXMudXJsID0gdXJsXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gpXG4gICAgdGhpcy5tZmEgPSB7XG4gICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgIGRlbGV0ZUZhY3RvcjogdGhpcy5fZGVsZXRlRmFjdG9yLmJpbmQodGhpcyksXG4gICAgfVxuICAgIHRoaXMub2F1dGggPSB7XG4gICAgICBsaXN0Q2xpZW50czogdGhpcy5fbGlzdE9BdXRoQ2xpZW50cy5iaW5kKHRoaXMpLFxuICAgICAgY3JlYXRlQ2xpZW50OiB0aGlzLl9jcmVhdGVPQXV0aENsaWVudC5iaW5kKHRoaXMpLFxuICAgICAgZ2V0Q2xpZW50OiB0aGlzLl9nZXRPQXV0aENsaWVudC5iaW5kKHRoaXMpLFxuICAgICAgdXBkYXRlQ2xpZW50OiB0aGlzLl91cGRhdGVPQXV0aENsaWVudC5iaW5kKHRoaXMpLFxuICAgICAgZGVsZXRlQ2xpZW50OiB0aGlzLl9kZWxldGVPQXV0aENsaWVudC5iaW5kKHRoaXMpLFxuICAgICAgcmVnZW5lcmF0ZUNsaWVudFNlY3JldDogdGhpcy5fcmVnZW5lcmF0ZU9BdXRoQ2xpZW50U2VjcmV0LmJpbmQodGhpcyksXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBsb2dnZWQtaW4gc2Vzc2lvbi5cbiAgICogQHBhcmFtIGp3dCBBIHZhbGlkLCBsb2dnZWQtaW4gSldULlxuICAgKiBAcGFyYW0gc2NvcGUgVGhlIGxvZ291dCBzb3BlLlxuICAgKi9cbiAgYXN5bmMgc2lnbk91dChcbiAgICBqd3Q6IHN0cmluZyxcbiAgICBzY29wZTogU2lnbk91dFNjb3BlID0gU0lHTl9PVVRfU0NPUEVTWzBdXG4gICk6IFByb21pc2U8eyBkYXRhOiBudWxsOyBlcnJvcjogQXV0aEVycm9yIHwgbnVsbCB9PiB7XG4gICAgaWYgKFNJR05fT1VUX1NDT1BFUy5pbmRleE9mKHNjb3BlKSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEBzdXBhYmFzZS9hdXRoLWpzOiBQYXJhbWV0ZXIgc2NvcGUgbXVzdCBiZSBvbmUgb2YgJHtTSUdOX09VVF9TQ09QRVMuam9pbignLCAnKX1gXG4gICAgICApXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2xvZ291dD9zY29wZT0ke3Njb3BlfWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBqd3QsXG4gICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYW4gaW52aXRlIGxpbmsgdG8gYW4gZW1haWwgYWRkcmVzcy5cbiAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gYmUgaW5jbHVkZWQgd2hlbiBpbnZpdGluZy5cbiAgICovXG4gIGFzeW5jIGludml0ZVVzZXJCeUVtYWlsKFxuICAgIGVtYWlsOiBzdHJpbmcsXG4gICAgb3B0aW9uczoge1xuICAgICAgLyoqIEEgY3VzdG9tIGRhdGEgb2JqZWN0IHRvIHN0b3JlIGFkZGl0aW9uYWwgbWV0YWRhdGEgYWJvdXQgdGhlIHVzZXIuIFRoaXMgbWFwcyB0byB0aGUgYGF1dGgudXNlcnMudXNlcl9tZXRhZGF0YWAgY29sdW1uLiAqL1xuICAgICAgZGF0YT86IG9iamVjdFxuXG4gICAgICAvKiogVGhlIFVSTCB3aGljaCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBlbWFpbCBsaW5rIHNlbnQgdG8gdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLiBPbmNlIGNsaWNrZWQgdGhlIHVzZXIgd2lsbCBlbmQgdXAgb24gdGhpcyBVUkwuICovXG4gICAgICByZWRpcmVjdFRvPzogc3RyaW5nXG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9pbnZpdGVgLCB7XG4gICAgICAgIGJvZHk6IHsgZW1haWwsIGRhdGE6IG9wdGlvbnMuZGF0YSB9LFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBlbWFpbCBsaW5rcyBhbmQgT1RQcyB0byBiZSBzZW50IHZpYSBhIGN1c3RvbSBlbWFpbCBwcm92aWRlci5cbiAgICogQHBhcmFtIGVtYWlsIFRoZSB1c2VyJ3MgZW1haWwuXG4gICAqIEBwYXJhbSBvcHRpb25zLnBhc3N3b3JkIFVzZXIgcGFzc3dvcmQuIEZvciBzaWdudXAgb25seS5cbiAgICogQHBhcmFtIG9wdGlvbnMuZGF0YSBPcHRpb25hbCB1c2VyIG1ldGFkYXRhLiBGb3Igc2lnbnVwIG9ubHkuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIHJlZGlyZWN0IHVybCB3aGljaCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGdlbmVyYXRlZCBsaW5rXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZUxpbmsocGFyYW1zOiBHZW5lcmF0ZUxpbmtQYXJhbXMpOiBQcm9taXNlPEdlbmVyYXRlTGlua1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgb3B0aW9ucywgLi4ucmVzdCB9ID0gcGFyYW1zXG4gICAgICBjb25zdCBib2R5OiBhbnkgPSB7IC4uLnJlc3QsIC4uLm9wdGlvbnMgfVxuICAgICAgaWYgKCduZXdFbWFpbCcgaW4gcmVzdCkge1xuICAgICAgICAvLyByZXBsYWNlIG5ld0VtYWlsIHdpdGggbmV3X2VtYWlsIGluIHJlcXVlc3QgYm9keVxuICAgICAgICBib2R5Lm5ld19lbWFpbCA9IHJlc3Q/Lm5ld0VtYWlsXG4gICAgICAgIGRlbGV0ZSBib2R5WyduZXdFbWFpbCddXG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vZ2VuZXJhdGVfbGlua2AsIHtcbiAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB4Zm9ybTogX2dlbmVyYXRlTGlua1Jlc3BvbnNlLFxuICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zPy5yZWRpcmVjdFRvLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLy8gVXNlciBBZG1pbiBBUElcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdXNlci5cbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVVzZXIoYXR0cmlidXRlczogQWRtaW5Vc2VyQXR0cmlidXRlcyk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vyc2AsIHtcbiAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiB1c2Vycy5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICogQHBhcmFtIHBhcmFtcyBBbiBvYmplY3Qgd2hpY2ggc3VwcG9ydHMgYHBhZ2VgIGFuZCBgcGVyUGFnZWAgYXMgbnVtYmVycywgdG8gYWx0ZXIgdGhlIHBhZ2luYXRlZCByZXN1bHRzLlxuICAgKi9cbiAgYXN5bmMgbGlzdFVzZXJzKFxuICAgIHBhcmFtcz86IFBhZ2VQYXJhbXNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHsgZGF0YTogeyB1c2VyczogVXNlcltdOyBhdWQ6IHN0cmluZyB9ICYgUGFnaW5hdGlvbjsgZXJyb3I6IG51bGwgfVxuICAgIHwgeyBkYXRhOiB7IHVzZXJzOiBbXSB9OyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb246IFBhZ2luYXRpb24gPSB7IG5leHRQYWdlOiBudWxsLCBsYXN0UGFnZTogMCwgdG90YWw6IDAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzYCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgcGFnZTogcGFyYW1zPy5wYWdlPy50b1N0cmluZygpID8/ICcnLFxuICAgICAgICAgIHBlcl9wYWdlOiBwYXJhbXM/LnBlclBhZ2U/LnRvU3RyaW5nKCkgPz8gJycsXG4gICAgICAgIH0sXG4gICAgICAgIHhmb3JtOiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlLFxuICAgICAgfSlcbiAgICAgIGlmIChyZXNwb25zZS5lcnJvcikgdGhyb3cgcmVzcG9uc2UuZXJyb3JcblxuICAgICAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIGNvbnN0IHRvdGFsID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtdG90YWwtY291bnQnKSA/PyAwXG4gICAgICBjb25zdCBsaW5rcyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdsaW5rJyk/LnNwbGl0KCcsJykgPz8gW11cbiAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxpbmtzLmZvckVhY2goKGxpbms6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhZ2UgPSBwYXJzZUludChsaW5rLnNwbGl0KCc7JylbMF0uc3BsaXQoJz0nKVsxXS5zdWJzdHJpbmcoMCwgMSkpXG4gICAgICAgICAgY29uc3QgcmVsID0gSlNPTi5wYXJzZShsaW5rLnNwbGl0KCc7JylbMV0uc3BsaXQoJz0nKVsxXSlcbiAgICAgICAgICBwYWdpbmF0aW9uW2Ake3JlbH1QYWdlYF0gPSBwYWdlXG4gICAgICAgIH0pXG5cbiAgICAgICAgcGFnaW5hdGlvbi50b3RhbCA9IHBhcnNlSW50KHRvdGFsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YTogeyAuLi51c2VycywgLi4ucGFnaW5hdGlvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyczogW10gfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXIgYnkgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB1aWQgVGhlIHVzZXIncyB1bmlxdWUgaWRlbnRpZmllclxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlckJ5SWQodWlkOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHZhbGlkYXRlVVVJRCh1aWQpXG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHt1aWR9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB1c2VyIGRhdGEuIENoYW5nZXMgYXJlIGFwcGxpZWQgZGlyZWN0bHkgd2l0aG91dCBjb25maXJtYXRpb24gZmxvd3MuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBkYXRhIHlvdSB3YW50IHRvIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVVzZXJCeUlkKHVpZDogc3RyaW5nLCBhdHRyaWJ1dGVzOiBBZG1pblVzZXJBdHRyaWJ1dGVzKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB2YWxpZGF0ZVVVSUQodWlkKVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgdXNlci4gUmVxdWlyZXMgYSBgc2VydmljZV9yb2xlYCBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBpZCBUaGUgdXNlciBpZCB5b3Ugd2FudCB0byByZW1vdmUuXG4gICAqIEBwYXJhbSBzaG91bGRTb2Z0RGVsZXRlIElmIHRydWUsIHRoZW4gdGhlIHVzZXIgd2lsbCBiZSBzb2Z0LWRlbGV0ZWQgZnJvbSB0aGUgYXV0aCBzY2hlbWEuIFNvZnQgZGVsZXRpb24gYWxsb3dzIHVzZXIgaWRlbnRpZmljYXRpb24gZnJvbSB0aGUgaGFzaGVkIHVzZXIgSUQgYnV0IGlzIG5vdCByZXZlcnNpYmxlLlxuICAgKiBEZWZhdWx0cyB0byBmYWxzZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZVVzZXIoaWQ6IHN0cmluZywgc2hvdWxkU29mdERlbGV0ZSA9IGZhbHNlKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB2YWxpZGF0ZVVVSUQoaWQpXG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtpZH1gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIHNob3VsZF9zb2Z0X2RlbGV0ZTogc2hvdWxkU29mdERlbGV0ZSxcbiAgICAgICAgfSxcbiAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfbGlzdEZhY3RvcnMoXG4gICAgcGFyYW1zOiBBdXRoTUZBQWRtaW5MaXN0RmFjdG9yc1BhcmFtc1xuICApOiBQcm9taXNlPEF1dGhNRkFBZG1pbkxpc3RGYWN0b3JzUmVzcG9uc2U+IHtcbiAgICB2YWxpZGF0ZVVVSUQocGFyYW1zLnVzZXJJZClcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgJ0dFVCcsXG4gICAgICAgIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnNgLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIHhmb3JtOiAoZmFjdG9yczogYW55KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGZhY3RvcnMgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZGVsZXRlRmFjdG9yKFxuICAgIHBhcmFtczogQXV0aE1GQUFkbWluRGVsZXRlRmFjdG9yUGFyYW1zXG4gICk6IFByb21pc2U8QXV0aE1GQUFkbWluRGVsZXRlRmFjdG9yUmVzcG9uc2U+IHtcbiAgICB2YWxpZGF0ZVVVSUQocGFyYW1zLnVzZXJJZClcbiAgICB2YWxpZGF0ZVVVSUQocGFyYW1zLmlkKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgJ0RFTEVURScsXG4gICAgICAgIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnMvJHtwYXJhbXMuaWR9YCxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgfVxuICAgICAgKVxuXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgT0F1dGggY2xpZW50cyB3aXRoIG9wdGlvbmFsIHBhZ2luYXRpb24uXG4gICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9saXN0T0F1dGhDbGllbnRzKHBhcmFtcz86IFBhZ2VQYXJhbXMpOiBQcm9taXNlPE9BdXRoQ2xpZW50TGlzdFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb246IFBhZ2luYXRpb24gPSB7IG5leHRQYWdlOiBudWxsLCBsYXN0UGFnZTogMCwgdG90YWw6IDAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHNgLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICBwYWdlOiBwYXJhbXM/LnBhZ2U/LnRvU3RyaW5nKCkgPz8gJycsXG4gICAgICAgICAgcGVyX3BhZ2U6IHBhcmFtcz8ucGVyUGFnZT8udG9TdHJpbmcoKSA/PyAnJyxcbiAgICAgICAgfSxcbiAgICAgICAgeGZvcm06IF9ub1Jlc29sdmVKc29uUmVzcG9uc2UsXG4gICAgICB9KVxuICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB0aHJvdyByZXNwb25zZS5lcnJvclxuXG4gICAgICBjb25zdCBjbGllbnRzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICBjb25zdCB0b3RhbCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXRvdGFsLWNvdW50JykgPz8gMFxuICAgICAgY29uc3QgbGlua3MgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnbGluaycpPy5zcGxpdCgnLCcpID8/IFtdXG4gICAgICBpZiAobGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICBsaW5rcy5mb3JFYWNoKChsaW5rOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBwYWdlID0gcGFyc2VJbnQobGluay5zcGxpdCgnOycpWzBdLnNwbGl0KCc9JylbMV0uc3Vic3RyaW5nKDAsIDEpKVxuICAgICAgICAgIGNvbnN0IHJlbCA9IEpTT04ucGFyc2UobGluay5zcGxpdCgnOycpWzFdLnNwbGl0KCc9JylbMV0pXG4gICAgICAgICAgcGFnaW5hdGlvbltgJHtyZWx9UGFnZWBdID0gcGFnZVxuICAgICAgICB9KVxuXG4gICAgICAgIHBhZ2luYXRpb24udG90YWwgPSBwYXJzZUludCh0b3RhbClcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgLi4uY2xpZW50cywgLi4ucGFnaW5hdGlvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjbGllbnRzOiBbXSB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE9BdXRoIGNsaWVudC5cbiAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2NyZWF0ZU9BdXRoQ2xpZW50KHBhcmFtczogQ3JlYXRlT0F1dGhDbGllbnRQYXJhbXMpOiBQcm9taXNlPE9BdXRoQ2xpZW50UmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHNgLCB7XG4gICAgICAgIGJvZHk6IHBhcmFtcyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB4Zm9ybTogKGNsaWVudDogYW55KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogY2xpZW50LCBlcnJvcjogbnVsbCB9XG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBkZXRhaWxzIG9mIGEgc3BlY2lmaWMgT0F1dGggY2xpZW50LlxuICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0T0F1dGhDbGllbnQoY2xpZW50SWQ6IHN0cmluZyk6IFByb21pc2U8T0F1dGhDbGllbnRSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzLyR7Y2xpZW50SWR9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiAoY2xpZW50OiBhbnkpID0+IHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBjbGllbnQsIGVycm9yOiBudWxsIH1cbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIE9BdXRoIGNsaWVudC5cbiAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3VwZGF0ZU9BdXRoQ2xpZW50KFxuICAgIGNsaWVudElkOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBVcGRhdGVPQXV0aENsaWVudFBhcmFtc1xuICApOiBQcm9taXNlPE9BdXRoQ2xpZW50UmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50cy8ke2NsaWVudElkfWAsIHtcbiAgICAgICAgYm9keTogcGFyYW1zLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiAoY2xpZW50OiBhbnkpID0+IHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBjbGllbnQsIGVycm9yOiBudWxsIH1cbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIE9BdXRoIGNsaWVudC5cbiAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2RlbGV0ZU9BdXRoQ2xpZW50KFxuICAgIGNsaWVudElkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfCBudWxsIH0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzLyR7Y2xpZW50SWR9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnZW5lcmF0ZXMgdGhlIHNlY3JldCBmb3IgYW4gT0F1dGggY2xpZW50LlxuICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfcmVnZW5lcmF0ZU9BdXRoQ2xpZW50U2VjcmV0KGNsaWVudElkOiBzdHJpbmcpOiBQcm9taXNlPE9BdXRoQ2xpZW50UmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICAnUE9TVCcsXG4gICAgICAgIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzLyR7Y2xpZW50SWR9L3JlZ2VuZXJhdGVfc2VjcmV0YCxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICB4Zm9ybTogKGNsaWVudDogYW55KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBjbGllbnQsIGVycm9yOiBudWxsIH1cbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IFN1cHBvcnRlZFN0b3JhZ2UgfSBmcm9tICcuL3R5cGVzJ1xuXG4vKipcbiAqIFJldHVybnMgYSBsb2NhbFN0b3JhZ2UtbGlrZSBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIGtleS12YWx1ZSBwYWlycyBpblxuICogbWVtb3J5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlcihzdG9yZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9KTogU3VwcG9ydGVkU3RvcmFnZSB7XG4gIHJldHVybiB7XG4gICAgZ2V0SXRlbTogKGtleSkgPT4ge1xuICAgICAgcmV0dXJuIHN0b3JlW2tleV0gfHwgbnVsbFxuICAgIH0sXG5cbiAgICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgc3RvcmVba2V5XSA9IHZhbHVlXG4gICAgfSxcblxuICAgIHJlbW92ZUl0ZW06IChrZXkpID0+IHtcbiAgICAgIGRlbGV0ZSBzdG9yZVtrZXldXG4gICAgfSxcbiAgfVxufVxuIiwgImltcG9ydCB7IHN1cHBvcnRzTG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9oZWxwZXJzJ1xuXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNvbnN0IGludGVybmFscyA9IHtcbiAgLyoqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIGRlYnVnOiAhIShcbiAgICBnbG9iYWxUaGlzICYmXG4gICAgc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSAmJlxuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICYmXG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc3VwYWJhc2UuZ290cnVlLWpzLmxvY2tzLmRlYnVnJykgPT09ICd0cnVlJ1xuICApLFxufVxuXG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGEgbG9jayBjYW5ub3QgYmUgYWNxdWlyZWQgYWZ0ZXIgc29tZSBhbW91bnQgb2YgdGltZS5cbiAqXG4gKiBVc2UgdGhlIHtAbGluayAjaXNBY3F1aXJlVGltZW91dH0gcHJvcGVydHkgaW5zdGVhZCBvZiBjaGVja2luZyB3aXRoIGBpbnN0YW5jZW9mYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IExvY2tBY3F1aXJlVGltZW91dEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogY2xhc3MgQ3VzdG9tTG9ja0Vycm9yIGV4dGVuZHMgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3Ige1xuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICBzdXBlcignTG9jayB0aW1lZCBvdXQnKVxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgaXNBY3F1aXJlVGltZW91dCA9IHRydWVcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICB9XG59XG5cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIGJyb3dzZXIgTmF2aWdhdG9yIExvY2sgQVBJIGZhaWxzIHRvIGFjcXVpcmUgYSBsb2NrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoJ0xvY2sgdGltZWQgb3V0JylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB7fVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgcHJvY2Vzcy1sZXZlbCBsb2NrIGhlbHBlciBjYW5ub3QgYWNxdWlyZSBhIGxvY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yKCdMb2NrIHRpbWVkIG91dCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHt9XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIGdsb2JhbCBleGNsdXNpdmUgbG9jayB1c2luZyB0aGUgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIEFQSS4gSXRcbiAqIGlzIGF2YWlsYWJsZSBvbiBhbGwgYnJvd3NlcnMgcmVsZWFzZWQgYWZ0ZXIgMjAyMi0wMy0xNSB3aXRoIFNhZmFyaSBiZWluZyB0aGVcbiAqIGxhc3Qgb25lIHRvIHJlbGVhc2Ugc3VwcG9ydC4gSWYgdGhlIEFQSSBpcyBub3QgYXZhaWxhYmxlLCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIHRocm93LiBNYWtlIHN1cmUgeW91IGNoZWNrIGF2YWlsYWJsaWxpdHkgYmVmb3JlIGNvbmZpZ3VyaW5nIHtAbGlua1xuICogR29UcnVlQ2xpZW50fS5cbiAqXG4gKiBZb3UgY2FuIHR1cm4gb24gZGVidWdnaW5nIGJ5IHNldHRpbmcgdGhlIGBzdXBhYmFzZS5nb3RydWUtanMubG9ja3MuZGVidWdgXG4gKiBsb2NhbCBzdG9yYWdlIGl0ZW0gdG8gYHRydWVgLlxuICpcbiAqIEludGVybmFsczpcbiAqXG4gKiBTaW5jZSB0aGUgTG9ja01hbmFnZXIgQVBJIGRvZXMgbm90IHByZXNlcnZlIHN0YWNrIHRyYWNlcyBmb3IgdGhlIGFzeW5jXG4gKiBmdW5jdGlvbiBwYXNzZWQgaW4gdGhlIGByZXF1ZXN0YCBtZXRob2QsIGEgdHJpY2sgaXMgdXNlZCB3aGVyZSBhY3F1aXJpbmcgdGhlXG4gKiBsb2NrIHJlbGVhc2VzIGEgcHJldmlvdXNseSBzdGFydGVkIHByb21pc2UgdG8gcnVuIHRoZSBvcGVyYXRpb24gaW4gdGhlIGBmbmBcbiAqIGZ1bmN0aW9uLiBUaGUgbG9jayB3YWl0cyBmb3IgdGhhdCBwcm9taXNlIHRvIGZpbmlzaCAod2l0aCBvciB3aXRob3V0IGVycm9yKSxcbiAqIHdoaWxlIHRoZSBmdW5jdGlvbiB3aWxsIGZpbmFsbHkgd2FpdCBmb3IgdGhlIHJlc3VsdCBhbnl3YXkuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbG9jayB0byBiZSBhY3F1aXJlZC5cbiAqIEBwYXJhbSBhY3F1aXJlVGltZW91dCBJZiBuZWdhdGl2ZSwgbm8gdGltZW91dC4gSWYgMCBhbiBlcnJvciBpcyB0aHJvd24gaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICB0aGUgbG9jayBjYW4ndCBiZSBhY3F1aXJlZCB3aXRob3V0IHdhaXRpbmcuIElmIHBvc2l0aXZlLCB0aGUgbG9jayBhY3F1aXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCB0aW1lIG91dCBhZnRlciBzbyBtYW55IG1pbGxpc2Vjb25kcy4gQW4gZXJyb3IgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICBhIHRpbWVvdXQgaWYgaXQgaGFzIGBpc0FjcXVpcmVUaW1lb3V0YCBzZXQgdG8gdHJ1ZS5cbiAqIEBwYXJhbSBmbiBUaGUgb3BlcmF0aW9uIHRvIHJ1biBvbmNlIHRoZSBsb2NrIGlzIGFjcXVpcmVkLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBhd2FpdCBuYXZpZ2F0b3JMb2NrKCdzeW5jLXVzZXInLCAxMDAwLCBhc3luYyAoKSA9PiB7XG4gKiAgIGF3YWl0IHJlZnJlc2hTZXNzaW9uKClcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRvckxvY2s8Uj4oXG4gIG5hbWU6IHN0cmluZyxcbiAgYWNxdWlyZVRpbWVvdXQ6IG51bWJlcixcbiAgZm46ICgpID0+IFByb21pc2U8Uj5cbik6IFByb21pc2U8Uj4ge1xuICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IGFjcXVpcmUgbG9jaycsIG5hbWUsIGFjcXVpcmVUaW1lb3V0KVxuICB9XG5cbiAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyKClcblxuICBpZiAoYWNxdWlyZVRpbWVvdXQgPiAwKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jayBhY3F1aXJlIHRpbWVkIG91dCcsIG5hbWUpXG4gICAgICB9XG4gICAgfSwgYWNxdWlyZVRpbWVvdXQpXG4gIH1cblxuICAvLyBNRE4gYXJ0aWNsZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0xvY2tNYW5hZ2VyL3JlcXVlc3RcblxuICAvLyBXcmFwcGluZyBuYXZpZ2F0b3IubG9ja3MucmVxdWVzdCgpIHdpdGggYSBwbGFpbiBQcm9taXNlIGlzIGRvbmUgYXMgc29tZVxuICAvLyBsaWJyYXJpZXMgbGlrZSB6b25lLmpzIHBhdGNoIHRoZSBQcm9taXNlIG9iamVjdCB0byB0cmFjayB0aGUgZXhlY3V0aW9uXG4gIC8vIGNvbnRleHQuIEhvd2V2ZXIsIGl0IGFwcGVhcnMgdGhhdCBtb3N0IGJyb3dzZXJzIHVzZSBhbiBpbnRlcm5hbCBwcm9taXNlXG4gIC8vIGltcGxlbWVudGF0aW9uIHdoZW4gdXNpbmcgdGhlIG5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KCkgQVBJIGNhdXNpbmcgdGhlbVxuICAvLyB0byBsb3NlIGNvbnRleHQgYW5kIGVtaXQgY29uZnVzaW5nIGxvZyBtZXNzYWdlcyBvciBicmVhayBjZXJ0YWluIGZlYXR1cmVzLlxuICAvLyBUaGlzIHdyYXBwaW5nIGlzIGJlbGlldmVkIHRvIGhlbHAgem9uZS5qcyB0cmFjayB0aGUgZXhlY3V0aW9uIGNvbnRleHRcbiAgLy8gYmV0dGVyLlxuICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PlxuICAgIGdsb2JhbFRoaXMubmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QoXG4gICAgICBuYW1lLFxuICAgICAgYWNxdWlyZVRpbWVvdXQgPT09IDBcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICAgIGlmQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICB9LFxuICAgICAgYXN5bmMgKGxvY2spID0+IHtcbiAgICAgICAgaWYgKGxvY2spIHtcbiAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogYWNxdWlyZWQnLCBuYW1lLCBsb2NrLm5hbWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpXG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IHJlbGVhc2VkJywgbmFtZSwgbG9jay5uYW1lKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYWNxdWlyZVRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IG5vdCBpbW1lZGlhdGVseSBhdmFpbGFibGUnLCBuYW1lKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoXG4gICAgICAgICAgICAgIGBBY3F1aXJpbmcgYW4gZXhjbHVzaXZlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBsb2NrIFwiJHtuYW1lfVwiIGltbWVkaWF0ZWx5IGZhaWxlZGBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdsb2JhbFRoaXMubmF2aWdhdG9yLmxvY2tzLnF1ZXJ5KClcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgJ0BzdXBhYmFzZS9nb3RydWUtanM6IE5hdmlnYXRvciBMb2NrTWFuYWdlciBzdGF0ZScsXG4gICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsICcgICcpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAnQHN1cGFiYXNlL2dvdHJ1ZS1qczogRXJyb3Igd2hlbiBxdWVyeWluZyBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3RhdGUnLFxuICAgICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCcm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBzcGVjLCBpdFxuICAgICAgICAgICAgLy8gcmV0dXJuZWQgYSBudWxsIGxvY2sgd2hlbiB3ZSBkaWRuJ3QgdXNlIGlmQXZhaWxhYmxlLiBTbyB3ZSBjYW5cbiAgICAgICAgICAgIC8vIHByZXRlbmQgdGhlIGxvY2sgaXMgYWNxdWlyZWQgaW4gdGhlIG5hbWUgb2YgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgLy8gYW5kIHVzZXIgZXhwZXJpZW5jZSBhbmQganVzdCBydW4gdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAnQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gdXNpbmcgI3JlcXVlc3Qgd2l0aG91dCBpZkF2YWlsYWJsZSBzZXQgdG8gdHJ1ZSwgaXQgYXBwZWFycyB0aGlzIGJyb3dzZXIgaXMgbm90IGZvbGxvd2luZyB0aGUgTG9ja01hbmFnZXIgc3BlYyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTG9ja01hbmFnZXIvcmVxdWVzdCdcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gIClcbn1cblxuY29uc3QgUFJPQ0VTU19MT0NLUzogeyBbbmFtZTogc3RyaW5nXTogUHJvbWlzZTxhbnk+IH0gPSB7fVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSBnbG9iYWwgZXhjbHVzaXZlIGxvY2sgdGhhdCB3b3JrcyBvbmx5IGluIHRoZSBjdXJyZW50IHByb2Nlc3MuXG4gKiBVc2VmdWwgZm9yIGVudmlyb25tZW50cyBsaWtlIFJlYWN0IE5hdGl2ZSBvciBvdGhlciBub24tYnJvd3NlclxuICogc2luZ2xlLXByb2Nlc3MgKGkuZS4gbm8gY29uY2VwdCBvZiBcInRhYnNcIikgZW52aXJvbm1lbnRzLlxuICpcbiAqIFVzZSB7QGxpbmsgI25hdmlnYXRvckxvY2t9IGluIGJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGxvY2sgdG8gYmUgYWNxdWlyZWQuXG4gKiBAcGFyYW0gYWNxdWlyZVRpbWVvdXQgSWYgbmVnYXRpdmUsIG5vIHRpbWVvdXQuIElmIDAgYW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIGxvY2sgY2FuJ3QgYmUgYWNxdWlyZWQgd2l0aG91dCB3YWl0aW5nLiBJZiBwb3NpdGl2ZSwgdGhlIGxvY2sgYWNxdWlyZVxuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgdGltZSBvdXQgYWZ0ZXIgc28gbWFueSBtaWxsaXNlY29uZHMuIEFuIGVycm9yIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYSB0aW1lb3V0IGlmIGl0IGhhcyBgaXNBY3F1aXJlVGltZW91dGAgc2V0IHRvIHRydWUuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBydW4gb25jZSB0aGUgbG9jayBpcyBhY3F1aXJlZC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogYXdhaXQgcHJvY2Vzc0xvY2soJ21pZ3JhdGUnLCA1MDAwLCBhc3luYyAoKSA9PiB7XG4gKiAgIGF3YWl0IHJ1bk1pZ3JhdGlvbigpXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzTG9jazxSPihcbiAgbmFtZTogc3RyaW5nLFxuICBhY3F1aXJlVGltZW91dDogbnVtYmVyLFxuICBmbjogKCkgPT4gUHJvbWlzZTxSPlxuKTogUHJvbWlzZTxSPiB7XG4gIGNvbnN0IHByZXZpb3VzT3BlcmF0aW9uID0gUFJPQ0VTU19MT0NLU1tuYW1lXSA/PyBQcm9taXNlLnJlc29sdmUoKVxuXG4gIGNvbnN0IGN1cnJlbnRPcGVyYXRpb24gPSBQcm9taXNlLnJhY2UoXG4gICAgW1xuICAgICAgcHJldmlvdXNPcGVyYXRpb24uY2F0Y2goKCkgPT4ge1xuICAgICAgICAvLyBpZ25vcmUgZXJyb3Igb2YgcHJldmlvdXMgb3BlcmF0aW9uIHRoYXQgd2UncmUgd2FpdGluZyB0byBmaW5pc2hcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0pLFxuICAgICAgYWNxdWlyZVRpbWVvdXQgPj0gMFxuICAgICAgICA/IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgYEBzdXBhYmFzZS9nb3RydWUtanM6IExvY2sgXCIke25hbWV9XCIgYWNxdWlzaXRpb24gdGltZWQgb3V0IGFmdGVyICR7YWNxdWlyZVRpbWVvdXR9bXMuIGAgK1xuICAgICAgICAgICAgICAgICAgJ1RoaXMgbWF5IGJlIGNhdXNlZCBieSBhbm90aGVyIG9wZXJhdGlvbiBob2xkaW5nIHRoZSBsb2NrLiAnICtcbiAgICAgICAgICAgICAgICAgICdDb25zaWRlciBpbmNyZWFzaW5nIGxvY2tBY3F1aXJlVGltZW91dCBvciBjaGVja2luZyBmb3Igc3R1Y2sgb3BlcmF0aW9ucy4nXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgbmV3IFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihcbiAgICAgICAgICAgICAgICAgIGBBY3F1aXJpbmcgcHJvY2VzcyBsb2NrIHdpdGggbmFtZSBcIiR7bmFtZX1cIiB0aW1lZCBvdXRgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9LCBhY3F1aXJlVGltZW91dClcbiAgICAgICAgICB9KVxuICAgICAgICA6IG51bGwsXG4gICAgXS5maWx0ZXIoKHgpID0+IHgpXG4gIClcbiAgICAuY2F0Y2goKGU6IGFueSkgPT4ge1xuICAgICAgaWYgKGUgJiYgZS5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAgICAgIHRocm93IGVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9KVxuICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgIC8vIHByZXZpb3VzIG9wZXJhdGlvbnMgZmluaXNoZWQgYW5kIHdlIGRpZG4ndCBnZXQgYSByYWNlIG9uIHRoZSBhY3F1aXJlXG4gICAgICAvLyB0aW1lb3V0LCBzbyB0aGUgY3VycmVudCBvcGVyYXRpb24gY2FuIGZpbmFsbHkgc3RhcnRcbiAgICAgIHJldHVybiBhd2FpdCBmbigpXG4gICAgfSlcblxuICBQUk9DRVNTX0xPQ0tTW25hbWVdID0gY3VycmVudE9wZXJhdGlvbi5jYXRjaChhc3luYyAoZTogYW55KSA9PiB7XG4gICAgaWYgKGUgJiYgZS5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAgICAvLyBpZiB0aGUgY3VycmVudCBvcGVyYXRpb24gdGltZWQgb3V0LCBpdCBkb2Vzbid0IG1lYW4gdGhhdCB0aGUgcHJldmlvdXNcbiAgICAgIC8vIG9wZXJhdGlvbiBmaW5pc2hlZCwgc28gd2UgbmVlZCBjb250bnVlIHdhaXRpbmcgZm9yIGl0IHRvIGZpbmlzaFxuICAgICAgYXdhaXQgcHJldmlvdXNPcGVyYXRpb25cblxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB0aHJvdyBlXG4gIH0pXG5cbiAgLy8gZmluYWxseSB3YWl0IGZvciB0aGUgY3VycmVudCBvcGVyYXRpb24gdG8gZmluaXNoIHN1Y2Nlc3NmdWxseSwgd2l0aCBhblxuICAvLyBlcnJvciBvciB3aXRoIGFuIGFjcXVpcmUgdGltZW91dCBlcnJvclxuICByZXR1cm4gYXdhaXQgY3VycmVudE9wZXJhdGlvblxufVxuIiwgIi8qKlxuICogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2dsb2JhbHRoaXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvbHlmaWxsR2xvYmFsVGhpcygpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuXG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdfX21hZ2ljX18nLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSlcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gbWFnaWMnXG4gICAgX19tYWdpY19fLmdsb2JhbFRoaXMgPSBfX21hZ2ljX19cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gbWFnaWMnXG4gICAgZGVsZXRlIE9iamVjdC5wcm90b3R5cGUuX19tYWdpY19fXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gZ2xvYmFscydcbiAgICAgIHNlbGYuZ2xvYmFsVGhpcyA9IHNlbGZcbiAgICB9XG4gIH1cbn1cbiIsICIvLyB0eXBlcyBhbmQgZnVuY3Rpb25zIGNvcGllZCBvdmVyIGZyb20gdmllbSBzbyB0aGlzIGxpYnJhcnkgZG9lc24ndCBkZXBlbmQgb24gaXRcblxuZXhwb3J0IHR5cGUgSGV4ID0gYDB4JHtzdHJpbmd9YFxuXG5leHBvcnQgdHlwZSBBZGRyZXNzID0gSGV4XG5cbmV4cG9ydCB0eXBlIEVJUDExOTNFdmVudE1hcCA9IHtcbiAgYWNjb3VudHNDaGFuZ2VkKGFjY291bnRzOiBBZGRyZXNzW10pOiB2b2lkXG4gIGNoYWluQ2hhbmdlZChjaGFpbklkOiBzdHJpbmcpOiB2b2lkXG4gIGNvbm5lY3QoY29ubmVjdEluZm86IHsgY2hhaW5JZDogc3RyaW5nIH0pOiB2b2lkXG4gIGRpc2Nvbm5lY3QoZXJyb3I6IHsgY29kZTogbnVtYmVyOyBtZXNzYWdlOiBzdHJpbmcgfSk6IHZvaWRcbiAgbWVzc2FnZShtZXNzYWdlOiB7IHR5cGU6IHN0cmluZzsgZGF0YTogdW5rbm93biB9KTogdm9pZFxufVxuXG5leHBvcnQgdHlwZSBFSVAxMTkzRXZlbnRzID0ge1xuICBvbjxldmVudCBleHRlbmRzIGtleW9mIEVJUDExOTNFdmVudE1hcD4oZXZlbnQ6IGV2ZW50LCBsaXN0ZW5lcjogRUlQMTE5M0V2ZW50TWFwW2V2ZW50XSk6IHZvaWRcbiAgcmVtb3ZlTGlzdGVuZXI8ZXZlbnQgZXh0ZW5kcyBrZXlvZiBFSVAxMTkzRXZlbnRNYXA+KFxuICAgIGV2ZW50OiBldmVudCxcbiAgICBsaXN0ZW5lcjogRUlQMTE5M0V2ZW50TWFwW2V2ZW50XVxuICApOiB2b2lkXG59XG5cbmV4cG9ydCB0eXBlIEVJUDExOTNSZXF1ZXN0Rm4gPSAoYXJnczogeyBtZXRob2Q6IHN0cmluZzsgcGFyYW1zPzogdW5rbm93biB9KSA9PiBQcm9taXNlPHVua25vd24+XG5cbmV4cG9ydCB0eXBlIEVJUDExOTNQcm92aWRlciA9IEVJUDExOTNFdmVudHMgJiB7XG4gIGFkZHJlc3M6IHN0cmluZ1xuICByZXF1ZXN0OiBFSVAxMTkzUmVxdWVzdEZuXG59XG5cbmV4cG9ydCB0eXBlIEV0aGVyZXVtV2FsbGV0ID0gRUlQMTE5M1Byb3ZpZGVyXG5cbi8qKlxuICogRUlQLTQzNjEgbWVzc2FnZSBmaWVsZHNcbiAqL1xuZXhwb3J0IHR5cGUgU2l3ZU1lc3NhZ2UgPSB7XG4gIC8qKlxuICAgKiBUaGUgRXRoZXJldW0gYWRkcmVzcyBwZXJmb3JtaW5nIHRoZSBzaWduaW5nLlxuICAgKi9cbiAgYWRkcmVzczogQWRkcmVzc1xuICAvKipcbiAgICogVGhlIFtFSVAtMTU1XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE1NSkgQ2hhaW4gSUQgdG8gd2hpY2ggdGhlIHNlc3Npb24gaXMgYm91bmQsXG4gICAqL1xuICBjaGFpbklkOiBudW1iZXJcbiAgLyoqXG4gICAqIFtSRkMgMzk4Nl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzM5ODYpIGF1dGhvcml0eSB0aGF0IGlzIHJlcXVlc3RpbmcgdGhlIHNpZ25pbmcuXG4gICAqL1xuICBkb21haW46IHN0cmluZ1xuICAvKipcbiAgICogVGltZSB3aGVuIHRoZSBzaWduZWQgYXV0aGVudGljYXRpb24gbWVzc2FnZSBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAqL1xuICBleHBpcmF0aW9uVGltZT86IERhdGUgfCB1bmRlZmluZWRcbiAgLyoqXG4gICAqIFRpbWUgd2hlbiB0aGUgbWVzc2FnZSB3YXMgZ2VuZXJhdGVkLCB0eXBpY2FsbHkgdGhlIGN1cnJlbnQgdGltZS5cbiAgICovXG4gIGlzc3VlZEF0PzogRGF0ZSB8IHVuZGVmaW5lZFxuICAvKipcbiAgICogQSByYW5kb20gc3RyaW5nIHR5cGljYWxseSBjaG9zZW4gYnkgdGhlIHJlbHlpbmcgcGFydHkgYW5kIHVzZWQgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrcy5cbiAgICovXG4gIG5vbmNlPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaW1lIHdoZW4gdGhlIHNpZ25lZCBhdXRoZW50aWNhdGlvbiBtZXNzYWdlIHdpbGwgYmVjb21lIHZhbGlkLlxuICAgKi9cbiAgbm90QmVmb3JlPzogRGF0ZSB8IHVuZGVmaW5lZFxuICAvKipcbiAgICogQSBzeXN0ZW0tc3BlY2lmaWMgaWRlbnRpZmllciB0aGF0IG1heSBiZSB1c2VkIHRvIHVuaXF1ZWx5IHJlZmVyIHRvIHRoZSBzaWduLWluIHJlcXVlc3QuXG4gICAqL1xuICByZXF1ZXN0SWQ/OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBpbmZvcm1hdGlvbiBvciByZWZlcmVuY2VzIHRvIGluZm9ybWF0aW9uIHRoZSB1c2VyIHdpc2hlcyB0byBoYXZlIHJlc29sdmVkIGFzIHBhcnQgb2YgYXV0aGVudGljYXRpb24gYnkgdGhlIHJlbHlpbmcgcGFydHkuXG4gICAqL1xuICByZXNvdXJjZXM/OiBzdHJpbmdbXSB8IHVuZGVmaW5lZFxuICAvKipcbiAgICogW1JGQyAzOTg2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMzk4NiNzZWN0aW9uLTMuMSkgVVJJIHNjaGVtZSBvZiB0aGUgb3JpZ2luIG9mIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgc2NoZW1lPzogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIC8qKlxuICAgKiBBIGh1bWFuLXJlYWRhYmxlIEFTQ0lJIGFzc2VydGlvbiB0aGF0IHRoZSB1c2VyIHdpbGwgc2lnbi5cbiAgICovXG4gIHN0YXRlbWVudD86IHN0cmluZyB8IHVuZGVmaW5lZFxuICAvKipcbiAgICogW1JGQyAzOTg2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMzk4NikgVVJJIHJlZmVycmluZyB0byB0aGUgcmVzb3VyY2UgdGhhdCBpcyB0aGUgc3ViamVjdCBvZiB0aGUgc2lnbmluZyAoYXMgaW4gdGhlIHN1YmplY3Qgb2YgYSBjbGFpbSkuXG4gICAqL1xuICB1cmk6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgU0lXRSBNZXNzYWdlLlxuICAgKi9cbiAgdmVyc2lvbjogJzEnXG59XG5cbmV4cG9ydCB0eXBlIEV0aGVyZXVtU2lnbkluSW5wdXQgPSBTaXdlTWVzc2FnZVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBBZGRyZXNzIHtcbiAgaWYgKCEvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChhZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEFkZHJlc3MgXCIke2FkZHJlc3N9XCIgaXMgaW52YWxpZC5gKVxuICB9XG4gIHJldHVybiBhZGRyZXNzLnRvTG93ZXJDYXNlKCkgYXMgQWRkcmVzc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChoZXg6IEhleCk6IG51bWJlciB7XG4gIHJldHVybiBwYXJzZUludChoZXgsIDE2KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWU6IHN0cmluZyk6IEhleCB7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKVxuICBjb25zdCBoZXggPSBBcnJheS5mcm9tKGJ5dGVzLCAoYnl0ZSkgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJylcbiAgcmV0dXJuICgnMHgnICsgaGV4KSBhcyBIZXhcbn1cblxuLyoqXG4gKiBDcmVhdGVzIEVJUC00MzYxIGZvcm1hdHRlZCBtZXNzYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2l3ZU1lc3NhZ2UocGFyYW1ldGVyczogU2l3ZU1lc3NhZ2UpOiBzdHJpbmcge1xuICBjb25zdCB7XG4gICAgY2hhaW5JZCxcbiAgICBkb21haW4sXG4gICAgZXhwaXJhdGlvblRpbWUsXG4gICAgaXNzdWVkQXQgPSBuZXcgRGF0ZSgpLFxuICAgIG5vbmNlLFxuICAgIG5vdEJlZm9yZSxcbiAgICByZXF1ZXN0SWQsXG4gICAgcmVzb3VyY2VzLFxuICAgIHNjaGVtZSxcbiAgICB1cmksXG4gICAgdmVyc2lvbixcbiAgfSA9IHBhcmFtZXRlcnNcblxuICAvLyBWYWxpZGF0ZSBmaWVsZHNcbiAge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjaGFpbklkKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcImNoYWluSWRcIi4gQ2hhaW4gSUQgbXVzdCBiZSBhIEVJUC0xNTUgY2hhaW4gSUQuIFByb3ZpZGVkIHZhbHVlOiAke2NoYWluSWR9YFxuICAgICAgKVxuXG4gICAgaWYgKCFkb21haW4pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJkb21haW5cIi4gRG9tYWluIG11c3QgYmUgcHJvdmlkZWQuYFxuICAgICAgKVxuXG4gICAgaWYgKG5vbmNlICYmIG5vbmNlLmxlbmd0aCA8IDgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJub25jZVwiLiBOb25jZSBtdXN0IGJlIGF0IGxlYXN0IDggY2hhcmFjdGVycy4gUHJvdmlkZWQgdmFsdWU6ICR7bm9uY2V9YFxuICAgICAgKVxuXG4gICAgaWYgKCF1cmkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcInVyaVwiLiBVUkkgbXVzdCBiZSBwcm92aWRlZC5gKVxuXG4gICAgaWYgKHZlcnNpb24gIT09ICcxJylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcInZlcnNpb25cIi4gVmVyc2lvbiBtdXN0IGJlICcxJy4gUHJvdmlkZWQgdmFsdWU6ICR7dmVyc2lvbn1gXG4gICAgICApXG5cbiAgICBpZiAocGFyYW1ldGVycy5zdGF0ZW1lbnQ/LmluY2x1ZGVzKCdcXG4nKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcInN0YXRlbWVudFwiLiBTdGF0ZW1lbnQgbXVzdCBub3QgaW5jbHVkZSAnXFxcXG4nLiBQcm92aWRlZCB2YWx1ZTogJHtwYXJhbWV0ZXJzLnN0YXRlbWVudH1gXG4gICAgICApXG4gIH1cblxuICAvLyBDb25zdHJ1Y3QgbWVzc2FnZVxuICBjb25zdCBhZGRyZXNzID0gZ2V0QWRkcmVzcyhwYXJhbWV0ZXJzLmFkZHJlc3MpXG4gIGNvbnN0IG9yaWdpbiA9IHNjaGVtZSA/IGAke3NjaGVtZX06Ly8ke2RvbWFpbn1gIDogZG9tYWluXG4gIGNvbnN0IHN0YXRlbWVudCA9IHBhcmFtZXRlcnMuc3RhdGVtZW50ID8gYCR7cGFyYW1ldGVycy5zdGF0ZW1lbnR9XFxuYCA6ICcnXG4gIGNvbnN0IHByZWZpeCA9IGAke29yaWdpbn0gd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIEV0aGVyZXVtIGFjY291bnQ6XFxuJHthZGRyZXNzfVxcblxcbiR7c3RhdGVtZW50fWBcblxuICBsZXQgc3VmZml4ID0gYFVSSTogJHt1cml9XFxuVmVyc2lvbjogJHt2ZXJzaW9ufVxcbkNoYWluIElEOiAke2NoYWluSWR9JHtcbiAgICBub25jZSA/IGBcXG5Ob25jZTogJHtub25jZX1gIDogJydcbiAgfVxcbklzc3VlZCBBdDogJHtpc3N1ZWRBdC50b0lTT1N0cmluZygpfWBcblxuICBpZiAoZXhwaXJhdGlvblRpbWUpIHN1ZmZpeCArPSBgXFxuRXhwaXJhdGlvbiBUaW1lOiAke2V4cGlyYXRpb25UaW1lLnRvSVNPU3RyaW5nKCl9YFxuICBpZiAobm90QmVmb3JlKSBzdWZmaXggKz0gYFxcbk5vdCBCZWZvcmU6ICR7bm90QmVmb3JlLnRvSVNPU3RyaW5nKCl9YFxuICBpZiAocmVxdWVzdElkKSBzdWZmaXggKz0gYFxcblJlcXVlc3QgSUQ6ICR7cmVxdWVzdElkfWBcbiAgaWYgKHJlc291cmNlcykge1xuICAgIGxldCBjb250ZW50ID0gJ1xcblJlc291cmNlczonXG4gICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiByZXNvdXJjZXMpIHtcbiAgICAgIGlmICghcmVzb3VyY2UgfHwgdHlwZW9mIHJlc291cmNlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJyZXNvdXJjZXNcIi4gRXZlcnkgcmVzb3VyY2UgbXVzdCBiZSBhIHZhbGlkIHN0cmluZy4gUHJvdmlkZWQgdmFsdWU6ICR7cmVzb3VyY2V9YFxuICAgICAgICApXG4gICAgICBjb250ZW50ICs9IGBcXG4tICR7cmVzb3VyY2V9YFxuICAgIH1cbiAgICBzdWZmaXggKz0gY29udGVudFxuICB9XG5cbiAgcmV0dXJuIGAke3ByZWZpeH1cXG4ke3N1ZmZpeH1gXG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50ICovXG5cbmltcG9ydCB7IFN0cmljdE9taXQgfSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHsgaXNWYWxpZERvbWFpbiB9IGZyb20gJy4vd2ViYXV0aG4nXG5pbXBvcnQge1xuICBQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlLFxuICBQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmUsXG59IGZyb20gJy4vd2ViYXV0aG4uZG9tJ1xuXG4vKipcbiAqIEEgY3VzdG9tIEVycm9yIHVzZWQgdG8gcmV0dXJuIGEgbW9yZSBudWFuY2VkIGVycm9yIGRldGFpbGluZyBfd2h5XyBvbmUgb2YgdGhlIGVpZ2h0IGRvY3VtZW50ZWRcbiAqIGVycm9ycyBpbiB0aGUgc3BlYyB3YXMgcmFpc2VkIGFmdGVyIGNhbGxpbmcgYG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKWAgb3JcbiAqIGBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KClgOlxuICpcbiAqIC0gYEFib3J0RXJyb3JgXG4gKiAtIGBDb25zdHJhaW50RXJyb3JgXG4gKiAtIGBJbnZhbGlkU3RhdGVFcnJvcmBcbiAqIC0gYE5vdEFsbG93ZWRFcnJvcmBcbiAqIC0gYE5vdFN1cHBvcnRlZEVycm9yYFxuICogLSBgU2VjdXJpdHlFcnJvcmBcbiAqIC0gYFR5cGVFcnJvcmBcbiAqIC0gYFVua25vd25FcnJvcmBcbiAqXG4gKiBFcnJvciBtZXNzYWdlcyB3ZXJlIGRldGVybWluZWQgdGhyb3VnaCBpbnZlc3RpZ2F0aW9uIG9mIHRoZSBzcGVjIHRvIGRldGVybWluZSB1bmRlciB3aGljaFxuICogc2NlbmFyaW9zIGEgZ2l2ZW4gZXJyb3Igd291bGQgYmUgcmFpc2VkLlxuICovXG5leHBvcnQgY2xhc3MgV2ViQXV0aG5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29kZTogV2ViQXV0aG5FcnJvckNvZGVcblxuICBwcm90ZWN0ZWQgX19pc1dlYkF1dGhuRXJyb3IgPSB0cnVlXG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgY29kZSxcbiAgICBjYXVzZSxcbiAgICBuYW1lLFxuICB9OiB7XG4gICAgbWVzc2FnZTogc3RyaW5nXG4gICAgY29kZTogV2ViQXV0aG5FcnJvckNvZGVcbiAgICBjYXVzZT86IEVycm9yIHwgdW5rbm93blxuICAgIG5hbWU/OiBzdHJpbmdcbiAgfSkge1xuICAgIC8vIEB0cy1pZ25vcmU6IGhlbHAgUm9sbHVwIHVuZGVyc3RhbmQgdGhhdCBgY2F1c2VgIGlzIG9rYXkgdG8gc2V0XG4gICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZSB9KVxuICAgIHRoaXMubmFtZSA9IG5hbWUgPz8gKGNhdXNlIGluc3RhbmNlb2YgRXJyb3IgPyBjYXVzZS5uYW1lIDogdW5kZWZpbmVkKSA/PyAnVW5rbm93biBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gIH1cbn1cblxuLyoqXG4gKiBFcnJvciBjbGFzcyBmb3IgdW5rbm93biBXZWJBdXRobiBlcnJvcnMuXG4gKiBXcmFwcyB1bmV4cGVjdGVkIGVycm9ycyB0aGF0IGRvbid0IG1hdGNoIGtub3duIFdlYkF1dGhuIGVycm9yIGNvbmRpdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJBdXRoblVua25vd25FcnJvciBleHRlbmRzIFdlYkF1dGhuRXJyb3Ige1xuICBvcmlnaW5hbEVycm9yOiB1bmtub3duXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBvcmlnaW5hbEVycm9yOiB1bmtub3duKSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29kZTogJ0VSUk9SX1BBU1NUSFJPVUdIX1NFRV9DQVVTRV9QUk9QRVJUWScsXG4gICAgICBjYXVzZTogb3JpZ2luYWxFcnJvcixcbiAgICAgIG1lc3NhZ2UsXG4gICAgfSlcbiAgICB0aGlzLm5hbWUgPSAnV2ViQXV0aG5Vbmtub3duRXJyb3InXG4gICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvclxuICB9XG59XG5cbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBhbiBlcnJvciBpcyBhIFdlYkF1dGhuRXJyb3IuXG4gKiBAcGFyYW0ge3Vua25vd259IGVycm9yIC0gVGhlIGVycm9yIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSBXZWJBdXRobkVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYkF1dGhuRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBXZWJBdXRobkVycm9yIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNXZWJBdXRobkVycm9yJyBpbiBlcnJvclxufVxuXG4vKipcbiAqIEVycm9yIGNvZGVzIGZvciBXZWJBdXRobiBvcGVyYXRpb25zLlxuICogVGhlc2UgY29kZXMgcHJvdmlkZSBzcGVjaWZpYyBpbmZvcm1hdGlvbiBhYm91dCB3aHkgYSBXZWJBdXRobiBjZXJlbW9ueSBmYWlsZWQuXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tZGVmaW5lZC1lcnJvcnMgVzNDIFdlYkF1dGhuIFNwZWMgLSBEZWZpbmVkIEVycm9yc31cbiAqL1xuZXhwb3J0IHR5cGUgV2ViQXV0aG5FcnJvckNvZGUgPVxuICB8ICdFUlJPUl9DRVJFTU9OWV9BQk9SVEVEJ1xuICB8ICdFUlJPUl9JTlZBTElEX0RPTUFJTidcbiAgfCAnRVJST1JfSU5WQUxJRF9SUF9JRCdcbiAgfCAnRVJST1JfSU5WQUxJRF9VU0VSX0lEX0xFTkdUSCdcbiAgfCAnRVJST1JfTUFMRk9STUVEX1BVQktFWUNSRURQQVJBTVMnXG4gIHwgJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfR0VORVJBTF9FUlJPUidcbiAgfCAnRVJST1JfQVVUSEVOVElDQVRPUl9NSVNTSU5HX0RJU0NPVkVSQUJMRV9DUkVERU5USUFMX1NVUFBPUlQnXG4gIHwgJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTUlTU0lOR19VU0VSX1ZFUklGSUNBVElPTl9TVVBQT1JUJ1xuICB8ICdFUlJPUl9BVVRIRU5USUNBVE9SX1BSRVZJT1VTTFlfUkVHSVNURVJFRCdcbiAgfCAnRVJST1JfQVVUSEVOVElDQVRPUl9OT19TVVBQT1JURURfUFVCS0VZQ1JFRFBBUkFNU19BTEcnXG4gIHwgJ0VSUk9SX0FVVE9fUkVHSVNURVJfVVNFUl9WRVJJRklDQVRJT05fRkFJTFVSRSdcbiAgfCAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJ1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gaW50dWl0IF93aHlfIGFuIGVycm9yIHdhcyByYWlzZWQgYWZ0ZXIgY2FsbGluZyBgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpYC5cbiAqIE1hcHMgYnJvd3NlciBlcnJvcnMgdG8gc3BlY2lmaWMgV2ViQXV0aG4gZXJyb3IgY29kZXMgZm9yIGJldHRlciBkZWJ1Z2dpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gRXJyb3IgaWRlbnRpZmljYXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtFcnJvcn0gcGFyYW1zLmVycm9yIC0gVGhlIGVycm9yIHRocm93biBieSB0aGUgYnJvd3NlclxuICogQHBhcmFtIHtDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zfSBwYXJhbXMub3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhc3NlZCB0byBjcmVkZW50aWFscy5jcmVhdGUoKVxuICogQHJldHVybnMge1dlYkF1dGhuRXJyb3J9IEEgV2ViQXV0aG5FcnJvciB3aXRoIGEgc3BlY2lmaWMgZXJyb3IgY29kZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgVzNDIFdlYkF1dGhuIFNwZWMgLSBDcmVhdGUgQ3JlZGVudGlhbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3Ioe1xuICBlcnJvcixcbiAgb3B0aW9ucyxcbn06IHtcbiAgZXJyb3I6IEVycm9yXG4gIG9wdGlvbnM6IFN0cmljdE9taXQ8Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucywgJ3B1YmxpY0tleSc+ICYge1xuICAgIHB1YmxpY0tleTogUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZVxuICB9XG59KTogV2ViQXV0aG5FcnJvciB7XG4gIGNvbnN0IHsgcHVibGljS2V5IH0gPSBvcHRpb25zXG5cbiAgaWYgKCFwdWJsaWNLZXkpIHtcbiAgICB0aHJvdyBFcnJvcignb3B0aW9ucyB3YXMgbWlzc2luZyByZXF1aXJlZCBwdWJsaWNLZXkgcHJvcGVydHknKVxuICB9XG5cbiAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgIGlmIChvcHRpb25zLnNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSB7XG4gICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDE2KVxuICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ1JlZ2lzdHJhdGlvbiBjZXJlbW9ueSB3YXMgc2VudCBhbiBhYm9ydCBzaWduYWwnLFxuICAgICAgICBjb2RlOiAnRVJST1JfQ0VSRU1PTllfQUJPUlRFRCcsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgIH0pXG4gICAgfVxuICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdDb25zdHJhaW50RXJyb3InKSB7XG4gICAgaWYgKHB1YmxpY0tleS5hdXRoZW50aWNhdG9yU2VsZWN0aW9uPy5yZXF1aXJlUmVzaWRlbnRLZXkgPT09IHRydWUpIHtcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCA0KVxuICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAnRGlzY292ZXJhYmxlIGNyZWRlbnRpYWxzIHdlcmUgcmVxdWlyZWQgYnV0IG5vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBpdCcsXG4gICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX01JU1NJTkdfRElTQ09WRVJBQkxFX0NSRURFTlRJQUxfU1VQUE9SVCcsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIEB0cy1pZ25vcmU6IGBtZWRpYXRpb25gIGRvZXNuJ3QgeWV0IGV4aXN0IG9uIENyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMgYnV0IGl0J3MgcG9zc2libGUgYXMgb2YgU2VwdCAyMDI0XG4gICAgICBvcHRpb25zLm1lZGlhdGlvbiA9PT0gJ2NvbmRpdGlvbmFsJyAmJlxuICAgICAgcHVibGljS2V5LmF1dGhlbnRpY2F0b3JTZWxlY3Rpb24/LnVzZXJWZXJpZmljYXRpb24gPT09ICdyZXF1aXJlZCdcbiAgICApIHtcbiAgICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDIyLjQpXG4gICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICdVc2VyIHZlcmlmaWNhdGlvbiB3YXMgcmVxdWlyZWQgZHVyaW5nIGF1dG9tYXRpYyByZWdpc3RyYXRpb24gYnV0IGl0IGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQnLFxuICAgICAgICBjb2RlOiAnRVJST1JfQVVUT19SRUdJU1RFUl9VU0VSX1ZFUklGSUNBVElPTl9GQUlMVVJFJyxcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKHB1YmxpY0tleS5hdXRoZW50aWNhdG9yU2VsZWN0aW9uPy51c2VyVmVyaWZpY2F0aW9uID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgNSlcbiAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdVc2VyIHZlcmlmaWNhdGlvbiB3YXMgcmVxdWlyZWQgYnV0IG5vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBpdCcsXG4gICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX01JU1NJTkdfVVNFUl9WRVJJRklDQVRJT05fU1VQUE9SVCcsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgIH0pXG4gICAgfVxuICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdJbnZhbGlkU3RhdGVFcnJvcicpIHtcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDIwKVxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAzKVxuICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICBtZXNzYWdlOiAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCcsXG4gICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9QUkVWSU9VU0xZX1JFR0lTVEVSRUQnLFxuICAgICAgY2F1c2U6IGVycm9yLFxuICAgIH0pXG4gIH0gZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAvKipcbiAgICAgKiBQYXNzIHRoZSBlcnJvciBkaXJlY3RseSB0aHJvdWdoLiBQbGF0Zm9ybXMgYXJlIG92ZXJsb2FkaW5nIHRoaXMgZXJyb3IgYmV5b25kIHdoYXQgdGhlIHNwZWNcbiAgICAgKiBkZWZpbmVzIGFuZCB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSBwb3RlbnRpYWxseSB1c2VmdWwgZXJyb3IgbWVzc2FnZXMuXG4gICAgICovXG4gICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgIGNhdXNlOiBlcnJvcixcbiAgICB9KVxuICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RTdXBwb3J0ZWRFcnJvcicpIHtcbiAgICBjb25zdCB2YWxpZFB1YktleUNyZWRQYXJhbXMgPSBwdWJsaWNLZXkucHViS2V5Q3JlZFBhcmFtcy5maWx0ZXIoXG4gICAgICAocGFyYW0pID0+IHBhcmFtLnR5cGUgPT09ICdwdWJsaWMta2V5J1xuICAgIClcblxuICAgIGlmICh2YWxpZFB1YktleUNyZWRQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDEwKVxuICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ05vIGVudHJ5IGluIHB1YktleUNyZWRQYXJhbXMgd2FzIG9mIHR5cGUgXCJwdWJsaWMta2V5XCInLFxuICAgICAgICBjb2RlOiAnRVJST1JfTUFMRk9STUVEX1BVQktFWUNSRURQQVJBTVMnLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAyKVxuICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICBtZXNzYWdlOlxuICAgICAgICAnTm8gYXZhaWxhYmxlIGF1dGhlbnRpY2F0b3Igc3VwcG9ydGVkIGFueSBvZiB0aGUgc3BlY2lmaWVkIHB1YktleUNyZWRQYXJhbXMgYWxnb3JpdGhtcycsXG4gICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9OT19TVVBQT1JURURfUFVCS0VZQ1JFRFBBUkFNU19BTEcnLFxuICAgICAgY2F1c2U6IGVycm9yLFxuICAgIH0pXG4gIH0gZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKSB7XG4gICAgY29uc3QgZWZmZWN0aXZlRG9tYWluID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lXG4gICAgaWYgKCFpc1ZhbGlkRG9tYWluKGVmZmVjdGl2ZURvbWFpbikpIHtcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgNylcbiAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGAke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX0gaXMgYW4gaW52YWxpZCBkb21haW5gLFxuICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9ET01BSU4nLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAocHVibGljS2V5LnJwLmlkICE9PSBlZmZlY3RpdmVEb21haW4pIHtcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgOClcbiAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBUaGUgUlAgSUQgXCIke3B1YmxpY0tleS5ycC5pZH1cIiBpcyBpbnZhbGlkIGZvciB0aGlzIGRvbWFpbmAsXG4gICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX1JQX0lEJyxcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1R5cGVFcnJvcicpIHtcbiAgICBpZiAocHVibGljS2V5LnVzZXIuaWQuYnl0ZUxlbmd0aCA8IDEgfHwgcHVibGljS2V5LnVzZXIuaWQuYnl0ZUxlbmd0aCA+IDY0KSB7XG4gICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDUpXG4gICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnVXNlciBJRCB3YXMgbm90IGJldHdlZW4gMSBhbmQgNjQgY2hhcmFjdGVycycsXG4gICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX1VTRVJfSURfTEVOR1RIJyxcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1Vua25vd25FcnJvcicpIHtcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgMSlcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgOClcbiAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgbWVzc2FnZTpcbiAgICAgICAgJ1RoZSBhdXRoZW50aWNhdG9yIHdhcyB1bmFibGUgdG8gcHJvY2VzcyB0aGUgc3BlY2lmaWVkIG9wdGlvbnMsIG9yIGNvdWxkIG5vdCBjcmVhdGUgYSBuZXcgY3JlZGVudGlhbCcsXG4gICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9HRU5FUkFMX0VSUk9SJyxcbiAgICAgIGNhdXNlOiBlcnJvcixcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICBtZXNzYWdlOiAnYSBOb24tV2ViYXV0aG4gcmVsYXRlZCBlcnJvciBoYXMgb2NjdXJyZWQnLFxuICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgIGNhdXNlOiBlcnJvcixcbiAgfSlcbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGludHVpdCBfd2h5XyBhbiBlcnJvciB3YXMgcmFpc2VkIGFmdGVyIGNhbGxpbmcgYG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKWAuXG4gKiBNYXBzIGJyb3dzZXIgZXJyb3JzIHRvIHNwZWNpZmljIFdlYkF1dGhuIGVycm9yIGNvZGVzIGZvciBiZXR0ZXIgZGVidWdnaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIEVycm9yIGlkZW50aWZpY2F0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RXJyb3J9IHBhcmFtcy5lcnJvciAtIFRoZSBlcnJvciB0aHJvd24gYnkgdGhlIGJyb3dzZXJcbiAqIEBwYXJhbSB7Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfSBwYXJhbXMub3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhc3NlZCB0byBjcmVkZW50aWFscy5nZXQoKVxuICogQHJldHVybnMge1dlYkF1dGhuRXJyb3J9IEEgV2ViQXV0aG5FcnJvciB3aXRoIGEgc3BlY2lmaWMgZXJyb3IgY29kZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWdldEFzc2VydGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIEdldCBBc3NlcnRpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3Ioe1xuICBlcnJvcixcbiAgb3B0aW9ucyxcbn06IHtcbiAgZXJyb3I6IEVycm9yXG4gIG9wdGlvbnM6IFN0cmljdE9taXQ8Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zLCAncHVibGljS2V5Jz4gJiB7XG4gICAgcHVibGljS2V5OiBQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmVcbiAgfVxufSk6IFdlYkF1dGhuRXJyb3Ige1xuICBjb25zdCB7IHB1YmxpY0tleSB9ID0gb3B0aW9uc1xuXG4gIGlmICghcHVibGljS2V5KSB7XG4gICAgdGhyb3cgRXJyb3IoJ29wdGlvbnMgd2FzIG1pc3NpbmcgcmVxdWlyZWQgcHVibGljS2V5IHByb3BlcnR5JylcbiAgfVxuXG4gIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICBpZiAob3B0aW9ucy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAxNilcbiAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdBdXRoZW50aWNhdGlvbiBjZXJlbW9ueSB3YXMgc2VudCBhbiBhYm9ydCBzaWduYWwnLFxuICAgICAgICBjb2RlOiAnRVJST1JfQ0VSRU1PTllfQUJPUlRFRCcsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgIH0pXG4gICAgfVxuICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgLyoqXG4gICAgICogUGFzcyB0aGUgZXJyb3IgZGlyZWN0bHkgdGhyb3VnaC4gUGxhdGZvcm1zIGFyZSBvdmVybG9hZGluZyB0aGlzIGVycm9yIGJleW9uZCB3aGF0IHRoZSBzcGVjXG4gICAgICogZGVmaW5lcyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgcG90ZW50aWFsbHkgdXNlZnVsIGVycm9yIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgY29kZTogJ0VSUk9SX1BBU1NUSFJPVUdIX1NFRV9DQVVTRV9QUk9QRVJUWScsXG4gICAgICBjYXVzZTogZXJyb3IsXG4gICAgfSlcbiAgfSBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnU2VjdXJpdHlFcnJvcicpIHtcbiAgICBjb25zdCBlZmZlY3RpdmVEb21haW4gPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWVcbiAgICBpZiAoIWlzVmFsaWREb21haW4oZWZmZWN0aXZlRG9tYWluKSkge1xuICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tZGlzY292ZXItZnJvbS1leHRlcm5hbC1zb3VyY2UgKFN0ZXAgNSlcbiAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGAke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX0gaXMgYW4gaW52YWxpZCBkb21haW5gLFxuICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9ET01BSU4nLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAocHVibGljS2V5LnJwSWQgIT09IGVmZmVjdGl2ZURvbWFpbikge1xuICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tZGlzY292ZXItZnJvbS1leHRlcm5hbC1zb3VyY2UgKFN0ZXAgNilcbiAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBUaGUgUlAgSUQgXCIke3B1YmxpY0tleS5ycElkfVwiIGlzIGludmFsaWQgZm9yIHRoaXMgZG9tYWluYCxcbiAgICAgICAgY29kZTogJ0VSUk9SX0lOVkFMSURfUlBfSUQnLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICB9KVxuICAgIH1cbiAgfSBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnVW5rbm93bkVycm9yJykge1xuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLWdldC1hc3NlcnRpb24gKFN0ZXAgMSlcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1nZXQtYXNzZXJ0aW9uIChTdGVwIDEyKVxuICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICBtZXNzYWdlOlxuICAgICAgICAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHVuYWJsZSB0byBwcm9jZXNzIHRoZSBzcGVjaWZpZWQgb3B0aW9ucywgb3IgY291bGQgbm90IGNyZWF0ZSBhIG5ldyBhc3NlcnRpb24gc2lnbmF0dXJlJyxcbiAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX0dFTkVSQUxfRVJST1InLFxuICAgICAgY2F1c2U6IGVycm9yLFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgIG1lc3NhZ2U6ICdhIE5vbi1XZWJhdXRobiByZWxhdGVkIGVycm9yIGhhcyBvY2N1cnJlZCcsXG4gICAgY29kZTogJ0VSUk9SX1BBU1NUSFJPVUdIX1NFRV9DQVVTRV9QUk9QRVJUWScsXG4gICAgY2F1c2U6IGVycm9yLFxuICB9KVxufVxuIiwgImltcG9ydCBHb1RydWVDbGllbnQgZnJvbSAnLi4vR29UcnVlQ2xpZW50J1xuaW1wb3J0IHsgYmFzZTY0VXJsVG9VaW50OEFycmF5LCBieXRlc1RvQmFzZTY0VVJMIH0gZnJvbSAnLi9iYXNlNjR1cmwnXG5pbXBvcnQgeyBBdXRoRXJyb3IsIEF1dGhVbmtub3duRXJyb3IsIGlzQXV0aEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnXG5pbXBvcnQge1xuICBBdXRoTUZBRW5yb2xsV2ViYXV0aG5SZXNwb25zZSxcbiAgQXV0aE1GQVZlcmlmeVJlc3BvbnNlLFxuICBBdXRoTUZBVmVyaWZ5UmVzcG9uc2VEYXRhLFxuICBNRkFDaGFsbGVuZ2VXZWJhdXRoblBhcmFtcyxcbiAgTUZBRW5yb2xsV2ViYXV0aG5QYXJhbXMsXG4gIE1GQVZlcmlmeVdlYmF1dGhuUGFyYW1GaWVsZHMsXG4gIE1GQVZlcmlmeVdlYmF1dGhuUGFyYW1zLFxuICBSZXF1ZXN0UmVzdWx0LFxuICBTdHJpY3RPbWl0LFxufSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHR5cGUge1xuICBBdXRoZW50aWNhdGlvbkNyZWRlbnRpYWwsXG4gIEF1dGhlbnRpY2F0aW9uUmVzcG9uc2VKU09OLFxuICBBdXRoZW50aWNhdG9yQXR0YWNobWVudCxcbiAgUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZSxcbiAgUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0pTT04sXG4gIFB1YmxpY0tleUNyZWRlbnRpYWxGdXR1cmUsXG4gIFB1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZSxcbiAgUHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zSlNPTixcbiAgUmVnaXN0cmF0aW9uQ3JlZGVudGlhbCxcbiAgUmVnaXN0cmF0aW9uUmVzcG9uc2VKU09OLFxufSBmcm9tICcuL3dlYmF1dGhuLmRvbSdcblxuaW1wb3J0IHtcbiAgaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yLFxuICBpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yLFxuICBpc1dlYkF1dGhuRXJyb3IsXG4gIFdlYkF1dGhuRXJyb3IsXG4gIFdlYkF1dGhuVW5rbm93bkVycm9yLFxufSBmcm9tICcuL3dlYmF1dGhuLmVycm9ycydcblxuZXhwb3J0IHsgV2ViQXV0aG5FcnJvciwgaXNXZWJBdXRobkVycm9yLCBpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yLCBpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IgfVxuLy8gUmUtZXhwb3J0IHRoZSBKU09OIHR5cGVzIGZvciB1c2UgaW4gb3RoZXIgZmlsZXNcbmV4cG9ydCB0eXBlIHsgUmVnaXN0cmF0aW9uUmVzcG9uc2VKU09OLCBBdXRoZW50aWNhdGlvblJlc3BvbnNlSlNPTiB9XG5cbi8qKlxuICogV2ViQXV0aG4gYWJvcnQgc2VydmljZSB0byBtYW5hZ2UgY2VyZW1vbnkgY2FuY2VsbGF0aW9uLlxuICogRW5zdXJlcyBvbmx5IG9uZSBXZWJBdXRobiBjZXJlbW9ueSBpcyBhY3RpdmUgYXQgYSB0aW1lIHRvIHByZXZlbnQgXCJvcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzc1wiIGVycm9ycy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgY2xhc3MgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWF1dG9tYXRpb24td2ViZHJpdmVyLWNhcGFiaWxpdHkgVzNDIFdlYkF1dGhuIFNwZWMgLSBBYm9ydGluZyBDZXJlbW9uaWVzfVxuICovXG5leHBvcnQgY2xhc3MgV2ViQXV0aG5BYm9ydFNlcnZpY2Uge1xuICBwcml2YXRlIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciB8IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYWJvcnQgc2lnbmFsIGZvciBhIG5ldyBXZWJBdXRobiBvcGVyYXRpb24uXG4gICAqIEF1dG9tYXRpY2FsbHkgY2FuY2VscyBhbnkgZXhpc3Rpbmcgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QWJvcnRTaWduYWx9IFNpZ25hbCB0byBwYXNzIHRvIG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKSBvciAuZ2V0KClcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsIE1ETiAtIEFib3J0U2lnbmFsfVxuICAgKi9cbiAgY3JlYXRlTmV3QWJvcnRTaWduYWwoKTogQWJvcnRTaWduYWwge1xuICAgIC8vIEFib3J0IGFueSBleGlzdGluZyBjYWxscyB0byBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKCkgb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpXG4gICAgaWYgKHRoaXMuY29udHJvbGxlcikge1xuICAgICAgY29uc3QgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignQ2FuY2VsbGluZyBleGlzdGluZyBXZWJBdXRobiBBUEkgY2FsbCBmb3IgbmV3IG9uZScpXG4gICAgICBhYm9ydEVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcidcbiAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydChhYm9ydEVycm9yKVxuICAgIH1cblxuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXdDb250cm9sbGVyXG4gICAgcmV0dXJuIG5ld0NvbnRyb2xsZXIuc2lnbmFsXG4gIH1cblxuICAvKipcbiAgICogTWFudWFsbHkgY2FuY2VsIHRoZSBjdXJyZW50IFdlYkF1dGhuIG9wZXJhdGlvbi5cbiAgICogVXNlZnVsIGZvciBjbGVhbmluZyB1cCB3aGVuIHVzZXIgY2FuY2VscyBvciBuYXZpZ2F0ZXMgYXdheS5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0Q29udHJvbGxlci9hYm9ydCBNRE4gLSBBYm9ydENvbnRyb2xsZXIuYWJvcnR9XG4gICAqL1xuICBjYW5jZWxDZXJlbW9ueSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBhYm9ydEVycm9yID0gbmV3IEVycm9yKCdNYW51YWxseSBjYW5jZWxsaW5nIGV4aXN0aW5nIFdlYkF1dGhuIEFQSSBjYWxsJylcbiAgICAgIGFib3J0RXJyb3IubmFtZSA9ICdBYm9ydEVycm9yJ1xuICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KGFib3J0RXJyb3IpXG4gICAgICB0aGlzLmNvbnRyb2xsZXIgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTaW5nbGV0b24gaW5zdGFuY2UgdG8gZW5zdXJlIG9ubHkgb25lIFdlYkF1dGhuIGNlcmVtb255IGlzIGFjdGl2ZSBhdCBhIHRpbWUuXG4gKiBUaGlzIHByZXZlbnRzIFwib3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiBlcnJvcnMgd2hlbiByZXRyeWluZyBXZWJBdXRobiBvcGVyYXRpb25zLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBpbnN0YW5jZSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gKi9cbmV4cG9ydCBjb25zdCB3ZWJBdXRobkFib3J0U2VydmljZSA9IG5ldyBXZWJBdXRobkFib3J0U2VydmljZSgpXG5cbi8qKlxuICogU2VydmVyIHJlc3BvbnNlIGZvcm1hdCBmb3IgV2ViQXV0aG4gY3JlZGVudGlhbCBjcmVhdGlvbiBvcHRpb25zLlxuICogVXNlcyBXM0Mgc3RhbmRhcmQgSlNPTiBmb3JtYXQgd2l0aCBiYXNlNjR1cmwtZW5jb2RlZCBiaW5hcnkgZmllbGRzLlxuICovXG5leHBvcnQgdHlwZSBTZXJ2ZXJDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zID0gUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0pTT05cblxuLyoqXG4gKiBTZXJ2ZXIgcmVzcG9uc2UgZm9ybWF0IGZvciBXZWJBdXRobiBjcmVkZW50aWFsIHJlcXVlc3Qgb3B0aW9ucy5cbiAqIFVzZXMgVzNDIHN0YW5kYXJkIEpTT04gZm9ybWF0IHdpdGggYmFzZTY0dXJsLWVuY29kZWQgYmluYXJ5IGZpZWxkcy5cbiAqL1xuZXhwb3J0IHR5cGUgU2VydmVyQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zID0gUHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zSlNPTlxuXG4vKipcbiAqIENvbnZlcnQgYmFzZTY0dXJsIGVuY29kZWQgc3RyaW5ncyBpbiBXZWJBdXRobiBjcmVkZW50aWFsIGNyZWF0aW9uIG9wdGlvbnMgdG8gQXJyYXlCdWZmZXJzXG4gKiBhcyByZXF1aXJlZCBieSB0aGUgV2ViQXV0aG4gYnJvd3NlciBBUEkuXG4gKiBTdXBwb3J0cyBib3RoIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIHBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04gYW5kIG1hbnVhbCBmYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1NlcnZlckNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBKU09OIG9wdGlvbnMgZnJvbSBzZXJ2ZXIgd2l0aCBiYXNlNjR1cmwgZW5jb2RlZCBmaWVsZHNcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlfSBPcHRpb25zIHJlYWR5IGZvciBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKClcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1wYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OIFczQyBXZWJBdXRobiBTcGVjIC0gcGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyhcbiAgb3B0aW9uczogU2VydmVyQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc1xuKTogUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ3JlZGVudGlhbCBjcmVhdGlvbiBvcHRpb25zIGFyZSByZXF1aXJlZCcpXG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGUgbmF0aXZlIHBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04gbWV0aG9kIGlzIGF2YWlsYWJsZVxuICBpZiAoXG4gICAgdHlwZW9mIFB1YmxpY0tleUNyZWRlbnRpYWwgIT09ICd1bmRlZmluZWQnICYmXG4gICAgJ3BhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04nIGluIFB1YmxpY0tleUNyZWRlbnRpYWwgJiZcbiAgICB0eXBlb2YgKFB1YmxpY0tleUNyZWRlbnRpYWwgYXMgdW5rbm93biBhcyBQdWJsaWNLZXlDcmVkZW50aWFsRnV0dXJlKVxuICAgICAgLnBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgLy8gVXNlIHRoZSBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBtZXRob2RcbiAgICByZXR1cm4gKFxuICAgICAgUHVibGljS2V5Q3JlZGVudGlhbCBhcyB1bmtub3duIGFzIFB1YmxpY0tleUNyZWRlbnRpYWxGdXR1cmVcbiAgICApLnBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04oXG4gICAgICAvKiogd2UgYXNzZXJ0IHRoZSBvcHRpb25zIGhlcmUgYXMgdHlwZXNjcmlwdCBzdGlsbCBkb2Vzbid0IGtub3cgYWJvdXQgZnV0dXJlIHdlYmF1dGhuIHR5cGVzICovXG4gICAgICBvcHRpb25zIGFzIGFueVxuICAgICkgYXMgUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZVxuICB9XG5cbiAgLy8gRmFsbGJhY2sgdG8gbWFudWFsIHBhcnNpbmcgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgbmF0aXZlIG1ldGhvZFxuICAvLyBEZXN0cnVjdHVyZSB0byBzZXBhcmF0ZSBmaWVsZHMgdGhhdCBuZWVkIHRyYW5zZm9ybWF0aW9uXG4gIGNvbnN0IHsgY2hhbGxlbmdlOiBjaGFsbGVuZ2VTdHIsIHVzZXI6IHVzZXJPcHRzLCBleGNsdWRlQ3JlZGVudGlhbHMsIC4uLnJlc3RPcHRpb25zIH0gPSBvcHRpb25zXG5cbiAgLy8gQ29udmVydCBjaGFsbGVuZ2UgZnJvbSBiYXNlNjR1cmwgdG8gQXJyYXlCdWZmZXJcbiAgY29uc3QgY2hhbGxlbmdlID0gYmFzZTY0VXJsVG9VaW50OEFycmF5KGNoYWxsZW5nZVN0cikuYnVmZmVyIGFzIEFycmF5QnVmZmVyXG5cbiAgLy8gQ29udmVydCB1c2VyLmlkIGZyb20gYmFzZTY0dXJsIHRvIEFycmF5QnVmZmVyXG4gIGNvbnN0IHVzZXI6IFB1YmxpY0tleUNyZWRlbnRpYWxVc2VyRW50aXR5ID0ge1xuICAgIC4uLnVzZXJPcHRzLFxuICAgIGlkOiBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkodXNlck9wdHMuaWQpLmJ1ZmZlciBhcyBBcnJheUJ1ZmZlcixcbiAgfVxuXG4gIC8vIEJ1aWxkIHRoZSByZXN1bHQgb2JqZWN0XG4gIGNvbnN0IHJlc3VsdDogUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZSA9IHtcbiAgICAuLi5yZXN0T3B0aW9ucyxcbiAgICBjaGFsbGVuZ2UsXG4gICAgdXNlcixcbiAgfVxuXG4gIC8vIE9ubHkgYWRkIGV4Y2x1ZGVDcmVkZW50aWFscyBpZiBpdCBleGlzdHNcbiAgaWYgKGV4Y2x1ZGVDcmVkZW50aWFscyAmJiBleGNsdWRlQ3JlZGVudGlhbHMubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdC5leGNsdWRlQ3JlZGVudGlhbHMgPSBuZXcgQXJyYXkoZXhjbHVkZUNyZWRlbnRpYWxzLmxlbmd0aClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhjbHVkZUNyZWRlbnRpYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjcmVkID0gZXhjbHVkZUNyZWRlbnRpYWxzW2ldXG4gICAgICByZXN1bHQuZXhjbHVkZUNyZWRlbnRpYWxzW2ldID0ge1xuICAgICAgICAuLi5jcmVkLFxuICAgICAgICBpZDogYmFzZTY0VXJsVG9VaW50OEFycmF5KGNyZWQuaWQpLmJ1ZmZlcixcbiAgICAgICAgdHlwZTogY3JlZC50eXBlIHx8ICdwdWJsaWMta2V5JyxcbiAgICAgICAgLy8gQ2FzdCB0cmFuc3BvcnRzIHRvIGhhbmRsZSBmdXR1cmUgdHJhbnNwb3J0IHR5cGVzIGxpa2UgXCJjYWJsZVwiXG4gICAgICAgIHRyYW5zcG9ydHM6IGNyZWQudHJhbnNwb3J0cyxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQ29udmVydCBiYXNlNjR1cmwgZW5jb2RlZCBzdHJpbmdzIGluIFdlYkF1dGhuIGNyZWRlbnRpYWwgcmVxdWVzdCBvcHRpb25zIHRvIEFycmF5QnVmZmVyc1xuICogYXMgcmVxdWlyZWQgYnkgdGhlIFdlYkF1dGhuIGJyb3dzZXIgQVBJLlxuICogU3VwcG9ydHMgYm90aCBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBwYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04gYW5kIG1hbnVhbCBmYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1NlcnZlckNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc30gb3B0aW9ucyAtIEpTT04gb3B0aW9ucyBmcm9tIHNlcnZlciB3aXRoIGJhc2U2NHVybCBlbmNvZGVkIGZpZWxkc1xuICogQHJldHVybnMge1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZX0gT3B0aW9ucyByZWFkeSBmb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tcGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OIFczQyBXZWJBdXRobiBTcGVjIC0gcGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMoXG4gIG9wdGlvbnM6IFNlcnZlckNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc1xuKTogUHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDcmVkZW50aWFsIHJlcXVlc3Qgb3B0aW9ucyBhcmUgcmVxdWlyZWQnKVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIG5hdGl2ZSBwYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04gbWV0aG9kIGlzIGF2YWlsYWJsZVxuICBpZiAoXG4gICAgdHlwZW9mIFB1YmxpY0tleUNyZWRlbnRpYWwgIT09ICd1bmRlZmluZWQnICYmXG4gICAgJ3BhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTicgaW4gUHVibGljS2V5Q3JlZGVudGlhbCAmJlxuICAgIHR5cGVvZiAoUHVibGljS2V5Q3JlZGVudGlhbCBhcyB1bmtub3duIGFzIFB1YmxpY0tleUNyZWRlbnRpYWxGdXR1cmUpXG4gICAgICAucGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIC8vIFVzZSB0aGUgbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgbWV0aG9kXG4gICAgcmV0dXJuIChcbiAgICAgIFB1YmxpY0tleUNyZWRlbnRpYWwgYXMgdW5rbm93biBhcyBQdWJsaWNLZXlDcmVkZW50aWFsRnV0dXJlXG4gICAgKS5wYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04ob3B0aW9ucykgYXMgUHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlXG4gIH1cblxuICAvLyBGYWxsYmFjayB0byBtYW51YWwgcGFyc2luZyBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBuYXRpdmUgbWV0aG9kXG4gIC8vIERlc3RydWN0dXJlIHRvIHNlcGFyYXRlIGZpZWxkcyB0aGF0IG5lZWQgdHJhbnNmb3JtYXRpb25cbiAgY29uc3QgeyBjaGFsbGVuZ2U6IGNoYWxsZW5nZVN0ciwgYWxsb3dDcmVkZW50aWFscywgLi4ucmVzdE9wdGlvbnMgfSA9IG9wdGlvbnNcblxuICAvLyBDb252ZXJ0IGNoYWxsZW5nZSBmcm9tIGJhc2U2NHVybCB0byBBcnJheUJ1ZmZlclxuICBjb25zdCBjaGFsbGVuZ2UgPSBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkoY2hhbGxlbmdlU3RyKS5idWZmZXIgYXMgQXJyYXlCdWZmZXJcblxuICAvLyBCdWlsZCB0aGUgcmVzdWx0IG9iamVjdFxuICBjb25zdCByZXN1bHQ6IFB1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZSA9IHtcbiAgICAuLi5yZXN0T3B0aW9ucyxcbiAgICBjaGFsbGVuZ2UsXG4gIH1cblxuICAvLyBPbmx5IGFkZCBhbGxvd0NyZWRlbnRpYWxzIGlmIGl0IGV4aXN0c1xuICBpZiAoYWxsb3dDcmVkZW50aWFscyAmJiBhbGxvd0NyZWRlbnRpYWxzLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQuYWxsb3dDcmVkZW50aWFscyA9IG5ldyBBcnJheShhbGxvd0NyZWRlbnRpYWxzLmxlbmd0aClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsb3dDcmVkZW50aWFscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3JlZCA9IGFsbG93Q3JlZGVudGlhbHNbaV1cbiAgICAgIHJlc3VsdC5hbGxvd0NyZWRlbnRpYWxzW2ldID0ge1xuICAgICAgICAuLi5jcmVkLFxuICAgICAgICBpZDogYmFzZTY0VXJsVG9VaW50OEFycmF5KGNyZWQuaWQpLmJ1ZmZlcixcbiAgICAgICAgdHlwZTogY3JlZC50eXBlIHx8ICdwdWJsaWMta2V5JyxcbiAgICAgICAgLy8gQ2FzdCB0cmFuc3BvcnRzIHRvIGhhbmRsZSBmdXR1cmUgdHJhbnNwb3J0IHR5cGVzIGxpa2UgXCJjYWJsZVwiXG4gICAgICAgIHRyYW5zcG9ydHM6IGNyZWQudHJhbnNwb3J0cyxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogU2VydmVyIGZvcm1hdCBmb3IgY3JlZGVudGlhbCByZXNwb25zZSB3aXRoIGJhc2U2NHVybC1lbmNvZGVkIGJpbmFyeSBmaWVsZHNcbiAqIENhbiBiZSBlaXRoZXIgYSByZWdpc3RyYXRpb24gb3IgYXV0aGVudGljYXRpb24gcmVzcG9uc2VcbiAqL1xuZXhwb3J0IHR5cGUgU2VydmVyQ3JlZGVudGlhbFJlc3BvbnNlID0gUmVnaXN0cmF0aW9uUmVzcG9uc2VKU09OIHwgQXV0aGVudGljYXRpb25SZXNwb25zZUpTT05cblxuLyoqXG4gKiBDb252ZXJ0IGEgcmVnaXN0cmF0aW9uL2Vucm9sbG1lbnQgY3JlZGVudGlhbCByZXNwb25zZSB0byBzZXJ2ZXIgZm9ybWF0LlxuICogU2VyaWFsaXplcyBiaW5hcnkgZmllbGRzIHRvIGJhc2U2NHVybCBmb3IgSlNPTiB0cmFuc21pc3Npb24uXG4gKiBTdXBwb3J0cyBib3RoIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIHRvSlNPTiBhbmQgbWFudWFsIGZhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7UmVnaXN0cmF0aW9uQ3JlZGVudGlhbH0gY3JlZGVudGlhbCAtIENyZWRlbnRpYWwgZnJvbSBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKClcbiAqIEByZXR1cm5zIHtSZWdpc3RyYXRpb25SZXNwb25zZUpTT059IEpTT04tc2VyaWFsaXphYmxlIGNyZWRlbnRpYWwgZm9yIHNlcnZlclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNkb20tcHVibGlja2V5Y3JlZGVudGlhbC10b2pzb24gVzNDIFdlYkF1dGhuIFNwZWMgLSB0b0pTT059XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25SZXNwb25zZShcbiAgY3JlZGVudGlhbDogUmVnaXN0cmF0aW9uQ3JlZGVudGlhbFxuKTogUmVnaXN0cmF0aW9uUmVzcG9uc2VKU09OIHtcbiAgLy8gQ2hlY2sgaWYgdGhlIGNyZWRlbnRpYWwgaW5zdGFuY2UgaGFzIHRoZSB0b0pTT04gbWV0aG9kXG4gIGlmICgndG9KU09OJyBpbiBjcmVkZW50aWFsICYmIHR5cGVvZiBjcmVkZW50aWFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSB0aGUgbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgbWV0aG9kXG4gICAgcmV0dXJuIChjcmVkZW50aWFsIGFzIFJlZ2lzdHJhdGlvbkNyZWRlbnRpYWwpLnRvSlNPTigpXG4gIH1cbiAgY29uc3QgY3JlZGVudGlhbFdpdGhBdHRhY2htZW50ID0gY3JlZGVudGlhbCBhcyBQdWJsaWNLZXlDcmVkZW50aWFsICYge1xuICAgIHJlc3BvbnNlOiBBdXRoZW50aWNhdG9yQXR0ZXN0YXRpb25SZXNwb25zZVxuICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50Pzogc3RyaW5nIHwgbnVsbFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogY3JlZGVudGlhbC5pZCxcbiAgICByYXdJZDogY3JlZGVudGlhbC5pZCxcbiAgICByZXNwb25zZToge1xuICAgICAgYXR0ZXN0YXRpb25PYmplY3Q6IGJ5dGVzVG9CYXNlNjRVUkwobmV3IFVpbnQ4QXJyYXkoY3JlZGVudGlhbC5yZXNwb25zZS5hdHRlc3RhdGlvbk9iamVjdCkpLFxuICAgICAgY2xpZW50RGF0YUpTT046IGJ5dGVzVG9CYXNlNjRVUkwobmV3IFVpbnQ4QXJyYXkoY3JlZGVudGlhbC5yZXNwb25zZS5jbGllbnREYXRhSlNPTikpLFxuICAgIH0sXG4gICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgIGNsaWVudEV4dGVuc2lvblJlc3VsdHM6IGNyZWRlbnRpYWwuZ2V0Q2xpZW50RXh0ZW5zaW9uUmVzdWx0cygpLFxuICAgIC8vIENvbnZlcnQgbnVsbCB0byB1bmRlZmluZWQgYW5kIGNhc3QgdG8gQXV0aGVudGljYXRvckF0dGFjaG1lbnQgdHlwZVxuICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50OiAoY3JlZGVudGlhbFdpdGhBdHRhY2htZW50LmF1dGhlbnRpY2F0b3JBdHRhY2htZW50ID8/IHVuZGVmaW5lZCkgYXNcbiAgICAgIHwgQXV0aGVudGljYXRvckF0dGFjaG1lbnRcbiAgICAgIHwgdW5kZWZpbmVkLFxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBhdXRoZW50aWNhdGlvbi92ZXJpZmljYXRpb24gY3JlZGVudGlhbCByZXNwb25zZSB0byBzZXJ2ZXIgZm9ybWF0LlxuICogU2VyaWFsaXplcyBiaW5hcnkgZmllbGRzIHRvIGJhc2U2NHVybCBmb3IgSlNPTiB0cmFuc21pc3Npb24uXG4gKiBTdXBwb3J0cyBib3RoIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIHRvSlNPTiBhbmQgbWFudWFsIGZhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7QXV0aGVudGljYXRpb25DcmVkZW50aWFsfSBjcmVkZW50aWFsIC0gQ3JlZGVudGlhbCBmcm9tIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKVxuICogQHJldHVybnMge0F1dGhlbnRpY2F0aW9uUmVzcG9uc2VKU09OfSBKU09OLXNlcmlhbGl6YWJsZSBjcmVkZW50aWFsIGZvciBzZXJ2ZXJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jZG9tLXB1YmxpY2tleWNyZWRlbnRpYWwtdG9qc29uIFczQyBXZWJBdXRobiBTcGVjIC0gdG9KU09OfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RSZXNwb25zZShcbiAgY3JlZGVudGlhbDogQXV0aGVudGljYXRpb25DcmVkZW50aWFsXG4pOiBBdXRoZW50aWNhdGlvblJlc3BvbnNlSlNPTiB7XG4gIC8vIENoZWNrIGlmIHRoZSBjcmVkZW50aWFsIGluc3RhbmNlIGhhcyB0aGUgdG9KU09OIG1ldGhvZFxuICBpZiAoJ3RvSlNPTicgaW4gY3JlZGVudGlhbCAmJiB0eXBlb2YgY3JlZGVudGlhbC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgdGhlIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIG1ldGhvZFxuICAgIHJldHVybiAoY3JlZGVudGlhbCBhcyBBdXRoZW50aWNhdGlvbkNyZWRlbnRpYWwpLnRvSlNPTigpXG4gIH1cblxuICAvLyBGYWxsYmFjayB0byBtYW51YWwgY29udmVyc2lvbiBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRvSlNPTlxuICAvLyBBY2Nlc3MgYXV0aGVudGljYXRvckF0dGFjaG1lbnQgdmlhIHR5cGUgYXNzZXJ0aW9uIHRvIGhhbmRsZSBUeXBlU2NyaXB0IHZlcnNpb24gZGlmZmVyZW5jZXNcbiAgLy8gQHNpbXBsZXdlYmF1dGhuL3R5cGVzIGluY2x1ZGVzIHRoaXMgcHJvcGVydHkgYnV0IGJhc2UgVHlwZVNjcmlwdCA0LjcuNCBkb2Vzbid0XG4gIGNvbnN0IGNyZWRlbnRpYWxXaXRoQXR0YWNobWVudCA9IGNyZWRlbnRpYWwgYXMgUHVibGljS2V5Q3JlZGVudGlhbCAmIHtcbiAgICByZXNwb25zZTogQXV0aGVudGljYXRvckFzc2VydGlvblJlc3BvbnNlXG4gICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnQ/OiBzdHJpbmcgfCBudWxsXG4gIH1cblxuICBjb25zdCBjbGllbnRFeHRlbnNpb25SZXN1bHRzID0gY3JlZGVudGlhbC5nZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzKClcbiAgY29uc3QgYXNzZXJ0aW9uUmVzcG9uc2UgPSBjcmVkZW50aWFsLnJlc3BvbnNlXG5cbiAgcmV0dXJuIHtcbiAgICBpZDogY3JlZGVudGlhbC5pZCxcbiAgICByYXdJZDogY3JlZGVudGlhbC5pZCwgLy8gVzNDIHNwZWMgZXhwZWN0cyByYXdJZCB0byBtYXRjaCBpZCBmb3IgSlNPTiBmb3JtYXRcbiAgICByZXNwb25zZToge1xuICAgICAgYXV0aGVudGljYXRvckRhdGE6IGJ5dGVzVG9CYXNlNjRVUkwobmV3IFVpbnQ4QXJyYXkoYXNzZXJ0aW9uUmVzcG9uc2UuYXV0aGVudGljYXRvckRhdGEpKSxcbiAgICAgIGNsaWVudERhdGFKU09OOiBieXRlc1RvQmFzZTY0VVJMKG5ldyBVaW50OEFycmF5KGFzc2VydGlvblJlc3BvbnNlLmNsaWVudERhdGFKU09OKSksXG4gICAgICBzaWduYXR1cmU6IGJ5dGVzVG9CYXNlNjRVUkwobmV3IFVpbnQ4QXJyYXkoYXNzZXJ0aW9uUmVzcG9uc2Uuc2lnbmF0dXJlKSksXG4gICAgICB1c2VySGFuZGxlOiBhc3NlcnRpb25SZXNwb25zZS51c2VySGFuZGxlXG4gICAgICAgID8gYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShhc3NlcnRpb25SZXNwb25zZS51c2VySGFuZGxlKSlcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICB0eXBlOiAncHVibGljLWtleScsXG4gICAgY2xpZW50RXh0ZW5zaW9uUmVzdWx0cyxcbiAgICAvLyBDb252ZXJ0IG51bGwgdG8gdW5kZWZpbmVkIGFuZCBjYXN0IHRvIEF1dGhlbnRpY2F0b3JBdHRhY2htZW50IHR5cGVcbiAgICBhdXRoZW50aWNhdG9yQXR0YWNobWVudDogKGNyZWRlbnRpYWxXaXRoQXR0YWNobWVudC5hdXRoZW50aWNhdG9yQXR0YWNobWVudCA/PyB1bmRlZmluZWQpIGFzXG4gICAgICB8IEF1dGhlbnRpY2F0b3JBdHRhY2htZW50XG4gICAgICB8IHVuZGVmaW5lZCxcbiAgfVxufVxuXG4vKipcbiAqIEEgc2ltcGxlIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGEgaG9zdG5hbWUgaXMgYSBwcm9wZXJseS1mb3JtYXR0ZWQgZG9tYWluIG5hbWUuXG4gKiBDb25zaWRlcnMgbG9jYWxob3N0IHZhbGlkIGZvciBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gKlxuICogQSBcInZhbGlkIGRvbWFpblwiIGlzIGRlZmluZWQgaGVyZTogaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN2YWxpZC1kb21haW5cbiAqXG4gKiBSZWdleCBzb3VyY2VkIGZyb20gaGVyZTpcbiAqIGh0dHBzOi8vd3d3Lm9yZWlsbHkuY29tL2xpYnJhcnkvdmlldy9yZWd1bGFyLWV4cHJlc3Npb25zLWNvb2tib29rLzk3ODE0NDkzMjc0NTMvY2gwOHMxNS5odG1sXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lIC0gVGhlIGhvc3RuYW1lIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWxpZCBkb21haW4gb3IgbG9jYWxob3N0XG4gKiBAc2VlIHtAbGluayBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3ZhbGlkLWRvbWFpbiBXSEFUV0cgVVJMIFNwZWMgLSBWYWxpZCBEb21haW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRG9tYWluKGhvc3RuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICAvLyBDb25zaWRlciBsb2NhbGhvc3QgdmFsaWQgYXMgd2VsbCBzaW5jZSBpdCdzIG9rYXkgd3J0IFNlY3VyZSBDb250ZXh0c1xuICAgIGhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCAvXihbYS16MC05XSsoLVthLXowLTldKykqXFwuKStbYS16XXsyLH0kL2kudGVzdChob3N0bmFtZSlcbiAgKVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIFdlYkF1dGhuLlxuICogQ2hlY2tzIGZvciBuZWNlc3NhcnkgV2ViIEFQSXM6IFB1YmxpY0tleUNyZWRlbnRpYWwgYW5kIENyZWRlbnRpYWwgTWFuYWdlbWVudC5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBicm93c2VyIHN1cHBvcnRzIFdlYkF1dGhuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUHVibGljS2V5Q3JlZGVudGlhbCNicm93c2VyX2NvbXBhdGliaWxpdHkgTUROIC0gUHVibGljS2V5Q3JlZGVudGlhbCBCcm93c2VyIENvbXBhdGliaWxpdHl9XG4gKi9cbmZ1bmN0aW9uIGJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gISEoXG4gICAgaXNCcm93c2VyKCkgJiZcbiAgICAnUHVibGljS2V5Q3JlZGVudGlhbCcgaW4gd2luZG93ICYmXG4gICAgd2luZG93LlB1YmxpY0tleUNyZWRlbnRpYWwgJiZcbiAgICAnY3JlZGVudGlhbHMnIGluIG5hdmlnYXRvciAmJlxuICAgIHR5cGVvZiBuYXZpZ2F0b3I/LmNyZWRlbnRpYWxzPy5jcmVhdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgbmF2aWdhdG9yPy5jcmVkZW50aWFscz8uZ2V0ID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBXZWJBdXRobiBjcmVkZW50aWFsIHVzaW5nIHRoZSBicm93c2VyJ3MgY3JlZGVudGlhbHMgQVBJLlxuICogV3JhcHMgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpIHdpdGggZXJyb3IgaGFuZGxpbmcuXG4gKlxuICogQHBhcmFtIHtDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zfSBvcHRpb25zIC0gT3B0aW9ucyBpbmNsdWRpbmcgcHVibGljS2V5IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ8UmVnaXN0cmF0aW9uQ3JlZGVudGlhbCwgV2ViQXV0aG5FcnJvcj4+fSBDcmVhdGVkIGNyZWRlbnRpYWwgb3IgZXJyb3JcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIFczQyBXZWJBdXRobiBTcGVjIC0gQ3JlYXRlIENyZWRlbnRpYWx9XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3JlZGVudGlhbHNDb250YWluZXIvY3JlYXRlIE1ETiAtIGNyZWRlbnRpYWxzLmNyZWF0ZX1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNyZWRlbnRpYWwoXG4gIG9wdGlvbnM6IFN0cmljdE9taXQ8Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucywgJ3B1YmxpY0tleSc+ICYge1xuICAgIHB1YmxpY0tleTogUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZVxuICB9XG4pOiBQcm9taXNlPFJlcXVlc3RSZXN1bHQ8UmVnaXN0cmF0aW9uQ3JlZGVudGlhbCwgV2ViQXV0aG5FcnJvcj4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoXG4gICAgICAvKiogd2UgYXNzZXJ0IHRoZSB0eXBlIGhlcmUgdW50aWwgdHlwZXNjcmlwdCB0eXBlcyBhcmUgdXBkYXRlZCAqL1xuICAgICAgb3B0aW9ucyBhcyBQYXJhbWV0ZXJzPHR5cGVvZiBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlPlswXVxuICAgIClcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogbmV3IFdlYkF1dGhuVW5rbm93bkVycm9yKCdFbXB0eSBjcmVkZW50aWFsIHJlc3BvbnNlJywgcmVzcG9uc2UpLFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIFB1YmxpY0tleUNyZWRlbnRpYWwpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogbmV3IFdlYkF1dGhuVW5rbm93bkVycm9yKCdCcm93c2VyIHJldHVybmVkIHVuZXhwZWN0ZWQgY3JlZGVudGlhbCB0eXBlJywgcmVzcG9uc2UpLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkYXRhOiByZXNwb25zZSBhcyBSZWdpc3RyYXRpb25DcmVkZW50aWFsLCBlcnJvcjogbnVsbCB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgZXJyb3I6IGlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3Ioe1xuICAgICAgICBlcnJvcjogZXJyIGFzIEVycm9yLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgfSksXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IGEgV2ViQXV0aG4gY3JlZGVudGlhbCB1c2luZyB0aGUgYnJvd3NlcidzIGNyZWRlbnRpYWxzIEFQSS5cbiAqIFdyYXBzIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKSB3aXRoIGVycm9yIGhhbmRsaW5nLlxuICpcbiAqIEBwYXJhbSB7Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfSBvcHRpb25zIC0gT3B0aW9ucyBpbmNsdWRpbmcgcHVibGljS2V5IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ8QXV0aGVudGljYXRpb25DcmVkZW50aWFsLCBXZWJBdXRobkVycm9yPj59IFJldHJpZXZlZCBjcmVkZW50aWFsIG9yIGVycm9yXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tZ2V0QXNzZXJ0aW9uIFczQyBXZWJBdXRobiBTcGVjIC0gR2V0IEFzc2VydGlvbn1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcmVkZW50aWFsc0NvbnRhaW5lci9nZXQgTUROIC0gY3JlZGVudGlhbHMuZ2V0fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbChcbiAgb3B0aW9uczogU3RyaWN0T21pdDxDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMsICdwdWJsaWNLZXknPiAmIHtcbiAgICBwdWJsaWNLZXk6IFB1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZVxuICB9XG4pOiBQcm9taXNlPFJlcXVlc3RSZXN1bHQ8QXV0aGVudGljYXRpb25DcmVkZW50aWFsLCBXZWJBdXRobkVycm9yPj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldChcbiAgICAgIC8qKiB3ZSBhc3NlcnQgdGhlIHR5cGUgaGVyZSB1bnRpbCB0eXBlc2NyaXB0IHR5cGVzIGFyZSB1cGRhdGVkICovXG4gICAgICBvcHRpb25zIGFzIFBhcmFtZXRlcnM8dHlwZW9mIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQ+WzBdXG4gICAgKVxuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiBuZXcgV2ViQXV0aG5Vbmtub3duRXJyb3IoJ0VtcHR5IGNyZWRlbnRpYWwgcmVzcG9uc2UnLCByZXNwb25zZSksXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUHVibGljS2V5Q3JlZGVudGlhbCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiBuZXcgV2ViQXV0aG5Vbmtub3duRXJyb3IoJ0Jyb3dzZXIgcmV0dXJuZWQgdW5leHBlY3RlZCBjcmVkZW50aWFsIHR5cGUnLCByZXNwb25zZSksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGRhdGE6IHJlc3BvbnNlIGFzIEF1dGhlbnRpY2F0aW9uQ3JlZGVudGlhbCwgZXJyb3I6IG51bGwgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGVycm9yOiBpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3Ioe1xuICAgICAgICBlcnJvcjogZXJyIGFzIEVycm9yLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgfSksXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0NSRUFUSU9OX09QVElPTlM6IFBhcnRpYWw8UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZT4gPSB7XG4gIGhpbnRzOiBbJ3NlY3VyaXR5LWtleSddLFxuICBhdXRoZW50aWNhdG9yU2VsZWN0aW9uOiB7XG4gICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnQ6ICdjcm9zcy1wbGF0Zm9ybScsXG4gICAgcmVxdWlyZVJlc2lkZW50S2V5OiBmYWxzZSxcbiAgICAvKiogc2V0IHRvIHByZWZlcnJlZCBiZWNhdXNlIG9sZGVyIHl1YmlrZXlzIGRvbid0IGhhdmUgUElOL0Jpb21ldHJpYyAqL1xuICAgIHVzZXJWZXJpZmljYXRpb246ICdwcmVmZXJyZWQnLFxuICAgIHJlc2lkZW50S2V5OiAnZGlzY291cmFnZWQnLFxuICB9LFxuICBhdHRlc3RhdGlvbjogJ2RpcmVjdCcsXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFUVVFU1RfT1BUSU9OUzogUGFydGlhbDxQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmU+ID0ge1xuICAvKiogc2V0IHRvIHByZWZlcnJlZCBiZWNhdXNlIG9sZGVyIHl1YmlrZXlzIGRvbid0IGhhdmUgUElOL0Jpb21ldHJpYyAqL1xuICB1c2VyVmVyaWZpY2F0aW9uOiAncHJlZmVycmVkJyxcbiAgaGludHM6IFsnc2VjdXJpdHkta2V5J10sXG4gIGF0dGVzdGF0aW9uOiAnZGlyZWN0Jyxcbn1cblxuZnVuY3Rpb24gZGVlcE1lcmdlPFQ+KC4uLnNvdXJjZXM6IFBhcnRpYWw8VD5bXSk6IFQge1xuICBjb25zdCBpc09iamVjdCA9ICh2YWw6IHVua25vd24pOiB2YWwgaXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPT5cbiAgICB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKVxuXG4gIGNvbnN0IGlzQXJyYXlCdWZmZXJMaWtlID0gKHZhbDogdW5rbm93bik6IHZhbCBpcyBBcnJheUJ1ZmZlciB8IEFycmF5QnVmZmVyVmlldyA9PlxuICAgIHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpXG5cbiAgY29uc3QgcmVzdWx0OiBQYXJ0aWFsPFQ+ID0ge31cblxuICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgaWYgKCFzb3VyY2UpIGNvbnRpbnVlXG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc291cmNlW2tleV1cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gcHJlc2VydmUgYXJyYXkgcmVmZXJlbmNlLCBpbmNsdWRpbmcgdW5pb25zIGxpa2UgQXV0aGVudGljYXRvclRyYW5zcG9ydFtdXG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWUgYXMgVFt0eXBlb2Yga2V5XVxuICAgICAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZSBhcyBUW3R5cGVvZiBrZXldXG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHJlc3VsdFtrZXldXG4gICAgICAgIGlmIChpc09iamVjdChleGlzdGluZykpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IGRlZXBNZXJnZShleGlzdGluZywgdmFsdWUpIGFzIHVua25vd24gYXMgVFt0eXBlb2Yga2V5XVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVlcE1lcmdlKHZhbHVlKSBhcyB1bmtub3duIGFzIFRbdHlwZW9mIGtleV1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZSBhcyBUW3R5cGVvZiBrZXldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCBhcyBUXG59XG5cbi8qKlxuICogTWVyZ2VzIFdlYkF1dGhuIGNyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9ucyB3aXRoIG92ZXJyaWRlcy5cbiAqIFNldHMgc2Vuc2libGUgZGVmYXVsdHMgZm9yIGF1dGhlbnRpY2F0b3Igc2VsZWN0aW9uIGFuZCBleHRlbnNpb25zLlxuICpcbiAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gYmFzZU9wdGlvbnMgLSBUaGUgYmFzZSBvcHRpb25zIGZyb20gdGhlIHNlcnZlclxuICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlfSBvdmVycmlkZXMgLSBPcHRpb25hbCBvdmVycmlkZXMgdG8gYXBwbHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBmcmllbmRseU5hbWUgLSBPcHRpb25hbCBmcmllbmRseSBuYW1lIGZvciB0aGUgY3JlZGVudGlhbFxuICogQHJldHVybnMge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IE1lcmdlZCBjcmVkZW50aWFsIGNyZWF0aW9uIG9wdGlvbnNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jZGljdGRlZi1hdXRoZW50aWNhdG9yc2VsZWN0aW9uY3JpdGVyaWEgVzNDIFdlYkF1dGhuIFNwZWMgLSBBdXRoZW50aWNhdG9yU2VsZWN0aW9uQ3JpdGVyaWF9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMoXG4gIGJhc2VPcHRpb25zOiBQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlLFxuICBvdmVycmlkZXM/OiBQYXJ0aWFsPFB1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmU+XG4pOiBQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlIHtcbiAgcmV0dXJuIGRlZXBNZXJnZShERUZBVUxUX0NSRUFUSU9OX09QVElPTlMsIGJhc2VPcHRpb25zLCBvdmVycmlkZXMgfHwge30pXG59XG5cbi8qKlxuICogTWVyZ2VzIFdlYkF1dGhuIGNyZWRlbnRpYWwgcmVxdWVzdCBvcHRpb25zIHdpdGggb3ZlcnJpZGVzLlxuICogU2V0cyBzZW5zaWJsZSBkZWZhdWx0cyBmb3IgdXNlciB2ZXJpZmljYXRpb24gYW5kIGhpbnRzLlxuICpcbiAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBiYXNlT3B0aW9ucyAtIFRoZSBiYXNlIG9wdGlvbnMgZnJvbSB0aGUgc2VydmVyXG4gKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzIC0gT3B0aW9uYWwgb3ZlcnJpZGVzIHRvIGFwcGx5XG4gKiBAcmV0dXJucyB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBNZXJnZWQgY3JlZGVudGlhbCByZXF1ZXN0IG9wdGlvbnNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jZGljdGRlZi1wdWJsaWNrZXljcmVkZW50aWFscmVxdWVzdG9wdGlvbnMgVzNDIFdlYkF1dGhuIFNwZWMgLSBQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyhcbiAgYmFzZU9wdGlvbnM6IFB1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZSxcbiAgb3ZlcnJpZGVzPzogUGFydGlhbDxQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmU+XG4pOiBQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmUge1xuICByZXR1cm4gZGVlcE1lcmdlKERFRkFVTFRfUkVRVUVTVF9PUFRJT05TLCBiYXNlT3B0aW9ucywgb3ZlcnJpZGVzIHx8IHt9KVxufVxuXG4vKipcbiAqIFdlYkF1dGhuIEFQSSB3cmFwcGVyIGZvciBTdXBhYmFzZSBBdXRoLlxuICogUHJvdmlkZXMgbWV0aG9kcyBmb3IgZW5yb2xsaW5nLCBjaGFsbGVuZ2luZywgdmVyaWZ5aW5nLCBhdXRoZW50aWNhdGluZywgYW5kIHJlZ2lzdGVyaW5nIFdlYkF1dGhuIGNyZWRlbnRpYWxzLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyBXM0MgV2ViQXV0aG4gU3BlY2lmaWNhdGlvbn1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfQXV0aGVudGljYXRpb25fQVBJIE1ETiAtIFdlYiBBdXRoZW50aWNhdGlvbiBBUEl9XG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJBdXRobkFwaSB7XG4gIHB1YmxpYyBlbnJvbGw6IHR5cGVvZiBXZWJBdXRobkFwaS5wcm90b3R5cGUuX2Vucm9sbFxuICBwdWJsaWMgY2hhbGxlbmdlOiB0eXBlb2YgV2ViQXV0aG5BcGkucHJvdG90eXBlLl9jaGFsbGVuZ2VcbiAgcHVibGljIHZlcmlmeTogdHlwZW9mIFdlYkF1dGhuQXBpLnByb3RvdHlwZS5fdmVyaWZ5XG4gIHB1YmxpYyBhdXRoZW50aWNhdGU6IHR5cGVvZiBXZWJBdXRobkFwaS5wcm90b3R5cGUuX2F1dGhlbnRpY2F0ZVxuICBwdWJsaWMgcmVnaXN0ZXI6IHR5cGVvZiBXZWJBdXRobkFwaS5wcm90b3R5cGUuX3JlZ2lzdGVyXG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjbGllbnQ6IEdvVHJ1ZUNsaWVudCkge1xuICAgIC8vIEJpbmQgYWxsIG1ldGhvZHMgc28gdGhleSBjYW4gYmUgZGVzdHJ1Y3R1cmVkXG4gICAgdGhpcy5lbnJvbGwgPSB0aGlzLl9lbnJvbGwuYmluZCh0aGlzKVxuICAgIHRoaXMuY2hhbGxlbmdlID0gdGhpcy5fY2hhbGxlbmdlLmJpbmQodGhpcylcbiAgICB0aGlzLnZlcmlmeSA9IHRoaXMuX3ZlcmlmeS5iaW5kKHRoaXMpXG4gICAgdGhpcy5hdXRoZW50aWNhdGUgPSB0aGlzLl9hdXRoZW50aWNhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMucmVnaXN0ZXIgPSB0aGlzLl9yZWdpc3Rlci5iaW5kKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogRW5yb2xsIGEgbmV3IFdlYkF1dGhuIGZhY3Rvci5cbiAgICogQ3JlYXRlcyBhbiB1bnZlcmlmaWVkIFdlYkF1dGhuIGZhY3RvciB0aGF0IG11c3QgYmUgdmVyaWZpZWQgd2l0aCBhIGNyZWRlbnRpYWwuXG4gICAqXG4gICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgKiBAcGFyYW0ge09taXQ8TUZBRW5yb2xsV2ViYXV0aG5QYXJhbXMsICdmYWN0b3JUeXBlJz59IHBhcmFtcyAtIEVucm9sbG1lbnQgcGFyYW1ldGVycyAoZnJpZW5kbHlOYW1lIHJlcXVpcmVkKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBdXRoTUZBRW5yb2xsV2ViYXV0aG5SZXNwb25zZT59IEVucm9sbGVkIGZhY3RvciBkZXRhaWxzIG9yIGVycm9yXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1yZWdpc3RlcmluZy1hLW5ldy1jcmVkZW50aWFsIFczQyBXZWJBdXRobiBTcGVjIC0gUmVnaXN0ZXJpbmcgYSBOZXcgQ3JlZGVudGlhbH1cbiAgICovXG4gIHB1YmxpYyBhc3luYyBfZW5yb2xsKFxuICAgIHBhcmFtczogT21pdDxNRkFFbnJvbGxXZWJhdXRoblBhcmFtcywgJ2ZhY3RvclR5cGUnPlxuICApOiBQcm9taXNlPEF1dGhNRkFFbnJvbGxXZWJhdXRoblJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50Lm1mYS5lbnJvbGwoeyAuLi5wYXJhbXMsIGZhY3RvclR5cGU6ICd3ZWJhdXRobicgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFsbGVuZ2UgZm9yIFdlYkF1dGhuIGNyZWRlbnRpYWwgY3JlYXRpb24gb3IgYXV0aGVudGljYXRpb24uXG4gICAqIENvbWJpbmVzIHNlcnZlciBjaGFsbGVuZ2Ugd2l0aCBicm93c2VyIGNyZWRlbnRpYWwgb3BlcmF0aW9ucy5cbiAgICogSGFuZGxlcyBib3RoIHJlZ2lzdHJhdGlvbiAoY3JlYXRlKSBhbmQgYXV0aGVudGljYXRpb24gKHJlcXVlc3QpIGZsb3dzLlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICogQHBhcmFtIHtNRkFDaGFsbGVuZ2VXZWJhdXRoblBhcmFtcyAmIHsgZnJpZW5kbHlOYW1lPzogc3RyaW5nOyBzaWduYWw/OiBBYm9ydFNpZ25hbCB9fSBwYXJhbXMgLSBDaGFsbGVuZ2UgcGFyYW1ldGVycyBpbmNsdWRpbmcgZmFjdG9ySWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyAtIEFsbG93cyB5b3UgdG8gb3ZlcnJpZGUgdGhlIHBhcmFtZXRlcnMgcGFzc2VkIHRvIG5hdmlnYXRvci5jcmVkZW50aWFsc1xuICAgKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcy5jcmVhdGUgLSBPdmVycmlkZSBvcHRpb25zIGZvciBjcmVkZW50aWFsIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBvdmVycmlkZXMucmVxdWVzdCAtIE92ZXJyaWRlIG9wdGlvbnMgZm9yIGNyZWRlbnRpYWwgcmVxdWVzdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXF1ZXN0UmVzdWx0Pn0gQ2hhbGxlbmdlIHJlc3BvbnNlIHdpdGggY3JlZGVudGlhbCBvciBlcnJvclxuICAgKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tY3JlZGVudGlhbC1jcmVhdGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIENyZWRlbnRpYWwgQ3JlYXRpb259XG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi12ZXJpZnlpbmctYXNzZXJ0aW9uIFczQyBXZWJBdXRobiBTcGVjIC0gVmVyaWZ5aW5nIEFzc2VydGlvbn1cbiAgICovXG4gIHB1YmxpYyBhc3luYyBfY2hhbGxlbmdlKFxuICAgIHtcbiAgICAgIGZhY3RvcklkLFxuICAgICAgd2ViYXV0aG4sXG4gICAgICBmcmllbmRseU5hbWUsXG4gICAgICBzaWduYWwsXG4gICAgfTogTUZBQ2hhbGxlbmdlV2ViYXV0aG5QYXJhbXMgJiB7IGZyaWVuZGx5TmFtZT86IHN0cmluZzsgc2lnbmFsPzogQWJvcnRTaWduYWwgfSxcbiAgICBvdmVycmlkZXM/OlxuICAgICAgfCB7XG4gICAgICAgICAgY3JlYXRlPzogUGFydGlhbDxQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlPlxuICAgICAgICAgIHJlcXVlc3Q/OiBuZXZlclxuICAgICAgICB9XG4gICAgICB8IHtcbiAgICAgICAgICBjcmVhdGU/OiBuZXZlclxuICAgICAgICAgIHJlcXVlc3Q/OiBQYXJ0aWFsPFB1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZT5cbiAgICAgICAgfVxuICApOiBQcm9taXNlPFxuICAgIFJlcXVlc3RSZXN1bHQ8XG4gICAgICB7IGZhY3RvcklkOiBzdHJpbmc7IGNoYWxsZW5nZUlkOiBzdHJpbmcgfSAmIHtcbiAgICAgICAgd2ViYXV0aG46IFN0cmljdE9taXQ8XG4gICAgICAgICAgTUZBVmVyaWZ5V2ViYXV0aG5QYXJhbUZpZWxkczwnY3JlYXRlJyB8ICdyZXF1ZXN0Jz5bJ3dlYmF1dGhuJ10sXG4gICAgICAgICAgJ3JwSWQnIHwgJ3JwT3JpZ2lucydcbiAgICAgICAgPlxuICAgICAgfSxcbiAgICAgIFdlYkF1dGhuRXJyb3IgfCBBdXRoRXJyb3JcbiAgICA+XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY2hhbGxlbmdlIGZyb20gc2VydmVyIHVzaW5nIHRoZSBjbGllbnQncyBNRkEgbWV0aG9kc1xuICAgICAgY29uc3QgeyBkYXRhOiBjaGFsbGVuZ2VSZXNwb25zZSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5tZmEuY2hhbGxlbmdlKHtcbiAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgIHdlYmF1dGhuLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFjaGFsbGVuZ2VSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBhYm9ydFNpZ25hbCA9IHNpZ25hbCA/PyB3ZWJBdXRobkFib3J0U2VydmljZS5jcmVhdGVOZXdBYm9ydFNpZ25hbCgpXG5cbiAgICAgIC8qKiB3ZWJhdXRobiB3aWxsIGZhaWwgaWYgZWl0aGVyIG9mIHRoZSBuYW1lL2Rpc3BsYXluYW1lIGFyZSBibGFuayAqL1xuICAgICAgaWYgKGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLnR5cGUgPT09ICdjcmVhdGUnKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlciB9ID0gY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zLnB1YmxpY0tleVxuICAgICAgICBpZiAoIXVzZXIubmFtZSkge1xuICAgICAgICAgIC8vIFByZXNlcnZlIG9yaWdpbmFsIGZvcm1hdDogdXNlIGZyaWVuZGx5TmFtZSBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIGZldGNoIGZhbGxiYWNrXG4gICAgICAgICAgLy8gVGhpcyBtYWludGFpbnMgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSAke3VzZXIuaWR9OiR7bmFtZX0gZm9ybWF0XG4gICAgICAgICAgY29uc3QgbmFtZVRvVXNlID0gZnJpZW5kbHlOYW1lXG4gICAgICAgICAgaWYgKCFuYW1lVG9Vc2UpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgZmV0Y2ggdXNlciBkYXRhIGlmIGZyaWVuZGx5TmFtZSBpcyBub3QgcHJvdmlkZWQgKGJ1ZyBmaXggZm9yIG51bGwgZnJpZW5kbHlOYW1lKVxuICAgICAgICAgICAgY29uc3QgY3VycmVudFVzZXIgPSBhd2FpdCB0aGlzLmNsaWVudC5nZXRVc2VyKClcbiAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0gY3VycmVudFVzZXIuZGF0YS51c2VyXG4gICAgICAgICAgICBjb25zdCBmYWxsYmFja05hbWUgPVxuICAgICAgICAgICAgICB1c2VyRGF0YT8udXNlcl9tZXRhZGF0YT8ubmFtZSB8fCB1c2VyRGF0YT8uZW1haWwgfHwgdXNlckRhdGE/LmlkIHx8ICdVc2VyJ1xuICAgICAgICAgICAgdXNlci5uYW1lID0gYCR7dXNlci5pZH06JHtmYWxsYmFja05hbWV9YFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1c2VyLm5hbWUgPSBgJHt1c2VyLmlkfToke25hbWVUb1VzZX1gXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdXNlci5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgIHVzZXIuZGlzcGxheU5hbWUgPSB1c2VyLm5hbWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY3JlYXRlJzoge1xuICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMoXG4gICAgICAgICAgICBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMucHVibGljS2V5LFxuICAgICAgICAgICAgb3ZlcnJpZGVzPy5jcmVhdGVcbiAgICAgICAgICApXG5cbiAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjcmVhdGVDcmVkZW50aWFsKHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogb3B0aW9ucyxcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRTaWduYWwsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZVJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlLFxuICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9yZXNwb25zZTogZGF0YSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVxdWVzdCc6IHtcbiAgICAgICAgICBjb25zdCBvcHRpb25zID0gbWVyZ2VDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMoXG4gICAgICAgICAgICBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMucHVibGljS2V5LFxuICAgICAgICAgICAgb3ZlcnJpZGVzPy5yZXF1ZXN0XG4gICAgICAgICAgKVxuXG4gICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgZ2V0Q3JlZGVudGlhbCh7XG4gICAgICAgICAgICAuLi5jaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IG9wdGlvbnMsXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgICAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2VSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICB3ZWJhdXRobjoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4udHlwZSxcbiAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxfcmVzcG9uc2U6IGRhdGEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiBjaGFsbGVuZ2UnLCBlcnJvciksXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBhIFdlYkF1dGhuIGNyZWRlbnRpYWwgd2l0aCB0aGUgc2VydmVyLlxuICAgKiBDb21wbGV0ZXMgdGhlIFdlYkF1dGhuIGNlcmVtb255IGJ5IHNlbmRpbmcgdGhlIGNyZWRlbnRpYWwgdG8gdGhlIHNlcnZlciBmb3IgdmVyaWZpY2F0aW9uLlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFZlcmlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhbGxlbmdlSWQgLSBJRCBvZiB0aGUgY2hhbGxlbmdlIGJlaW5nIHZlcmlmaWVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZmFjdG9ySWQgLSBJRCBvZiB0aGUgV2ViQXV0aG4gZmFjdG9yXG4gICAqIEBwYXJhbSB7TUZBVmVyaWZ5V2ViYXV0aG5QYXJhbXM8VD5bJ3dlYmF1dGhuJ119IHBhcmFtcy53ZWJhdXRobiAtIFdlYkF1dGhuIGNyZWRlbnRpYWwgcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2U8QXV0aE1GQVZlcmlmeVJlc3BvbnNlPn0gVmVyaWZpY2F0aW9uIHJlc3VsdCB3aXRoIHNlc3Npb24gb3IgZXJyb3JcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXZlcmlmeWluZy1hc3NlcnRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBWZXJpZnlpbmcgYW4gQXV0aGVudGljYXRpb24gQXNzZXJ0aW9ufVxuICAgKiAqL1xuICBwdWJsaWMgYXN5bmMgX3ZlcmlmeTxUIGV4dGVuZHMgJ2NyZWF0ZScgfCAncmVxdWVzdCc+KHtcbiAgICBjaGFsbGVuZ2VJZCxcbiAgICBmYWN0b3JJZCxcbiAgICB3ZWJhdXRobixcbiAgfToge1xuICAgIGNoYWxsZW5nZUlkOiBzdHJpbmdcbiAgICBmYWN0b3JJZDogc3RyaW5nXG4gICAgd2ViYXV0aG46IE1GQVZlcmlmeVdlYmF1dGhuUGFyYW1zPFQ+Wyd3ZWJhdXRobiddXG4gIH0pOiBQcm9taXNlPEF1dGhNRkFWZXJpZnlSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5tZmEudmVyaWZ5KHtcbiAgICAgIGZhY3RvcklkLFxuICAgICAgY2hhbGxlbmdlSWQsXG4gICAgICB3ZWJhdXRobjogd2ViYXV0aG4sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSBXZWJBdXRobiBhdXRoZW50aWNhdGlvbiBmbG93LlxuICAgKiBQZXJmb3JtcyBjaGFsbGVuZ2UgYW5kIHZlcmlmaWNhdGlvbiBpbiBhIHNpbmdsZSBvcGVyYXRpb24gZm9yIGV4aXN0aW5nIGNyZWRlbnRpYWxzLlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIEF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mYWN0b3JJZCAtIElEIG9mIHRoZSBXZWJBdXRobiBmYWN0b3IgdG8gYXV0aGVudGljYXRlIHdpdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy53ZWJhdXRobiAtIFdlYkF1dGhuIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy53ZWJhdXRobi5ycElkIC0gUmVseWluZyBQYXJ0eSBJRCAoZGVmYXVsdHMgdG8gY3VycmVudCBob3N0bmFtZSlcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLndlYmF1dGhuLnJwT3JpZ2lucyAtIEFsbG93ZWQgb3JpZ2lucyAoZGVmYXVsdHMgdG8gY3VycmVudCBvcmlnaW4pXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IHBhcmFtcy53ZWJhdXRobi5zaWduYWwgLSBPcHRpb25hbCBhYm9ydCBzaWduYWxcbiAgICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcyAtIE92ZXJyaWRlIG9wdGlvbnMgZm9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXRcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVxdWVzdFJlc3VsdDxBdXRoTUZBVmVyaWZ5UmVzcG9uc2VEYXRhLCBXZWJBdXRobkVycm9yIHwgQXV0aEVycm9yPj59IEF1dGhlbnRpY2F0aW9uIHJlc3VsdFxuICAgKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tYXV0aGVudGljYXRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBBdXRoZW50aWNhdGlvbiBDZXJlbW9ueX1cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyBNRE4gLSBQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnN9XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgX2F1dGhlbnRpY2F0ZShcbiAgICB7XG4gICAgICBmYWN0b3JJZCxcbiAgICAgIHdlYmF1dGhuOiB7XG4gICAgICAgIHJwSWQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgcnBPcmlnaW5zID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBbd2luZG93LmxvY2F0aW9uLm9yaWdpbl0gOiB1bmRlZmluZWQsXG4gICAgICAgIHNpZ25hbCxcbiAgICAgIH0gPSB7fSxcbiAgICB9OiB7XG4gICAgICBmYWN0b3JJZDogc3RyaW5nXG4gICAgICB3ZWJhdXRobj86IHtcbiAgICAgICAgcnBJZD86IHN0cmluZ1xuICAgICAgICBycE9yaWdpbnM/OiBzdHJpbmdbXVxuICAgICAgICBzaWduYWw/OiBBYm9ydFNpZ25hbFxuICAgICAgfVxuICAgIH0sXG4gICAgb3ZlcnJpZGVzPzogUHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlXG4gICk6IFByb21pc2U8UmVxdWVzdFJlc3VsdDxBdXRoTUZBVmVyaWZ5UmVzcG9uc2VEYXRhLCBXZWJBdXRobkVycm9yIHwgQXV0aEVycm9yPj4ge1xuICAgIGlmICghcnBJZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IG5ldyBBdXRoRXJyb3IoJ3JwSWQgaXMgcmVxdWlyZWQgZm9yIFdlYkF1dGhuIGF1dGhlbnRpY2F0aW9uJyksXG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAoIWJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuKCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkF1dGhuJywgbnVsbCksXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGNoYWxsZW5nZSBhbmQgY3JlZGVudGlhbFxuICAgICAgY29uc3QgeyBkYXRhOiBjaGFsbGVuZ2VSZXNwb25zZSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLmNoYWxsZW5nZShcbiAgICAgICAge1xuICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgIHdlYmF1dGhuOiB7IHJwSWQsIHJwT3JpZ2lucyB9LFxuICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgfSxcbiAgICAgICAgeyByZXF1ZXN0OiBvdmVycmlkZXMgfVxuICAgICAgKVxuXG4gICAgICBpZiAoIWNoYWxsZW5nZVJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgd2ViYXV0aG4gfSA9IGNoYWxsZW5nZVJlc3BvbnNlXG5cbiAgICAgIC8vIFZlcmlmeSBjcmVkZW50aWFsXG4gICAgICByZXR1cm4gdGhpcy5fdmVyaWZ5KHtcbiAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2VSZXNwb25zZS5jaGFsbGVuZ2VJZCxcbiAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICB0eXBlOiB3ZWJhdXRobi50eXBlLFxuICAgICAgICAgIHJwSWQsXG4gICAgICAgICAgcnBPcmlnaW5zLFxuICAgICAgICAgIGNyZWRlbnRpYWxfcmVzcG9uc2U6IHdlYmF1dGhuLmNyZWRlbnRpYWxfcmVzcG9uc2UsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiBhdXRoZW50aWNhdGUnLCBlcnJvciksXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlIFdlYkF1dGhuIHJlZ2lzdHJhdGlvbiBmbG93LlxuICAgKiBQZXJmb3JtcyBlbnJvbGxtZW50LCBjaGFsbGVuZ2UsIGFuZCB2ZXJpZmljYXRpb24gaW4gYSBzaW5nbGUgb3BlcmF0aW9uIGZvciBuZXcgY3JlZGVudGlhbHMuXG4gICAqXG4gICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gUmVnaXN0cmF0aW9uIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mcmllbmRseU5hbWUgLSBVc2VyLWZyaWVuZGx5IG5hbWUgZm9yIHRoZSBjcmVkZW50aWFsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucnBJZCAtIFJlbHlpbmcgUGFydHkgSUQgKGRlZmF1bHRzIHRvIGN1cnJlbnQgaG9zdG5hbWUpXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5ycE9yaWdpbnMgLSBBbGxvd2VkIG9yaWdpbnMgKGRlZmF1bHRzIHRvIGN1cnJlbnQgb3JpZ2luKVxuICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBwYXJhbXMuc2lnbmFsIC0gT3B0aW9uYWwgYWJvcnQgc2lnbmFsXG4gICAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzIC0gT3ZlcnJpZGUgb3B0aW9ucyBmb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXF1ZXN0UmVzdWx0PEF1dGhNRkFWZXJpZnlSZXNwb25zZURhdGEsIFdlYkF1dGhuRXJyb3IgfCBBdXRoRXJyb3I+Pn0gUmVnaXN0cmF0aW9uIHJlc3VsdFxuICAgKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tcmVnaXN0ZXJpbmctYS1uZXctY3JlZGVudGlhbCBXM0MgV2ViQXV0aG4gU3BlYyAtIFJlZ2lzdHJhdGlvbiBDZXJlbW9ueX1cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMgTUROIC0gUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc31cbiAgICovXG4gIHB1YmxpYyBhc3luYyBfcmVnaXN0ZXIoXG4gICAge1xuICAgICAgZnJpZW5kbHlOYW1lLFxuICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgcnBJZCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lIDogdW5kZWZpbmVkLFxuICAgICAgICBycE9yaWdpbnMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFt3aW5kb3cubG9jYXRpb24ub3JpZ2luXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2lnbmFsLFxuICAgICAgfSA9IHt9LFxuICAgIH06IHtcbiAgICAgIGZyaWVuZGx5TmFtZTogc3RyaW5nXG4gICAgICB3ZWJhdXRobj86IHtcbiAgICAgICAgcnBJZD86IHN0cmluZ1xuICAgICAgICBycE9yaWdpbnM/OiBzdHJpbmdbXVxuICAgICAgICBzaWduYWw/OiBBYm9ydFNpZ25hbFxuICAgICAgfVxuICAgIH0sXG4gICAgb3ZlcnJpZGVzPzogUGFydGlhbDxQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlPlxuICApOiBQcm9taXNlPFJlcXVlc3RSZXN1bHQ8QXV0aE1GQVZlcmlmeVJlc3BvbnNlRGF0YSwgV2ViQXV0aG5FcnJvciB8IEF1dGhFcnJvcj4+IHtcbiAgICBpZiAoIXJwSWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiBuZXcgQXV0aEVycm9yKCdycElkIGlzIHJlcXVpcmVkIGZvciBXZWJBdXRobiByZWdpc3RyYXRpb24nKSxcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICghYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4oKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViQXV0aG4nLCBudWxsKSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBFbnJvbGwgZmFjdG9yXG4gICAgICBjb25zdCB7IGRhdGE6IGZhY3RvciwgZXJyb3I6IGVucm9sbEVycm9yIH0gPSBhd2FpdCB0aGlzLl9lbnJvbGwoe1xuICAgICAgICBmcmllbmRseU5hbWUsXG4gICAgICB9KVxuXG4gICAgICBpZiAoIWZhY3Rvcikge1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5tZmFcbiAgICAgICAgICAubGlzdEZhY3RvcnMoKVxuICAgICAgICAgIC50aGVuKChmYWN0b3JzKSA9PlxuICAgICAgICAgICAgZmFjdG9ycy5kYXRhPy5hbGwuZmluZChcbiAgICAgICAgICAgICAgKHYpID0+XG4gICAgICAgICAgICAgICAgdi5mYWN0b3JfdHlwZSA9PT0gJ3dlYmF1dGhuJyAmJlxuICAgICAgICAgICAgICAgIHYuZnJpZW5kbHlfbmFtZSA9PT0gZnJpZW5kbHlOYW1lICYmXG4gICAgICAgICAgICAgICAgdi5zdGF0dXMgIT09ICd1bnZlcmlmaWVkJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgICAudGhlbigoZmFjdG9yKSA9PiAoZmFjdG9yID8gdGhpcy5jbGllbnQubWZhLnVuZW5yb2xsKHsgZmFjdG9ySWQ6IGZhY3Rvcj8uaWQgfSkgOiB2b2lkIDApKVxuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogZW5yb2xsRXJyb3IgfVxuICAgICAgfVxuXG4gICAgICAvLyBHZXQgY2hhbGxlbmdlIGFuZCBjcmVhdGUgY3JlZGVudGlhbFxuICAgICAgY29uc3QgeyBkYXRhOiBjaGFsbGVuZ2VSZXNwb25zZSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLl9jaGFsbGVuZ2UoXG4gICAgICAgIHtcbiAgICAgICAgICBmYWN0b3JJZDogZmFjdG9yLmlkLFxuICAgICAgICAgIGZyaWVuZGx5TmFtZTogZmFjdG9yLmZyaWVuZGx5X25hbWUsXG4gICAgICAgICAgd2ViYXV0aG46IHsgcnBJZCwgcnBPcmlnaW5zIH0sXG4gICAgICAgICAgc2lnbmFsLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY3JlYXRlOiBvdmVycmlkZXMsXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgICAgaWYgKCFjaGFsbGVuZ2VSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fdmVyaWZ5KHtcbiAgICAgICAgZmFjdG9ySWQ6IGZhY3Rvci5pZCxcbiAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZVJlc3BvbnNlLmNoYWxsZW5nZUlkLFxuICAgICAgICB3ZWJhdXRobjoge1xuICAgICAgICAgIHJwSWQsXG4gICAgICAgICAgcnBPcmlnaW5zLFxuICAgICAgICAgIHR5cGU6IGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLnR5cGUsXG4gICAgICAgICAgY3JlZGVudGlhbF9yZXNwb25zZTogY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4uY3JlZGVudGlhbF9yZXNwb25zZSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGluIHJlZ2lzdGVyJywgZXJyb3IpLFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJ1xuaW1wb3J0IHtcbiAgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMsXG4gIEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCxcbiAgREVGQVVMVF9IRUFERVJTLFxuICBFWFBJUllfTUFSR0lOX01TLFxuICBHT1RSVUVfVVJMLFxuICBKV0tTX1RUTCxcbiAgU1RPUkFHRV9LRVksXG59IGZyb20gJy4vbGliL2NvbnN0YW50cydcbmltcG9ydCB7XG4gIEF1dGhFcnJvcixcbiAgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yLFxuICBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IsXG4gIEF1dGhJbnZhbGlkSnd0RXJyb3IsXG4gIEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yLFxuICBBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvcixcbiAgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yLFxuICBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcixcbiAgQXV0aFVua25vd25FcnJvcixcbiAgaXNBdXRoQXBpRXJyb3IsXG4gIGlzQXV0aEVycm9yLFxuICBpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcixcbiAgaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcixcbiAgaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcixcbn0gZnJvbSAnLi9saWIvZXJyb3JzJ1xuaW1wb3J0IHtcbiAgRmV0Y2gsXG4gIF9yZXF1ZXN0LFxuICBfc2Vzc2lvblJlc3BvbnNlLFxuICBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gIF9zc29SZXNwb25zZSxcbiAgX3VzZXJSZXNwb25zZSxcbn0gZnJvbSAnLi9saWIvZmV0Y2gnXG5pbXBvcnQge1xuICBkZWNvZGVKV1QsXG4gIGRlZXBDbG9uZSxcbiAgRGVmZXJyZWQsXG4gIGdlbmVyYXRlQ2FsbGJhY2tJZCxcbiAgZ2V0QWxnb3JpdGhtLFxuICBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kLFxuICBnZXRJdGVtQXN5bmMsXG4gIGluc2VjdXJlVXNlcldhcm5pbmdQcm94eSxcbiAgaXNCcm93c2VyLFxuICBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMLFxuICByZW1vdmVJdGVtQXN5bmMsXG4gIHJlc29sdmVGZXRjaCxcbiAgcmV0cnlhYmxlLFxuICBzZXRJdGVtQXN5bmMsXG4gIHNsZWVwLFxuICBzdXBwb3J0c0xvY2FsU3RvcmFnZSxcbiAgdXNlck5vdEF2YWlsYWJsZVByb3h5LFxuICB2YWxpZGF0ZUV4cCxcbn0gZnJvbSAnLi9saWIvaGVscGVycydcbmltcG9ydCB7IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2xpYi9sb2NhbC1zdG9yYWdlJ1xuaW1wb3J0IHsgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IsIG5hdmlnYXRvckxvY2sgfSBmcm9tICcuL2xpYi9sb2NrcydcbmltcG9ydCB7IHBvbHlmaWxsR2xvYmFsVGhpcyB9IGZyb20gJy4vbGliL3BvbHlmaWxscydcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL2xpYi92ZXJzaW9uJ1xuXG5pbXBvcnQgeyBieXRlc1RvQmFzZTY0VVJMLCBzdHJpbmdUb1VpbnQ4QXJyYXkgfSBmcm9tICcuL2xpYi9iYXNlNjR1cmwnXG5pbXBvcnQgdHlwZSB7XG4gIEF1dGhDaGFuZ2VFdmVudCxcbiAgQXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVscyxcbiAgQXV0aEZsb3dUeXBlLFxuICBBdXRoTUZBQ2hhbGxlbmdlUGhvbmVSZXNwb25zZSxcbiAgQXV0aE1GQUNoYWxsZW5nZVJlc3BvbnNlLFxuICBBdXRoTUZBQ2hhbGxlbmdlVE9UUFJlc3BvbnNlLFxuICBBdXRoTUZBQ2hhbGxlbmdlV2ViYXV0aG5SZXNwb25zZSxcbiAgQXV0aE1GQUNoYWxsZW5nZVdlYmF1dGhuU2VydmVyUmVzcG9uc2UsXG4gIEF1dGhNRkFFbnJvbGxQaG9uZVJlc3BvbnNlLFxuICBBdXRoTUZBRW5yb2xsUmVzcG9uc2UsXG4gIEF1dGhNRkFFbnJvbGxUT1RQUmVzcG9uc2UsXG4gIEF1dGhNRkFFbnJvbGxXZWJhdXRoblJlc3BvbnNlLFxuICBBdXRoTUZBR2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsUmVzcG9uc2UsXG4gIEF1dGhNRkFMaXN0RmFjdG9yc1Jlc3BvbnNlLFxuICBBdXRoTUZBVW5lbnJvbGxSZXNwb25zZSxcbiAgQXV0aE1GQVZlcmlmeVJlc3BvbnNlLFxuICBBdXRoT3RwUmVzcG9uc2UsXG4gIEF1dGhSZXNwb25zZSxcbiAgQXV0aFJlc3BvbnNlUGFzc3dvcmQsXG4gIEF1dGhUb2tlblJlc3BvbnNlLFxuICBBdXRoVG9rZW5SZXNwb25zZVBhc3N3b3JkLFxuICBDYWxsUmVmcmVzaFRva2VuUmVzdWx0LFxuICBFdGhlcmV1bVdhbGxldCxcbiAgRXRoZXJldW1XZWIzQ3JlZGVudGlhbHMsXG4gIEZhY3RvcixcbiAgR29UcnVlQ2xpZW50T3B0aW9ucyxcbiAgR29UcnVlTUZBQXBpLFxuICBJbml0aWFsaXplUmVzdWx0LFxuICBKV0ssXG4gIEp3dEhlYWRlcixcbiAgSnd0UGF5bG9hZCxcbiAgTG9ja0Z1bmMsXG4gIE1GQUNoYWxsZW5nZUFuZFZlcmlmeVBhcmFtcyxcbiAgTUZBQ2hhbGxlbmdlUGFyYW1zLFxuICBNRkFDaGFsbGVuZ2VQaG9uZVBhcmFtcyxcbiAgTUZBQ2hhbGxlbmdlVE9UUFBhcmFtcyxcbiAgTUZBQ2hhbGxlbmdlV2ViYXV0aG5QYXJhbXMsXG4gIE1GQUVucm9sbFBhcmFtcyxcbiAgTUZBRW5yb2xsUGhvbmVQYXJhbXMsXG4gIE1GQUVucm9sbFRPVFBQYXJhbXMsXG4gIE1GQUVucm9sbFdlYmF1dGhuUGFyYW1zLFxuICBNRkFVbmVucm9sbFBhcmFtcyxcbiAgTUZBVmVyaWZ5UGFyYW1zLFxuICBNRkFWZXJpZnlQaG9uZVBhcmFtcyxcbiAgTUZBVmVyaWZ5VE9UUFBhcmFtcyxcbiAgTUZBVmVyaWZ5V2ViYXV0aG5QYXJhbUZpZWxkcyxcbiAgTUZBVmVyaWZ5V2ViYXV0aG5QYXJhbXMsXG4gIE9BdXRoUmVzcG9uc2UsXG4gIEF1dGhPQXV0aFNlcnZlckFwaSxcbiAgQXV0aE9BdXRoQXV0aG9yaXphdGlvbkRldGFpbHNSZXNwb25zZSxcbiAgQXV0aE9BdXRoQ29uc2VudFJlc3BvbnNlLFxuICBBdXRoT0F1dGhHcmFudHNSZXNwb25zZSxcbiAgQXV0aE9BdXRoUmV2b2tlR3JhbnRSZXNwb25zZSxcbiAgUHJldHRpZnksXG4gIFByb3ZpZGVyLFxuICBSZXNlbmRQYXJhbXMsXG4gIFNlc3Npb24sXG4gIFNpZ25JbkFub255bW91c2x5Q3JlZGVudGlhbHMsXG4gIFNpZ25JbldpdGhJZFRva2VuQ3JlZGVudGlhbHMsXG4gIFNpZ25JbldpdGhPQXV0aENyZWRlbnRpYWxzLFxuICBTaWduSW5XaXRoUGFzc3dvcmRDcmVkZW50aWFscyxcbiAgU2lnbkluV2l0aFBhc3N3b3JkbGVzc0NyZWRlbnRpYWxzLFxuICBTaWduSW5XaXRoU1NPLFxuICBTaWduT3V0LFxuICBTaWduVXBXaXRoUGFzc3dvcmRDcmVkZW50aWFscyxcbiAgU29sYW5hV2FsbGV0LFxuICBTb2xhbmFXZWIzQ3JlZGVudGlhbHMsXG4gIFNTT1Jlc3BvbnNlLFxuICBTdHJpY3RPbWl0LFxuICBTdWJzY3JpcHRpb24sXG4gIFN1cHBvcnRlZFN0b3JhZ2UsXG4gIFVzZXIsXG4gIFVzZXJBdHRyaWJ1dGVzLFxuICBVc2VySWRlbnRpdHksXG4gIFVzZXJSZXNwb25zZSxcbiAgVmVyaWZ5T3RwUGFyYW1zLFxuICBXZWIzQ3JlZGVudGlhbHMsXG59IGZyb20gJy4vbGliL3R5cGVzJ1xuaW1wb3J0IHtcbiAgY3JlYXRlU2l3ZU1lc3NhZ2UsXG4gIGZyb21IZXgsXG4gIGdldEFkZHJlc3MsXG4gIEhleCxcbiAgU2l3ZU1lc3NhZ2UsXG4gIHRvSGV4LFxufSBmcm9tICcuL2xpYi93ZWIzL2V0aGVyZXVtJ1xuaW1wb3J0IHtcbiAgZGVzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zLFxuICBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyxcbiAgc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uUmVzcG9uc2UsXG4gIHNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UsXG4gIFdlYkF1dGhuQXBpLFxufSBmcm9tICcuL2xpYi93ZWJhdXRobidcbmltcG9ydCB7XG4gIEF1dGhlbnRpY2F0aW9uQ3JlZGVudGlhbCxcbiAgUHVibGljS2V5Q3JlZGVudGlhbEpTT04sXG4gIFJlZ2lzdHJhdGlvbkNyZWRlbnRpYWwsXG59IGZyb20gJy4vbGliL3dlYmF1dGhuLmRvbSdcblxucG9seWZpbGxHbG9iYWxUaGlzKCkgLy8gTWFrZSBcImdsb2JhbFRoaXNcIiBhdmFpbGFibGVcblxuY29uc3QgREVGQVVMVF9PUFRJT05TOiBPbWl0PFxuICBSZXF1aXJlZDxHb1RydWVDbGllbnRPcHRpb25zPixcbiAgJ2ZldGNoJyB8ICdzdG9yYWdlJyB8ICd1c2VyU3RvcmFnZScgfCAnbG9jaydcbj4gPSB7XG4gIHVybDogR09UUlVFX1VSTCxcbiAgc3RvcmFnZUtleTogU1RPUkFHRV9LRVksXG4gIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gIGhlYWRlcnM6IERFRkFVTFRfSEVBREVSUyxcbiAgZmxvd1R5cGU6ICdpbXBsaWNpdCcsXG4gIGRlYnVnOiBmYWxzZSxcbiAgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjogZmFsc2UsXG4gIHRocm93T25FcnJvcjogZmFsc2UsXG4gIGxvY2tBY3F1aXJlVGltZW91dDogMTAwMDAsIC8vIDEwIHNlY29uZHNcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9ja05vT3A8Uj4obmFtZTogc3RyaW5nLCBhY3F1aXJlVGltZW91dDogbnVtYmVyLCBmbjogKCkgPT4gUHJvbWlzZTxSPik6IFByb21pc2U8Uj4ge1xuICByZXR1cm4gYXdhaXQgZm4oKVxufVxuXG4vKipcbiAqIENhY2hlcyBKV0tTIHZhbHVlcyBmb3IgYWxsIGNsaWVudHMgY3JlYXRlZCBpbiB0aGUgc2FtZSBlbnZpcm9ubWVudC4gVGhpcyBpc1xuICogZXNwZWNpYWxseSB1c2VmdWwgZm9yIHNoYXJlZC1tZW1vcnkgZXhlY3V0aW9uIGVudmlyb25tZW50cyBzdWNoIGFzIFZlcmNlbCdzXG4gKiBGbHVpZCBDb21wdXRlLCBBV1MgTGFtYmRhIG9yIFN1cGFiYXNlJ3MgRWRnZSBGdW5jdGlvbnMuIFJlZ2FyZGxlc3Mgb2YgaG93XG4gKiBtYW55IGNsaWVudHMgYXJlIGNyZWF0ZWQsIGlmIHRoZXkgc2hhcmUgdGhlIHNhbWUgc3RvcmFnZSBrZXkgdGhleSB3aWxsIHVzZVxuICogdGhlIHNhbWUgSldLUyBjYWNoZSwgc2lnbmlmaWNhbnRseSBzcGVlZGluZyB1cCBnZXRDbGFpbXMoKSB3aXRoIGFzeW1tZXRyaWNcbiAqIEpXVHMuXG4gKi9cbmNvbnN0IEdMT0JBTF9KV0tTOiB7IFtzdG9yYWdlS2V5OiBzdHJpbmddOiB7IGNhY2hlZEF0OiBudW1iZXI7IGp3a3M6IHsga2V5czogSldLW10gfSB9IH0gPSB7fVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb1RydWVDbGllbnQge1xuICBwcml2YXRlIHN0YXRpYyBuZXh0SW5zdGFuY2VJRDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9XG5cbiAgcHJpdmF0ZSBpbnN0YW5jZUlEOiBudW1iZXJcblxuICAvKipcbiAgICogTmFtZXNwYWNlIGZvciB0aGUgR29UcnVlIGFkbWluIG1ldGhvZHMuXG4gICAqIFRoZXNlIG1ldGhvZHMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiBhIHRydXN0ZWQgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQuXG4gICAqL1xuICBhZG1pbjogR29UcnVlQWRtaW5BcGlcbiAgLyoqXG4gICAqIE5hbWVzcGFjZSBmb3IgdGhlIE1GQSBtZXRob2RzLlxuICAgKi9cbiAgbWZhOiBHb1RydWVNRkFBcGlcbiAgLyoqXG4gICAqIE5hbWVzcGFjZSBmb3IgdGhlIE9BdXRoIDIuMSBhdXRob3JpemF0aW9uIHNlcnZlciBtZXRob2RzLlxuICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgKiBVc2VkIHRvIGltcGxlbWVudCB0aGUgYXV0aG9yaXphdGlvbiBjb2RlIGZsb3cgb24gdGhlIGNvbnNlbnQgcGFnZS5cbiAgICovXG4gIG9hdXRoOiBBdXRoT0F1dGhTZXJ2ZXJBcGlcbiAgLyoqXG4gICAqIFRoZSBzdG9yYWdlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB2YWx1ZXMgc2F2ZWQgaW4gbG9jYWxTdG9yYWdlXG4gICAqL1xuICBwcm90ZWN0ZWQgc3RvcmFnZUtleTogc3RyaW5nXG5cbiAgcHJvdGVjdGVkIGZsb3dUeXBlOiBBdXRoRmxvd1R5cGVcblxuICAvKipcbiAgICogVGhlIEpXS1MgdXNlZCBmb3IgdmVyaWZ5aW5nIGFzeW1tZXRyaWMgSldUc1xuICAgKi9cbiAgcHJvdGVjdGVkIGdldCBqd2tzKCkge1xuICAgIHJldHVybiBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldPy5qd2tzID8/IHsga2V5czogW10gfVxuICB9XG5cbiAgcHJvdGVjdGVkIHNldCBqd2tzKHZhbHVlOiB7IGtleXM6IEpXS1tdIH0pIHtcbiAgICBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldID0geyAuLi5HTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldLCBqd2tzOiB2YWx1ZSB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IGp3a3NfY2FjaGVkX2F0KCkge1xuICAgIHJldHVybiBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldPy5jYWNoZWRBdCA/PyBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxuICB9XG5cbiAgcHJvdGVjdGVkIHNldCBqd2tzX2NhY2hlZF9hdCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSA9IHsgLi4uR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSwgY2FjaGVkQXQ6IHZhbHVlIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhdXRvUmVmcmVzaFRva2VuOiBib29sZWFuXG4gIHByb3RlY3RlZCBwZXJzaXN0U2Vzc2lvbjogYm9vbGVhblxuICBwcm90ZWN0ZWQgc3RvcmFnZTogU3VwcG9ydGVkU3RvcmFnZVxuICAvKipcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgcHJvdGVjdGVkIHVzZXJTdG9yYWdlOiBTdXBwb3J0ZWRTdG9yYWdlIHwgbnVsbCA9IG51bGxcbiAgcHJvdGVjdGVkIG1lbW9yeVN0b3JhZ2U6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gfCBudWxsID0gbnVsbFxuICBwcm90ZWN0ZWQgc3RhdGVDaGFuZ2VFbWl0dGVyczogTWFwPHN0cmluZyB8IHN5bWJvbCwgU3Vic2NyaXB0aW9uPiA9IG5ldyBNYXAoKVxuICBwcm90ZWN0ZWQgYXV0b1JlZnJlc2hUaWNrZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPiB8IG51bGwgPSBudWxsXG4gIHByb3RlY3RlZCBhdXRvUmVmcmVzaFRpY2tUaW1lb3V0OiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IG51bGwgPSBudWxsXG4gIHByb3RlY3RlZCB2aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrOiAoKCkgPT4gUHJvbWlzZTxhbnk+KSB8IG51bGwgPSBudWxsXG4gIHByb3RlY3RlZCByZWZyZXNoaW5nRGVmZXJyZWQ6IERlZmVycmVkPENhbGxSZWZyZXNoVG9rZW5SZXN1bHQ+IHwgbnVsbCA9IG51bGxcbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBhc3luYyBjbGllbnQgaW5pdGlhbGl6YXRpb24uXG4gICAqIFdoZW4gbnVsbCBvciBub3QgeWV0IHJlc29sdmVkIHRoZSBhdXRoIHN0YXRlIGlzIGB1bmtub3duYFxuICAgKiBPbmNlIHJlc29sdmVkIHRoZSBhdXRoIHN0YXRlIGlzIGtub3duIGFuZCBpdCdzIHNhZmUgdG8gY2FsbCBhbnkgZnVydGhlciBjbGllbnQgbWV0aG9kcy5cbiAgICogS2VlcCBleHRyYSBjYXJlIHRvIG5ldmVyIHJlamVjdCBvciB0aHJvdyB1bmNhdWdodCBlcnJvcnNcbiAgICovXG4gIHByb3RlY3RlZCBpbml0aWFsaXplUHJvbWlzZTogUHJvbWlzZTxJbml0aWFsaXplUmVzdWx0PiB8IG51bGwgPSBudWxsXG4gIHByb3RlY3RlZCBkZXRlY3RTZXNzaW9uSW5Vcmw6XG4gICAgfCBib29sZWFuXG4gICAgfCAoKHVybDogVVJMLCBwYXJhbXM6IHsgW3BhcmFtZXRlcjogc3RyaW5nXTogc3RyaW5nIH0pID0+IGJvb2xlYW4pID0gdHJ1ZVxuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuICBwcm90ZWN0ZWQgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IGZhbHNlXG4gIHByb3RlY3RlZCBzdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gZmFsc2VcbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuICBwcm90ZWN0ZWQgbG9jazogTG9ja0Z1bmNcbiAgcHJvdGVjdGVkIGxvY2tBY3F1aXJlZCA9IGZhbHNlXG4gIHByb3RlY3RlZCBwZW5kaW5nSW5Mb2NrOiBQcm9taXNlPGFueT5bXSA9IFtdXG4gIHByb3RlY3RlZCB0aHJvd09uRXJyb3I6IGJvb2xlYW5cbiAgcHJvdGVjdGVkIGxvY2tBY3F1aXJlVGltZW91dDogbnVtYmVyXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gYnJvYWRjYXN0IHN0YXRlIGNoYW5nZSBldmVudHMgdG8gb3RoZXIgdGFicyBsaXN0ZW5pbmcuXG4gICAqL1xuICBwcm90ZWN0ZWQgYnJvYWRjYXN0Q2hhbm5lbDogQnJvYWRjYXN0Q2hhbm5lbCB8IG51bGwgPSBudWxsXG5cbiAgcHJvdGVjdGVkIGxvZ0RlYnVnTWVzc2FnZXM6IGJvb2xlYW5cbiAgcHJvdGVjdGVkIGxvZ2dlcjogKG1lc3NhZ2U6IHN0cmluZywgLi4uYXJnczogYW55W10pID0+IHZvaWQgPSBjb25zb2xlLmxvZ1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgY2xpZW50IGZvciB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7IEdvVHJ1ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICAgKlxuICAgKiBjb25zdCBhdXRoID0gbmV3IEdvVHJ1ZUNsaWVudCh7XG4gICAqICAgdXJsOiAnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL2F1dGgvdjEnLFxuICAgKiAgIGhlYWRlcnM6IHsgYXBpa2V5OiAncHVibGljLWFub24ta2V5JyB9LFxuICAgKiAgIHN0b3JhZ2VLZXk6ICdzdXBhYmFzZS1hdXRoJyxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBHb1RydWVDbGllbnRPcHRpb25zKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7IC4uLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9XG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gc2V0dGluZ3Muc3RvcmFnZUtleVxuXG4gICAgdGhpcy5pbnN0YW5jZUlEID0gR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEW3RoaXMuc3RvcmFnZUtleV0gPz8gMFxuICAgIEdvVHJ1ZUNsaWVudC5uZXh0SW5zdGFuY2VJRFt0aGlzLnN0b3JhZ2VLZXldID0gdGhpcy5pbnN0YW5jZUlEICsgMVxuXG4gICAgdGhpcy5sb2dEZWJ1Z01lc3NhZ2VzID0gISFzZXR0aW5ncy5kZWJ1Z1xuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuZGVidWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMubG9nZ2VyID0gc2V0dGluZ3MuZGVidWdcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbnN0YW5jZUlEID4gMCAmJiBpc0Jyb3dzZXIoKSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGAke3RoaXMuX2xvZ1ByZWZpeCgpfSBNdWx0aXBsZSBHb1RydWVDbGllbnQgaW5zdGFuY2VzIGRldGVjdGVkIGluIHRoZSBzYW1lIGJyb3dzZXIgY29udGV4dC4gSXQgaXMgbm90IGFuIGVycm9yLCBidXQgdGhpcyBzaG91bGQgYmUgYXZvaWRlZCBhcyBpdCBtYXkgcHJvZHVjZSB1bmRlZmluZWQgYmVoYXZpb3Igd2hlbiB1c2VkIGNvbmN1cnJlbnRseSB1bmRlciB0aGUgc2FtZSBzdG9yYWdlIGtleS5gXG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSlcbiAgICAgIGlmICh0aGlzLmxvZ0RlYnVnTWVzc2FnZXMpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtZXNzYWdlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucGVyc2lzdFNlc3Npb24gPSBzZXR0aW5ncy5wZXJzaXN0U2Vzc2lvblxuICAgIHRoaXMuYXV0b1JlZnJlc2hUb2tlbiA9IHNldHRpbmdzLmF1dG9SZWZyZXNoVG9rZW5cbiAgICB0aGlzLmFkbWluID0gbmV3IEdvVHJ1ZUFkbWluQXBpKHtcbiAgICAgIHVybDogc2V0dGluZ3MudXJsLFxuICAgICAgaGVhZGVyczogc2V0dGluZ3MuaGVhZGVycyxcbiAgICAgIGZldGNoOiBzZXR0aW5ncy5mZXRjaCxcbiAgICB9KVxuXG4gICAgdGhpcy51cmwgPSBzZXR0aW5ncy51cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBzZXR0aW5ncy5oZWFkZXJzXG4gICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChzZXR0aW5ncy5mZXRjaClcbiAgICB0aGlzLmxvY2sgPSBzZXR0aW5ncy5sb2NrIHx8IGxvY2tOb09wXG4gICAgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgPSBzZXR0aW5ncy5kZXRlY3RTZXNzaW9uSW5VcmxcbiAgICB0aGlzLmZsb3dUeXBlID0gc2V0dGluZ3MuZmxvd1R5cGVcbiAgICB0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIgPSBzZXR0aW5ncy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSBzZXR0aW5ncy50aHJvd09uRXJyb3JcbiAgICB0aGlzLmxvY2tBY3F1aXJlVGltZW91dCA9IHNldHRpbmdzLmxvY2tBY3F1aXJlVGltZW91dFxuXG4gICAgaWYgKHNldHRpbmdzLmxvY2spIHtcbiAgICAgIHRoaXMubG9jayA9IHNldHRpbmdzLmxvY2tcbiAgICB9IGVsc2UgaWYgKHRoaXMucGVyc2lzdFNlc3Npb24gJiYgaXNCcm93c2VyKCkgJiYgZ2xvYmFsVGhpcz8ubmF2aWdhdG9yPy5sb2Nrcykge1xuICAgICAgdGhpcy5sb2NrID0gbmF2aWdhdG9yTG9ja1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvY2sgPSBsb2NrTm9PcFxuICAgIH1cblxuICAgIGlmICghdGhpcy5qd2tzKSB7XG4gICAgICB0aGlzLmp3a3MgPSB7IGtleXM6IFtdIH1cbiAgICAgIHRoaXMuandrc19jYWNoZWRfYXQgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxuICAgIH1cblxuICAgIHRoaXMubWZhID0ge1xuICAgICAgdmVyaWZ5OiB0aGlzLl92ZXJpZnkuYmluZCh0aGlzKSxcbiAgICAgIGVucm9sbDogdGhpcy5fZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICB1bmVucm9sbDogdGhpcy5fdW5lbnJvbGwuYmluZCh0aGlzKSxcbiAgICAgIGNoYWxsZW5nZTogdGhpcy5fY2hhbGxlbmdlLmJpbmQodGhpcyksXG4gICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgIGNoYWxsZW5nZUFuZFZlcmlmeTogdGhpcy5fY2hhbGxlbmdlQW5kVmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICBnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWw6IHRoaXMuX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbC5iaW5kKHRoaXMpLFxuICAgICAgd2ViYXV0aG46IG5ldyBXZWJBdXRobkFwaSh0aGlzKSxcbiAgICB9XG5cbiAgICB0aGlzLm9hdXRoID0ge1xuICAgICAgZ2V0QXV0aG9yaXphdGlvbkRldGFpbHM6IHRoaXMuX2dldEF1dGhvcml6YXRpb25EZXRhaWxzLmJpbmQodGhpcyksXG4gICAgICBhcHByb3ZlQXV0aG9yaXphdGlvbjogdGhpcy5fYXBwcm92ZUF1dGhvcml6YXRpb24uYmluZCh0aGlzKSxcbiAgICAgIGRlbnlBdXRob3JpemF0aW9uOiB0aGlzLl9kZW55QXV0aG9yaXphdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgbGlzdEdyYW50czogdGhpcy5fbGlzdE9BdXRoR3JhbnRzLmJpbmQodGhpcyksXG4gICAgICByZXZva2VHcmFudDogdGhpcy5fcmV2b2tlT0F1dGhHcmFudC5iaW5kKHRoaXMpLFxuICAgIH1cblxuICAgIGlmICh0aGlzLnBlcnNpc3RTZXNzaW9uKSB7XG4gICAgICBpZiAoc2V0dGluZ3Muc3RvcmFnZSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzZXR0aW5ncy5zdG9yYWdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0ge31cbiAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2V0dGluZ3MudXNlclN0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy51c2VyU3RvcmFnZSA9IHNldHRpbmdzLnVzZXJTdG9yYWdlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IHt9XG4gICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSlcbiAgICB9XG5cbiAgICBpZiAoaXNCcm93c2VyKCkgJiYgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsICYmIHRoaXMucGVyc2lzdFNlc3Npb24gJiYgdGhpcy5zdG9yYWdlS2V5KSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBuZXcgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsKHRoaXMuc3RvcmFnZUtleSlcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdGYWlsZWQgdG8gY3JlYXRlIGEgbmV3IEJyb2FkY2FzdENoYW5uZWwsIG11bHRpLXRhYiBzdGF0ZSBjaGFuZ2VzIHdpbGwgbm90IGJlIGF2YWlsYWJsZScsXG4gICAgICAgICAgZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbD8uYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWJ1ZygncmVjZWl2ZWQgYnJvYWRjYXN0IG5vdGlmaWNhdGlvbiBmcm9tIG90aGVyIHRhYiBvciBjbGllbnQnLCBldmVudClcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKGV2ZW50LmRhdGEuZXZlbnQsIGV2ZW50LmRhdGEuc2Vzc2lvbiwgZmFsc2UpIC8vIGJyb2FkY2FzdCA9IGZhbHNlIHNvIHdlIGRvbid0IGdldCBhbiBlbmRsZXNzIGxvb3Agb2YgbWVzc2FnZXNcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLl9kZWJ1ZygnI2Jyb2FkY2FzdENoYW5uZWwnLCAnZXJyb3InLCBlcnJvcilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWxpemUoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMuX2RlYnVnKCcjaW5pdGlhbGl6ZSgpJywgJ2Vycm9yJywgZXJyb3IpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgZXJyb3IgdGhyb3dpbmcgbW9kZSBpcyBlbmFibGVkIGZvciB0aGlzIGNsaWVudC5cbiAgICovXG4gIHB1YmxpYyBpc1Rocm93T25FcnJvckVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudGhyb3dPbkVycm9yXG4gIH1cblxuICAvKipcbiAgICogQ2VudHJhbGl6ZXMgcmV0dXJuIGhhbmRsaW5nIHdpdGggb3B0aW9uYWwgZXJyb3IgdGhyb3dpbmcuIFdoZW4gYHRocm93T25FcnJvcmAgaXMgZW5hYmxlZFxuICAgKiBhbmQgdGhlIHByb3ZpZGVkIHJlc3VsdCBjb250YWlucyBhIG5vbi1udWxsaXNoIGVycm9yLCB0aGUgZXJyb3IgaXMgdGhyb3duIGluc3RlYWQgb2ZcbiAgICogYmVpbmcgcmV0dXJuZWQuIFRoaXMgZW5zdXJlcyBjb25zaXN0ZW50IGJlaGF2aW9yIGFjcm9zcyBhbGwgcHVibGljIEFQSSBtZXRob2RzLlxuICAgKi9cbiAgcHJpdmF0ZSBfcmV0dXJuUmVzdWx0PFQgZXh0ZW5kcyB7IGVycm9yOiBhbnkgfT4ocmVzdWx0OiBUKTogVCB7XG4gICAgaWYgKHRoaXMudGhyb3dPbkVycm9yICYmIHJlc3VsdCAmJiByZXN1bHQuZXJyb3IpIHtcbiAgICAgIHRocm93IHJlc3VsdC5lcnJvclxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBwcml2YXRlIF9sb2dQcmVmaXgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKFxuICAgICAgJ0dvVHJ1ZUNsaWVudEAnICtcbiAgICAgIGAke3RoaXMuc3RvcmFnZUtleX06JHt0aGlzLmluc3RhbmNlSUR9ICgke3ZlcnNpb259KSAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gXG4gICAgKVxuICB9XG5cbiAgcHJpdmF0ZSBfZGVidWcoLi4uYXJnczogYW55W10pOiBHb1RydWVDbGllbnQge1xuICAgIGlmICh0aGlzLmxvZ0RlYnVnTWVzc2FnZXMpIHtcbiAgICAgIHRoaXMubG9nZ2VyKHRoaXMuX2xvZ1ByZWZpeCgpLCAuLi5hcmdzKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNsaWVudCBzZXNzaW9uIGVpdGhlciBmcm9tIHRoZSB1cmwgb3IgZnJvbSBzdG9yYWdlLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuIGluc3RhbnRpYXRpbmcgdGhlIGNsaWVudCwgYnV0IHNob3VsZCBhbHNvIGJlIGNhbGxlZFxuICAgKiBtYW51YWxseSB3aGVuIGNoZWNraW5nIGZvciBhbiBlcnJvciBmcm9tIGFuIGF1dGggcmVkaXJlY3QgKG9hdXRoLCBtYWdpY2xpbmssIHBhc3N3b3JkIHJlY292ZXJ5LCBldGMpLlxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPEluaXRpYWxpemVSZXN1bHQ+IHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faW5pdGlhbGl6ZSgpXG4gICAgICB9KVxuICAgIH0pKClcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogSU1QT1JUQU5UOlxuICAgKiAxLiBOZXZlciB0aHJvdyBpbiB0aGlzIG1ldGhvZCwgYXMgaXQgaXMgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAqIDIuIE5ldmVyIHJldHVybiBhIHNlc3Npb24gZnJvbSB0aGlzIG1ldGhvZCBhcyBpdCB3b3VsZCBiZSBjYWNoZWQgb3ZlclxuICAgKiAgICB0aGUgd2hvbGUgbGlmZXRpbWUgb2YgdGhlIGNsaWVudFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaW5pdGlhbGl6ZSgpOiBQcm9taXNlPEluaXRpYWxpemVSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHBhcmFtczogeyBbcGFyYW1ldGVyOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9XG4gICAgICBsZXQgY2FsbGJhY2tVcmxUeXBlID0gJ25vbmUnXG5cbiAgICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICBwYXJhbXMgPSBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgICBpZiAodGhpcy5faXNJbXBsaWNpdEdyYW50Q2FsbGJhY2socGFyYW1zKSkge1xuICAgICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdpbXBsaWNpdCdcbiAgICAgICAgfSBlbHNlIGlmIChhd2FpdCB0aGlzLl9pc1BLQ0VDYWxsYmFjayhwYXJhbXMpKSB7XG4gICAgICAgICAgY2FsbGJhY2tVcmxUeXBlID0gJ3BrY2UnXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBdHRlbXB0IHRvIGdldCB0aGUgc2Vzc2lvbiBmcm9tIHRoZSBVUkwgb25seSBpZiB0aGVzZSBjb25kaXRpb25zIGFyZSBmdWxmaWxsZWRcbiAgICAgICAqXG4gICAgICAgKiBOb3RlOiBJZiB0aGUgVVJMIGlzbid0IG9uZSBvZiB0aGUgY2FsbGJhY2sgdXJsIHR5cGVzIChpbXBsaWNpdCBvciBwa2NlKSxcbiAgICAgICAqIHRoZW4gdGhlcmUgY291bGQgYmUgYW4gZXhpc3Rpbmcgc2Vzc2lvbiBzbyB3ZSBkb24ndCB3YW50IHRvIHByZW1hdHVyZWx5IHJlbW92ZSBpdFxuICAgICAgICovXG4gICAgICBpZiAoaXNCcm93c2VyKCkgJiYgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgJiYgY2FsbGJhY2tVcmxUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0U2Vzc2lvbkZyb21VUkwocGFyYW1zLCBjYWxsYmFja1VybFR5cGUpXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdlcnJvciBkZXRlY3Rpbmcgc2Vzc2lvbiBmcm9tIFVSTCcsIGVycm9yKVxuXG4gICAgICAgICAgaWYgKGlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gZXJyb3IuZGV0YWlscz8uY29kZVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdpZGVudGl0eV9hbHJlYWR5X2V4aXN0cycgfHxcbiAgICAgICAgICAgICAgZXJyb3JDb2RlID09PSAnaWRlbnRpdHlfbm90X2ZvdW5kJyB8fFxuICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdzaW5nbGVfaWRlbnRpdHlfbm90X2RlbGV0YWJsZSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRG9uJ3QgcmVtb3ZlIGV4aXN0aW5nIHNlc3Npb24gb24gVVJMIGxvZ2luIGZhaWx1cmUuXG4gICAgICAgICAgLy8gQSBmYWlsZWQgYXR0ZW1wdCAoZS5nLiByZXVzZWQgbWFnaWMgbGluaykgc2hvdWxkbid0IGludmFsaWRhdGUgYSB2YWxpZCBzZXNzaW9uLlxuXG4gICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzZXNzaW9uLCByZWRpcmVjdFR5cGUgfSA9IGRhdGFcblxuICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAnI19pbml0aWFsaXplKCknLFxuICAgICAgICAgICdkZXRlY3RlZCBzZXNzaW9uIGluIFVSTCcsXG4gICAgICAgICAgc2Vzc2lvbixcbiAgICAgICAgICAncmVkaXJlY3QgdHlwZScsXG4gICAgICAgICAgcmVkaXJlY3RUeXBlXG4gICAgICAgIClcblxuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKVxuXG4gICAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmIChyZWRpcmVjdFR5cGUgPT09ICdyZWNvdmVyeScpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdQQVNTV09SRF9SRUNPVkVSWScsIHNlc3Npb24pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgMClcblxuICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9XG4gICAgICB9XG4gICAgICAvLyBubyBsb2dpbiBhdHRlbXB0IHZpYSBjYWxsYmFjayB1cmwgdHJ5IHRvIHJlY292ZXIgc2Vzc2lvbiBmcm9tIHN0b3JhZ2VcbiAgICAgIGF3YWl0IHRoaXMuX3JlY292ZXJBbmRSZWZyZXNoKClcbiAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZXJyb3IgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBkdXJpbmcgaW5pdGlhbGl6YXRpb24nLCBlcnJvciksXG4gICAgICB9KVxuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCB0aGlzLl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKClcbiAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGFub255bW91cyB1c2VyLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHNlc3Npb24gd2hlcmUgdGhlIGlzX2Fub255bW91cyBjbGFpbSBpbiB0aGUgYWNjZXNzIHRva2VuIEpXVCBzZXQgdG8gdHJ1ZVxuICAgKi9cbiAgYXN5bmMgc2lnbkluQW5vbnltb3VzbHkoY3JlZGVudGlhbHM/OiBTaWduSW5Bbm9ueW1vdXNseUNyZWRlbnRpYWxzKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc2lnbnVwYCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBkYXRhOiBjcmVkZW50aWFscz8ub3B0aW9ucz8uZGF0YSA/PyB7fSxcbiAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBjcmVkZW50aWFscz8ub3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgfSlcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc1xuXG4gICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gfCBudWxsID0gZGF0YS5zZXNzaW9uXG4gICAgICBjb25zdCB1c2VyOiBVc2VyIHwgbnVsbCA9IGRhdGEudXNlclxuXG4gICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pXG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdXNlci5cbiAgICpcbiAgICogQmUgYXdhcmUgdGhhdCBpZiBhIHVzZXIgYWNjb3VudCBleGlzdHMgaW4gdGhlIHN5c3RlbSB5b3UgbWF5IGdldCBiYWNrIGFuXG4gICAqIGVycm9yIG1lc3NhZ2UgdGhhdCBhdHRlbXB0cyB0byBoaWRlIHRoaXMgaW5mb3JtYXRpb24gZnJvbSB0aGUgdXNlci5cbiAgICogVGhpcyBtZXRob2QgaGFzIHN1cHBvcnQgZm9yIFBLQ0UgdmlhIGVtYWlsIHNpZ251cHMuIFRoZSBQS0NFIGZsb3cgY2Fubm90IGJlIHVzZWQgd2hlbiBhdXRvY29uZmlybSBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIGxvZ2dlZC1pbiBzZXNzaW9uIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPTlxuICAgKiBAcmV0dXJucyBBIHVzZXIgaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9GRlxuICAgKi9cbiAgYXN5bmMgc2lnblVwKGNyZWRlbnRpYWxzOiBTaWduVXBXaXRoUGFzc3dvcmRDcmVkZW50aWFscyk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXM6IEF1dGhSZXNwb25zZVxuICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBlbWFpbCwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgIDtbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlS2V5XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucz8uZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBkYXRhOiBvcHRpb25zPy5kYXRhID8/IHt9LFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBkYXRhOiBvcHRpb25zPy5kYXRhID8/IHt9LFxuICAgICAgICAgICAgY2hhbm5lbDogb3B0aW9ucz8uY2hhbm5lbCA/PyAnc21zJyxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKFxuICAgICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzXG5cbiAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCA9IGRhdGEuc2Vzc2lvblxuICAgICAgY29uc3QgdXNlcjogVXNlciB8IG51bGwgPSBkYXRhLnVzZXJcblxuICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApXG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSlcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgd2l0aCBhbiBlbWFpbCBhbmQgcGFzc3dvcmQgb3IgcGhvbmUgYW5kIHBhc3N3b3JkLlxuICAgKlxuICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAqIGJldHdlZW4gdGhlIGNhc2VzIHdoZXJlIHRoZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0IG9yIHRoYXQgdGhlXG4gICAqIGVtYWlsL3Bob25lIGFuZCBwYXNzd29yZCBjb21iaW5hdGlvbiBpcyB3cm9uZyBvciB0aGF0IHRoZSBhY2NvdW50IGNhbiBvbmx5XG4gICAqIGJlIGFjY2Vzc2VkIHZpYSBzb2NpYWwgbG9naW4uXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoUGFzc3dvcmQoXG4gICAgY3JlZGVudGlhbHM6IFNpZ25JbldpdGhQYXNzd29yZENyZWRlbnRpYWxzXG4gICk6IFByb21pc2U8QXV0aFRva2VuUmVzcG9uc2VQYXNzd29yZD4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzOiBBdXRoUmVzcG9uc2VQYXNzd29yZFxuICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBlbWFpbCwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKFxuICAgICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KVxuICAgICAgfSBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgY29uc3QgaW52YWxpZFRva2VuRXJyb3IgPSBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKVxuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBpbnZhbGlkVG9rZW5FcnJvciB9KVxuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHVzZXI6IGRhdGEudXNlcixcbiAgICAgICAgICBzZXNzaW9uOiBkYXRhLnNlc3Npb24sXG4gICAgICAgICAgLi4uKGRhdGEud2Vha19wYXNzd29yZCA/IHsgd2Vha1Bhc3N3b3JkOiBkYXRhLndlYWtfcGFzc3dvcmQgfSA6IG51bGwpLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcixcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgdmlhIGEgdGhpcmQtcGFydHkgcHJvdmlkZXIuXG4gICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoT0F1dGgoY3JlZGVudGlhbHM6IFNpZ25JbldpdGhPQXV0aENyZWRlbnRpYWxzKTogUHJvbWlzZTxPQXV0aFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2hhbmRsZVByb3ZpZGVyU2lnbkluKGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB7XG4gICAgICByZWRpcmVjdFRvOiBjcmVkZW50aWFscy5vcHRpb25zPy5yZWRpcmVjdFRvLFxuICAgICAgc2NvcGVzOiBjcmVkZW50aWFscy5vcHRpb25zPy5zY29wZXMsXG4gICAgICBxdWVyeVBhcmFtczogY3JlZGVudGlhbHMub3B0aW9ucz8ucXVlcnlQYXJhbXMsXG4gICAgICBza2lwQnJvd3NlclJlZGlyZWN0OiBjcmVkZW50aWFscy5vcHRpb25zPy5za2lwQnJvd3NlclJlZGlyZWN0LFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgYnkgZXhjaGFuZ2luZyBhbiBBdXRoIENvZGUgaXNzdWVkIGR1cmluZyB0aGUgUEtDRSBmbG93LlxuICAgKi9cbiAgYXN5bmMgZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZTogc3RyaW5nKTogUHJvbWlzZTxBdXRoVG9rZW5SZXNwb25zZT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBpbiBhIHVzZXIgYnkgdmVyaWZ5aW5nIGEgbWVzc2FnZSBzaWduZWQgYnkgdGhlIHVzZXIncyBwcml2YXRlIGtleS5cbiAgICogU3VwcG9ydHMgRXRoZXJldW0gKHZpYSBTaWduLUluLVdpdGgtRXRoZXJldW0pICYgU29sYW5hIChTaWduLUluLVdpdGgtU29sYW5hKSBzdGFuZGFyZHMsXG4gICAqIGJvdGggb2Ygd2hpY2ggZGVyaXZlIGZyb20gdGhlIEVJUC00MzYxIHN0YW5kYXJkXG4gICAqIFdpdGggc2xpZ2h0IHZhcmlhdGlvbiBvbiBTb2xhbmEncyBzaWRlLlxuICAgKiBAcmVmZXJlbmNlIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNDM2MVxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aFdlYjMoY3JlZGVudGlhbHM6IFdlYjNDcmVkZW50aWFscyk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogU2Vzc2lvbjsgdXNlcjogVXNlciB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbDsgdXNlcjogbnVsbCB9OyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgY29uc3QgeyBjaGFpbiB9ID0gY3JlZGVudGlhbHNcblxuICAgIHN3aXRjaCAoY2hhaW4pIHtcbiAgICAgIGNhc2UgJ2V0aGVyZXVtJzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbkluV2l0aEV0aGVyZXVtKGNyZWRlbnRpYWxzKVxuICAgICAgY2FzZSAnc29sYW5hJzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbkluV2l0aFNvbGFuYShjcmVkZW50aWFscylcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IFVuc3VwcG9ydGVkIGNoYWluIFwiJHtjaGFpbn1cImApXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzaWduSW5XaXRoRXRoZXJldW0oXG4gICAgY3JlZGVudGlhbHM6IEV0aGVyZXVtV2ViM0NyZWRlbnRpYWxzXG4gICk6IFByb21pc2U8XG4gICAgfCB7IGRhdGE6IHsgc2Vzc2lvbjogU2Vzc2lvbjsgdXNlcjogVXNlciB9OyBlcnJvcjogbnVsbCB9XG4gICAgfCB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbDsgdXNlcjogbnVsbCB9OyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgLy8gVE9ETzogZmxhdHRlbiB0eXBlXG4gICAgbGV0IG1lc3NhZ2U6IHN0cmluZ1xuICAgIGxldCBzaWduYXR1cmU6IEhleFxuXG4gICAgaWYgKCdtZXNzYWdlJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgbWVzc2FnZSA9IGNyZWRlbnRpYWxzLm1lc3NhZ2VcbiAgICAgIHNpZ25hdHVyZSA9IGNyZWRlbnRpYWxzLnNpZ25hdHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGNoYWluLCB3YWxsZXQsIHN0YXRlbWVudCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcblxuICAgICAgbGV0IHJlc29sdmVkV2FsbGV0OiBFdGhlcmV1bVdhbGxldFxuXG4gICAgICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2FsbGV0ICE9PSAnb2JqZWN0JyB8fCAhb3B0aW9ucz8udXJsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0BzdXBhYmFzZS9hdXRoLWpzOiBCb3RoIHdhbGxldCBhbmQgdXJsIG11c3QgYmUgc3BlY2lmaWVkIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy4nXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXRcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdhbGxldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHdpbmRvd0FueSA9IHdpbmRvdyBhcyBhbnlcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgJ2V0aGVyZXVtJyBpbiB3aW5kb3dBbnkgJiZcbiAgICAgICAgICB0eXBlb2Ygd2luZG93QW55LmV0aGVyZXVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICdyZXF1ZXN0JyBpbiB3aW5kb3dBbnkuZXRoZXJldW0gJiZcbiAgICAgICAgICB0eXBlb2Ygd2luZG93QW55LmV0aGVyZXVtLnJlcXVlc3QgPT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3aW5kb3dBbnkuZXRoZXJldW1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQHN1cGFiYXNlL2F1dGgtanM6IE5vIGNvbXBhdGlibGUgRXRoZXJldW0gd2FsbGV0IGludGVyZmFjZSBvbiB0aGUgd2luZG93IG9iamVjdCAod2luZG93LmV0aGVyZXVtKSBkZXRlY3RlZC4gTWFrZSBzdXJlIHRoZSB1c2VyIGFscmVhZHkgaGFzIGEgd2FsbGV0IGluc3RhbGxlZCBhbmQgY29ubmVjdGVkIGZvciB0aGlzIGFwcC4gUHJlZmVyIHBhc3NpbmcgdGhlIHdhbGxldCBpbnRlcmZhY2Ugb2JqZWN0IGRpcmVjdGx5IHRvIHNpZ25JbldpdGhXZWIzKHsgY2hhaW46ICdldGhlcmV1bScsIHdhbGxldDogcmVzb2x2ZWRVc2VyV2FsbGV0IH0pIGluc3RlYWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKG9wdGlvbnM/LnVybCA/PyB3aW5kb3cubG9jYXRpb24uaHJlZilcblxuICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCByZXNvbHZlZFdhbGxldFxuICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKChhY2NzKSA9PiBhY2NzIGFzIHN0cmluZ1tdKVxuICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IG1ldGhvZCBldGhfcmVxdWVzdEFjY291bnRzIGlzIG1pc3Npbmcgb3IgaW52YWxpZGBcbiAgICAgICAgICApXG4gICAgICAgIH0pXG5cbiAgICAgIGlmICghYWNjb3VudHMgfHwgYWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQHN1cGFiYXNlL2F1dGgtanM6IE5vIGFjY291bnRzIGF2YWlsYWJsZS4gUGxlYXNlIGVuc3VyZSB0aGUgd2FsbGV0IGlzIGNvbm5lY3RlZC5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWNjb3VudHNbMF0pXG5cbiAgICAgIGxldCBjaGFpbklkID0gb3B0aW9ucz8uc2lnbkluV2l0aEV0aGVyZXVtPy5jaGFpbklkXG4gICAgICBpZiAoIWNoYWluSWQpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZEhleCA9IGF3YWl0IHJlc29sdmVkV2FsbGV0LnJlcXVlc3Qoe1xuICAgICAgICAgIG1ldGhvZDogJ2V0aF9jaGFpbklkJyxcbiAgICAgICAgfSlcbiAgICAgICAgY2hhaW5JZCA9IGZyb21IZXgoY2hhaW5JZEhleCBhcyBIZXgpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpd2VNZXNzYWdlOiBTaXdlTWVzc2FnZSA9IHtcbiAgICAgICAgZG9tYWluOiB1cmwuaG9zdCxcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgc3RhdGVtZW50OiBzdGF0ZW1lbnQsXG4gICAgICAgIHVyaTogdXJsLmhyZWYsXG4gICAgICAgIHZlcnNpb246ICcxJyxcbiAgICAgICAgY2hhaW5JZDogY2hhaW5JZCxcbiAgICAgICAgbm9uY2U6IG9wdGlvbnM/LnNpZ25JbldpdGhFdGhlcmV1bT8ubm9uY2UsXG4gICAgICAgIGlzc3VlZEF0OiBvcHRpb25zPy5zaWduSW5XaXRoRXRoZXJldW0/Lmlzc3VlZEF0ID8/IG5ldyBEYXRlKCksXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBvcHRpb25zPy5zaWduSW5XaXRoRXRoZXJldW0/LmV4cGlyYXRpb25UaW1lLFxuICAgICAgICBub3RCZWZvcmU6IG9wdGlvbnM/LnNpZ25JbldpdGhFdGhlcmV1bT8ubm90QmVmb3JlLFxuICAgICAgICByZXF1ZXN0SWQ6IG9wdGlvbnM/LnNpZ25JbldpdGhFdGhlcmV1bT8ucmVxdWVzdElkLFxuICAgICAgICByZXNvdXJjZXM6IG9wdGlvbnM/LnNpZ25JbldpdGhFdGhlcmV1bT8ucmVzb3VyY2VzLFxuICAgICAgfVxuXG4gICAgICBtZXNzYWdlID0gY3JlYXRlU2l3ZU1lc3NhZ2Uoc2l3ZU1lc3NhZ2UpXG5cbiAgICAgIC8vIFNpZ24gbWVzc2FnZVxuICAgICAgc2lnbmF0dXJlID0gKGF3YWl0IHJlc29sdmVkV2FsbGV0LnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdwZXJzb25hbF9zaWduJyxcbiAgICAgICAgcGFyYW1zOiBbdG9IZXgobWVzc2FnZSksIGFkZHJlc3NdLFxuICAgICAgfSkpIGFzIEhleFxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgJ1BPU1QnLFxuICAgICAgICBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT13ZWIzYCxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBjaGFpbjogJ2V0aGVyZXVtJyxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICAuLi4oY3JlZGVudGlhbHMub3B0aW9ucz8uY2FwdGNoYVRva2VuXG4gICAgICAgICAgICAgID8geyBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBjcmVkZW50aWFscy5vcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSB9XG4gICAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKClcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSlcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgLi4uZGF0YSB9LCBlcnJvciB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSlcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNpZ25JbldpdGhTb2xhbmEoY3JlZGVudGlhbHM6IFNvbGFuYVdlYjNDcmVkZW50aWFscykge1xuICAgIGxldCBtZXNzYWdlOiBzdHJpbmdcbiAgICBsZXQgc2lnbmF0dXJlOiBVaW50OEFycmF5XG5cbiAgICBpZiAoJ21lc3NhZ2UnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICBtZXNzYWdlID0gY3JlZGVudGlhbHMubWVzc2FnZVxuICAgICAgc2lnbmF0dXJlID0gY3JlZGVudGlhbHMuc2lnbmF0dXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgY2hhaW4sIHdhbGxldCwgc3RhdGVtZW50LCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuXG4gICAgICBsZXQgcmVzb2x2ZWRXYWxsZXQ6IFNvbGFuYVdhbGxldFxuXG4gICAgICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2FsbGV0ICE9PSAnb2JqZWN0JyB8fCAhb3B0aW9ucz8udXJsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0BzdXBhYmFzZS9hdXRoLWpzOiBCb3RoIHdhbGxldCBhbmQgdXJsIG11c3QgYmUgc3BlY2lmaWVkIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy4nXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXRcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdhbGxldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHdpbmRvd0FueSA9IHdpbmRvdyBhcyBhbnlcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgJ3NvbGFuYScgaW4gd2luZG93QW55ICYmXG4gICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5zb2xhbmEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgKCgnc2lnbkluJyBpbiB3aW5kb3dBbnkuc29sYW5hICYmIHR5cGVvZiB3aW5kb3dBbnkuc29sYW5hLnNpZ25JbiA9PT0gJ2Z1bmN0aW9uJykgfHxcbiAgICAgICAgICAgICgnc2lnbk1lc3NhZ2UnIGluIHdpbmRvd0FueS5zb2xhbmEgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5zb2xhbmEuc2lnbk1lc3NhZ2UgPT09ICdmdW5jdGlvbicpKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdpbmRvd0FueS5zb2xhbmFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQHN1cGFiYXNlL2F1dGgtanM6IE5vIGNvbXBhdGlibGUgU29sYW5hIHdhbGxldCBpbnRlcmZhY2Ugb24gdGhlIHdpbmRvdyBvYmplY3QgKHdpbmRvdy5zb2xhbmEpIGRldGVjdGVkLiBNYWtlIHN1cmUgdGhlIHVzZXIgYWxyZWFkeSBoYXMgYSB3YWxsZXQgaW5zdGFsbGVkIGFuZCBjb25uZWN0ZWQgZm9yIHRoaXMgYXBwLiBQcmVmZXIgcGFzc2luZyB0aGUgd2FsbGV0IGludGVyZmFjZSBvYmplY3QgZGlyZWN0bHkgdG8gc2lnbkluV2l0aFdlYjMoeyBjaGFpbjogJ3NvbGFuYScsIHdhbGxldDogcmVzb2x2ZWRVc2VyV2FsbGV0IH0pIGluc3RlYWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKG9wdGlvbnM/LnVybCA/PyB3aW5kb3cubG9jYXRpb24uaHJlZilcblxuICAgICAgaWYgKCdzaWduSW4nIGluIHJlc29sdmVkV2FsbGV0ICYmIHJlc29sdmVkV2FsbGV0LnNpZ25Jbikge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByZXNvbHZlZFdhbGxldC5zaWduSW4oe1xuICAgICAgICAgIGlzc3VlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG5cbiAgICAgICAgICAuLi5vcHRpb25zPy5zaWduSW5XaXRoU29sYW5hLFxuXG4gICAgICAgICAgLy8gbm9uLW92ZXJyaWRhYmxlIHByb3BlcnRpZXNcbiAgICAgICAgICB2ZXJzaW9uOiAnMScsXG4gICAgICAgICAgZG9tYWluOiB1cmwuaG9zdCxcbiAgICAgICAgICB1cmk6IHVybC5ocmVmLFxuXG4gICAgICAgICAgLi4uKHN0YXRlbWVudCA/IHsgc3RhdGVtZW50IH0gOiBudWxsKSxcbiAgICAgICAgfSlcblxuICAgICAgICBsZXQgb3V0cHV0VG9Qcm9jZXNzOiBhbnlcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXQpICYmIG91dHB1dFswXSAmJiB0eXBlb2Ygb3V0cHV0WzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIG91dHB1dFRvUHJvY2VzcyA9IG91dHB1dFswXVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIG91dHB1dCAmJlxuICAgICAgICAgIHR5cGVvZiBvdXRwdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgJ3NpZ25lZE1lc3NhZ2UnIGluIG91dHB1dCAmJlxuICAgICAgICAgICdzaWduYXR1cmUnIGluIG91dHB1dFxuICAgICAgICApIHtcbiAgICAgICAgICBvdXRwdXRUb1Byb2Nlc3MgPSBvdXRwdXRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBXYWxsZXQgbWV0aG9kIHNpZ25JbigpIHJldHVybmVkIHVucmVjb2duaXplZCB2YWx1ZScpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgJ3NpZ25lZE1lc3NhZ2UnIGluIG91dHB1dFRvUHJvY2VzcyAmJlxuICAgICAgICAgICdzaWduYXR1cmUnIGluIG91dHB1dFRvUHJvY2VzcyAmJlxuICAgICAgICAgICh0eXBlb2Ygb3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICBvdXRwdXRUb1Byb2Nlc3Muc2lnbmVkTWVzc2FnZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICYmXG4gICAgICAgICAgb3V0cHV0VG9Qcm9jZXNzLnNpZ25hdHVyZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICAgICAgKSB7XG4gICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICB0eXBlb2Ygb3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgID8gb3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2VcbiAgICAgICAgICAgICAgOiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUob3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UpXG4gICAgICAgICAgc2lnbmF0dXJlID0gb3V0cHV0VG9Qcm9jZXNzLnNpZ25hdHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IG1ldGhvZCBzaWduSW4oKSBBUEkgcmV0dXJuZWQgb2JqZWN0IHdpdGhvdXQgc2lnbmVkTWVzc2FnZSBhbmQgc2lnbmF0dXJlIGZpZWxkcydcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKCdzaWduTWVzc2FnZScgaW4gcmVzb2x2ZWRXYWxsZXQpIHx8XG4gICAgICAgICAgdHlwZW9mIHJlc29sdmVkV2FsbGV0LnNpZ25NZXNzYWdlICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgISgncHVibGljS2V5JyBpbiByZXNvbHZlZFdhbGxldCkgfHxcbiAgICAgICAgICB0eXBlb2YgcmVzb2x2ZWRXYWxsZXQgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgIXJlc29sdmVkV2FsbGV0LnB1YmxpY0tleSB8fFxuICAgICAgICAgICEoJ3RvQmFzZTU4JyBpbiByZXNvbHZlZFdhbGxldC5wdWJsaWNLZXkpIHx8XG4gICAgICAgICAgdHlwZW9mIHJlc29sdmVkV2FsbGV0LnB1YmxpY0tleS50b0Jhc2U1OCAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQHN1cGFiYXNlL2F1dGgtanM6IFdhbGxldCBkb2VzIG5vdCBoYXZlIGEgY29tcGF0aWJsZSBzaWduTWVzc2FnZSgpIGFuZCBwdWJsaWNLZXkudG9CYXNlNTgoKSBBUEknXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgbWVzc2FnZSA9IFtcbiAgICAgICAgICBgJHt1cmwuaG9zdH0gd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIFNvbGFuYSBhY2NvdW50OmAsXG4gICAgICAgICAgcmVzb2x2ZWRXYWxsZXQucHVibGljS2V5LnRvQmFzZTU4KCksXG4gICAgICAgICAgLi4uKHN0YXRlbWVudCA/IFsnJywgc3RhdGVtZW50LCAnJ10gOiBbJyddKSxcbiAgICAgICAgICAnVmVyc2lvbjogMScsXG4gICAgICAgICAgYFVSSTogJHt1cmwuaHJlZn1gLFxuICAgICAgICAgIGBJc3N1ZWQgQXQ6ICR7b3B0aW9ucz8uc2lnbkluV2l0aFNvbGFuYT8uaXNzdWVkQXQgPz8gbmV3IERhdGUoKS50b0lTT1N0cmluZygpfWAsXG4gICAgICAgICAgLi4uKG9wdGlvbnM/LnNpZ25JbldpdGhTb2xhbmE/Lm5vdEJlZm9yZVxuICAgICAgICAgICAgPyBbYE5vdCBCZWZvcmU6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLm5vdEJlZm9yZX1gXVxuICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgLi4uKG9wdGlvbnM/LnNpZ25JbldpdGhTb2xhbmE/LmV4cGlyYXRpb25UaW1lXG4gICAgICAgICAgICA/IFtgRXhwaXJhdGlvbiBUaW1lOiAke29wdGlvbnMuc2lnbkluV2l0aFNvbGFuYS5leHBpcmF0aW9uVGltZX1gXVxuICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgLi4uKG9wdGlvbnM/LnNpZ25JbldpdGhTb2xhbmE/LmNoYWluSWRcbiAgICAgICAgICAgID8gW2BDaGFpbiBJRDogJHtvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEuY2hhaW5JZH1gXVxuICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgLi4uKG9wdGlvbnM/LnNpZ25JbldpdGhTb2xhbmE/Lm5vbmNlID8gW2BOb25jZTogJHtvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEubm9uY2V9YF0gOiBbXSksXG4gICAgICAgICAgLi4uKG9wdGlvbnM/LnNpZ25JbldpdGhTb2xhbmE/LnJlcXVlc3RJZFxuICAgICAgICAgICAgPyBbYFJlcXVlc3QgSUQ6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLnJlcXVlc3RJZH1gXVxuICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgLi4uKG9wdGlvbnM/LnNpZ25JbldpdGhTb2xhbmE/LnJlc291cmNlcz8ubGVuZ3RoXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAnUmVzb3VyY2VzJyxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLnNpZ25JbldpdGhTb2xhbmEucmVzb3VyY2VzLm1hcCgocmVzb3VyY2UpID0+IGAtICR7cmVzb3VyY2V9YCksXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogW10pLFxuICAgICAgICBdLmpvaW4oJ1xcbicpXG5cbiAgICAgICAgY29uc3QgbWF5YmVTaWduYXR1cmUgPSBhd2FpdCByZXNvbHZlZFdhbGxldC5zaWduTWVzc2FnZShcbiAgICAgICAgICBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobWVzc2FnZSksXG4gICAgICAgICAgJ3V0ZjgnXG4gICAgICAgIClcblxuICAgICAgICBpZiAoIW1heWJlU2lnbmF0dXJlIHx8ICEobWF5YmVTaWduYXR1cmUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IHNpZ25NZXNzYWdlKCkgQVBJIHJldHVybmVkIGFuIHJlY29nbml6ZWQgdmFsdWUnXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgc2lnbmF0dXJlID0gbWF5YmVTaWduYXR1cmVcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICdQT1NUJyxcbiAgICAgICAgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9d2ViM2AsXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgY2hhaW46ICdzb2xhbmEnLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogYnl0ZXNUb0Jhc2U2NFVSTChzaWduYXR1cmUpLFxuXG4gICAgICAgICAgICAuLi4oY3JlZGVudGlhbHMub3B0aW9ucz8uY2FwdGNoYVRva2VuXG4gICAgICAgICAgICAgID8geyBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBjcmVkZW50aWFscy5vcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSB9XG4gICAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKClcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSlcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgLi4uZGF0YSB9LCBlcnJvciB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSlcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlOiBzdHJpbmcpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IHNlc3Npb246IFNlc3Npb247IHVzZXI6IFVzZXI7IHJlZGlyZWN0VHlwZTogc3RyaW5nIHwgbnVsbCB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbDsgdXNlcjogbnVsbDsgcmVkaXJlY3RUeXBlOiBudWxsIH07IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICBjb25zdCBzdG9yYWdlSXRlbSA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApXG4gICAgY29uc3QgW2NvZGVWZXJpZmllciwgcmVkaXJlY3RUeXBlXSA9ICgoc3RvcmFnZUl0ZW0gPz8gJycpIGFzIHN0cmluZykuc3BsaXQoJy8nKVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghY29kZVZlcmlmaWVyICYmIHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgJ1BPU1QnLFxuICAgICAgICBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1wa2NlYCxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBhdXRoX2NvZGU6IGF1dGhDb2RlLFxuICAgICAgICAgICAgY29kZV92ZXJpZmllcjogY29kZVZlcmlmaWVyLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgY29uc3QgaW52YWxpZFRva2VuRXJyb3IgPSBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKVxuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICAgIGVycm9yOiBpbnZhbGlkVG9rZW5FcnJvcixcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgLi4uZGF0YSwgcmVkaXJlY3RUeXBlOiByZWRpcmVjdFR5cGUgPz8gbnVsbCB9LCBlcnJvciB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHNpZ25pbmcgaW4gd2l0aCBhbiBPSURDIElEIHRva2VuLiBUaGUgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgdXNlZFxuICAgKiBzaG91bGQgYmUgZW5hYmxlZCBhbmQgY29uZmlndXJlZC5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhJZFRva2VuKGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoSWRUb2tlbkNyZWRlbnRpYWxzKTogUHJvbWlzZTxBdXRoVG9rZW5SZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IG9wdGlvbnMsIHByb3ZpZGVyLCB0b2tlbiwgYWNjZXNzX3Rva2VuLCBub25jZSB9ID0gY3JlZGVudGlhbHNcblxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1pZF90b2tlbmAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgaWRfdG9rZW46IHRva2VuLFxuICAgICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgICBub25jZSxcbiAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgfSxcbiAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXNcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pXG4gICAgICB9IGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICBjb25zdCBpbnZhbGlkVG9rZW5FcnJvciA9IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGludmFsaWRUb2tlbkVycm9yIH0pXG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbilcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhLCBlcnJvciB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSlcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgbWFnaWNsaW5rIG9yIGEgb25lLXRpbWUgcGFzc3dvcmQgKE9UUCkuXG4gICAqXG4gICAqIElmIHRoZSBge3sgLkNvbmZpcm1hdGlvblVSTCB9fWAgdmFyaWFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBlbWFpbCB0ZW1wbGF0ZSwgYSBtYWdpY2xpbmsgd2lsbCBiZSBzZW50LlxuICAgKiBJZiB0aGUgYHt7IC5Ub2tlbiB9fWAgdmFyaWFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBlbWFpbCB0ZW1wbGF0ZSwgYW4gT1RQIHdpbGwgYmUgc2VudC5cbiAgICogSWYgeW91J3JlIHVzaW5nIHBob25lIHNpZ24taW5zLCBvbmx5IGFuIE9UUCB3aWxsIGJlIHNlbnQuIFlvdSB3b24ndCBiZSBhYmxlIHRvIHNlbmQgYSBtYWdpY2xpbmsgZm9yIHBob25lIHNpZ24taW5zLlxuICAgKlxuICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAqIGJldHdlZW4gdGhlIGNhc2VzIHdoZXJlIHRoZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0IG9yLCB0aGF0IHRoZSBhY2NvdW50XG4gICAqIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIHZpYSBzb2NpYWwgbG9naW4uXG4gICAqXG4gICAqIERvIG5vdGUgdGhhdCB5b3Ugd2lsbCBuZWVkIHRvIGNvbmZpZ3VyZSBhIFdoYXRzYXBwIHNlbmRlciBvbiBUd2lsaW9cbiAgICogaWYgeW91IGFyZSB1c2luZyBwaG9uZSBzaWduIGluIHdpdGggdGhlICd3aGF0c2FwcCcgY2hhbm5lbC4gVGhlIHdoYXRzYXBwXG4gICAqIGNoYW5uZWwgaXMgbm90IHN1cHBvcnRlZCBvbiBvdGhlciBwcm92aWRlcnNcbiAgICogYXQgdGhpcyB0aW1lLlxuICAgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBQS0NFIHdoZW4gYW4gZW1haWwgaXMgcGFzc2VkLlxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aE90cChjcmVkZW50aWFsczogU2lnbkluV2l0aFBhc3N3b3JkbGVzc0NyZWRlbnRpYWxzKTogUHJvbWlzZTxBdXRoT3RwUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBlbWFpbCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2U6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgO1tjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UsXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2VLZXlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb3RwYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIGRhdGE6IG9wdGlvbnM/LmRhdGEgPz8ge30sXG4gICAgICAgICAgICBjcmVhdGVfdXNlcjogb3B0aW9ucz8uc2hvdWxkQ3JlYXRlVXNlciA/PyB0cnVlLFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnM/LmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KVxuICAgICAgfVxuICAgICAgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBwaG9uZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb3RwYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgIGRhdGE6IG9wdGlvbnM/LmRhdGEgPz8ge30sXG4gICAgICAgICAgICBjcmVhdGVfdXNlcjogb3B0aW9ucz8uc2hvdWxkQ3JlYXRlVXNlciA/PyB0cnVlLFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICBjaGFubmVsOiBvcHRpb25zPy5jaGFubmVsID8/ICdzbXMnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoe1xuICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgbWVzc2FnZUlkOiBkYXRhPy5tZXNzYWdlX2lkIH0sXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIuJylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYClcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgaW4gYSB1c2VyIGdpdmVuIGEgVXNlciBzdXBwbGllZCBPVFAgb3IgVG9rZW5IYXNoIHJlY2VpdmVkIHRocm91Z2ggbW9iaWxlIG9yIGVtYWlsLlxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5T3RwKHBhcmFtczogVmVyaWZ5T3RwUGFyYW1zKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHJlZGlyZWN0VG86IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICAgICAgbGV0IGNhcHRjaGFUb2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gICAgICBpZiAoJ29wdGlvbnMnIGluIHBhcmFtcykge1xuICAgICAgICByZWRpcmVjdFRvID0gcGFyYW1zLm9wdGlvbnM/LnJlZGlyZWN0VG9cbiAgICAgICAgY2FwdGNoYVRva2VuID0gcGFyYW1zLm9wdGlvbnM/LmNhcHRjaGFUb2tlblxuICAgICAgfVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdmVyaWZ5YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogY2FwdGNoYVRva2VuIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJlZGlyZWN0VG8sXG4gICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgfSlcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgY29uc3QgdG9rZW5WZXJpZmljYXRpb25FcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgb24gdG9rZW4gdmVyaWZpY2F0aW9uLicpXG4gICAgICAgIHRocm93IHRva2VuVmVyaWZpY2F0aW9uRXJyb3JcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBkYXRhLnNlc3Npb25cbiAgICAgIGNvbnN0IHVzZXI6IFVzZXIgPSBkYXRhLnVzZXJcblxuICAgICAgaWYgKHNlc3Npb24/LmFjY2Vzc190b2tlbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uIGFzIFNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKFxuICAgICAgICAgIHBhcmFtcy50eXBlID09ICdyZWNvdmVyeScgPyAnUEFTU1dPUkRfUkVDT1ZFUlknIDogJ1NJR05FRF9JTicsXG4gICAgICAgICAgc2Vzc2lvblxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pXG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIGEgc2luZ2xlLXNpZ24gb24gdXNpbmcgYW4gZW50ZXJwcmlzZSBJZGVudGl0eSBQcm92aWRlci4gQVxuICAgKiBzdWNjZXNzZnVsIFNTTyBhdHRlbXB0IHdpbGwgcmVkaXJlY3QgdGhlIGN1cnJlbnQgcGFnZSB0byB0aGUgaWRlbnRpdHlcbiAgICogcHJvdmlkZXIgYXV0aG9yaXphdGlvbiBwYWdlLiBUaGUgcmVkaXJlY3QgVVJMIGlzIGltcGxlbWVudGF0aW9uIGFuZCBTU09cbiAgICogcHJvdG9jb2wgc3BlY2lmaWMuXG4gICAqXG4gICAqIFlvdSBjYW4gdXNlIGl0IGJ5IHByb3ZpZGluZyBhIFNTTyBkb21haW4uIFR5cGljYWxseSB5b3UgY2FuIGV4dHJhY3QgdGhpc1xuICAgKiBkb21haW4gYnkgYXNraW5nIHVzZXJzIGZvciB0aGVpciBlbWFpbCBhZGRyZXNzLiBJZiB0aGlzIGRvbWFpbiBpc1xuICAgKiByZWdpc3RlcmVkIG9uIHRoZSBBdXRoIGluc3RhbmNlIHRoZSByZWRpcmVjdCB3aWxsIHVzZSB0aGF0IG9yZ2FuaXphdGlvbidzXG4gICAqIGN1cnJlbnRseSBhY3RpdmUgU1NPIElkZW50aXR5IFByb3ZpZGVyIGZvciB0aGUgbG9naW4uXG4gICAqXG4gICAqIElmIHlvdSBoYXZlIGJ1aWx0IGFuIG9yZ2FuaXphdGlvbi1zcGVjaWZpYyBsb2dpbiBwYWdlLCB5b3UgY2FuIHVzZSB0aGVcbiAgICogb3JnYW5pemF0aW9uJ3MgU1NPIElkZW50aXR5IFByb3ZpZGVyIFVVSUQgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhTU08ocGFyYW1zOiBTaWduSW5XaXRoU1NPKTogUHJvbWlzZTxTU09SZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29kZUNoYWxsZW5nZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICA7W2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgICAgICAgICB0aGlzLnN0b3JhZ2UsXG4gICAgICAgICAgdGhpcy5zdG9yYWdlS2V5XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc3NvYCwge1xuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgLi4uKCdwcm92aWRlcklkJyBpbiBwYXJhbXMgPyB7IHByb3ZpZGVyX2lkOiBwYXJhbXMucHJvdmlkZXJJZCB9IDogbnVsbCksXG4gICAgICAgICAgLi4uKCdkb21haW4nIGluIHBhcmFtcyA/IHsgZG9tYWluOiBwYXJhbXMuZG9tYWluIH0gOiBudWxsKSxcbiAgICAgICAgICByZWRpcmVjdF90bzogcGFyYW1zLm9wdGlvbnM/LnJlZGlyZWN0VG8gPz8gdW5kZWZpbmVkLFxuICAgICAgICAgIC4uLihwYXJhbXM/Lm9wdGlvbnM/LmNhcHRjaGFUb2tlblxuICAgICAgICAgICAgPyB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IHBhcmFtcy5vcHRpb25zLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgc2tpcF9odHRwX3JlZGlyZWN0OiB0cnVlLCAvLyBmZXRjaCBkb2VzIG5vdCBoYW5kbGUgcmVkaXJlY3RzXG4gICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfc3NvUmVzcG9uc2UsXG4gICAgICB9KVxuXG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlZGlyZWN0IGluIGJyb3dzZXIgdW5sZXNzIHNraXBCcm93c2VyUmVkaXJlY3QgaXMgdHJ1ZVxuICAgICAgaWYgKHJlc3VsdC5kYXRhPy51cmwgJiYgaXNCcm93c2VyKCkgJiYgIXBhcmFtcy5vcHRpb25zPy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24ocmVzdWx0LmRhdGEudXJsKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHJlc3VsdClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYClcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHJlYXV0aGVudGljYXRpb24gT1RQIHRvIHRoZSB1c2VyJ3MgZW1haWwgb3IgcGhvbmUgbnVtYmVyLlxuICAgKiBSZXF1aXJlcyB0aGUgdXNlciB0byBiZSBzaWduZWQtaW4uXG4gICAqL1xuICBhc3luYyByZWF1dGhlbnRpY2F0ZSgpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlYXV0aGVudGljYXRlKClcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfcmVhdXRoZW50aWNhdGUoKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICAgICAgZXJyb3I6IHNlc3Npb25FcnJvcixcbiAgICAgICAgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB0aHJvdyBzZXNzaW9uRXJyb3JcbiAgICAgICAgaWYgKCFzZXNzaW9uKSB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKVxuXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vcmVhdXRoZW50aWNhdGVgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSlcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZW5kcyBhbiBleGlzdGluZyBzaWdudXAgY29uZmlybWF0aW9uIGVtYWlsLCBlbWFpbCBjaGFuZ2UgZW1haWwsIFNNUyBPVFAgb3IgcGhvbmUgY2hhbmdlIE9UUC5cbiAgICovXG4gIGFzeW5jIHJlc2VuZChjcmVkZW50aWFsczogUmVzZW5kUGFyYW1zKTogUHJvbWlzZTxBdXRoT3RwUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLnVybH0vcmVzZW5kYFxuICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBlbWFpbCwgdHlwZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBlbmRwb2ludCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnM/LmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KVxuICAgICAgfSBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgcGhvbmUsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCBtZXNzYWdlSWQ6IGRhdGE/Lm1lc3NhZ2VfaWQgfSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoXG4gICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgdHlwZSdcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzZXNzaW9uLCByZWZyZXNoaW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogVGhlIHNlc3Npb24gcmV0dXJuZWQgY2FuIGJlIG51bGwgaWYgdGhlIHNlc3Npb24gaXMgbm90IGRldGVjdGVkIHdoaWNoIGNhbiBoYXBwZW4gaW4gdGhlIGV2ZW50IGEgdXNlciBpcyBub3Qgc2lnbmVkLWluIG9yIGhhcyBsb2dnZWQgb3V0LlxuICAgKlxuICAgKiAqKklNUE9SVEFOVDoqKiBUaGlzIG1ldGhvZCBsb2FkcyB2YWx1ZXMgZGlyZWN0bHkgZnJvbSB0aGUgc3RvcmFnZSBhdHRhY2hlZFxuICAgKiB0byB0aGUgY2xpZW50LiBJZiB0aGF0IHN0b3JhZ2UgaXMgYmFzZWQgb24gcmVxdWVzdCBjb29raWVzIGZvciBleGFtcGxlLFxuICAgKiB0aGUgdmFsdWVzIGluIGl0IG1heSBub3QgYmUgYXV0aGVudGljIGFuZCB0aGVyZWZvcmUgaXQncyBzdHJvbmdseSBhZHZpc2VkXG4gICAqIGFnYWluc3QgdXNpbmcgdGhpcyBtZXRob2QgYW5kIGl0cyByZXN1bHRzIGluIHN1Y2ggY2lyY3Vtc3RhbmNlcy4gQSB3YXJuaW5nXG4gICAqIHdpbGwgYmUgZW1pdHRlZCBpZiB0aGlzIGlzIGRldGVjdGVkLiBVc2Uge0BsaW5rICNnZXRVc2VyKCl9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRTZXNzaW9uKCkge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3F1aXJlcyBhIGdsb2JhbCBsb2NrIGJhc2VkIG9uIHRoZSBzdG9yYWdlIGtleS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2FjcXVpcmVMb2NrPFI+KGFjcXVpcmVUaW1lb3V0OiBudW1iZXIsIGZuOiAoKSA9PiBQcm9taXNlPFI+KTogUHJvbWlzZTxSPiB7XG4gICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnYmVnaW4nLCBhY3F1aXJlVGltZW91dClcblxuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5sb2NrQWNxdWlyZWQpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGVuZGluZ0luTG9jay5sZW5ndGhcbiAgICAgICAgICA/IHRoaXMucGVuZGluZ0luTG9ja1t0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoIC0gMV1cbiAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBsYXN0XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKClcbiAgICAgICAgfSkoKVxuXG4gICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5wdXNoKFxuICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCByZXN1bHRcbiAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGNhcmUgaWYgaXQgZmluaXNoZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpXG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvY2soYGxvY2s6JHt0aGlzLnN0b3JhZ2VLZXl9YCwgYWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnbG9jayBhY3F1aXJlZCBmb3Igc3RvcmFnZSBrZXknLCB0aGlzLnN0b3JhZ2VLZXkpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IHRydWVcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKClcblxuICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5wdXNoKFxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHRcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKClcbiAgICAgICAgICApXG5cbiAgICAgICAgICBhd2FpdCByZXN1bHRcblxuICAgICAgICAgIC8vIGtlZXAgZHJhaW5pbmcgdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uXG4gICAgICAgICAgd2hpbGUgKHRoaXMucGVuZGluZ0luTG9jay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdhaXRPbiA9IFsuLi50aGlzLnBlbmRpbmdJbkxvY2tdXG5cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHdhaXRPbilcblxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnNwbGljZSgwLCB3YWl0T24ubGVuZ3RoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhd2FpdCByZXN1bHRcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIHJlbGVhc2VkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSlcblxuICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlIGluc3RlYWQgb2Yge0BsaW5rICNnZXRTZXNzaW9ufSBpbnNpZGUgdGhlIGxpYnJhcnkuIEl0IGlzXG4gICAqIHNlbWFudGljYWxseSB1c3VhbGx5IHdoYXQgeW91IHdhbnQsIGFzIGdldHRpbmcgYSBzZXNzaW9uIGludm9sdmVzIHNvbWVcbiAgICogcHJvY2Vzc2luZyBhZnRlcndhcmRzIHRoYXQgcmVxdWlyZXMgb25seSBvbmUgY2xpZW50IG9wZXJhdGluZyBvbiB0aGVcbiAgICogc2Vzc2lvbiBhdCBvbmNlIGFjcm9zcyBtdWx0aXBsZSB0YWJzIG9yIHByb2Nlc3Nlcy5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3VzZVNlc3Npb248Uj4oXG4gICAgZm46IChcbiAgICAgIHJlc3VsdDpcbiAgICAgICAgfCB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNlc3Npb246IFNlc3Npb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB8IHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3I6IEF1dGhFcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfCB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgfVxuICAgICkgPT4gUHJvbWlzZTxSPlxuICApOiBQcm9taXNlPFI+IHtcbiAgICB0aGlzLl9kZWJ1ZygnI191c2VTZXNzaW9uJywgJ2JlZ2luJylcblxuICAgIHRyeSB7XG4gICAgICAvLyB0aGUgdXNlIG9mIF9fbG9hZFNlc3Npb24gaGVyZSBpcyB0aGUgb25seSBjb3JyZWN0IHVzZSBvZiB0aGUgZnVuY3Rpb24hXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9fbG9hZFNlc3Npb24oKVxuXG4gICAgICByZXR1cm4gYXdhaXQgZm4ocmVzdWx0KVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnI191c2VTZXNzaW9uJywgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5FVkVSIFVTRSBESVJFQ1RMWSFcbiAgICpcbiAgICogQWx3YXlzIHVzZSB7QGxpbmsgI191c2VTZXNzaW9ufS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX19sb2FkU2Vzc2lvbigpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc2Vzc2lvbjogU2Vzc2lvblxuICAgICAgICB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgZXJyb3I6IEF1dGhFcnJvclxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgICB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gID4ge1xuICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2JlZ2luJylcblxuICAgIGlmICghdGhpcy5sb2NrQWNxdWlyZWQpIHtcbiAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ3VzZWQgb3V0c2lkZSBvZiBhbiBhY3F1aXJlZCBsb2NrIScsIG5ldyBFcnJvcigpLnN0YWNrKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBsZXQgY3VycmVudFNlc3Npb246IFNlc3Npb24gfCBudWxsID0gbnVsbFxuXG4gICAgICBjb25zdCBtYXliZVNlc3Npb24gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpXG5cbiAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgbWF5YmVTZXNzaW9uKVxuXG4gICAgICBpZiAobWF5YmVTZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkU2Vzc2lvbihtYXliZVNlc3Npb24pKSB7XG4gICAgICAgICAgY3VycmVudFNlc3Npb24gPSBtYXliZVNlc3Npb25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kZWJ1ZygnI2dldFNlc3Npb24oKScsICdzZXNzaW9uIGZyb20gc3RvcmFnZSBpcyBub3QgdmFsaWQnKVxuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH1cbiAgICAgIH1cblxuICAgICAgLy8gQSBzZXNzaW9uIGlzIGNvbnNpZGVyZWQgZXhwaXJlZCBiZWZvcmUgdGhlIGFjY2VzcyB0b2tlbiBfYWN0dWFsbHlfXG4gICAgICAvLyBleHBpcmVzLiBXaGVuIHRoZSBhdXRvUmVmcmVzaFRva2VuIG9wdGlvbiBpcyBvZmYgKG9yIHdoZW4gdGhlIHRhYiBpc1xuICAgICAgLy8gaW4gdGhlIGJhY2tncm91bmQpLCB2ZXJ5IGVhZ2VyIHVzZXJzIG9mIGdldFNlc3Npb24oKSAtLSBsaWtlXG4gICAgICAvLyByZWFsdGltZS1qcyAtLSBtaWdodCBzZW5kIGEgdmFsaWQgSldUIHdoaWNoIHdpbGwgZXhwaXJlIGJ5IHRoZSB0aW1lIGl0XG4gICAgICAvLyByZWFjaGVzIHRoZSBzZXJ2ZXIuXG4gICAgICBjb25zdCBoYXNFeHBpcmVkID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgICA/IGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXQgKiAxMDAwIC0gRGF0ZS5ub3coKSA8IEVYUElSWV9NQVJHSU5fTVNcbiAgICAgICAgOiBmYWxzZVxuXG4gICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgJyNfX2xvYWRTZXNzaW9uKCknLFxuICAgICAgICBgc2Vzc2lvbiBoYXMke2hhc0V4cGlyZWQgPyAnJyA6ICcgbm90J30gZXhwaXJlZGAsXG4gICAgICAgICdleHBpcmVzX2F0JyxcbiAgICAgICAgY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgKVxuXG4gICAgICBpZiAoIWhhc0V4cGlyZWQpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlclN0b3JhZ2UpIHtcbiAgICAgICAgICBjb25zdCBtYXliZVVzZXI6IHsgdXNlcj86IFVzZXIgfCBudWxsIH0gfCBudWxsID0gKGF3YWl0IGdldEl0ZW1Bc3luYyhcbiAgICAgICAgICAgIHRoaXMudXNlclN0b3JhZ2UsXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInXG4gICAgICAgICAgKSkgYXMgYW55XG5cbiAgICAgICAgICBpZiAobWF5YmVVc2VyPy51c2VyKSB7XG4gICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyID0gbWF5YmVVc2VyLnVzZXJcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IHVzZXJOb3RBdmFpbGFibGVQcm94eSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JhcCB0aGUgdXNlciBvYmplY3Qgd2l0aCBhIHdhcm5pbmcgcHJveHkgb24gdGhlIHNlcnZlclxuICAgICAgICAvLyBUaGlzIHdhcm5zIHdoZW4gcHJvcGVydGllcyBvZiB0aGUgdXNlciBhcmUgYWNjZXNzZWQsIG5vdCB3aGVuIHNlc3Npb24udXNlciBpdHNlbGYgaXMgYWNjZXNzZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuc3RvcmFnZS5pc1NlcnZlciAmJlxuICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgJiZcbiAgICAgICAgICAhKGN1cnJlbnRTZXNzaW9uLnVzZXIgYXMgYW55KS5fX2lzVXNlck5vdEF2YWlsYWJsZVByb3h5XG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHN1cHByZXNzV2FybmluZ1JlZiA9IHsgdmFsdWU6IHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyB9XG4gICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IGluc2VjdXJlVXNlcldhcm5pbmdQcm94eShjdXJyZW50U2Vzc2lvbi51c2VyLCBzdXBwcmVzc1dhcm5pbmdSZWYpXG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNsaWVudC1sZXZlbCBzdXBwcmVzc2lvbiBmbGFnIHdoZW4gdGhlIHByb3h5IHN1cHByZXNzZXMgdGhlIHdhcm5pbmdcbiAgICAgICAgICBpZiAoc3VwcHJlc3NXYXJuaW5nUmVmLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBjdXJyZW50U2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbilcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfSlcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB1c2VyIGRldGFpbHMgaWYgdGhlcmUgaXMgYW4gZXhpc3Rpbmcgc2Vzc2lvbi4gVGhpcyBtZXRob2RcbiAgICogcGVyZm9ybXMgYSBuZXR3b3JrIHJlcXVlc3QgdG8gdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLCBzbyB0aGUgcmV0dXJuZWRcbiAgICogdmFsdWUgaXMgYXV0aGVudGljIGFuZCBjYW4gYmUgdXNlZCB0byBiYXNlIGF1dGhvcml6YXRpb24gcnVsZXMgb24uXG4gICAqXG4gICAqIEBwYXJhbSBqd3QgVGFrZXMgaW4gYW4gb3B0aW9uYWwgYWNjZXNzIHRva2VuIEpXVC4gSWYgbm8gSldUIGlzIHByb3ZpZGVkLCB0aGUgSldUIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyB1c2VkLlxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlcihqd3Q/OiBzdHJpbmcpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIGlmIChqd3QpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKGp3dClcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFVzZXIoKVxuICAgIH0pXG5cbiAgICBpZiAocmVzdWx0LmRhdGEudXNlcikge1xuICAgICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2dldFVzZXIoand0Pzogc3RyaW5nKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKGp3dCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBqd3Q6IGp3dCxcbiAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybnMgYW4gZXJyb3IgaWYgdGhlcmUgaXMgbm8gYWNjZXNzX3Rva2VuIG9yIGN1c3RvbSBhdXRob3JpemF0aW9uIGhlYWRlclxuICAgICAgICBpZiAoIWRhdGEuc2Vzc2lvbj8uYWNjZXNzX3Rva2VuICYmICF0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGp3dDogZGF0YS5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4gPz8gdW5kZWZpbmVkLFxuICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICBpZiAoaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAvLyBKV1QgY29udGFpbnMgYSBgc2Vzc2lvbl9pZGAgd2hpY2ggZG9lcyBub3QgY29ycmVzcG9uZCB0byBhbiBhY3RpdmVcbiAgICAgICAgICAvLyBzZXNzaW9uIGluIHRoZSBkYXRhYmFzZSwgaW5kaWNhdGluZyB0aGUgdXNlciBpcyBzaWduZWQgb3V0LlxuXG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfSlcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB1c2VyIGRhdGEgZm9yIGEgbG9nZ2VkIGluIHVzZXIuXG4gICAqL1xuICBhc3luYyB1cGRhdGVVc2VyKFxuICAgIGF0dHJpYnV0ZXM6IFVzZXJBdHRyaWJ1dGVzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGVtYWlsUmVkaXJlY3RUbz86IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgIH0gPSB7fVxuICApOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucylcbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF91cGRhdGVVc2VyKFxuICAgIGF0dHJpYnV0ZXM6IFVzZXJBdHRyaWJ1dGVzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGVtYWlsUmVkaXJlY3RUbz86IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgIH0gPSB7fVxuICApOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZXNzaW9uRGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXNzaW9uOiBTZXNzaW9uID0gc2Vzc2lvbkRhdGEuc2Vzc2lvblxuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2Q6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScgJiYgYXR0cmlidXRlcy5lbWFpbCAhPSBudWxsKSB7XG4gICAgICAgICAgO1tjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UsXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2VLZXlcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucz8uZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICAgIGlmICh1c2VyRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyB1c2VyRXJyb3JcbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uLnVzZXIgPSBkYXRhLnVzZXIgYXMgVXNlclxuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnVVNFUl9VUERBVEVEJywgc2Vzc2lvbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyIH0sIGVycm9yOiBudWxsIH0pXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH0pXG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50IHNlc3Npb24uIElmIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgZXhwaXJlZCwgc2V0U2Vzc2lvbiB3aWxsIHRha2UgY2FyZSBvZiByZWZyZXNoaW5nIGl0IHRvIG9idGFpbiBhIG5ldyBzZXNzaW9uLlxuICAgKiBJZiB0aGUgcmVmcmVzaCB0b2tlbiBvciBhY2Nlc3MgdG9rZW4gaW4gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyBpbnZhbGlkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICogQHBhcmFtIGN1cnJlbnRTZXNzaW9uIFRoZSBjdXJyZW50IHNlc3Npb24gdGhhdCBtaW5pbWFsbHkgY29udGFpbnMgYW4gYWNjZXNzIHRva2VuIGFuZCByZWZyZXNoIHRva2VuLlxuICAgKi9cbiAgYXN5bmMgc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbjoge1xuICAgIGFjY2Vzc190b2tlbjogc3RyaW5nXG4gICAgcmVmcmVzaF90b2tlbjogc3RyaW5nXG4gIH0pOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NldFNlc3Npb24oY3VycmVudFNlc3Npb24pXG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbjoge1xuICAgIGFjY2Vzc190b2tlbjogc3RyaW5nXG4gICAgcmVmcmVzaF90b2tlbjogc3RyaW5nXG4gIH0pOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbiB8fCAhY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0aW1lTm93ID0gRGF0ZS5ub3coKSAvIDEwMDBcbiAgICAgIGxldCBleHBpcmVzQXQgPSB0aW1lTm93XG4gICAgICBsZXQgaGFzRXhwaXJlZCA9IHRydWVcbiAgICAgIGxldCBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCA9IG51bGxcbiAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gZGVjb2RlSldUKGN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbilcbiAgICAgIGlmIChwYXlsb2FkLmV4cCkge1xuICAgICAgICBleHBpcmVzQXQgPSBwYXlsb2FkLmV4cFxuICAgICAgICBoYXNFeHBpcmVkID0gZXhwaXJlc0F0IDw9IHRpbWVOb3dcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0V4cGlyZWQpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiByZWZyZXNoZWRTZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihcbiAgICAgICAgICBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuXG4gICAgICAgIClcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVmcmVzaGVkU2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9XG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvbiA9IHJlZnJlc2hlZFNlc3Npb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pXG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvbiA9IHtcbiAgICAgICAgICBhY2Nlc3NfdG9rZW46IGN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICByZWZyZXNoX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgIHVzZXI6IGRhdGEudXNlcixcbiAgICAgICAgICB0b2tlbl90eXBlOiAnYmVhcmVyJyxcbiAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzQXQgLSB0aW1lTm93LFxuICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbilcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9KVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHNlc3Npb24sIHJlZ2FyZGxlc3Mgb2YgZXhwaXJ5IHN0YXR1cy5cbiAgICogVGFrZXMgaW4gYW4gb3B0aW9uYWwgY3VycmVudCBzZXNzaW9uLiBJZiBub3QgcGFzc2VkIGluLCB0aGVuIHJlZnJlc2hTZXNzaW9uKCkgd2lsbCBhdHRlbXB0IHRvIHJldHJpZXZlIGl0IGZyb20gZ2V0U2Vzc2lvbigpLlxuICAgKiBJZiB0aGUgY3VycmVudCBzZXNzaW9uJ3MgcmVmcmVzaCB0b2tlbiBpcyBpbnZhbGlkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICogQHBhcmFtIGN1cnJlbnRTZXNzaW9uIFRoZSBjdXJyZW50IHNlc3Npb24uIElmIHBhc3NlZCBpbiwgaXQgbXVzdCBjb250YWluIGEgcmVmcmVzaCB0b2tlbi5cbiAgICovXG4gIGFzeW5jIHJlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uPzogeyByZWZyZXNoX3Rva2VuOiBzdHJpbmcgfSk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pXG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24/OiB7XG4gICAgcmVmcmVzaF90b2tlbjogc3RyaW5nXG4gIH0pOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFNlc3Npb24gPSBkYXRhLnNlc3Npb24gPz8gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uPy5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbilcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG51bGwgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9KVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pXG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIGEgVVJMIHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0U2Vzc2lvbkZyb21VUkwoXG4gICAgcGFyYW1zOiB7IFtwYXJhbWV0ZXI6IHN0cmluZ106IHN0cmluZyB9LFxuICAgIGNhbGxiYWNrVXJsVHlwZTogc3RyaW5nXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogU2Vzc2lvbjsgcmVkaXJlY3RUeXBlOiBzdHJpbmcgfCBudWxsIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHsgZGF0YTogeyBzZXNzaW9uOiBudWxsOyByZWRpcmVjdFR5cGU6IG51bGwgfTsgZXJyb3I6IEF1dGhFcnJvciB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWlzQnJvd3NlcigpKSB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdObyBicm93c2VyIGRldGVjdGVkLicpXG5cbiAgICAgIC8vIElmIHRoZXJlJ3MgYW4gZXJyb3IgaW4gdGhlIFVSTCwgaXQgZG9lc24ndCBtYXR0ZXIgd2hhdCBmbG93IGl0IGlzLCB3ZSBqdXN0IHJldHVybiB0aGUgZXJyb3IuXG4gICAgICBpZiAocGFyYW1zLmVycm9yIHx8IHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCBwYXJhbXMuZXJyb3JfY29kZSkge1xuICAgICAgICAvLyBUaGUgZXJyb3IgY2xhc3MgcmV0dXJuZWQgaW1wbGllcyB0aGF0IHRoZSByZWRpcmVjdCBpcyBmcm9tIGFuIGltcGxpY2l0IGdyYW50IGZsb3dcbiAgICAgICAgLy8gYnV0IGl0IGNvdWxkIGFsc28gYmUgZnJvbSBhIHJlZGlyZWN0IGVycm9yIGZyb20gYSBQS0NFIGZsb3cuXG4gICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoXG4gICAgICAgICAgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uIHx8ICdFcnJvciBpbiBVUkwgd2l0aCB1bnNwZWNpZmllZCBlcnJvcl9kZXNjcmlwdGlvbicsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3I6IHBhcmFtcy5lcnJvciB8fCAndW5zcGVjaWZpZWRfZXJyb3InLFxuICAgICAgICAgICAgY29kZTogcGFyYW1zLmVycm9yX2NvZGUgfHwgJ3Vuc3BlY2lmaWVkX2NvZGUnLFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVja3MgZm9yIG1pc21hdGNoZXMgYmV0d2VlbiB0aGUgZmxvd1R5cGUgaW5pdGlhbGlzZWQgaW4gdGhlIGNsaWVudCBhbmQgdGhlIFVSTCBwYXJhbWV0ZXJzXG4gICAgICBzd2l0Y2ggKGNhbGxiYWNrVXJsVHlwZSkge1xuICAgICAgICBjYXNlICdpbXBsaWNpdCc6XG4gICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcignTm90IGEgdmFsaWQgUEtDRSBmbG93IHVybC4nKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwa2NlJzpcbiAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ2ltcGxpY2l0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm90IGEgdmFsaWQgaW1wbGljaXQgZ3JhbnQgZmxvdyB1cmwuJylcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gdGhlcmUncyBubyBtaXNtYXRjaCBzbyB3ZSBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgcmVkaXJlY3QgZm9yIFBLQ0UsIHdlIGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIGNvZGUgZnJvbSB0aGUgVVJMIGZvciB0aGUgY29kZSBleGNoYW5nZVxuICAgICAgaWYgKGNhbGxiYWNrVXJsVHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdiZWdpbicsICdpcyBQS0NFIGZsb3cnLCB0cnVlKVxuICAgICAgICBpZiAoIXBhcmFtcy5jb2RlKSB0aHJvdyBuZXcgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yKCdObyBjb2RlIGRldGVjdGVkLicpXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24ocGFyYW1zLmNvZGUpXG4gICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZSgnY29kZScpXG5cbiAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHdpbmRvdy5oaXN0b3J5LnN0YXRlLCAnJywgdXJsLnRvU3RyaW5nKCkpXG5cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBkYXRhLnNlc3Npb24sIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcHJvdmlkZXJfdG9rZW4sXG4gICAgICAgIHByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sXG4gICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgcmVmcmVzaF90b2tlbixcbiAgICAgICAgZXhwaXJlc19pbixcbiAgICAgICAgZXhwaXJlc19hdCxcbiAgICAgICAgdG9rZW5fdHlwZSxcbiAgICAgIH0gPSBwYXJhbXNcblxuICAgICAgaWYgKCFhY2Nlc3NfdG9rZW4gfHwgIWV4cGlyZXNfaW4gfHwgIXJlZnJlc2hfdG9rZW4gfHwgIXRva2VuX3R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gc2Vzc2lvbiBkZWZpbmVkIGluIFVSTCcpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKVxuICAgICAgY29uc3QgZXhwaXJlc0luID0gcGFyc2VJbnQoZXhwaXJlc19pbilcbiAgICAgIGxldCBleHBpcmVzQXQgPSB0aW1lTm93ICsgZXhwaXJlc0luXG5cbiAgICAgIGlmIChleHBpcmVzX2F0KSB7XG4gICAgICAgIGV4cGlyZXNBdCA9IHBhcnNlSW50KGV4cGlyZXNfYXQpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjdHVhbGx5RXhwaXJlc0luID0gZXhwaXJlc0F0IC0gdGltZU5vd1xuICAgICAgaWYgKGFjdHVhbGx5RXhwaXJlc0luICogMTAwMCA8PSBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYEBzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIGV4cGlyZXMgaW4gJHthY3R1YWxseUV4cGlyZXNJbn1zLCBzaG91bGQgaGF2ZSBiZWVuIGNsb3NlciB0byAke2V4cGlyZXNJbn1zYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzc3VlZEF0ID0gZXhwaXJlc0F0IC0gZXhwaXJlc0luXG4gICAgICBpZiAodGltZU5vdyAtIGlzc3VlZEF0ID49IDEyMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgb3ZlciAxMjBzIGFnbywgVVJMIGNvdWxkIGJlIHN0YWxlJyxcbiAgICAgICAgICBpc3N1ZWRBdCxcbiAgICAgICAgICBleHBpcmVzQXQsXG4gICAgICAgICAgdGltZU5vd1xuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA8IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCB3YXMgaXNzdWVkIGluIHRoZSBmdXR1cmU/IENoZWNrIHRoZSBkZXZpY2UgY2xvY2sgZm9yIHNrZXcnLFxuICAgICAgICAgIGlzc3VlZEF0LFxuICAgICAgICAgIGV4cGlyZXNBdCxcbiAgICAgICAgICB0aW1lTm93XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihhY2Nlc3NfdG9rZW4pXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gPSB7XG4gICAgICAgIHByb3ZpZGVyX3Rva2VuLFxuICAgICAgICBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLFxuICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgIGV4cGlyZXNfaW46IGV4cGlyZXNJbixcbiAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LFxuICAgICAgICByZWZyZXNoX3Rva2VuLFxuICAgICAgICB0b2tlbl90eXBlOiB0b2tlbl90eXBlIGFzICdiZWFyZXInLFxuICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0b2tlbnMgZnJvbSBVUkxcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJydcbiAgICAgIHRoaXMuX2RlYnVnKCcjX2dldFNlc3Npb25Gcm9tVVJMKCknLCAnY2xlYXJpbmcgd2luZG93LmxvY2F0aW9uLmhhc2gnKVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBzZXNzaW9uLCByZWRpcmVjdFR5cGU6IHBhcmFtcy50eXBlIH0sIGVycm9yOiBudWxsIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yIH0pXG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgY29udGFpbnMgcGFyYW1ldGVycyBnaXZlbiBieSBhbiBpbXBsaWNpdCBvYXV0aCBncmFudCBmbG93IChodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjc0OS5odG1sI3NlY3Rpb24tNC4yKVxuICAgKlxuICAgKiBJZiBgZGV0ZWN0U2Vzc2lvbkluVXJsYCBpcyBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBVUkwgYW5kIHBhcmFtcyB0byBkZXRlcm1pbmVcbiAgICogaWYgdGhlIFVSTCBzaG91bGQgYmUgcHJvY2Vzc2VkIGFzIGEgU3VwYWJhc2UgYXV0aCBjYWxsYmFjay4gVGhpcyBhbGxvd3MgdXNlcnMgdG8gZXhjbHVkZVxuICAgKiBVUkxzIGZyb20gb3RoZXIgT0F1dGggcHJvdmlkZXJzIChlLmcuLCBGYWNlYm9vayBMb2dpbikgdGhhdCBhbHNvIHJldHVybiBhY2Nlc3NfdG9rZW4gaW4gdGhlIGZyYWdtZW50LlxuICAgKi9cbiAgcHJpdmF0ZSBfaXNJbXBsaWNpdEdyYW50Q2FsbGJhY2socGFyYW1zOiB7IFtwYXJhbWV0ZXI6IHN0cmluZ106IHN0cmluZyB9KTogYm9vbGVhbiB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmRldGVjdFNlc3Npb25JblVybCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpLCBwYXJhbXMpXG4gICAgfVxuICAgIHJldHVybiBCb29sZWFuKHBhcmFtcy5hY2Nlc3NfdG9rZW4gfHwgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgYW5kIGJhY2tpbmcgc3RvcmFnZSBjb250YWluIHBhcmFtZXRlcnMgZ2l2ZW4gYnkgYSBQS0NFIGZsb3dcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2lzUEtDRUNhbGxiYWNrKHBhcmFtczogeyBbcGFyYW1ldGVyOiBzdHJpbmddOiBzdHJpbmcgfSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGN1cnJlbnRTdG9yYWdlQ29udGVudCA9IGF3YWl0IGdldEl0ZW1Bc3luYyhcbiAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmBcbiAgICApXG5cbiAgICByZXR1cm4gISEocGFyYW1zLmNvZGUgJiYgY3VycmVudFN0b3JhZ2VDb250ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2lkZSBhIGJyb3dzZXIgY29udGV4dCwgYHNpZ25PdXQoKWAgd2lsbCByZW1vdmUgdGhlIGxvZ2dlZCBpbiB1c2VyIGZyb20gdGhlIGJyb3dzZXIgc2Vzc2lvbiBhbmQgbG9nIHRoZW0gb3V0IC0gcmVtb3ZpbmcgYWxsIGl0ZW1zIGZyb20gbG9jYWxzdG9yYWdlIGFuZCB0aGVuIHRyaWdnZXIgYSBgXCJTSUdORURfT1VUXCJgIGV2ZW50LlxuICAgKlxuICAgKiBGb3Igc2VydmVyLXNpZGUgbWFuYWdlbWVudCwgeW91IGNhbiByZXZva2UgYWxsIHJlZnJlc2ggdG9rZW5zIGZvciBhIHVzZXIgYnkgcGFzc2luZyBhIHVzZXIncyBKV1QgdGhyb3VnaCB0byBgYXV0aC5hcGkuc2lnbk91dChKV1Q6IHN0cmluZylgLlxuICAgKiBUaGVyZSBpcyBubyB3YXkgdG8gcmV2b2tlIGEgdXNlcidzIGFjY2VzcyB0b2tlbiBqd3QgdW50aWwgaXQgZXhwaXJlcy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gc2V0IGEgc2hvcnRlciBleHBpcnkgb24gdGhlIGp3dCBmb3IgdGhpcyByZWFzb24uXG4gICAqXG4gICAqIElmIHVzaW5nIGBvdGhlcnNgIHNjb3BlLCBubyBgU0lHTkVEX09VVGAgZXZlbnQgaXMgZmlyZWQhXG4gICAqL1xuICBhc3luYyBzaWduT3V0KG9wdGlvbnM6IFNpZ25PdXQgPSB7IHNjb3BlOiAnZ2xvYmFsJyB9KTogUHJvbWlzZTx7IGVycm9yOiBBdXRoRXJyb3IgfCBudWxsIH0+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zaWduT3V0KG9wdGlvbnMpXG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfc2lnbk91dChcbiAgICB7IHNjb3BlIH06IFNpZ25PdXQgPSB7IHNjb3BlOiAnZ2xvYmFsJyB9XG4gICk6IFByb21pc2U8eyBlcnJvcjogQXV0aEVycm9yIHwgbnVsbCB9PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHRcbiAgICAgIGlmIChzZXNzaW9uRXJyb3IgJiYgIWlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3Ioc2Vzc2lvbkVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZXJyb3I6IHNlc3Npb25FcnJvciB9KVxuICAgICAgfVxuICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSBkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlblxuICAgICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuYWRtaW4uc2lnbk91dChhY2Nlc3NUb2tlbiwgc2NvcGUpXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIC8vIGlnbm9yZSA0MDRzIHNpbmNlIHVzZXIgbWlnaHQgbm90IGV4aXN0IGFueW1vcmVcbiAgICAgICAgICAvLyBpZ25vcmUgNDAxcyBzaW5jZSBhbiBpbnZhbGlkIG9yIGV4cGlyZWQgSldUIHNob3VsZCBzaWduIG91dCB0aGUgY3VycmVudCBzZXNzaW9uXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgKGlzQXV0aEFwaUVycm9yKGVycm9yKSAmJlxuICAgICAgICAgICAgICAgIChlcnJvci5zdGF0dXMgPT09IDQwNCB8fCBlcnJvci5zdGF0dXMgPT09IDQwMSB8fCBlcnJvci5zdGF0dXMgPT09IDQwMykpIHx8XG4gICAgICAgICAgICAgIGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZXJyb3IgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzY29wZSAhPT0gJ290aGVycycpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZXJyb3I6IG51bGwgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY2VpdmUgYSBub3RpZmljYXRpb24gZXZlcnkgdGltZSBhbiBhdXRoIGV2ZW50IGhhcHBlbnMuXG4gICAqIFNhZmUgdG8gdXNlIHdpdGhvdXQgYW4gYXN5bmMgZnVuY3Rpb24gYXMgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiBhbiBhdXRoIGV2ZW50IGhhcHBlbnMuXG4gICAqL1xuICBvbkF1dGhTdGF0ZUNoYW5nZShjYWxsYmFjazogKGV2ZW50OiBBdXRoQ2hhbmdlRXZlbnQsIHNlc3Npb246IFNlc3Npb24gfCBudWxsKSA9PiB2b2lkKToge1xuICAgIGRhdGE6IHsgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gfVxuICB9XG5cbiAgLyoqXG4gICAqIEF2b2lkIHVzaW5nIGFuIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSBgb25BdXRoU3RhdGVDaGFuZ2VgIGFzIHlvdSBtaWdodCBlbmRcbiAgICogdXAgd2l0aCBhIGRlYWRsb2NrLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gcnVucyBpbnNpZGUgYW4gZXhjbHVzaXZlIGxvY2ssXG4gICAqIHNvIGNhbGxpbmcgb3RoZXIgU3VwYWJhc2UgQ2xpZW50IEFQSXMgdGhhdCBhbHNvIHRyeSB0byBhY3F1aXJlIHRoZVxuICAgKiBleGNsdXNpdmUgbG9jaywgbWlnaHQgY2F1c2UgYSBkZWFkbG9jay4gVGhpcyBiZWhhdmlvciBpcyBvYnNlcnZhYmxlIGFjcm9zc1xuICAgKiB0YWJzLiBJbiB0aGUgbmV4dCBtYWpvciBsaWJyYXJ5IHZlcnNpb24sIHRoaXMgYmVoYXZpb3Igd2lsbCBub3QgYmUgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBSZWNlaXZlIGEgbm90aWZpY2F0aW9uIGV2ZXJ5IHRpbWUgYW4gYXV0aCBldmVudCBoYXBwZW5zLlxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gYW4gYXV0aCBldmVudCBoYXBwZW5zLlxuICAgKiBAZGVwcmVjYXRlZCBEdWUgdG8gdGhlIHBvc3NpYmlsaXR5IG9mIGRlYWRsb2NrcyB3aXRoIGFzeW5jIGZ1bmN0aW9ucyBhcyBjYWxsYmFja3MsIHVzZSB0aGUgdmVyc2lvbiB3aXRob3V0IGFuIGFzeW5jIGZ1bmN0aW9uLlxuICAgKi9cbiAgb25BdXRoU3RhdGVDaGFuZ2UoY2FsbGJhY2s6IChldmVudDogQXV0aENoYW5nZUV2ZW50LCBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCkgPT4gUHJvbWlzZTx2b2lkPik6IHtcbiAgICBkYXRhOiB7IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uIH1cbiAgfVxuXG4gIG9uQXV0aFN0YXRlQ2hhbmdlKFxuICAgIGNhbGxiYWNrOiAoZXZlbnQ6IEF1dGhDaGFuZ2VFdmVudCwgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG4gICk6IHtcbiAgICBkYXRhOiB7IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uIH1cbiAgfSB7XG4gICAgY29uc3QgaWQ6IHN0cmluZyB8IHN5bWJvbCA9IGdlbmVyYXRlQ2FsbGJhY2tJZCgpXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gPSB7XG4gICAgICBpZCxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyN1bnN1YnNjcmliZSgpJywgJ3N0YXRlIGNoYW5nZSBjYWxsYmFjayB3aXRoIGlkIHJlbW92ZWQnLCBpZClcblxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZGVsZXRlKGlkKVxuICAgICAgfSxcbiAgICB9XG5cbiAgICB0aGlzLl9kZWJ1ZygnI29uQXV0aFN0YXRlQ2hhbmdlKCknLCAncmVnaXN0ZXJlZCBjYWxsYmFjayB3aXRoIGlkJywgaWQpXG5cbiAgICB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuc2V0KGlkLCBzdWJzY3JpcHRpb24pXG4gICAgOyhhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VtaXRJbml0aWFsU2Vzc2lvbihpZClcbiAgICAgIH0pXG4gICAgfSkoKVxuXG4gICAgcmV0dXJuIHsgZGF0YTogeyBzdWJzY3JpcHRpb24gfSB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9lbWl0SW5pdGlhbFNlc3Npb24oaWQ6IHN0cmluZyB8IHN5bWJvbCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgICAgYXdhaXQgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLmdldChpZCk/LmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBzZXNzaW9uKVxuICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdzZXNzaW9uJywgc2Vzc2lvbilcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBhd2FpdCB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZ2V0KGlkKT8uY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIG51bGwpXG4gICAgICAgIHRoaXMuX2RlYnVnKCdJTklUSUFMX1NFU1NJT04nLCAnY2FsbGJhY2sgaWQnLCBpZCwgJ2Vycm9yJywgZXJyKVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGFzc3dvcmQgcmVzZXQgcmVxdWVzdCB0byBhbiBlbWFpbCBhZGRyZXNzLiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgKlxuICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIFVSTCB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgY2xpY2sgdGhlIHBhc3N3b3JkIHJlc2V0IGxpbmsuXG4gICAqIEBwYXJhbSBvcHRpb25zLmNhcHRjaGFUb2tlbiBWZXJpZmljYXRpb24gdG9rZW4gcmVjZWl2ZWQgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIGNhcHRjaGEgb24gdGhlIHNpdGUuXG4gICAqL1xuICBhc3luYyByZXNldFBhc3N3b3JkRm9yRW1haWwoXG4gICAgZW1haWw6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZWRpcmVjdFRvPzogc3RyaW5nXG4gICAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YToge31cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHsgZGF0YTogbnVsbDsgZXJyb3I6IEF1dGhFcnJvciB9XG4gID4ge1xuICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgO1tjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5LFxuICAgICAgICB0cnVlIC8vIGlzUGFzc3dvcmRSZWNvdmVyeVxuICAgICAgKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3JlY292ZXJgLCB7XG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSlcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgdGhlIGlkZW50aXRpZXMgbGlua2VkIHRvIGEgdXNlci5cbiAgICovXG4gIGFzeW5jIGdldFVzZXJJZGVudGl0aWVzKCk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZGVudGl0aWVzOiBVc2VySWRlbnRpdHlbXVxuICAgICAgICB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKClcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IGlkZW50aXRpZXM6IGRhdGEudXNlci5pZGVudGl0aWVzID8/IFtdIH0sIGVycm9yOiBudWxsIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMaW5rcyBhbiBvYXV0aCBpZGVudGl0eSB0byBhbiBleGlzdGluZyB1c2VyLlxuICAgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgKi9cbiAgYXN5bmMgbGlua0lkZW50aXR5KGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoT0F1dGhDcmVkZW50aWFscyk6IFByb21pc2U8T0F1dGhSZXNwb25zZT5cblxuICAvKipcbiAgICogTGlua3MgYW4gT0lEQyBpZGVudGl0eSB0byBhbiBleGlzdGluZyB1c2VyLlxuICAgKi9cbiAgYXN5bmMgbGlua0lkZW50aXR5KGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoSWRUb2tlbkNyZWRlbnRpYWxzKTogUHJvbWlzZTxBdXRoVG9rZW5SZXNwb25zZT5cblxuICBhc3luYyBsaW5rSWRlbnRpdHkoY3JlZGVudGlhbHM6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCd0b2tlbicgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpbmtJZGVudGl0eUlkVG9rZW4oY3JlZGVudGlhbHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubGlua0lkZW50aXR5T0F1dGgoY3JlZGVudGlhbHMpXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxpbmtJZGVudGl0eU9BdXRoKGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoT0F1dGhDcmVkZW50aWFscyk6IFByb21pc2U8T0F1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgICAgY29uc3QgdXJsOiBzdHJpbmcgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihcbiAgICAgICAgICBgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzL2F1dGhvcml6ZWAsXG4gICAgICAgICAgY3JlZGVudGlhbHMucHJvdmlkZXIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVkaXJlY3RUbzogY3JlZGVudGlhbHMub3B0aW9ucz8ucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIHNjb3BlczogY3JlZGVudGlhbHMub3B0aW9ucz8uc2NvcGVzLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgc2tpcEJyb3dzZXJSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCB1cmwsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbiA/PyB1bmRlZmluZWQsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgaWYgKGlzQnJvd3NlcigpICYmICFjcmVkZW50aWFscy5vcHRpb25zPy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oZGF0YT8udXJsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgIGRhdGE6IHsgcHJvdmlkZXI6IGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB1cmw6IGRhdGE/LnVybCB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgcHJvdmlkZXI6IGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB1cmw6IG51bGwgfSwgZXJyb3IgfSlcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsaW5rSWRlbnRpdHlJZFRva2VuKFxuICAgIGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoSWRUb2tlbkNyZWRlbnRpYWxzXG4gICk6IFByb21pc2U8QXV0aFRva2VuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZXJyb3I6IHNlc3Npb25FcnJvcixcbiAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB0aHJvdyBzZXNzaW9uRXJyb3JcblxuICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHByb3ZpZGVyLCB0b2tlbiwgYWNjZXNzX3Rva2VuLCBub25jZSB9ID0gY3JlZGVudGlhbHNcblxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPWlkX3Rva2VuYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBqd3Q6IHNlc3Npb24/LmFjY2Vzc190b2tlbiA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICBpZF90b2tlbjogdG9rZW4sXG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgIGxpbmtfaWRlbnRpdHk6IHRydWUsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pXG4gICAgICAgIH0gZWxzZSBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pXG4gICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1VTRVJfVVBEQVRFRCcsIGRhdGEuc2Vzc2lvbilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YSwgZXJyb3IgfSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApXG4gICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFVubGlua3MgYW4gaWRlbnRpdHkgZnJvbSBhIHVzZXIgYnkgZGVsZXRpbmcgaXQuIFRoZSB1c2VyIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gc2lnbiBpbiB3aXRoIHRoYXQgaWRlbnRpdHkgb25jZSBpdCdzIHVubGlua2VkLlxuICAgKi9cbiAgYXN5bmMgdW5saW5rSWRlbnRpdHkoaWRlbnRpdHk6IFVzZXJJZGVudGl0eSk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHt9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QoXG4gICAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgICAnREVMRVRFJyxcbiAgICAgICAgICBgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzLyR7aWRlbnRpdHkuaWRlbnRpdHlfaWR9YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBqd3Q6IGRhdGEuc2Vzc2lvbj8uYWNjZXNzX3Rva2VuID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBuZXcgSldULlxuICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuIEEgdmFsaWQgcmVmcmVzaCB0b2tlbiB0aGF0IHdhcyByZXR1cm5lZCBvbiBsb2dpbi5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW46IHN0cmluZyk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgY29uc3QgZGVidWdOYW1lID0gYCNfcmVmcmVzaEFjY2Vzc1Rva2VuKCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCA1KX0uLi4pYFxuICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJylcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFydGVkQXQgPSBEYXRlLm5vdygpXG5cbiAgICAgIC8vIHdpbGwgYXR0ZW1wdCB0byByZWZyZXNoIHRoZSB0b2tlbiB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgIHJldHVybiBhd2FpdCByZXRyeWFibGUoXG4gICAgICAgIGFzeW5jIChhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcCgyMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0IC0gMSkpIC8vIDIwMCwgNDAwLCA4MDAsIC4uLlxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3JlZnJlc2hpbmcgYXR0ZW1wdCcsIGF0dGVtcHQpXG5cbiAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1yZWZyZXNoX3Rva2VuYCwge1xuICAgICAgICAgICAgYm9keTogeyByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4gfSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIChhdHRlbXB0LCBlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnN0IG5leHRCYWNrT2ZmSW50ZXJ2YWwgPSAyMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0KVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBlcnJvciAmJlxuICAgICAgICAgICAgaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICAgIC8vIHJldHJ5YWJsZSBvbmx5IGlmIHRoZSByZXF1ZXN0IGNhbiBiZSBzZW50IGJlZm9yZSB0aGUgYmFja29mZiBvdmVyZmxvd3MgdGhlIHRpY2sgZHVyYXRpb25cbiAgICAgICAgICAgIERhdGUubm93KCkgKyBuZXh0QmFja09mZkludGVydmFsIC0gc3RhcnRlZEF0IDwgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVNcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnJvcilcblxuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCB1c2VyOiBudWxsIH0sIGVycm9yIH0pXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2lzVmFsaWRTZXNzaW9uKG1heWJlU2Vzc2lvbjogdW5rbm93bik6IG1heWJlU2Vzc2lvbiBpcyBTZXNzaW9uIHtcbiAgICBjb25zdCBpc1ZhbGlkU2Vzc2lvbiA9XG4gICAgICB0eXBlb2YgbWF5YmVTZXNzaW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgbWF5YmVTZXNzaW9uICE9PSBudWxsICYmXG4gICAgICAnYWNjZXNzX3Rva2VuJyBpbiBtYXliZVNlc3Npb24gJiZcbiAgICAgICdyZWZyZXNoX3Rva2VuJyBpbiBtYXliZVNlc3Npb24gJiZcbiAgICAgICdleHBpcmVzX2F0JyBpbiBtYXliZVNlc3Npb25cblxuICAgIHJldHVybiBpc1ZhbGlkU2Vzc2lvblxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfaGFuZGxlUHJvdmlkZXJTaWduSW4oXG4gICAgcHJvdmlkZXI6IFByb3ZpZGVyLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgICAgIHNjb3Blcz86IHN0cmluZ1xuICAgICAgcXVlcnlQYXJhbXM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gICAgICBza2lwQnJvd3NlclJlZGlyZWN0PzogYm9vbGVhblxuICAgIH1cbiAgKSB7XG4gICAgY29uc3QgdXJsOiBzdHJpbmcgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihgJHt0aGlzLnVybH0vYXV0aG9yaXplYCwgcHJvdmlkZXIsIHtcbiAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgIHNjb3Blczogb3B0aW9ucy5zY29wZXMsXG4gICAgICBxdWVyeVBhcmFtczogb3B0aW9ucy5xdWVyeVBhcmFtcyxcbiAgICB9KVxuXG4gICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlUHJvdmlkZXJTaWduSW4oKScsICdwcm92aWRlcicsIHByb3ZpZGVyLCAnb3B0aW9ucycsIG9wdGlvbnMsICd1cmwnLCB1cmwpXG5cbiAgICAvLyB0cnkgdG8gb3BlbiBvbiB0aGUgYnJvd3NlclxuICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybClcbiAgICB9XG5cbiAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyLCB1cmwgfSwgZXJyb3I6IG51bGwgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY292ZXJzIHRoZSBzZXNzaW9uIGZyb20gTG9jYWxTdG9yYWdlIGFuZCByZWZyZXNoZXMgdGhlIHRva2VuXG4gICAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIGFzeW5jIHRvIGFjY29tbW9kYXRlIGZvciBBc3luY1N0b3JhZ2UgZS5nLiBpbiBSZWFjdCBuYXRpdmUuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9yZWNvdmVyQW5kUmVmcmVzaCgpIHtcbiAgICBjb25zdCBkZWJ1Z05hbWUgPSAnI19yZWNvdmVyQW5kUmVmcmVzaCgpJ1xuICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJylcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpKSBhcyBTZXNzaW9uIHwgbnVsbFxuXG4gICAgICBpZiAoY3VycmVudFNlc3Npb24gJiYgdGhpcy51c2VyU3RvcmFnZSkge1xuICAgICAgICBsZXQgbWF5YmVVc2VyOiB7IHVzZXI6IFVzZXIgfCBudWxsIH0gfCBudWxsID0gKGF3YWl0IGdldEl0ZW1Bc3luYyhcbiAgICAgICAgICB0aGlzLnVzZXJTdG9yYWdlLFxuICAgICAgICAgIHRoaXMuc3RvcmFnZUtleSArICctdXNlcidcbiAgICAgICAgKSkgYXMgYW55XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0b3JhZ2UuaXNTZXJ2ZXIgJiYgT2JqZWN0LmlzKHRoaXMuc3RvcmFnZSwgdGhpcy51c2VyU3RvcmFnZSkgJiYgIW1heWJlVXNlcikge1xuICAgICAgICAgIC8vIHN0b3JhZ2UgYW5kIHVzZXJTdG9yYWdlIGFyZSB0aGUgc2FtZSBzdG9yYWdlIG1lZGl1bSwgZm9yIGV4YW1wbGVcbiAgICAgICAgICAvLyB3aW5kb3cubG9jYWxTdG9yYWdlIGlmIHVzZXJTdG9yYWdlIGRvZXMgbm90IGhhdmUgdGhlIHVzZXIgZnJvbVxuICAgICAgICAgIC8vIHN0b3JhZ2Ugc3RvcmVkLCBzdG9yZSBpdCBmaXJzdCB0aGVyZWJ5IG1pZ3JhdGluZyB0aGUgdXNlciBvYmplY3RcbiAgICAgICAgICAvLyBmcm9tIHN0b3JhZ2UgLT4gdXNlclN0b3JhZ2VcblxuICAgICAgICAgIG1heWJlVXNlciA9IHsgdXNlcjogY3VycmVudFNlc3Npb24udXNlciB9XG4gICAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMudXNlclN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicsIG1heWJlVXNlcilcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSBtYXliZVVzZXI/LnVzZXIgPz8gdXNlck5vdEF2YWlsYWJsZVByb3h5KClcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFNlc3Npb24gJiYgIWN1cnJlbnRTZXNzaW9uLnVzZXIpIHtcbiAgICAgICAgLy8gdXNlciBzdG9yYWdlIGlzIG5vdCBzZXQsIGxldCdzIGNoZWNrIGlmIGl0IHdhcyBwcmV2aW91c2x5IGVuYWJsZWQgc29cbiAgICAgICAgLy8gd2UgYnJpbmcgYmFjayB0aGUgc3RvcmFnZSBhcyBpdCBzaG91bGQgYmVcblxuICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uLnVzZXIpIHtcbiAgICAgICAgICAvLyB0ZXN0IGlmIHVzZXJTdG9yYWdlIHdhcyBwcmV2aW91c2x5IGVuYWJsZWQgYW5kIHRoZSBzdG9yYWdlIG1lZGl1bSB3YXMgdGhlIHNhbWUsIHRvIG1vdmUgdGhlIHVzZXIgYmFjayB1bmRlciB0aGUgc2FtZSBrZXlcbiAgICAgICAgICBjb25zdCBzZXBhcmF0ZVVzZXI6IHsgdXNlcjogVXNlciB8IG51bGwgfSB8IG51bGwgPSAoYXdhaXQgZ2V0SXRlbUFzeW5jKFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJ1xuICAgICAgICAgICkpIGFzIGFueVxuXG4gICAgICAgICAgaWYgKHNlcGFyYXRlVXNlciAmJiBzZXBhcmF0ZVVzZXI/LnVzZXIpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSBzZXBhcmF0ZVVzZXIudXNlclxuXG4gICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInKVxuICAgICAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCBjdXJyZW50U2Vzc2lvbilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IHVzZXJOb3RBdmFpbGFibGVQcm94eSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgY3VycmVudFNlc3Npb24pXG5cbiAgICAgIGlmICghdGhpcy5faXNWYWxpZFNlc3Npb24oY3VycmVudFNlc3Npb24pKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3Nlc3Npb24gaXMgbm90IHZhbGlkJylcbiAgICAgICAgaWYgKGN1cnJlbnRTZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgZXhwaXJlc1dpdGhNYXJnaW4gPVxuICAgICAgICAoY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCA/PyBJbmZpbml0eSkgKiAxMDAwIC0gRGF0ZS5ub3coKSA8IEVYUElSWV9NQVJHSU5fTVNcblxuICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgIGRlYnVnTmFtZSxcbiAgICAgICAgYHNlc3Npb24gaGFzJHtleHBpcmVzV2l0aE1hcmdpbiA/ICcnIDogJyBub3QnfSBleHBpcmVkIHdpdGggbWFyZ2luIG9mICR7RVhQSVJZX01BUkdJTl9NU31zYFxuICAgICAgKVxuXG4gICAgICBpZiAoZXhwaXJlc1dpdGhNYXJnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbiAmJiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKVxuXG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuXG4gICAgICAgICAgICBpZiAoIWlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICAgICAgICAgIGRlYnVnTmFtZSxcbiAgICAgICAgICAgICAgICAncmVmcmVzaCBmYWlsZWQgd2l0aCBhIG5vbi1yZXRyeWFibGUgZXJyb3IsIHJlbW92aW5nIHRoZSBzZXNzaW9uJyxcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgY3VycmVudFNlc3Npb24udXNlciAmJlxuICAgICAgICAoY3VycmVudFNlc3Npb24udXNlciBhcyBhbnkpLl9faXNVc2VyTm90QXZhaWxhYmxlUHJveHkgPT09IHRydWVcbiAgICAgICkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcHJveHkgdXNlciwgdHJ5IHRvIGdldCB0aGUgcmVhbCB1c2VyIGRhdGFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKVxuXG4gICAgICAgICAgaWYgKCF1c2VyRXJyb3IgJiYgZGF0YT8udXNlcikge1xuICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IGRhdGEudXNlclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oY3VycmVudFNlc3Npb24pXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgY3VycmVudFNlc3Npb24pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2NvdWxkIG5vdCBnZXQgdXNlciBkYXRhLCBza2lwcGluZyBTSUdORURfSU4gbm90aWZpY2F0aW9uJylcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGdldFVzZXJFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlciBkYXRhOicsIGdldFVzZXJFcnJvcilcbiAgICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAgIGRlYnVnTmFtZSxcbiAgICAgICAgICAgICdlcnJvciBnZXR0aW5nIHVzZXIgZGF0YSwgc2tpcHBpbmcgU0lHTkVEX0lOIG5vdGlmaWNhdGlvbicsXG4gICAgICAgICAgICBnZXRVc2VyRXJyb3JcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gcGVyc2lzdCBjdXJyZW50U2Vzc2lvbiBhZ2FpbiwgYXMgd2UganVzdCBsb2FkZWQgaXQgZnJvbVxuICAgICAgICAvLyBsb2NhbCBzdG9yYWdlOyBwZXJzaXN0aW5nIGl0IGFnYWluIG1heSBvdmVyd3JpdGUgYSB2YWx1ZSBzYXZlZCBieVxuICAgICAgICAvLyBhbm90aGVyIGNsaWVudCB3aXRoIGFjY2VzcyB0byB0aGUgc2FtZSBsb2NhbCBzdG9yYWdlXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBjdXJyZW50U2Vzc2lvbilcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2Vycm9yJywgZXJyKVxuXG4gICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIHJldHVyblxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2NhbGxSZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuOiBzdHJpbmcpOiBQcm9taXNlPENhbGxSZWZyZXNoVG9rZW5SZXN1bHQ+IHtcbiAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAgICB9XG5cbiAgICAvLyByZWZyZXNoaW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICBpZiAodGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5wcm9taXNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVidWdOYW1lID0gYCNfY2FsbFJlZnJlc2hUb2tlbigke3JlZnJlc2hUb2tlbi5zdWJzdHJpbmcoMCwgNSl9Li4uKWBcblxuICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJylcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCA9IG5ldyBEZWZlcnJlZDxDYWxsUmVmcmVzaFRva2VuUmVzdWx0PigpXG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICBpZiAoIWRhdGEuc2Vzc2lvbikgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcblxuICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1RPS0VOX1JFRlJFU0hFRCcsIGRhdGEuc2Vzc2lvbilcblxuICAgICAgY29uc3QgcmVzdWx0ID0geyBkYXRhOiBkYXRhLnNlc3Npb24sIGVycm9yOiBudWxsIH1cblxuICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpXG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnJvcilcblxuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGRhdGE6IG51bGwsIGVycm9yIH1cblxuICAgICAgICBpZiAoIWlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZD8ucmVzb2x2ZShyZXN1bHQpXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZD8ucmVqZWN0KGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBudWxsXG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX25vdGlmeUFsbFN1YnNjcmliZXJzKFxuICAgIGV2ZW50OiBBdXRoQ2hhbmdlRXZlbnQsXG4gICAgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwsXG4gICAgYnJvYWRjYXN0ID0gdHJ1ZVxuICApIHtcbiAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19ub3RpZnlBbGxTdWJzY3JpYmVycygke2V2ZW50fSlgXG4gICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nLCBzZXNzaW9uLCBgYnJvYWRjYXN0ID0gJHticm9hZGNhc3R9YClcblxuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5icm9hZGNhc3RDaGFubmVsICYmIGJyb2FkY2FzdCkge1xuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2UoeyBldmVudCwgc2Vzc2lvbiB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlcnJvcnM6IGFueVtdID0gW11cbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMudmFsdWVzKCkpLm1hcChhc3luYyAoeCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHguY2FsbGJhY2soZXZlbnQsIHNlc3Npb24pXG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yc1tpXSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycm9yc1swXVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgY3VycmVudFNlc3Npb24gYW5kIGN1cnJlbnRVc2VyXG4gICAqIHByb2Nlc3MgdG8gX3N0YXJ0QXV0b1JlZnJlc2hUb2tlbiBpZiBwb3NzaWJsZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfc2F2ZVNlc3Npb24oc2Vzc2lvbjogU2Vzc2lvbikge1xuICAgIHRoaXMuX2RlYnVnKCcjX3NhdmVTZXNzaW9uKCknLCBzZXNzaW9uKVxuICAgIC8vIF9zYXZlU2Vzc2lvbiBpcyBhbHdheXMgY2FsbGVkIHdoZW5ldmVyIGEgbmV3IHNlc3Npb24gaGFzIGJlZW4gYWNxdWlyZWRcbiAgICAvLyBzbyB3ZSBjYW4gc2FmZWx5IHN1cHByZXNzIHRoZSB3YXJuaW5nIHJldHVybmVkIGJ5IGZ1dHVyZSBnZXRTZXNzaW9uIGNhbGxzXG4gICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gdHJ1ZVxuICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApXG4gICAgLy8gQ3JlYXRlIGEgc2hhbGxvdyBjb3B5IHRvIHdvcmsgd2l0aCwgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIHNlc3Npb24gb2JqZWN0IGlmIGl0J3MgdXNlZCBlbHNld2hlcmVcbiAgICBjb25zdCBzZXNzaW9uVG9Qcm9jZXNzID0geyAuLi5zZXNzaW9uIH1cblxuICAgIGNvbnN0IHVzZXJJc1Byb3h5ID1cbiAgICAgIHNlc3Npb25Ub1Byb2Nlc3MudXNlciAmJiAoc2Vzc2lvblRvUHJvY2Vzcy51c2VyIGFzIGFueSkuX19pc1VzZXJOb3RBdmFpbGFibGVQcm94eSA9PT0gdHJ1ZVxuICAgIGlmICh0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICBpZiAoIXVzZXJJc1Byb3h5ICYmIHNlc3Npb25Ub1Byb2Nlc3MudXNlcikge1xuICAgICAgICAvLyBJZiBpdCdzIGEgcmVhbCB1c2VyIG9iamVjdCwgc2F2ZSBpdCB0byB1c2VyU3RvcmFnZS5cbiAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMudXNlclN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicsIHtcbiAgICAgICAgICB1c2VyOiBzZXNzaW9uVG9Qcm9jZXNzLnVzZXIsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKHVzZXJJc1Byb3h5KSB7XG4gICAgICAgIC8vIElmIGl0J3MgdGhlIHByb3h5LCBpdCBtZWFucyB1c2VyIHdhcyBub3QgZm91bmQgaW4gdXNlclN0b3JhZ2UuXG4gICAgICAgIC8vIFdlIHNob3VsZCBlbnN1cmUgbm8gc3RhbGUgdXNlciBkYXRhIGZvciB0aGlzIGtleSBleGlzdHMgaW4gdXNlclN0b3JhZ2UgaWYgd2Ugd2VyZSB0byBzYXZlIG51bGwsXG4gICAgICAgIC8vIG9yIHNpbXBseSBub3Qgc2F2ZSB0aGUgcHJveHkuIEZvciBub3csIHdlIGRvbid0IHNhdmUgdGhlIHByb3h5IGhlcmUuXG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYSBuZWVkIHRvIGNsZWFyIHVzZXJTdG9yYWdlIGlmIHVzZXIgYmVjb21lcyBwcm94eSwgdGhhdCBsb2dpYyB3b3VsZCBnbyBoZXJlLlxuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSBtYWluIHNlc3Npb24gZGF0YSBmb3IgcHJpbWFyeSBzdG9yYWdlOiByZW1vdmUgdGhlIHVzZXIgcHJvcGVydHkgYmVmb3JlIGNsb25pbmdcbiAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIG9yaWdpbmFsIHNlc3Npb24udXNlciBtaWdodCBiZSB0aGUgcHJveHlcbiAgICAgIGNvbnN0IG1haW5TZXNzaW9uRGF0YTogT21pdDxTZXNzaW9uLCAndXNlcic+ICYgeyB1c2VyPzogVXNlciB9ID0geyAuLi5zZXNzaW9uVG9Qcm9jZXNzIH1cbiAgICAgIGRlbGV0ZSBtYWluU2Vzc2lvbkRhdGEudXNlciAvLyBSZW1vdmUgdXNlciAocmVhbCBvciBwcm94eSkgYmVmb3JlIGNsb25pbmcgZm9yIG1haW4gc3RvcmFnZVxuXG4gICAgICBjb25zdCBjbG9uZWRNYWluU2Vzc2lvbkRhdGEgPSBkZWVwQ2xvbmUobWFpblNlc3Npb25EYXRhKVxuICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCBjbG9uZWRNYWluU2Vzc2lvbkRhdGEpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIHVzZXJTdG9yYWdlIGlzIGNvbmZpZ3VyZWQuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIHNlc3Npb24udXNlciBzaG91bGQgaWRlYWxseSBub3QgYmUgYSBwcm94eS5cbiAgICAgIC8vIElmIGl0IHdlcmUsIHN0cnVjdHVyZWRDbG9uZSB3b3VsZCBmYWlsLiBUaGlzIGltcGxpZXMgYW4gaXNzdWUgZWxzZXdoZXJlIGlmIHVzZXIgaXMgYSBwcm94eSBoZXJlXG4gICAgICBjb25zdCBjbG9uZWRTZXNzaW9uID0gZGVlcENsb25lKHNlc3Npb25Ub1Byb2Nlc3MpIC8vIHNlc3Npb25Ub1Byb2Nlc3Mgc3RpbGwgaGFzIGl0cyBvcmlnaW5hbCB1c2VyIHByb3BlcnR5XG4gICAgICBhd2FpdCBzZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXksIGNsb25lZFNlc3Npb24pXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfcmVtb3ZlU2Vzc2lvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnI19yZW1vdmVTZXNzaW9uKCknKVxuXG4gICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gZmFsc2VcblxuICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSlcbiAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLWNvZGUtdmVyaWZpZXInKVxuICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicpXG5cbiAgICBpZiAodGhpcy51c2VyU3RvcmFnZSkge1xuICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMudXNlclN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicpXG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9PVVQnLCBudWxsKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW55IHJlZ2lzdGVyZWQgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjay5cbiAgICpcbiAgICoge0BzZWUgI3N0YXJ0QXV0b1JlZnJlc2h9XG4gICAqIHtAc2VlICNzdG9wQXV0b1JlZnJlc2h9XG4gICAqL1xuICBwcml2YXRlIF9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2RlYnVnKCcjX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKScpXG5cbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFja1xuICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IG51bGxcblxuICAgIHRyeSB7XG4gICAgICBpZiAoY2FsbGJhY2sgJiYgaXNCcm93c2VyKCkgJiYgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcigncmVtb3ZpbmcgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjayBmYWlsZWQnLCBlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAqIHdpdGhpbiB0aGUgbGlicmFyeS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3N0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgYXdhaXQgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKClcblxuICAgIHRoaXMuX2RlYnVnKCcjX3N0YXJ0QXV0b1JlZnJlc2goKScpXG5cbiAgICBjb25zdCB0aWNrZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLl9hdXRvUmVmcmVzaFRva2VuVGljaygpLCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUylcbiAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gdGlja2VyXG5cbiAgICBpZiAodGlja2VyICYmIHR5cGVvZiB0aWNrZXIgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aWNrZXIudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHRpY2tlciBpcyBhIE5vZGVKUyBUaW1lb3V0IG9iamVjdCB0aGF0IGhhcyBhbiBgdW5yZWZgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lb3V0dW5yZWZcbiAgICAgIC8vIFdoZW4gYXV0byByZWZyZXNoIGlzIHVzZWQgaW4gTm9kZUpTIChsaWtlIGZvciB0ZXN0aW5nKSB0aGVcbiAgICAgIC8vIGBzZXRJbnRlcnZhbGAgaXMgcHJldmVudGluZyB0aGUgcHJvY2VzcyBmcm9tIGJlaW5nIG1hcmtlZCBhc1xuICAgICAgLy8gZmluaXNoZWQgYW5kIHRlc3RzIHJ1biBlbmRsZXNzbHkuIFRoaXMgY2FuIGJlIHByZXZlbnRlZCBieSBjYWxsaW5nXG4gICAgICAvLyBgdW5yZWYoKWAgb24gdGhlIHJldHVybmVkIG9iamVjdC5cbiAgICAgIHRpY2tlci51bnJlZigpXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGVuby51bnJlZlRpbWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBzaW1pbGFyIGxpa2UgZm9yIE5vZGVKUywgYnV0IHdpdGggdGhlIERlbm8gQVBJXG4gICAgICAvLyBodHRwczovL2Rlbm8ubGFuZC9hcGlAbGF0ZXN0P3Vuc3RhYmxlJnM9RGVuby51bnJlZlRpbWVyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICAgIERlbm8udW5yZWZUaW1lcih0aWNrZXIpXG4gICAgfVxuXG4gICAgLy8gcnVuIHRoZSB0aWNrIGltbWVkaWF0ZWx5LCBidXQgaW4gdGhlIG5leHQgcGFzcyBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0XG4gICAgLy8gI19pbml0aWFsaXplIGNhbiBiZSBhbGxvd2VkIHRvIGNvbXBsZXRlIHdpdGhvdXQgcmVjdXJzaXZlbHkgd2FpdGluZyBvblxuICAgIC8vIGl0c2VsZlxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcbiAgICAgIGF3YWl0IHRoaXMuX2F1dG9SZWZyZXNoVG9rZW5UaWNrKClcbiAgICB9LCAwKVxuICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrVGltZW91dCA9IHRpbWVvdXRcblxuICAgIGlmICh0aW1lb3V0ICYmIHR5cGVvZiB0aW1lb3V0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGltZW91dC51bnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGltZW91dC51bnJlZigpXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGVuby51bnJlZlRpbWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICAgIERlbm8udW5yZWZUaW1lcih0aW1lb3V0KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RvcEF1dG9SZWZyZXNofS4gVXNlIHRoaXNcbiAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfc3RvcEF1dG9SZWZyZXNoKCkge1xuICAgIHRoaXMuX2RlYnVnKCcjX3N0b3BBdXRvUmVmcmVzaCgpJylcblxuICAgIGNvbnN0IHRpY2tlciA9IHRoaXMuYXV0b1JlZnJlc2hUaWNrZXJcbiAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gbnVsbFxuXG4gICAgaWYgKHRpY2tlcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aWNrZXIpXG4gICAgfVxuXG4gICAgY29uc3QgdGltZW91dCA9IHRoaXMuYXV0b1JlZnJlc2hUaWNrVGltZW91dFxuICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrVGltZW91dCA9IG51bGxcblxuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIGFuIGF1dG8tcmVmcmVzaCBwcm9jZXNzIGluIHRoZSBiYWNrZ3JvdW5kLiBUaGUgc2Vzc2lvbiBpcyBjaGVja2VkXG4gICAqIGV2ZXJ5IGZldyBzZWNvbmRzLiBDbG9zZSB0byB0aGUgdGltZSBvZiBleHBpcmF0aW9uIGEgcHJvY2VzcyBpcyBzdGFydGVkIHRvXG4gICAqIHJlZnJlc2ggdGhlIHNlc3Npb24uIElmIHJlZnJlc2hpbmcgZmFpbHMgaXQgd2lsbCBiZSByZXRyaWVkIGZvciBhcyBsb25nIGFzXG4gICAqIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogSWYgeW91IHNldCB0aGUge0BsaW5rIEdvVHJ1ZUNsaWVudE9wdGlvbnMjYXV0b1JlZnJlc2hUb2tlbn0geW91IGRvbid0IG5lZWRcbiAgICogdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgeW91LlxuICAgKlxuICAgKiBPbiBicm93c2VycyB0aGUgcmVmcmVzaCBwcm9jZXNzIHdvcmtzIG9ubHkgd2hlbiB0aGUgdGFiL3dpbmRvdyBpcyBpbiB0aGVcbiAgICogZm9yZWdyb3VuZCB0byBjb25zZXJ2ZSByZXNvdXJjZXMgYXMgd2VsbCBhcyBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucyBhbmRcbiAgICogZmxvb2RpbmcgYXV0aCB3aXRoIHJlcXVlc3RzLiBJZiB5b3UgY2FsbCB0aGlzIG1ldGhvZCBhbnkgbWFuYWdlZFxuICAgKiB2aXNpYmlsaXR5IGNoYW5nZSBjYWxsYmFjayB3aWxsIGJlIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5XG4gICAqIGNoYW5nZXMgb24geW91ciBvd24uXG4gICAqXG4gICAqIE9uIG5vbi1icm93c2VyIHBsYXRmb3JtcyB0aGUgcmVmcmVzaCBwcm9jZXNzIHdvcmtzICpjb250aW51b3VzbHkqIGluIHRoZVxuICAgKiBiYWNrZ3JvdW5kLCB3aGljaCBtYXkgbm90IGJlIGRlc2lyYWJsZS4gWW91IHNob3VsZCBob29rIGludG8geW91clxuICAgKiBwbGF0Zm9ybSdzIGZvcmVncm91bmQgaW5kaWNhdGlvbiBtZWNoYW5pc20gYW5kIGNhbGwgdGhlc2UgbWV0aG9kc1xuICAgKiBhcHByb3ByaWF0ZWx5IHRvIGNvbnNlcnZlIHJlc291cmNlcy5cbiAgICpcbiAgICoge0BzZWUgI3N0b3BBdXRvUmVmcmVzaH1cbiAgICovXG4gIGFzeW5jIHN0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpXG4gICAgYXdhaXQgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpXG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgYW4gYWN0aXZlIGF1dG8gcmVmcmVzaCBwcm9jZXNzIHJ1bm5pbmcgaW4gdGhlIGJhY2tncm91bmQgKGlmIGFueSkuXG4gICAqXG4gICAqIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkIHZpc2liaWxpdHkgY2hhbmdlIGNhbGxiYWNrIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBhbmQgeW91IG11c3QgbWFuYWdlIHZpc2liaWxpdHkgY2hhbmdlcyBvbiB5b3VyIG93bi5cbiAgICpcbiAgICogU2VlIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGFzeW5jIHN0b3BBdXRvUmVmcmVzaCgpIHtcbiAgICB0aGlzLl9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKClcbiAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgdGhlIGF1dG8gcmVmcmVzaCB0b2tlbiB0aWNrLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfYXV0b1JlZnJlc2hUb2tlblRpY2soKSB7XG4gICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdiZWdpbicpXG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgICAgICAgfSA9IHJlc3VsdFxuXG4gICAgICAgICAgICAgIGlmICghc2Vzc2lvbiB8fCAhc2Vzc2lvbi5yZWZyZXNoX3Rva2VuIHx8ICFzZXNzaW9uLmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ25vIHNlc3Npb24nKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gc2Vzc2lvbiB3aWxsIGV4cGlyZSBpbiB0aGlzIG1hbnkgdGlja3MgKG9yIGhhcyBhbHJlYWR5IGV4cGlyZWQgaWYgPD0gMClcbiAgICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luVGlja3MgPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIChzZXNzaW9uLmV4cGlyZXNfYXQgKiAxMDAwIC0gbm93KSAvIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgICAnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJyxcbiAgICAgICAgICAgICAgICBgYWNjZXNzIHRva2VuIGV4cGlyZXMgaW4gJHtleHBpcmVzSW5UaWNrc30gdGlja3MsIGEgdGljayBsYXN0cyAke0FVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TfW1zLCByZWZyZXNoIHRocmVzaG9sZCBpcyAke0FVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRH0gdGlja3NgXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICBpZiAoZXhwaXJlc0luVGlja3MgPD0gQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihzZXNzaW9uLnJlZnJlc2hfdG9rZW4pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnQXV0byByZWZyZXNoIHRpY2sgZmFpbGVkIHdpdGggZXJyb3IuIFRoaXMgaXMgbGlrZWx5IGEgdHJhbnNpZW50IGVycm9yLicsXG4gICAgICAgICAgICAgIGVcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdlbmQnKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgaWYgKGUuaXNBY3F1aXJlVGltZW91dCB8fCBlIGluc3RhbmNlb2YgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ2F1dG8gcmVmcmVzaCB0b2tlbiB0aWNrIGxvY2sgbm90IGF2YWlsYWJsZScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3Mgb24gdGhlIGJyb3dzZXIgLyBwbGF0Zm9ybSwgd2hpY2ggaW4tdHVybiBydW5cbiAgICogYWxnb3JpdGhtcyB3aGVuIHRoZSBicm93c2VyIHdpbmRvdy90YWIgYXJlIGluIGZvcmVncm91bmQuIE9uIG5vbi1icm93c2VyXG4gICAqIHBsYXRmb3JtcyBpdCBhc3N1bWVzIGFsd2F5cyBmb3JlZ3JvdW5kLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICB0aGlzLl9kZWJ1ZygnI19oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCknKVxuXG4gICAgaWYgKCFpc0Jyb3dzZXIoKSB8fCAhd2luZG93Py5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuKSB7XG4gICAgICAgIC8vIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cyB0aGUgcmVmcmVzaCB0b2tlbiB0aWNrZXIgcnVucyBhbHdheXNcbiAgICAgICAgdGhpcy5zdGFydEF1dG9SZWZyZXNoKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2VkKGZhbHNlKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjdmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaycsICdlcnJvcicsIGVycm9yKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaylcblxuICAgICAgLy8gbm93IGltbWVkaWF0ZWx5IGNhbGwgdGhlIHZpc2JpbGl0eSBjaGFuZ2VkIGNhbGxiYWNrIHRvIHNldHVwIHdpdGggdGhlXG4gICAgICAvLyBjdXJyZW50IHZpc2JpbGl0eSBzdGF0ZVxuICAgICAgYXdhaXQgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlZCh0cnVlKSAvLyBpbml0aWFsIGNhbGxcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UnLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgcmVnaXN0ZXJlZCB3aXRoIGB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScpYC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX29uVmlzaWJpbGl0eUNoYW5nZWQoY2FsbGVkRnJvbUluaXRpYWxpemU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBtZXRob2ROYW1lID0gYCNfb25WaXNpYmlsaXR5Q2hhbmdlZCgke2NhbGxlZEZyb21Jbml0aWFsaXplfSlgXG4gICAgdGhpcy5fZGVidWcobWV0aG9kTmFtZSwgJ3Zpc2liaWxpdHlTdGF0ZScsIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSlcblxuICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAvLyBpbiBicm93c2VyIGVudmlyb25tZW50cyB0aGUgcmVmcmVzaCB0b2tlbiB0aWNrZXIgcnVucyBvbmx5IG9uIGZvY3VzZWQgdGFic1xuICAgICAgICAvLyB3aGljaCBwcmV2ZW50cyByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpXG4gICAgICB9XG5cbiAgICAgIGlmICghY2FsbGVkRnJvbUluaXRpYWxpemUpIHtcbiAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQsIGkuZS4gdGhlIGJyb3dzZXJcbiAgICAgICAgLy8gdHJhbnNpdGlvbmVkIGZyb20gaGlkZGVuIC0+IHZpc2libGUgc28gd2UgbmVlZCB0byBzZWUgaWYgdGhlIHNlc3Npb25cbiAgICAgICAgLy8gc2hvdWxkIGJlIHJlY292ZXJlZCBpbW1lZGlhdGVseS4uLiBidXQgdG8gZG8gdGhhdCB3ZSBuZWVkIHRvIGFjcXVpcmVcbiAgICAgICAgLy8gdGhlIGxvY2sgZmlyc3QgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgJ2FjcXVpcmVkIHRoZSBsb2NrIHRvIHJlY292ZXIgdGhlIHNlc3Npb24sIGJ1dCB0aGUgYnJvd3NlciB2aXNpYmlsaXR5U3RhdGUgaXMgbm8gbG9uZ2VyIHZpc2libGUsIGFib3J0aW5nJ1xuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAvLyB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBsb2NrLCBhYm9ydFxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVjb3ZlciB0aGUgc2Vzc2lvblxuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlY292ZXJBbmRSZWZyZXNoKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSByZWxldmFudCBsb2dpbiBVUkwgZm9yIGEgdGhpcmQtcGFydHkgcHJvdmlkZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gQSBVUkwgb3IgbW9iaWxlIGFkZHJlc3MgdG8gc2VuZCB0aGUgdXNlciB0byBhZnRlciB0aGV5IGFyZSBjb25maXJtZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNjb3BlcyBBIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHNjb3BlcyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICogQHBhcmFtIG9wdGlvbnMucXVlcnlQYXJhbXMgQW4gb2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyBjb250YWluaW5nIHF1ZXJ5IHBhcmFtZXRlcnMgZ3JhbnRlZCB0byB0aGUgT0F1dGggYXBwbGljYXRpb24uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9nZXRVcmxGb3JQcm92aWRlcihcbiAgICB1cmw6IHN0cmluZyxcbiAgICBwcm92aWRlcjogUHJvdmlkZXIsXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVkaXJlY3RUbz86IHN0cmluZ1xuICAgICAgc2NvcGVzPzogc3RyaW5nXG4gICAgICBxdWVyeVBhcmFtcz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q/OiBib29sZWFuXG4gICAgfVxuICApIHtcbiAgICBjb25zdCB1cmxQYXJhbXM6IHN0cmluZ1tdID0gW2Bwcm92aWRlcj0ke2VuY29kZVVSSUNvbXBvbmVudChwcm92aWRlcil9YF1cbiAgICBpZiAob3B0aW9ucz8ucmVkaXJlY3RUbykge1xuICAgICAgdXJsUGFyYW1zLnB1c2goYHJlZGlyZWN0X3RvPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMucmVkaXJlY3RUbyl9YClcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnNjb3Blcykge1xuICAgICAgdXJsUGFyYW1zLnB1c2goYHNjb3Blcz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnNjb3Blcyl9YClcbiAgICB9XG4gICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgY29uc3QgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICB0aGlzLnN0b3JhZ2VLZXlcbiAgICAgIClcblxuICAgICAgY29uc3QgZmxvd1BhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBjb2RlX2NoYWxsZW5nZTogYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGVDaGFsbGVuZ2UpfWAsXG4gICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGVDaGFsbGVuZ2VNZXRob2QpfWAsXG4gICAgICB9KVxuICAgICAgdXJsUGFyYW1zLnB1c2goZmxvd1BhcmFtcy50b1N0cmluZygpKVxuICAgIH1cbiAgICBpZiAob3B0aW9ucz8ucXVlcnlQYXJhbXMpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zLnF1ZXJ5UGFyYW1zKVxuICAgICAgdXJsUGFyYW1zLnB1c2gocXVlcnkudG9TdHJpbmcoKSlcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnNraXBCcm93c2VyUmVkaXJlY3QpIHtcbiAgICAgIHVybFBhcmFtcy5wdXNoKGBza2lwX2h0dHBfcmVkaXJlY3Q9JHtvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3R9YClcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7dXJsfT8ke3VybFBhcmFtcy5qb2luKCcmJyl9YFxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfdW5lbnJvbGwocGFyYW1zOiBNRkFVbmVucm9sbFBhcmFtcyk6IFByb21pc2U8QXV0aE1GQVVuZW5yb2xsUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfWAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBzZXNzaW9uRGF0YT8uc2Vzc2lvbj8uYWNjZXNzX3Rva2VuLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSlcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNlbnJvbGx9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9lbnJvbGwocGFyYW1zOiBNRkFFbnJvbGxUT1RQUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBRW5yb2xsVE9UUFJlc3BvbnNlPlxuICBwcml2YXRlIGFzeW5jIF9lbnJvbGwocGFyYW1zOiBNRkFFbnJvbGxQaG9uZVBhcmFtcyk6IFByb21pc2U8QXV0aE1GQUVucm9sbFBob25lUmVzcG9uc2U+XG4gIHByaXZhdGUgYXN5bmMgX2Vucm9sbChwYXJhbXM6IE1GQUVucm9sbFdlYmF1dGhuUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBRW5yb2xsV2ViYXV0aG5SZXNwb25zZT5cbiAgcHJpdmF0ZSBhc3luYyBfZW5yb2xsKHBhcmFtczogTUZBRW5yb2xsUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBRW5yb2xsUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgIGZyaWVuZGx5X25hbWU6IHBhcmFtcy5mcmllbmRseU5hbWUsXG4gICAgICAgICAgZmFjdG9yX3R5cGU6IHBhcmFtcy5mYWN0b3JUeXBlLFxuICAgICAgICAgIC4uLihwYXJhbXMuZmFjdG9yVHlwZSA9PT0gJ3Bob25lJ1xuICAgICAgICAgICAgPyB7IHBob25lOiBwYXJhbXMucGhvbmUgfVxuICAgICAgICAgICAgOiBwYXJhbXMuZmFjdG9yVHlwZSA9PT0gJ3RvdHAnXG4gICAgICAgICAgICAgID8geyBpc3N1ZXI6IHBhcmFtcy5pc3N1ZXIgfVxuICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IChhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzYCwge1xuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGp3dDogc2Vzc2lvbkRhdGE/LnNlc3Npb24/LmFjY2Vzc190b2tlbixcbiAgICAgICAgfSkpIGFzIEF1dGhNRkFFbnJvbGxSZXNwb25zZVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuZmFjdG9yVHlwZSA9PT0gJ3RvdHAnICYmIGRhdGEudHlwZSA9PT0gJ3RvdHAnICYmIGRhdGE/LnRvdHA/LnFyX2NvZGUpIHtcbiAgICAgICAgICBkYXRhLnRvdHAucXJfY29kZSA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7dXRmLTgsJHtkYXRhLnRvdHAucXJfY29kZX1gXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YSwgZXJyb3I6IG51bGwgfSlcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjdmVyaWZ5fVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfdmVyaWZ5KHBhcmFtczogTUZBVmVyaWZ5VE9UUFBhcmFtcyk6IFByb21pc2U8QXV0aE1GQVZlcmlmeVJlc3BvbnNlPlxuICBwcml2YXRlIGFzeW5jIF92ZXJpZnkocGFyYW1zOiBNRkFWZXJpZnlQaG9uZVBhcmFtcyk6IFByb21pc2U8QXV0aE1GQVZlcmlmeVJlc3BvbnNlPlxuICBwcml2YXRlIGFzeW5jIF92ZXJpZnk8VCBleHRlbmRzICdjcmVhdGUnIHwgJ3JlcXVlc3QnPihcbiAgICBwYXJhbXM6IE1GQVZlcmlmeVdlYmF1dGhuUGFyYW1zPFQ+XG4gICk6IFByb21pc2U8QXV0aE1GQVZlcmlmeVJlc3BvbnNlPlxuICBwcml2YXRlIGFzeW5jIF92ZXJpZnkocGFyYW1zOiBNRkFWZXJpZnlQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFWZXJpZnlSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYm9keTogU3RyaWN0T21pdDxcbiAgICAgICAgICAgIHwgRXhjbHVkZTxNRkFWZXJpZnlQYXJhbXMsIE1GQVZlcmlmeVdlYmF1dGhuUGFyYW1zPlxuICAgICAgICAgICAgLyoqIEV4Y2x1ZGUgb3V0IHRoZSB3ZWJhdXRobiBwYXJhbXMgZnJvbSBoZXJlIGJlY2F1c2Ugd2UncmUgZ29pbmcgdG8gbmVlZCB0byBzZXJpYWxpemUgdGhlbSBpbiB0aGUgcmVzcG9uc2UgKi9cbiAgICAgICAgICAgIHwgUHJldHRpZnk8XG4gICAgICAgICAgICAgICAgU3RyaWN0T21pdDxNRkFWZXJpZnlXZWJhdXRoblBhcmFtcywgJ3dlYmF1dGhuJz4gJiB7XG4gICAgICAgICAgICAgICAgICB3ZWJhdXRobjogUHJldHRpZnk8XG4gICAgICAgICAgICAgICAgICAgIFN0cmljdE9taXQ8TUZBVmVyaWZ5V2ViYXV0aG5QYXJhbUZpZWxkc1snd2ViYXV0aG4nXSwgJ2NyZWRlbnRpYWxfcmVzcG9uc2UnPiAmIHtcbiAgICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3Jlc3BvbnNlOiBQdWJsaWNLZXlDcmVkZW50aWFsSlNPTlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA+LFxuICAgICAgICAgICAgLyogIEV4Y2x1ZGUgY2hhbGxlbmdlSWQgYmVjYXVzZSB0aGUgYmFja2VuZCBleHBlY3RzIHNuYWtlX2Nhc2UsIGFuZCBleGNsdWRlIGZhY3RvcklkIHNpbmNlIGl0J3MgcGFzc2VkIGluIHRoZSBwYXRoIHBhcmFtcyAqL1xuICAgICAgICAgICAgJ2NoYWxsZW5nZUlkJyB8ICdmYWN0b3JJZCdcbiAgICAgICAgICA+ICYge1xuICAgICAgICAgICAgY2hhbGxlbmdlX2lkOiBzdHJpbmdcbiAgICAgICAgICB9ID0ge1xuICAgICAgICAgICAgY2hhbGxlbmdlX2lkOiBwYXJhbXMuY2hhbGxlbmdlSWQsXG4gICAgICAgICAgICAuLi4oJ3dlYmF1dGhuJyBpbiBwYXJhbXNcbiAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICB3ZWJhdXRobjoge1xuICAgICAgICAgICAgICAgICAgICAuLi5wYXJhbXMud2ViYXV0aG4sXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxfcmVzcG9uc2U6XG4gICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLndlYmF1dGhuLnR5cGUgPT09ICdjcmVhdGUnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy53ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlIGFzIFJlZ2lzdHJhdGlvbkNyZWRlbnRpYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdFJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy53ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlIGFzIEF1dGhlbnRpY2F0aW9uQ3JlZGVudGlhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDogeyBjb2RlOiBwYXJhbXMuY29kZSB9KSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICAnUE9TVCcsXG4gICAgICAgICAgICBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH0vdmVyaWZ5YCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICBqd3Q6IHNlc3Npb25EYXRhPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oe1xuICAgICAgICAgICAgZXhwaXJlc19hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgKyBkYXRhLmV4cGlyZXNfaW4sXG4gICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ01GQV9DSEFMTEVOR0VfVkVSSUZJRUQnLCBkYXRhKVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGEsIGVycm9yIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNjaGFsbGVuZ2V9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9jaGFsbGVuZ2UoXG4gICAgcGFyYW1zOiBNRkFDaGFsbGVuZ2VUT1RQUGFyYW1zXG4gICk6IFByb21pc2U8UHJldHRpZnk8QXV0aE1GQUNoYWxsZW5nZVRPVFBSZXNwb25zZT4+XG4gIHByaXZhdGUgYXN5bmMgX2NoYWxsZW5nZShcbiAgICBwYXJhbXM6IE1GQUNoYWxsZW5nZVBob25lUGFyYW1zXG4gICk6IFByb21pc2U8UHJldHRpZnk8QXV0aE1GQUNoYWxsZW5nZVBob25lUmVzcG9uc2U+PlxuICBwcml2YXRlIGFzeW5jIF9jaGFsbGVuZ2UoXG4gICAgcGFyYW1zOiBNRkFDaGFsbGVuZ2VXZWJhdXRoblBhcmFtc1xuICApOiBQcm9taXNlPFByZXR0aWZ5PEF1dGhNRkFDaGFsbGVuZ2VXZWJhdXRoblJlc3BvbnNlPj5cbiAgcHJpdmF0ZSBhc3luYyBfY2hhbGxlbmdlKHBhcmFtczogTUZBQ2hhbGxlbmdlUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBQ2hhbGxlbmdlUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgICAgICdQT1NUJyxcbiAgICAgICAgICAgIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfS9jaGFsbGVuZ2VgLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBib2R5OiBwYXJhbXMsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgand0OiBzZXNzaW9uRGF0YT8uc2Vzc2lvbj8uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICkpIGFzXG4gICAgICAgICAgICB8IEV4Y2x1ZGU8QXV0aE1GQUNoYWxsZW5nZVJlc3BvbnNlLCBBdXRoTUZBQ2hhbGxlbmdlV2ViYXV0aG5SZXNwb25zZT5cbiAgICAgICAgICAgIC8qKiBUaGUgc2VydmVyIHdpbGwgc2VuZCBgc2VyaWFsaXplZGAgZGF0YSwgc28gd2UgYXNzZXJ0IHRoZSBzZXJpYWxpemVkIHJlc3BvbnNlICovXG4gICAgICAgICAgICB8IEF1dGhNRkFDaGFsbGVuZ2VXZWJhdXRoblNlcnZlclJlc3BvbnNlXG5cbiAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gcmVzcG9uc2VcblxuICAgICAgICAgIGlmIChkYXRhLnR5cGUgIT09ICd3ZWJhdXRobicpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKGRhdGEud2ViYXV0aG4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY3JlYXRlJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZGF0YS53ZWJhdXRobixcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9vcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucy5wdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdyZXF1ZXN0JzpcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZGF0YS53ZWJhdXRobixcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9vcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zLnB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNjaGFsbGVuZ2VBbmRWZXJpZnl9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9jaGFsbGVuZ2VBbmRWZXJpZnkoXG4gICAgcGFyYW1zOiBNRkFDaGFsbGVuZ2VBbmRWZXJpZnlQYXJhbXNcbiAgKTogUHJvbWlzZTxBdXRoTUZBVmVyaWZ5UmVzcG9uc2U+IHtcbiAgICAvLyBib3RoIF9jaGFsbGVuZ2UgYW5kIF92ZXJpZnkgaW5kZXBlbmRlbnRseSBhY3F1aXJlIHRoZSBsb2NrLCBzbyBubyBuZWVkXG4gICAgLy8gdG8gYWNxdWlyZSBpdCBoZXJlXG5cbiAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZURhdGEsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgdGhpcy5fY2hhbGxlbmdlKHtcbiAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgfSlcbiAgICBpZiAoY2hhbGxlbmdlRXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fdmVyaWZ5KHtcbiAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlRGF0YS5pZCxcbiAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgR29UcnVlTUZBQXBpI2xpc3RGYWN0b3JzfVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfbGlzdEZhY3RvcnMoKTogUHJvbWlzZTxBdXRoTUZBTGlzdEZhY3RvcnNSZXNwb25zZT4ge1xuICAgIC8vIHVzZSAjZ2V0VXNlciBpbnN0ZWFkIG9mICNfZ2V0VXNlciBhcyB0aGUgZm9ybWVyIGFjcXVpcmVzIGEgbG9ja1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHsgdXNlciB9LFxuICAgICAgZXJyb3I6IHVzZXJFcnJvcixcbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKClcbiAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogdXNlckVycm9yIH1cbiAgICB9XG5cbiAgICBjb25zdCBkYXRhOiBBdXRoTUZBTGlzdEZhY3RvcnNSZXNwb25zZVsnZGF0YSddID0ge1xuICAgICAgYWxsOiBbXSxcbiAgICAgIHBob25lOiBbXSxcbiAgICAgIHRvdHA6IFtdLFxuICAgICAgd2ViYXV0aG46IFtdLFxuICAgIH1cblxuICAgIC8vIGxvb3Agb3ZlciB0aGUgZmFjdG9ycyBPTkNFXG4gICAgZm9yIChjb25zdCBmYWN0b3Igb2YgdXNlcj8uZmFjdG9ycyA/PyBbXSkge1xuICAgICAgZGF0YS5hbGwucHVzaChmYWN0b3IpXG4gICAgICBpZiAoZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJykge1xuICAgICAgICA7KGRhdGFbZmFjdG9yLmZhY3Rvcl90eXBlXSBhcyAodHlwZW9mIGZhY3RvcilbXSkucHVzaChmYWN0b3IpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGEsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgR29UcnVlTUZBQXBpI2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbH1cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbChcbiAgICBqd3Q/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxBdXRoTUZBR2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsUmVzcG9uc2U+IHtcbiAgICBpZiAoand0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGRlY29kZUpXVChqd3QpXG5cbiAgICAgICAgbGV0IGN1cnJlbnRMZXZlbDogQXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVscyB8IG51bGwgPSBudWxsXG4gICAgICAgIGlmIChwYXlsb2FkLmFhbCkge1xuICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IHBheWxvYWQuYWFsXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV4dExldmVsOiBBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxzIHwgbnVsbCA9IGN1cnJlbnRMZXZlbFxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhOiB7IHVzZXIgfSxcbiAgICAgICAgICBlcnJvcjogdXNlckVycm9yLFxuICAgICAgICB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKGp3dClcblxuICAgICAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiB1c2VyRXJyb3IgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZlcmlmaWVkRmFjdG9ycyA9XG4gICAgICAgICAgdXNlcj8uZmFjdG9ycz8uZmlsdGVyKChmYWN0b3I6IEZhY3RvcikgPT4gZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJykgPz8gW11cblxuICAgICAgICBpZiAodmVyaWZpZWRGYWN0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBuZXh0TGV2ZWwgPSAnYWFsMidcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgPSBwYXlsb2FkLmFtciB8fCBbXVxuXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgY3VycmVudExldmVsLCBuZXh0TGV2ZWwsIGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICBlcnJvcjogc2Vzc2lvbkVycm9yLFxuICAgIH0gPSBhd2FpdCB0aGlzLmdldFNlc3Npb24oKVxuXG4gICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSlcbiAgICB9XG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB7IGN1cnJlbnRMZXZlbDogbnVsbCwgbmV4dExldmVsOiBudWxsLCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzOiBbXSB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IHBheWxvYWQgfSA9IGRlY29kZUpXVChzZXNzaW9uLmFjY2Vzc190b2tlbilcblxuICAgIGxldCBjdXJyZW50TGV2ZWw6IEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbHMgfCBudWxsID0gbnVsbFxuXG4gICAgaWYgKHBheWxvYWQuYWFsKSB7XG4gICAgICBjdXJyZW50TGV2ZWwgPSBwYXlsb2FkLmFhbFxuICAgIH1cblxuICAgIGxldCBuZXh0TGV2ZWw6IEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbHMgfCBudWxsID0gY3VycmVudExldmVsXG5cbiAgICBjb25zdCB2ZXJpZmllZEZhY3RvcnMgPVxuICAgICAgc2Vzc2lvbi51c2VyLmZhY3RvcnM/LmZpbHRlcigoZmFjdG9yOiBGYWN0b3IpID0+IGZhY3Rvci5zdGF0dXMgPT09ICd2ZXJpZmllZCcpID8/IFtdXG5cbiAgICBpZiAodmVyaWZpZWRGYWN0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIG5leHRMZXZlbCA9ICdhYWwyJ1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgPSBwYXlsb2FkLmFtciB8fCBbXVxuXG4gICAgcmV0dXJuIHsgZGF0YTogeyBjdXJyZW50TGV2ZWwsIG5leHRMZXZlbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyB9LCBlcnJvcjogbnVsbCB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGRldGFpbHMgYWJvdXQgYW4gT0F1dGggYXV0aG9yaXphdGlvbiByZXF1ZXN0LlxuICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgKlxuICAgKiBSZXR1cm5zIGF1dGhvcml6YXRpb24gZGV0YWlscyBpbmNsdWRpbmcgY2xpZW50IGluZm8sIHNjb3BlcywgYW5kIHVzZXIgaW5mb3JtYXRpb24uXG4gICAqIElmIHRoZSBBUEkgcmV0dXJucyBhIHJlZGlyZWN0X3VyaSwgaXQgbWVhbnMgY29uc2VudCB3YXMgYWxyZWFkeSBnaXZlbiAtIHRoZSBjYWxsZXJcbiAgICogc2hvdWxkIGhhbmRsZSB0aGUgcmVkaXJlY3QgbWFudWFsbHkgaWYgbmVlZGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0QXV0aG9yaXphdGlvbkRldGFpbHMoXG4gICAgYXV0aG9yaXphdGlvbklkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxBdXRoT0F1dGhBdXRob3JpemF0aW9uRGV0YWlsc1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRhdGE6IHsgc2Vzc2lvbiB9LFxuICAgICAgICAgIGVycm9yOiBzZXNzaW9uRXJyb3IsXG4gICAgICAgIH0gPSByZXN1bHRcblxuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCkgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICAgICdHRVQnLFxuICAgICAgICAgIGAke3RoaXMudXJsfS9vYXV0aC9hdXRob3JpemF0aW9ucy8ke2F1dGhvcml6YXRpb25JZH1gLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB4Zm9ybTogKGRhdGE6IGFueSkgPT4gKHsgZGF0YSwgZXJyb3I6IG51bGwgfSksXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHByb3ZlcyBhbiBPQXV0aCBhdXRob3JpemF0aW9uIHJlcXVlc3QuXG4gICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9hcHByb3ZlQXV0aG9yaXphdGlvbihcbiAgICBhdXRob3JpemF0aW9uSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBza2lwQnJvd3NlclJlZGlyZWN0PzogYm9vbGVhbiB9XG4gICk6IFByb21pc2U8QXV0aE9BdXRoQ29uc2VudFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRhdGE6IHsgc2Vzc2lvbiB9LFxuICAgICAgICAgIGVycm9yOiBzZXNzaW9uRXJyb3IsXG4gICAgICAgIH0gPSByZXN1bHRcblxuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCkgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3JlcXVlc3QoXG4gICAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgICAnUE9TVCcsXG4gICAgICAgICAgYCR7dGhpcy51cmx9L29hdXRoL2F1dGhvcml6YXRpb25zLyR7YXV0aG9yaXphdGlvbklkfS9jb25zZW50YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgYm9keTogeyBhY3Rpb246ICdhcHByb3ZlJyB9LFxuICAgICAgICAgICAgeGZvcm06IChkYXRhOiBhbnkpID0+ICh7IGRhdGEsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhICYmIHJlc3BvbnNlLmRhdGEucmVkaXJlY3RfdXJsKSB7XG4gICAgICAgICAgLy8gQXV0b21hdGljYWxseSByZWRpcmVjdCBpbiBicm93c2VyIHVubGVzcyBza2lwQnJvd3NlclJlZGlyZWN0IGlzIHRydWVcbiAgICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgIW9wdGlvbnM/LnNraXBCcm93c2VyUmVkaXJlY3QpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24ocmVzcG9uc2UuZGF0YS5yZWRpcmVjdF91cmwpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZW5pZXMgYW4gT0F1dGggYXV0aG9yaXphdGlvbiByZXF1ZXN0LlxuICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZGVueUF1dGhvcml6YXRpb24oXG4gICAgYXV0aG9yaXphdGlvbklkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgc2tpcEJyb3dzZXJSZWRpcmVjdD86IGJvb2xlYW4gfVxuICApOiBQcm9taXNlPEF1dGhPQXV0aENvbnNlbnRSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgICBlcnJvcjogc2Vzc2lvbkVycm9yLFxuICAgICAgICB9ID0gcmVzdWx0XG5cbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH0pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICAgJ1BPU1QnLFxuICAgICAgICAgIGAke3RoaXMudXJsfS9vYXV0aC9hdXRob3JpemF0aW9ucy8ke2F1dGhvcml6YXRpb25JZH0vY29uc2VudGAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIGJvZHk6IHsgYWN0aW9uOiAnZGVueScgfSxcbiAgICAgICAgICAgIHhmb3JtOiAoZGF0YTogYW55KSA9PiAoeyBkYXRhLCBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLnJlZGlyZWN0X3VybCkge1xuICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVkaXJlY3QgaW4gYnJvd3NlciB1bmxlc3Mgc2tpcEJyb3dzZXJSZWRpcmVjdCBpcyB0cnVlXG4gICAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmICFvcHRpb25zPy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHJlc3BvbnNlLmRhdGEucmVkaXJlY3RfdXJsKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSlcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGlzdHMgYWxsIE9BdXRoIGdyYW50cyB0aGF0IHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgaGFzIGF1dGhvcml6ZWQuXG4gICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9saXN0T0F1dGhHcmFudHMoKTogUHJvbWlzZTxBdXRoT0F1dGhHcmFudHNSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgICBlcnJvcjogc2Vzc2lvbkVycm9yLFxuICAgICAgICB9ID0gcmVzdWx0XG5cbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyL29hdXRoL2dyYW50c2AsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICB4Zm9ybTogKGRhdGE6IGFueSkgPT4gKHsgZGF0YSwgZXJyb3I6IG51bGwgfSksXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXZva2VzIGEgdXNlcidzIE9BdXRoIGdyYW50IGZvciBhIHNwZWNpZmljIGNsaWVudC5cbiAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3Jldm9rZU9BdXRoR3JhbnQob3B0aW9uczoge1xuICAgIGNsaWVudElkOiBzdHJpbmdcbiAgfSk6IFByb21pc2U8QXV0aE9BdXRoUmV2b2tlR3JhbnRSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgICBlcnJvcjogc2Vzc2lvbkVycm9yLFxuICAgICAgICB9ID0gcmVzdWx0XG5cbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH0pXG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L3VzZXIvb2F1dGgvZ3JhbnRzYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgIHF1ZXJ5OiB7IGNsaWVudF9pZDogb3B0aW9ucy5jbGllbnRJZCB9LFxuICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHt9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hKd2soa2lkOiBzdHJpbmcsIGp3a3M6IHsga2V5czogSldLW10gfSA9IHsga2V5czogW10gfSk6IFByb21pc2U8SldLIHwgbnVsbD4ge1xuICAgIC8vIHRyeSBmZXRjaGluZyBmcm9tIHRoZSBzdXBwbGllZCBqd2tzXG4gICAgbGV0IGp3ayA9IGp3a3Mua2V5cy5maW5kKChrZXkpID0+IGtleS5raWQgPT09IGtpZClcbiAgICBpZiAoandrKSB7XG4gICAgICByZXR1cm4gandrXG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuXG4gICAgLy8gdHJ5IGZldGNoaW5nIGZyb20gY2FjaGVcbiAgICBqd2sgPSB0aGlzLmp3a3Mua2V5cy5maW5kKChrZXkpID0+IGtleS5raWQgPT09IGtpZClcblxuICAgIC8vIGp3ayBleGlzdHMgYW5kIGp3a3MgaXNuJ3Qgc3RhbGVcbiAgICBpZiAoandrICYmIHRoaXMuandrc19jYWNoZWRfYXQgKyBKV0tTX1RUTCA+IG5vdykge1xuICAgICAgcmV0dXJuIGp3a1xuICAgIH1cbiAgICAvLyBqd2sgaXNuJ3QgY2FjaGVkIGluIG1lbW9yeSBzbyB3ZSBuZWVkIHRvIGZldGNoIGl0IGZyb20gdGhlIHdlbGwta25vd24gZW5kcG9pbnRcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9Ly53ZWxsLWtub3duL2p3a3MuanNvbmAsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICB9KVxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gICAgaWYgKCFkYXRhLmtleXMgfHwgZGF0YS5rZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB0aGlzLmp3a3MgPSBkYXRhXG4gICAgdGhpcy5qd2tzX2NhY2hlZF9hdCA9IG5vd1xuXG4gICAgLy8gRmluZCB0aGUgc2lnbmluZyBrZXlcbiAgICBqd2sgPSBkYXRhLmtleXMuZmluZCgoa2V5OiBhbnkpID0+IGtleS5raWQgPT09IGtpZClcbiAgICBpZiAoIWp3aykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIGp3a1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBKV1QgY2xhaW1zIHByZXNlbnQgaW4gdGhlIGFjY2VzcyB0b2tlbiBieSBmaXJzdCB2ZXJpZnlpbmcgdGhlXG4gICAqIEpXVCBhZ2FpbnN0IHRoZSBzZXJ2ZXIncyBKU09OIFdlYiBLZXkgU2V0IGVuZHBvaW50XG4gICAqIGAvLndlbGwta25vd24vandrcy5qc29uYCB3aGljaCBpcyBvZnRlbiBjYWNoZWQsIHJlc3VsdGluZyBpbiBzaWduaWZpY2FudGx5XG4gICAqIGZhc3RlciByZXNwb25zZXMuIFByZWZlciB0aGlzIG1ldGhvZCBvdmVyIHtAbGluayAjZ2V0VXNlcn0gd2hpY2ggYWx3YXlzXG4gICAqIHNlbmRzIGEgcmVxdWVzdCB0byB0aGUgQXV0aCBzZXJ2ZXIgZm9yIGVhY2ggSldULlxuICAgKlxuICAgKiBJZiB0aGUgcHJvamVjdCBpcyBub3QgdXNpbmcgYW4gYXN5bW1ldHJpYyBKV1Qgc2lnbmluZyBrZXkgKGxpa2UgRUNDIG9yXG4gICAqIFJTQSkgaXQgYWx3YXlzIHNlbmRzIGEgcmVxdWVzdCB0byB0aGUgQXV0aCBzZXJ2ZXIgKHNpbWlsYXIgdG8ge0BsaW5rXG4gICAqICNnZXRVc2VyfSkgdG8gdmVyaWZ5IHRoZSBKV1QuXG4gICAqXG4gICAqIEBwYXJhbSBqd3QgQW4gb3B0aW9uYWwgc3BlY2lmaWMgSldUIHlvdSB3aXNoIHRvIHZlcmlmeSwgbm90IHRoZSBvbmUgeW91XG4gICAqICAgICAgICAgICAgY2FuIG9idGFpbiBmcm9tIHtAbGluayAjZ2V0U2Vzc2lvbn0uXG4gICAqIEBwYXJhbSBvcHRpb25zIFZhcmlvdXMgYWRkaXRpb25hbCBvcHRpb25zIHRoYXQgYWxsb3cgeW91IHRvIGN1c3RvbWl6ZSB0aGVcbiAgICogICAgICAgICAgICAgICAgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QuXG4gICAqL1xuICBhc3luYyBnZXRDbGFpbXMoXG4gICAgand0Pzogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIC8qKlxuICAgICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBvcHRpb25zLmp3a3MgaW5zdGVhZC5cbiAgICAgICAqL1xuICAgICAga2V5cz86IEpXS1tdXG5cbiAgICAgIC8qKiBJZiBzZXQgdG8gYHRydWVgIHRoZSBgZXhwYCBjbGFpbSB3aWxsIG5vdCBiZSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgY3VycmVudCB0aW1lLiAqL1xuICAgICAgYWxsb3dFeHBpcmVkPzogYm9vbGVhblxuXG4gICAgICAvKiogSWYgc2V0LCB0aGlzIEpTT04gV2ViIEtleSBTZXQgaXMgZ29pbmcgdG8gaGF2ZSBwcmVjZWRlbmNlIG92ZXIgdGhlIGNhY2hlZCB2YWx1ZSBhdmFpbGFibGUgb24gdGhlIHNlcnZlci4gKi9cbiAgICAgIGp3a3M/OiB7IGtleXM6IEpXS1tdIH1cbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBjbGFpbXM6IEp3dFBheWxvYWQ7IGhlYWRlcjogSnd0SGVhZGVyOyBzaWduYXR1cmU6IFVpbnQ4QXJyYXkgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwgeyBkYXRhOiBudWxsOyBlcnJvcjogQXV0aEVycm9yIH1cbiAgICB8IHsgZGF0YTogbnVsbDsgZXJyb3I6IG51bGwgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHRva2VuID0gand0XG4gICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0U2Vzc2lvbigpXG4gICAgICAgIGlmIChlcnJvciB8fCAhZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pXG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSBkYXRhLnNlc3Npb24uYWNjZXNzX3Rva2VuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIHJhdzogeyBoZWFkZXI6IHJhd0hlYWRlciwgcGF5bG9hZDogcmF3UGF5bG9hZCB9LFxuICAgICAgfSA9IGRlY29kZUpXVCh0b2tlbilcblxuICAgICAgaWYgKCFvcHRpb25zPy5hbGxvd0V4cGlyZWQpIHtcbiAgICAgICAgLy8gUmVqZWN0IGV4cGlyZWQgSldUcyBzaG91bGQgb25seSBoYXBwZW4gaWYgand0IGFyZ3VtZW50IHdhcyBwYXNzZWRcbiAgICAgICAgdmFsaWRhdGVFeHAocGF5bG9hZC5leHApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpZ25pbmdLZXkgPVxuICAgICAgICAhaGVhZGVyLmFsZyB8fFxuICAgICAgICBoZWFkZXIuYWxnLnN0YXJ0c1dpdGgoJ0hTJykgfHxcbiAgICAgICAgIWhlYWRlci5raWQgfHxcbiAgICAgICAgISgnY3J5cHRvJyBpbiBnbG9iYWxUaGlzICYmICdzdWJ0bGUnIGluIGdsb2JhbFRoaXMuY3J5cHRvKVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogYXdhaXQgdGhpcy5mZXRjaEp3ayhoZWFkZXIua2lkLCBvcHRpb25zPy5rZXlzID8geyBrZXlzOiBvcHRpb25zLmtleXMgfSA6IG9wdGlvbnM/Lmp3a3MpXG5cbiAgICAgIC8vIElmIHN5bW1ldHJpYyBhbGdvcml0aG0gb3IgV2ViQ3J5cHRvIEFQSSBpcyB1bmF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gZ2V0VXNlcigpXG4gICAgICBpZiAoIXNpZ25pbmdLZXkpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKHRva2VuKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9XG4gICAgICAgIC8vIGdldFVzZXIgc3VjY2VlZHMgc28gdGhlIGNsYWltcyBpbiB0aGUgSldUIGNhbiBiZSB0cnVzdGVkXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgY2xhaW1zOiBwYXlsb2FkLFxuICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgYWxnb3JpdGhtID0gZ2V0QWxnb3JpdGhtKGhlYWRlci5hbGcpXG5cbiAgICAgIC8vIENvbnZlcnQgSldLIHRvIENyeXB0b0tleVxuICAgICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ2p3aycsIHNpZ25pbmdLZXksIGFsZ29yaXRobSwgdHJ1ZSwgW1xuICAgICAgICAndmVyaWZ5JyxcbiAgICAgIF0pXG5cbiAgICAgIC8vIFZlcmlmeSB0aGUgc2lnbmF0dXJlXG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS52ZXJpZnkoXG4gICAgICAgIGFsZ29yaXRobSxcbiAgICAgICAgcHVibGljS2V5LFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIHN0cmluZ1RvVWludDhBcnJheShgJHtyYXdIZWFkZXJ9LiR7cmF3UGF5bG9hZH1gKVxuICAgICAgKVxuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkSnd0RXJyb3IoJ0ludmFsaWQgSldUIHNpZ25hdHVyZScpXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHZlcmlmaWNhdGlvbiBzdWNjZWVkcywgZGVjb2RlIGFuZCByZXR1cm4gY2xhaW1zXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY2xhaW1zOiBwYXlsb2FkLFxuICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgR29UcnVlQ2xpZW50IGZyb20gJy4vR29UcnVlQ2xpZW50J1xuXG5jb25zdCBBdXRoQ2xpZW50ID0gR29UcnVlQ2xpZW50XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGhDbGllbnRcbiIsICIvLyBHZW5lcmF0ZWQgYXV0b21hdGljYWxseSBkdXJpbmcgcmVsZWFzZXMgYnkgc2NyaXB0cy91cGRhdGUtdmVyc2lvbi1maWxlcy50c1xuLy8gVGhpcyBmaWxlIHByb3ZpZGVzIHJ1bnRpbWUgYWNjZXNzIHRvIHRoZSBwYWNrYWdlIHZlcnNpb24gZm9yOlxuLy8gLSBIVFRQIHJlcXVlc3QgaGVhZGVycyAoZS5nLiwgWC1DbGllbnQtSW5mbyBoZWFkZXIgZm9yIEFQSSByZXF1ZXN0cylcbi8vIC0gRGVidWdnaW5nIGFuZCBzdXBwb3J0IChpZGVudGlmeWluZyB3aGljaCB2ZXJzaW9uIGlzIHJ1bm5pbmcpXG4vLyAtIFRlbGVtZXRyeSBhbmQgbG9nZ2luZyAodmVyc2lvbiByZXBvcnRpbmcgaW4gZXJyb3JzL2FuYWx5dGljcylcbi8vIC0gRW5zdXJpbmcgYnVpbGQgYXJ0aWZhY3RzIG1hdGNoIHRoZSBwdWJsaXNoZWQgcGFja2FnZSB2ZXJzaW9uXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjkzLjMnXG4iLCAiLy8gY29uc3RhbnRzLnRzXG5pbXBvcnQgeyBSZWFsdGltZUNsaWVudE9wdGlvbnMgfSBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnXG5pbXBvcnQgeyBTdXBhYmFzZUF1dGhDbGllbnRPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nXG5cbmxldCBKU19FTlYgPSAnJ1xuLy8gQHRzLWlnbm9yZVxuaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJykge1xuICBKU19FTlYgPSAnZGVubydcbn0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBKU19FTlYgPSAnd2ViJ1xufSBlbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICBKU19FTlYgPSAncmVhY3QtbmF0aXZlJ1xufSBlbHNlIHtcbiAgSlNfRU5WID0gJ25vZGUnXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHN1cGFiYXNlLWpzLSR7SlNfRU5WfS8ke3ZlcnNpb259YCB9XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0dMT0JBTF9PUFRJT05TID0ge1xuICBoZWFkZXJzOiBERUZBVUxUX0hFQURFUlMsXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0RCX09QVElPTlMgPSB7XG4gIHNjaGVtYTogJ3B1YmxpYycsXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0FVVEhfT1BUSU9OUzogU3VwYWJhc2VBdXRoQ2xpZW50T3B0aW9ucyA9IHtcbiAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gIGRldGVjdFNlc3Npb25JblVybDogdHJ1ZSxcbiAgZmxvd1R5cGU6ICdpbXBsaWNpdCcsXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFQUxUSU1FX09QVElPTlM6IFJlYWx0aW1lQ2xpZW50T3B0aW9ucyA9IHt9XG4iLCAidHlwZSBGZXRjaCA9IHR5cGVvZiBmZXRjaFxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoPzogRmV0Y2gpOiBGZXRjaCA9PiB7XG4gIGlmIChjdXN0b21GZXRjaCkge1xuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxGZXRjaD4pID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpXG4gIH1cbiAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPEZldGNoPikgPT4gZmV0Y2goLi4uYXJncylcbn1cblxuZXhwb3J0IGNvbnN0IHJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IgPSAoKSA9PiB7XG4gIHJldHVybiBIZWFkZXJzXG59XG5cbmV4cG9ydCBjb25zdCBmZXRjaFdpdGhBdXRoID0gKFxuICBzdXBhYmFzZUtleTogc3RyaW5nLFxuICBnZXRBY2Nlc3NUb2tlbjogKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPixcbiAgY3VzdG9tRmV0Y2g/OiBGZXRjaFxuKTogRmV0Y2ggPT4ge1xuICBjb25zdCBmZXRjaCA9IHJlc29sdmVGZXRjaChjdXN0b21GZXRjaClcbiAgY29uc3QgSGVhZGVyc0NvbnN0cnVjdG9yID0gcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvcigpXG5cbiAgcmV0dXJuIGFzeW5jIChpbnB1dCwgaW5pdCkgPT4ge1xuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gKGF3YWl0IGdldEFjY2Vzc1Rva2VuKCkpID8/IHN1cGFiYXNlS2V5XG4gICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVyc0NvbnN0cnVjdG9yKGluaXQ/LmhlYWRlcnMpXG5cbiAgICBpZiAoIWhlYWRlcnMuaGFzKCdhcGlrZXknKSkge1xuICAgICAgaGVhZGVycy5zZXQoJ2FwaWtleScsIHN1cGFiYXNlS2V5KVxuICAgIH1cblxuICAgIGlmICghaGVhZGVycy5oYXMoJ0F1dGhvcml6YXRpb24nKSkge1xuICAgICAgaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7YWNjZXNzVG9rZW59YClcbiAgICB9XG5cbiAgICByZXR1cm4gZmV0Y2goaW5wdXQsIHsgLi4uaW5pdCwgaGVhZGVycyB9KVxuICB9XG59XG4iLCAiLy8gaGVscGVycy50c1xuaW1wb3J0IHsgU3VwYWJhc2VDbGllbnRPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsXG4gICAgICB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVUcmFpbGluZ1NsYXNoKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHVybC5lbmRzV2l0aCgnLycpID8gdXJsIDogdXJsICsgJy8nXG59XG5cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTZXR0aW5nRGVmYXVsdHM8XG4gIERhdGFiYXNlID0gYW55LFxuICBTY2hlbWFOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgRGF0YWJhc2UgPSAncHVibGljJyBleHRlbmRzIGtleW9mIERhdGFiYXNlXG4gICAgPyAncHVibGljJ1xuICAgIDogc3RyaW5nICYga2V5b2YgRGF0YWJhc2UsXG4+KFxuICBvcHRpb25zOiBTdXBhYmFzZUNsaWVudE9wdGlvbnM8U2NoZW1hTmFtZT4sXG4gIGRlZmF1bHRzOiBTdXBhYmFzZUNsaWVudE9wdGlvbnM8YW55PlxuKTogUmVxdWlyZWQ8U3VwYWJhc2VDbGllbnRPcHRpb25zPFNjaGVtYU5hbWU+PiB7XG4gIGNvbnN0IHtcbiAgICBkYjogZGJPcHRpb25zLFxuICAgIGF1dGg6IGF1dGhPcHRpb25zLFxuICAgIHJlYWx0aW1lOiByZWFsdGltZU9wdGlvbnMsXG4gICAgZ2xvYmFsOiBnbG9iYWxPcHRpb25zLFxuICB9ID0gb3B0aW9uc1xuICBjb25zdCB7XG4gICAgZGI6IERFRkFVTFRfREJfT1BUSU9OUyxcbiAgICBhdXRoOiBERUZBVUxUX0FVVEhfT1BUSU9OUyxcbiAgICByZWFsdGltZTogREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLFxuICAgIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUyxcbiAgfSA9IGRlZmF1bHRzXG5cbiAgY29uc3QgcmVzdWx0OiBSZXF1aXJlZDxTdXBhYmFzZUNsaWVudE9wdGlvbnM8U2NoZW1hTmFtZT4+ID0ge1xuICAgIGRiOiB7XG4gICAgICAuLi5ERUZBVUxUX0RCX09QVElPTlMsXG4gICAgICAuLi5kYk9wdGlvbnMsXG4gICAgfSxcbiAgICBhdXRoOiB7XG4gICAgICAuLi5ERUZBVUxUX0FVVEhfT1BUSU9OUyxcbiAgICAgIC4uLmF1dGhPcHRpb25zLFxuICAgIH0sXG4gICAgcmVhbHRpbWU6IHtcbiAgICAgIC4uLkRFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyxcbiAgICAgIC4uLnJlYWx0aW1lT3B0aW9ucyxcbiAgICB9LFxuICAgIHN0b3JhZ2U6IHt9LFxuICAgIGdsb2JhbDoge1xuICAgICAgLi4uREVGQVVMVF9HTE9CQUxfT1BUSU9OUyxcbiAgICAgIC4uLmdsb2JhbE9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLihERUZBVUxUX0dMT0JBTF9PUFRJT05TPy5oZWFkZXJzID8/IHt9KSxcbiAgICAgICAgLi4uKGdsb2JhbE9wdGlvbnM/LmhlYWRlcnMgPz8ge30pLFxuICAgICAgfSxcbiAgICB9LFxuICAgIGFjY2Vzc1Rva2VuOiBhc3luYyAoKSA9PiAnJyxcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFjY2Vzc1Rva2VuKSB7XG4gICAgcmVzdWx0LmFjY2Vzc1Rva2VuID0gb3B0aW9ucy5hY2Nlc3NUb2tlblxuICB9IGVsc2Uge1xuICAgIC8vIGhhY2sgYXJvdW5kIFJlcXVpcmVkPD5cbiAgICBkZWxldGUgKHJlc3VsdCBhcyBhbnkpLmFjY2Vzc1Rva2VuXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgU3VwYWJhc2UgY2xpZW50IFVSTFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdXBhYmFzZVVybCAtIFRoZSBTdXBhYmFzZSBjbGllbnQgVVJMIHN0cmluZy5cbiAqIEByZXR1cm5zIHtVUkx9IC0gVGhlIHZhbGlkYXRlZCBiYXNlIFVSTC5cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTdXBhYmFzZVVybChzdXBhYmFzZVVybDogc3RyaW5nKTogVVJMIHtcbiAgY29uc3QgdHJpbW1lZFVybCA9IHN1cGFiYXNlVXJsPy50cmltKClcblxuICBpZiAoIXRyaW1tZWRVcmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1cGFiYXNlVXJsIGlzIHJlcXVpcmVkLicpXG4gIH1cblxuICBpZiAoIXRyaW1tZWRVcmwubWF0Y2goL15odHRwcz86XFwvXFwvL2kpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN1cGFiYXNlVXJsOiBNdXN0IGJlIGEgdmFsaWQgSFRUUCBvciBIVFRQUyBVUkwuJylcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoZW5zdXJlVHJhaWxpbmdTbGFzaCh0cmltbWVkVXJsKSlcbiAgfSBjYXRjaCB7XG4gICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgc3VwYWJhc2VVcmw6IFByb3ZpZGVkIFVSTCBpcyBtYWxmb3JtZWQuJylcbiAgfVxufVxuIiwgImltcG9ydCB7IEF1dGhDbGllbnQgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbmltcG9ydCB7IFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgY2xhc3MgU3VwYWJhc2VBdXRoQ2xpZW50IGV4dGVuZHMgQXV0aENsaWVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBBdXRoQ2hhbmdlRXZlbnQgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbmltcG9ydCB7IEZ1bmN0aW9uc0NsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG5pbXBvcnQge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIHR5cGUgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgdHlwZSBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG59IGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG5pbXBvcnQge1xuICB0eXBlIFJlYWx0aW1lQ2hhbm5lbCxcbiAgdHlwZSBSZWFsdGltZUNoYW5uZWxPcHRpb25zLFxuICBSZWFsdGltZUNsaWVudCxcbiAgdHlwZSBSZWFsdGltZUNsaWVudE9wdGlvbnMsXG59IGZyb20gJ0BzdXBhYmFzZS9yZWFsdGltZS1qcydcbmltcG9ydCB7IFN0b3JhZ2VDbGllbnQgYXMgU3VwYWJhc2VTdG9yYWdlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N0b3JhZ2UtanMnXG5pbXBvcnQge1xuICBERUZBVUxUX0FVVEhfT1BUSU9OUyxcbiAgREVGQVVMVF9EQl9PUFRJT05TLFxuICBERUZBVUxUX0dMT0JBTF9PUFRJT05TLFxuICBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG59IGZyb20gJy4vbGliL2NvbnN0YW50cydcbmltcG9ydCB7IGZldGNoV2l0aEF1dGggfSBmcm9tICcuL2xpYi9mZXRjaCdcbmltcG9ydCB7IGFwcGx5U2V0dGluZ0RlZmF1bHRzLCB2YWxpZGF0ZVN1cGFiYXNlVXJsIH0gZnJvbSAnLi9saWIvaGVscGVycydcbmltcG9ydCB7IFN1cGFiYXNlQXV0aENsaWVudCB9IGZyb20gJy4vbGliL1N1cGFiYXNlQXV0aENsaWVudCdcbmltcG9ydCB0eXBlIHtcbiAgRmV0Y2gsXG4gIEdlbmVyaWNTY2hlbWEsXG4gIFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMsXG4gIFN1cGFiYXNlQ2xpZW50T3B0aW9ucyxcbn0gZnJvbSAnLi9saWIvdHlwZXMnXG5pbXBvcnQgeyBHZXRScGNGdW5jdGlvbkZpbHRlckJ1aWxkZXJCeUFyZ3MgfSBmcm9tICcuL2xpYi9yZXN0L3R5cGVzL2NvbW1vbi9ycGMnXG5cbi8qKlxuICogU3VwYWJhc2UgQ2xpZW50LlxuICpcbiAqIEFuIGlzb21vcnBoaWMgSmF2YXNjcmlwdCBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggUG9zdGdyZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1cGFiYXNlQ2xpZW50PFxuICBEYXRhYmFzZSA9IGFueSxcbiAgLy8gVGhlIHNlY29uZCB0eXBlIHBhcmFtZXRlciBpcyBhbHNvIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGJfc2NoZW1hLCBzbyB3ZVxuICAvLyBzdXBwb3J0IGJvdGggY2FzZXMuXG4gIC8vIFRPRE86IEFsbG93IHNldHRpbmcgZGJfc2NoZW1hIGZyb20gQ2xpZW50T3B0aW9ucy5cbiAgU2NoZW1hTmFtZU9yQ2xpZW50T3B0aW9ucyBleHRlbmRzXG4gICAgfCAoc3RyaW5nICYga2V5b2YgT21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+KVxuICAgIHwgeyBQb3N0Z3Jlc3RWZXJzaW9uOiBzdHJpbmcgfSA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgT21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+XG4gICAgPyAncHVibGljJ1xuICAgIDogc3RyaW5nICYga2V5b2YgT21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+LFxuICBTY2hlbWFOYW1lIGV4dGVuZHMgc3RyaW5nICZcbiAgICBrZXlvZiBPbWl0PERhdGFiYXNlLCAnX19JbnRlcm5hbFN1cGFiYXNlJz4gPSBTY2hlbWFOYW1lT3JDbGllbnRPcHRpb25zIGV4dGVuZHMgc3RyaW5nICZcbiAgICBrZXlvZiBPbWl0PERhdGFiYXNlLCAnX19JbnRlcm5hbFN1cGFiYXNlJz5cbiAgICA/IFNjaGVtYU5hbWVPckNsaWVudE9wdGlvbnNcbiAgICA6ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgT21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+XG4gICAgICA/ICdwdWJsaWMnXG4gICAgICA6IHN0cmluZyAmIGtleW9mIE9taXQ8T21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+LCAnX19JbnRlcm5hbFN1cGFiYXNlJz4sXG4gIFNjaGVtYSBleHRlbmRzIE9taXQ8RGF0YWJhc2UsICdfX0ludGVybmFsU3VwYWJhc2UnPltTY2hlbWFOYW1lXSBleHRlbmRzIEdlbmVyaWNTY2hlbWFcbiAgICA/IE9taXQ8RGF0YWJhc2UsICdfX0ludGVybmFsU3VwYWJhc2UnPltTY2hlbWFOYW1lXVxuICAgIDogbmV2ZXIgPSBPbWl0PERhdGFiYXNlLCAnX19JbnRlcm5hbFN1cGFiYXNlJz5bU2NoZW1hTmFtZV0gZXh0ZW5kcyBHZW5lcmljU2NoZW1hXG4gICAgPyBPbWl0PERhdGFiYXNlLCAnX19JbnRlcm5hbFN1cGFiYXNlJz5bU2NoZW1hTmFtZV1cbiAgICA6IG5ldmVyLFxuICBDbGllbnRPcHRpb25zIGV4dGVuZHMgeyBQb3N0Z3Jlc3RWZXJzaW9uOiBzdHJpbmcgfSA9IFNjaGVtYU5hbWVPckNsaWVudE9wdGlvbnMgZXh0ZW5kcyBzdHJpbmcgJlxuICAgIGtleW9mIE9taXQ8RGF0YWJhc2UsICdfX0ludGVybmFsU3VwYWJhc2UnPlxuICAgID8gLy8gSWYgdGhlIHZlcnNpb24gaXNuJ3QgZXhwbGljaXRseSBzZXQsIGxvb2sgZm9yIGl0IGluIHRoZSBfX0ludGVybmFsU3VwYWJhc2Ugb2JqZWN0IHRvIGluZmVyIHRoZSByaWdodCB2ZXJzaW9uXG4gICAgICBEYXRhYmFzZSBleHRlbmRzIHsgX19JbnRlcm5hbFN1cGFiYXNlOiB7IFBvc3RncmVzdFZlcnNpb246IHN0cmluZyB9IH1cbiAgICAgID8gRGF0YWJhc2VbJ19fSW50ZXJuYWxTdXBhYmFzZSddXG4gICAgICA6IC8vIG90aGVyd2lzZSBkZWZhdWx0IHRvIDEyXG4gICAgICAgIHsgUG9zdGdyZXN0VmVyc2lvbjogJzEyJyB9XG4gICAgOiBTY2hlbWFOYW1lT3JDbGllbnRPcHRpb25zIGV4dGVuZHMgeyBQb3N0Z3Jlc3RWZXJzaW9uOiBzdHJpbmcgfVxuICAgICAgPyBTY2hlbWFOYW1lT3JDbGllbnRPcHRpb25zXG4gICAgICA6IG5ldmVyLFxuPiB7XG4gIC8qKlxuICAgKiBTdXBhYmFzZSBBdXRoIGFsbG93cyB5b3UgdG8gY3JlYXRlIGFuZCBtYW5hZ2UgdXNlciBzZXNzaW9ucyBmb3IgYWNjZXNzIHRvIGRhdGEgdGhhdCBpcyBzZWN1cmVkIGJ5IGFjY2VzcyBwb2xpY2llcy5cbiAgICovXG4gIGF1dGg6IFN1cGFiYXNlQXV0aENsaWVudFxuICByZWFsdGltZTogUmVhbHRpbWVDbGllbnRcbiAgLyoqXG4gICAqIFN1cGFiYXNlIFN0b3JhZ2UgYWxsb3dzIHlvdSB0byBtYW5hZ2UgdXNlci1nZW5lcmF0ZWQgY29udGVudCwgc3VjaCBhcyBwaG90b3Mgb3IgdmlkZW9zLlxuICAgKi9cbiAgc3RvcmFnZTogU3VwYWJhc2VTdG9yYWdlQ2xpZW50XG5cbiAgcHJvdGVjdGVkIHJlYWx0aW1lVXJsOiBVUkxcbiAgcHJvdGVjdGVkIGF1dGhVcmw6IFVSTFxuICBwcm90ZWN0ZWQgc3RvcmFnZVVybDogVVJMXG4gIHByb3RlY3RlZCBmdW5jdGlvbnNVcmw6IFVSTFxuICBwcm90ZWN0ZWQgcmVzdDogUG9zdGdyZXN0Q2xpZW50PERhdGFiYXNlLCBDbGllbnRPcHRpb25zLCBTY2hlbWFOYW1lPlxuICBwcm90ZWN0ZWQgc3RvcmFnZUtleTogc3RyaW5nXG4gIHByb3RlY3RlZCBmZXRjaD86IEZldGNoXG4gIHByb3RlY3RlZCBjaGFuZ2VkQWNjZXNzVG9rZW4/OiBzdHJpbmdcbiAgcHJvdGVjdGVkIGFjY2Vzc1Rva2VuPzogKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPlxuXG4gIHByb3RlY3RlZCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3Nlci5cbiAgICogQHBhcmFtIHN1cGFiYXNlVXJsIFRoZSB1bmlxdWUgU3VwYWJhc2UgVVJMIHdoaWNoIGlzIHN1cHBsaWVkIHdoZW4geW91IGNyZWF0ZSBhIG5ldyBwcm9qZWN0IGluIHlvdXIgcHJvamVjdCBkYXNoYm9hcmQuXG4gICAqIEBwYXJhbSBzdXBhYmFzZUtleSBUaGUgdW5pcXVlIFN1cGFiYXNlIEtleSB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kYi5zY2hlbWEgWW91IGNhbiBzd2l0Y2ggaW4gYmV0d2VlbiBzY2hlbWFzLiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG4gICAqIEBwYXJhbSBvcHRpb25zLmF1dGguYXV0b1JlZnJlc2hUb2tlbiBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZWZyZXNoIHRoZSB0b2tlbiBiZWZvcmUgZXhwaXJpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLmF1dGgucGVyc2lzdFNlc3Npb24gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgc2F2ZSB0aGUgdXNlciBzZXNzaW9uIGludG8gbG9jYWwgc3RvcmFnZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuYXV0aC5kZXRlY3RTZXNzaW9uSW5VcmwgU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyBPQXV0aCBncmFudHMgaW4gdGhlIFVSTCBhbmQgc2lnbnMgaW4gdGhlIHVzZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlYWx0aW1lIE9wdGlvbnMgcGFzc2VkIGFsb25nIHRvIHJlYWx0aW1lLWpzIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zdG9yYWdlIE9wdGlvbnMgcGFzc2VkIGFsb25nIHRvIHRoZSBzdG9yYWdlLWpzIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuZmV0Y2ggQSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zLmdsb2JhbC5oZWFkZXJzIEFueSBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gc2VuZCB3aXRoIGVhY2ggbmV0d29yayByZXF1ZXN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXG4gICAqXG4gICAqIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28nLCAncHVibGljLWFub24ta2V5JylcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwcm9maWxlcycpLnNlbGVjdCgnKicpXG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHN1cGFiYXNlVXJsOiBzdHJpbmcsXG4gICAgcHJvdGVjdGVkIHN1cGFiYXNlS2V5OiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IFN1cGFiYXNlQ2xpZW50T3B0aW9uczxTY2hlbWFOYW1lPlxuICApIHtcbiAgICBjb25zdCBiYXNlVXJsID0gdmFsaWRhdGVTdXBhYmFzZVVybChzdXBhYmFzZVVybClcbiAgICBpZiAoIXN1cGFiYXNlS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ3N1cGFiYXNlS2V5IGlzIHJlcXVpcmVkLicpXG5cbiAgICB0aGlzLnJlYWx0aW1lVXJsID0gbmV3IFVSTCgncmVhbHRpbWUvdjEnLCBiYXNlVXJsKVxuICAgIHRoaXMucmVhbHRpbWVVcmwucHJvdG9jb2wgPSB0aGlzLnJlYWx0aW1lVXJsLnByb3RvY29sLnJlcGxhY2UoJ2h0dHAnLCAnd3MnKVxuICAgIHRoaXMuYXV0aFVybCA9IG5ldyBVUkwoJ2F1dGgvdjEnLCBiYXNlVXJsKVxuICAgIHRoaXMuc3RvcmFnZVVybCA9IG5ldyBVUkwoJ3N0b3JhZ2UvdjEnLCBiYXNlVXJsKVxuICAgIHRoaXMuZnVuY3Rpb25zVXJsID0gbmV3IFVSTCgnZnVuY3Rpb25zL3YxJywgYmFzZVVybClcblxuICAgIC8vIGRlZmF1bHQgc3RvcmFnZSBrZXkgdXNlcyB0aGUgc3VwYWJhc2UgcHJvamVjdCByZWYgYXMgYSBuYW1lc3BhY2VcbiAgICBjb25zdCBkZWZhdWx0U3RvcmFnZUtleSA9IGBzYi0ke2Jhc2VVcmwuaG9zdG5hbWUuc3BsaXQoJy4nKVswXX0tYXV0aC10b2tlbmBcbiAgICBjb25zdCBERUZBVUxUUyA9IHtcbiAgICAgIGRiOiBERUZBVUxUX0RCX09QVElPTlMsXG4gICAgICByZWFsdGltZTogREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLFxuICAgICAgYXV0aDogeyAuLi5ERUZBVUxUX0FVVEhfT1BUSU9OUywgc3RvcmFnZUtleTogZGVmYXVsdFN0b3JhZ2VLZXkgfSxcbiAgICAgIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUyxcbiAgICB9XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IGFwcGx5U2V0dGluZ0RlZmF1bHRzKG9wdGlvbnMgPz8ge30sIERFRkFVTFRTKVxuXG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gc2V0dGluZ3MuYXV0aC5zdG9yYWdlS2V5ID8/ICcnXG4gICAgdGhpcy5oZWFkZXJzID0gc2V0dGluZ3MuZ2xvYmFsLmhlYWRlcnMgPz8ge31cblxuICAgIGlmICghc2V0dGluZ3MuYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRoaXMuYXV0aCA9IHRoaXMuX2luaXRTdXBhYmFzZUF1dGhDbGllbnQoXG4gICAgICAgIHNldHRpbmdzLmF1dGggPz8ge30sXG4gICAgICAgIHRoaXMuaGVhZGVycyxcbiAgICAgICAgc2V0dGluZ3MuZ2xvYmFsLmZldGNoXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBzZXR0aW5ncy5hY2Nlc3NUb2tlblxuXG4gICAgICB0aGlzLmF1dGggPSBuZXcgUHJveHk8U3VwYWJhc2VBdXRoQ2xpZW50Pih7fSBhcyBhbnksIHtcbiAgICAgICAgZ2V0OiAoXywgcHJvcCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBAc3VwYWJhc2Uvc3VwYWJhc2UtanM6IFN1cGFiYXNlIENsaWVudCBpcyBjb25maWd1cmVkIHdpdGggdGhlIGFjY2Vzc1Rva2VuIG9wdGlvbiwgYWNjZXNzaW5nIHN1cGFiYXNlLmF1dGguJHtTdHJpbmcoXG4gICAgICAgICAgICAgIHByb3BcbiAgICAgICAgICAgICl9IGlzIG5vdCBwb3NzaWJsZWBcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaFdpdGhBdXRoKHN1cGFiYXNlS2V5LCB0aGlzLl9nZXRBY2Nlc3NUb2tlbi5iaW5kKHRoaXMpLCBzZXR0aW5ncy5nbG9iYWwuZmV0Y2gpXG4gICAgdGhpcy5yZWFsdGltZSA9IHRoaXMuX2luaXRSZWFsdGltZUNsaWVudCh7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBhY2Nlc3NUb2tlbjogdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSxcbiAgICAgIC4uLnNldHRpbmdzLnJlYWx0aW1lLFxuICAgIH0pXG4gICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgIC8vIFN0YXJ0IGF1dGggaW1tZWRpYXRlbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb24gd2l0aCBjaGFubmVsIHN1YnNjcmlwdGlvbnNcbiAgICAgIC8vIFdyYXAgUHJvbWlzZSB0byBhdm9pZCBGaXJlZm94IGV4dGVuc2lvbiBjcm9zcy1jb250ZXh0IFByb21pc2UgYWNjZXNzIGVycm9yc1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjZXNzVG9rZW4oKSlcbiAgICAgICAgLnRoZW4oKHRva2VuKSA9PiB0aGlzLnJlYWx0aW1lLnNldEF1dGgodG9rZW4pKVxuICAgICAgICAuY2F0Y2goKGUpID0+IGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNldCBpbml0aWFsIFJlYWx0aW1lIGF1dGggdG9rZW46JywgZSkpXG4gICAgfVxuXG4gICAgdGhpcy5yZXN0ID0gbmV3IFBvc3RncmVzdENsaWVudChuZXcgVVJMKCdyZXN0L3YxJywgYmFzZVVybCkuaHJlZiwge1xuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgc2NoZW1hOiBzZXR0aW5ncy5kYi5zY2hlbWEsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICB9KVxuXG4gICAgdGhpcy5zdG9yYWdlID0gbmV3IFN1cGFiYXNlU3RvcmFnZUNsaWVudChcbiAgICAgIHRoaXMuc3RvcmFnZVVybC5ocmVmLFxuICAgICAgdGhpcy5oZWFkZXJzLFxuICAgICAgdGhpcy5mZXRjaCxcbiAgICAgIG9wdGlvbnM/LnN0b3JhZ2VcbiAgICApXG5cbiAgICBpZiAoIXNldHRpbmdzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICB0aGlzLl9saXN0ZW5Gb3JBdXRoRXZlbnRzKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3VwYWJhc2UgRnVuY3Rpb25zIGFsbG93cyB5b3UgdG8gZGVwbG95IGFuZCBpbnZva2UgZWRnZSBmdW5jdGlvbnMuXG4gICAqL1xuICBnZXQgZnVuY3Rpb25zKCk6IEZ1bmN0aW9uc0NsaWVudCB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbnNDbGllbnQodGhpcy5mdW5jdGlvbnNVcmwuaHJlZiwge1xuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgY3VzdG9tRmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgfSlcbiAgfVxuXG4gIC8vIE5PVEU6IHNpZ25hdHVyZXMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBQb3N0Z3Jlc3RDbGllbnQuZnJvbVxuICBmcm9tPFxuICAgIFRhYmxlTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFNjaGVtYVsnVGFibGVzJ10sXG4gICAgVGFibGUgZXh0ZW5kcyBTY2hlbWFbJ1RhYmxlcyddW1RhYmxlTmFtZV0sXG4gID4ocmVsYXRpb246IFRhYmxlTmFtZSk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxDbGllbnRPcHRpb25zLCBTY2hlbWEsIFRhYmxlLCBUYWJsZU5hbWU+XG4gIGZyb208Vmlld05hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ1ZpZXdzJ10sIFZpZXcgZXh0ZW5kcyBTY2hlbWFbJ1ZpZXdzJ11bVmlld05hbWVdPihcbiAgICByZWxhdGlvbjogVmlld05hbWVcbiAgKTogUG9zdGdyZXN0UXVlcnlCdWlsZGVyPENsaWVudE9wdGlvbnMsIFNjaGVtYSwgVmlldywgVmlld05hbWU+XG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgcXVlcnkgb24gYSB0YWJsZSBvciBhIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSB0YWJsZSBvciB2aWV3IG5hbWUgdG8gcXVlcnlcbiAgICovXG4gIGZyb20ocmVsYXRpb246IHN0cmluZyk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxDbGllbnRPcHRpb25zLCBTY2hlbWEsIGFueT4ge1xuICAgIHJldHVybiB0aGlzLnJlc3QuZnJvbShyZWxhdGlvbilcbiAgfVxuXG4gIC8vIE5PVEU6IHNpZ25hdHVyZXMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBQb3N0Z3Jlc3RDbGllbnQuc2NoZW1hXG4gIC8qKlxuICAgKiBTZWxlY3QgYSBzY2hlbWEgdG8gcXVlcnkgb3IgcGVyZm9ybSBhbiBmdW5jdGlvbiAocnBjKSBjYWxsLlxuICAgKlxuICAgKiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG4gICAqXG4gICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG4gICAqL1xuICBzY2hlbWE8RHluYW1pY1NjaGVtYSBleHRlbmRzIHN0cmluZyAmIGtleW9mIE9taXQ8RGF0YWJhc2UsICdfX0ludGVybmFsU3VwYWJhc2UnPj4oXG4gICAgc2NoZW1hOiBEeW5hbWljU2NoZW1hXG4gICk6IFBvc3RncmVzdENsaWVudDxcbiAgICBEYXRhYmFzZSxcbiAgICBDbGllbnRPcHRpb25zLFxuICAgIER5bmFtaWNTY2hlbWEsXG4gICAgRGF0YWJhc2VbRHluYW1pY1NjaGVtYV0gZXh0ZW5kcyBHZW5lcmljU2NoZW1hID8gRGF0YWJhc2VbRHluYW1pY1NjaGVtYV0gOiBhbnlcbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5zY2hlbWE8RHluYW1pY1NjaGVtYT4oc2NoZW1hKVxuICB9XG5cbiAgLy8gTk9URTogc2lnbmF0dXJlcyBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIFBvc3RncmVzdENsaWVudC5ycGNcbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuICAgKiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuICAgKiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuICAgKiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIHJwYzxcbiAgICBGbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ0Z1bmN0aW9ucyddLFxuICAgIEFyZ3MgZXh0ZW5kcyBTY2hlbWFbJ0Z1bmN0aW9ucyddW0ZuTmFtZV1bJ0FyZ3MnXSA9IG5ldmVyLFxuICAgIEZpbHRlckJ1aWxkZXIgZXh0ZW5kcyBHZXRScGNGdW5jdGlvbkZpbHRlckJ1aWxkZXJCeUFyZ3M8XG4gICAgICBTY2hlbWEsXG4gICAgICBGbk5hbWUsXG4gICAgICBBcmdzXG4gICAgPiA9IEdldFJwY0Z1bmN0aW9uRmlsdGVyQnVpbGRlckJ5QXJnczxTY2hlbWEsIEZuTmFtZSwgQXJncz4sXG4gID4oXG4gICAgZm46IEZuTmFtZSxcbiAgICBhcmdzOiBBcmdzID0ge30gYXMgQXJncyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBoZWFkPzogYm9vbGVhblxuICAgICAgZ2V0PzogYm9vbGVhblxuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICB9ID0ge1xuICAgICAgaGVhZDogZmFsc2UsXG4gICAgICBnZXQ6IGZhbHNlLFxuICAgICAgY291bnQ6IHVuZGVmaW5lZCxcbiAgICB9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8XG4gICAgQ2xpZW50T3B0aW9ucyxcbiAgICBTY2hlbWEsXG4gICAgRmlsdGVyQnVpbGRlclsnUm93J10sXG4gICAgRmlsdGVyQnVpbGRlclsnUmVzdWx0J10sXG4gICAgRmlsdGVyQnVpbGRlclsnUmVsYXRpb25OYW1lJ10sXG4gICAgRmlsdGVyQnVpbGRlclsnUmVsYXRpb25zaGlwcyddLFxuICAgICdSUEMnXG4gID4ge1xuICAgIHJldHVybiB0aGlzLnJlc3QucnBjKGZuLCBhcmdzLCBvcHRpb25zKSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8XG4gICAgICBDbGllbnRPcHRpb25zLFxuICAgICAgU2NoZW1hLFxuICAgICAgRmlsdGVyQnVpbGRlclsnUm93J10sXG4gICAgICBGaWx0ZXJCdWlsZGVyWydSZXN1bHQnXSxcbiAgICAgIEZpbHRlckJ1aWxkZXJbJ1JlbGF0aW9uTmFtZSddLFxuICAgICAgRmlsdGVyQnVpbGRlclsnUmVsYXRpb25zaGlwcyddLFxuICAgICAgJ1JQQydcbiAgICA+XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlYWx0aW1lIGNoYW5uZWwgd2l0aCBCcm9hZGNhc3QsIFByZXNlbmNlLCBhbmQgUG9zdGdyZXMgQ2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuICAgKlxuICAgKi9cbiAgY2hhbm5lbChuYW1lOiBzdHJpbmcsIG9wdHM6IFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMgPSB7IGNvbmZpZzoge30gfSk6IFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgcmV0dXJuIHRoaXMucmVhbHRpbWUuY2hhbm5lbChuYW1lLCBvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIFJlYWx0aW1lIGNoYW5uZWxzLlxuICAgKi9cbiAgZ2V0Q2hhbm5lbHMoKTogUmVhbHRpbWVDaGFubmVsW10ge1xuICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLmdldENoYW5uZWxzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgUmVhbHRpbWUgY2hhbm5lbCBmcm9tIFJlYWx0aW1lIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFsdGltZUNoYW5uZWx9IGNoYW5uZWwgLSBUaGUgbmFtZSBvZiB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICpcbiAgICovXG4gIHJlbW92ZUNoYW5uZWwoY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsKTogUHJvbWlzZTwnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InPiB7XG4gICAgcmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQ2hhbm5lbChjaGFubmVsKVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhbGwgUmVhbHRpbWUgY2hhbm5lbHMgZnJvbSBSZWFsdGltZSBjbGllbnQuXG4gICAqL1xuICByZW1vdmVBbGxDaGFubmVscygpOiBQcm9taXNlPCgnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InKVtdPiB7XG4gICAgcmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQWxsQ2hhbm5lbHMoKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFjY2Vzc1Rva2VuKClcbiAgICB9XG5cbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMuYXV0aC5nZXRTZXNzaW9uKClcblxuICAgIHJldHVybiBkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbiA/PyB0aGlzLnN1cGFiYXNlS2V5XG4gIH1cblxuICBwcml2YXRlIF9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KFxuICAgIHtcbiAgICAgIGF1dG9SZWZyZXNoVG9rZW4sXG4gICAgICBwZXJzaXN0U2Vzc2lvbixcbiAgICAgIGRldGVjdFNlc3Npb25JblVybCxcbiAgICAgIHN0b3JhZ2UsXG4gICAgICB1c2VyU3RvcmFnZSxcbiAgICAgIHN0b3JhZ2VLZXksXG4gICAgICBmbG93VHlwZSxcbiAgICAgIGxvY2ssXG4gICAgICBkZWJ1ZyxcbiAgICAgIHRocm93T25FcnJvcixcbiAgICB9OiBTdXBhYmFzZUF1dGhDbGllbnRPcHRpb25zLFxuICAgIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGZldGNoPzogRmV0Y2hcbiAgKSB7XG4gICAgY29uc3QgYXV0aEhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5zdXBhYmFzZUtleX1gLFxuICAgICAgYXBpa2V5OiBgJHt0aGlzLnN1cGFiYXNlS2V5fWAsXG4gICAgfVxuICAgIHJldHVybiBuZXcgU3VwYWJhc2VBdXRoQ2xpZW50KHtcbiAgICAgIHVybDogdGhpcy5hdXRoVXJsLmhyZWYsXG4gICAgICBoZWFkZXJzOiB7IC4uLmF1dGhIZWFkZXJzLCAuLi5oZWFkZXJzIH0sXG4gICAgICBzdG9yYWdlS2V5OiBzdG9yYWdlS2V5LFxuICAgICAgYXV0b1JlZnJlc2hUb2tlbixcbiAgICAgIHBlcnNpc3RTZXNzaW9uLFxuICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsLFxuICAgICAgc3RvcmFnZSxcbiAgICAgIHVzZXJTdG9yYWdlLFxuICAgICAgZmxvd1R5cGUsXG4gICAgICBsb2NrLFxuICAgICAgZGVidWcsXG4gICAgICB0aHJvd09uRXJyb3IsXG4gICAgICBmZXRjaCxcbiAgICAgIC8vIGF1dGggY2hlY2tzIGlmIHRoZXJlIGlzIGEgY3VzdG9tIGF1dGhvcml6YWl0b24gaGVhZGVyIHVzaW5nIHRoaXMgZmxhZ1xuICAgICAgLy8gc28gaXQga25vd3Mgd2hldGhlciB0byByZXR1cm4gYW4gZXJyb3Igd2hlbiBnZXRVc2VyIGlzIGNhbGxlZCB3aXRoIG5vIHNlc3Npb25cbiAgICAgIGhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI6IE9iamVjdC5rZXlzKHRoaXMuaGVhZGVycykuc29tZShcbiAgICAgICAgKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdhdXRob3JpemF0aW9uJ1xuICAgICAgKSxcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBfaW5pdFJlYWx0aW1lQ2xpZW50KG9wdGlvbnM6IFJlYWx0aW1lQ2xpZW50T3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVhbHRpbWVDbGllbnQodGhpcy5yZWFsdGltZVVybC5ocmVmLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcGFyYW1zOiB7IC4uLnsgYXBpa2V5OiB0aGlzLnN1cGFiYXNlS2V5IH0sIC4uLm9wdGlvbnM/LnBhcmFtcyB9LFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIF9saXN0ZW5Gb3JBdXRoRXZlbnRzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKGV2ZW50LCBzZXNzaW9uKSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVUb2tlbkNoYW5nZWQoZXZlbnQsICdDTElFTlQnLCBzZXNzaW9uPy5hY2Nlc3NfdG9rZW4pXG4gICAgfSlcbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgcHJpdmF0ZSBfaGFuZGxlVG9rZW5DaGFuZ2VkKFxuICAgIGV2ZW50OiBBdXRoQ2hhbmdlRXZlbnQsXG4gICAgc291cmNlOiAnQ0xJRU5UJyB8ICdTVE9SQUdFJyxcbiAgICB0b2tlbj86IHN0cmluZ1xuICApIHtcbiAgICBpZiAoXG4gICAgICAoZXZlbnQgPT09ICdUT0tFTl9SRUZSRVNIRUQnIHx8IGV2ZW50ID09PSAnU0lHTkVEX0lOJykgJiZcbiAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuICE9PSB0b2tlblxuICAgICkge1xuICAgICAgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB0b2tlblxuICAgICAgdGhpcy5yZWFsdGltZS5zZXRBdXRoKHRva2VuKVxuICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdTSUdORURfT1VUJykge1xuICAgICAgdGhpcy5yZWFsdGltZS5zZXRBdXRoKClcbiAgICAgIGlmIChzb3VyY2UgPT0gJ1NUT1JBR0UnKSB0aGlzLmF1dGguc2lnbk91dCgpXG4gICAgICB0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBTdXBhYmFzZUNsaWVudCBmcm9tICcuL1N1cGFiYXNlQ2xpZW50J1xuaW1wb3J0IHR5cGUgeyBTdXBhYmFzZUNsaWVudE9wdGlvbnMgfSBmcm9tICcuL2xpYi90eXBlcydcblxuZXhwb3J0ICogZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG5leHBvcnQgdHlwZSB7IFVzZXIgYXMgQXV0aFVzZXIsIFNlc3Npb24gYXMgQXV0aFNlc3Npb24gfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbmV4cG9ydCB0eXBlIHtcbiAgUG9zdGdyZXN0UmVzcG9uc2UsXG4gIFBvc3RncmVzdFNpbmdsZVJlc3BvbnNlLFxuICBQb3N0Z3Jlc3RNYXliZVNpbmdsZVJlc3BvbnNlLFxufSBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuZXhwb3J0IHsgUG9zdGdyZXN0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuZXhwb3J0IHR5cGUgeyBGdW5jdGlvbkludm9rZU9wdGlvbnMgfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuZXhwb3J0IHtcbiAgRnVuY3Rpb25zSHR0cEVycm9yLFxuICBGdW5jdGlvbnNGZXRjaEVycm9yLFxuICBGdW5jdGlvbnNSZWxheUVycm9yLFxuICBGdW5jdGlvbnNFcnJvcixcbiAgRnVuY3Rpb25SZWdpb24sXG59IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG5leHBvcnQgKiBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN1cGFiYXNlQ2xpZW50IH0gZnJvbSAnLi9TdXBhYmFzZUNsaWVudCdcbmV4cG9ydCB0eXBlIHtcbiAgU3VwYWJhc2VDbGllbnRPcHRpb25zLFxuICBRdWVyeVJlc3VsdCxcbiAgUXVlcnlEYXRhLFxuICBRdWVyeUVycm9yLFxuICBEYXRhYmFzZVdpdGhvdXRJbnRlcm5hbHMsXG59IGZyb20gJy4vbGliL3R5cGVzJ1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU3VwYWJhc2UgQ2xpZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xuICpcbiAqIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28nLCAncHVibGljLWFub24ta2V5JylcbiAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykuc2VsZWN0KCcqJylcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ2xpZW50ID0gPFxuICBEYXRhYmFzZSA9IGFueSxcbiAgU2NoZW1hTmFtZU9yQ2xpZW50T3B0aW9ucyBleHRlbmRzXG4gICAgfCAoc3RyaW5nICYga2V5b2YgT21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+KVxuICAgIHwgeyBQb3N0Z3Jlc3RWZXJzaW9uOiBzdHJpbmcgfSA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgT21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+XG4gICAgPyAncHVibGljJ1xuICAgIDogc3RyaW5nICYga2V5b2YgT21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+LFxuICBTY2hlbWFOYW1lIGV4dGVuZHMgc3RyaW5nICZcbiAgICBrZXlvZiBPbWl0PERhdGFiYXNlLCAnX19JbnRlcm5hbFN1cGFiYXNlJz4gPSBTY2hlbWFOYW1lT3JDbGllbnRPcHRpb25zIGV4dGVuZHMgc3RyaW5nICZcbiAgICBrZXlvZiBPbWl0PERhdGFiYXNlLCAnX19JbnRlcm5hbFN1cGFiYXNlJz5cbiAgICA/IFNjaGVtYU5hbWVPckNsaWVudE9wdGlvbnNcbiAgICA6ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgT21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+XG4gICAgICA/ICdwdWJsaWMnXG4gICAgICA6IHN0cmluZyAmIGtleW9mIE9taXQ8T21pdDxEYXRhYmFzZSwgJ19fSW50ZXJuYWxTdXBhYmFzZSc+LCAnX19JbnRlcm5hbFN1cGFiYXNlJz4sXG4+KFxuICBzdXBhYmFzZVVybDogc3RyaW5nLFxuICBzdXBhYmFzZUtleTogc3RyaW5nLFxuICBvcHRpb25zPzogU3VwYWJhc2VDbGllbnRPcHRpb25zPFNjaGVtYU5hbWU+XG4pOiBTdXBhYmFzZUNsaWVudDxEYXRhYmFzZSwgU2NoZW1hTmFtZU9yQ2xpZW50T3B0aW9ucywgU2NoZW1hTmFtZT4gPT4ge1xuICByZXR1cm4gbmV3IFN1cGFiYXNlQ2xpZW50PERhdGFiYXNlLCBTY2hlbWFOYW1lT3JDbGllbnRPcHRpb25zLCBTY2hlbWFOYW1lPihcbiAgICBzdXBhYmFzZVVybCxcbiAgICBzdXBhYmFzZUtleSxcbiAgICBvcHRpb25zXG4gIClcbn1cblxuLy8gQ2hlY2sgZm9yIE5vZGUuanMgPD0gMTggZGVwcmVjYXRpb25cbmZ1bmN0aW9uIHNob3VsZFNob3dEZXByZWNhdGlvbldhcm5pbmcoKTogYm9vbGVhbiB7XG4gIC8vIFNraXAgaW4gYnJvd3NlciBlbnZpcm9ubWVudHNcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBTa2lwIGlmIHByb2Nlc3MgaXMgbm90IGF2YWlsYWJsZSAoZS5nLiwgRWRnZSBSdW50aW1lKVxuICAvLyBVc2UgZHluYW1pYyBwcm9wZXJ0eSBhY2Nlc3MgdG8gYXZvaWQgTmV4dC5qcyBFZGdlIFJ1bnRpbWUgc3RhdGljIGFuYWx5c2lzIHdhcm5pbmdzXG4gIGNvbnN0IF9wcm9jZXNzID0gKGdsb2JhbFRoaXMgYXMgYW55KVsncHJvY2VzcyddXG4gIGlmICghX3Byb2Nlc3MpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IHByb2Nlc3NWZXJzaW9uID0gX3Byb2Nlc3NbJ3ZlcnNpb24nXVxuICBpZiAocHJvY2Vzc1ZlcnNpb24gPT09IHVuZGVmaW5lZCB8fCBwcm9jZXNzVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgdmVyc2lvbk1hdGNoID0gcHJvY2Vzc1ZlcnNpb24ubWF0Y2goL152KFxcZCspXFwuLylcbiAgaWYgKCF2ZXJzaW9uTWF0Y2gpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IG1ham9yVmVyc2lvbiA9IHBhcnNlSW50KHZlcnNpb25NYXRjaFsxXSwgMTApXG4gIHJldHVybiBtYWpvclZlcnNpb24gPD0gMThcbn1cblxuaWYgKHNob3VsZFNob3dEZXByZWNhdGlvbldhcm5pbmcoKSkge1xuICBjb25zb2xlLndhcm4oXG4gICAgYOKaoO+4jyAgTm9kZS5qcyAxOCBhbmQgYmVsb3cgYXJlIGRlcHJlY2F0ZWQgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgQHN1cGFiYXNlL3N1cGFiYXNlLWpzLiBgICtcbiAgICAgIGBQbGVhc2UgdXBncmFkZSB0byBOb2RlLmpzIDIwIG9yIGxhdGVyLiBgICtcbiAgICAgIGBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgdmlzaXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9vcmdzL3N1cGFiYXNlL2Rpc2N1c3Npb25zLzM3MjE3YFxuICApXG59XG4iLCAiLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBEYWlseSBTY3J1bSBFeHRlbnNpb25cbiAqXG4gKiBTdXBhYmFzZSBcdUQ2NThcdUFDQkQgXHVCQ0MwXHVDMjE4IFx1QUQwMFx1QjlBQ1xuICogXHVENTA0XHVCODVDXHVCMzU1XHVDMTU4IFx1QkMzMFx1RDNFQyBcdUMyREMgXHVENjU4XHVBQ0JEIFx1QkNDMFx1QzIxOFx1Qjg1QyBcdUM4RkNcdUM3ODVcdUQ1NThcdUFDNzBcdUIwOTggXHVCQ0M0XHVCM0M0IFx1QzEyNFx1QzgxNSBcdUQzMENcdUM3N0NcdUI4NUMgXHVBRDAwXHVCOUFDXG4gKlxuICogQHNlZSBkb2NzL3Jlc2VhcmNoLm1kIDQuMVx1QzgwOFxuICovXG5cbi8qKlxuICogU3VwYWJhc2UgXHVENTA0XHVCODVDXHVDODFEXHVEMkI4IFVSTFxuICogQGNvbnN0YW50IHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBTVVBBQkFTRV9VUkwgPSBpbXBvcnQubWV0YS5lbnY/LlZJVEVfU1VQQUJBU0VfVVJMIHx8ICdodHRwczovL3pvcXR2cmNycW5hYXRrZHdtYWlsLnN1cGFiYXNlLmNvJztcblxuXG4vKipcbiAqIFN1cGFiYXNlIEFub255bW91cyBLZXkgKFx1QUNGNVx1QUMxQyBcdUFDMDBcdUIyQTUpXG4gKiBAY29uc3RhbnQge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFNVUEFCQVNFX0FOT05fS0VZID0gaW1wb3J0Lm1ldGEuZW52Py5WSVRFX1NVUEFCQVNFX0FOT05fS0VZIHx8ICdleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKcGMzTWlPaUp6ZFhCaFltRnpaU0lzSW5KbFppSTZJbnB2Y1hSMmNtTnljVzVoWVhSclpIZHRZV2xzSWl3aWNtOXNaU0k2SW1GdWIyNGlMQ0pwWVhRaU9qRTNOamswTURnNU9Ea3NJbVY0Y0NJNk1qQTRORGs0TkRrNE9YMC5qMk5OQzU3am1XUEFOakd1ZmRMWmIwRlB6OGxoT2RhcTlWMzJGdjB6WnBFJztcblxuLy8gRGVidWc6IExvZyBjb25maWd1cmF0aW9uIHZhbHVlc1xuXG4vKipcbiAqIEdvb2dsZSBPQXV0aCBcdUQwNzRcdUI3N0NcdUM3NzRcdUM1QjhcdUQyQjggSUQgKENocm9tZSBFeHRlbnNpb24gXHVEMEMwXHVDNzg1KVxuICogR29vZ2xlIFdvcmtzcGFjZSBBUElcdUM2QTkgLSBjaHJvbWUuaWRlbnRpdHkuZ2V0QXV0aFRva2VuKClcdUM1RDBcdUMxMUMgXHVDMEFDXHVDNkE5XG4gKiBAY29uc3RhbnQge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IEdPT0dMRV9DTElFTlRfSUQgPSBpbXBvcnQubWV0YS5lbnY/LlZJVEVfR09PR0xFX0NMSUVOVF9JRCB8fCAnMTY3MjkwOTAyMTA0LWltaHJxdG4zMW9ycTZ0bm81NWNlb2RvOGc0YjQ1NDc4LmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tJztcblxuLyoqXG4gKiBHb29nbGUgT0F1dGggXHVEMDc0XHVCNzdDXHVDNzc0XHVDNUI4XHVEMkI4IElEIChcdUM2RjkgXHVDNTYwXHVENTBDXHVCOUFDXHVDRjAwXHVDNzc0XHVDMTU4IFx1RDBDMFx1Qzc4NSlcbiAqIFN1cGFiYXNlIFx1Qzc3OFx1Qzk5RFx1QzZBOSAtIGNocm9tZS5pZGVudGl0eS5sYXVuY2hXZWJBdXRoRmxvdygpXHVDNUQwXHVDMTFDIFx1QzBBQ1x1QzZBOVxuICogQGNvbnN0YW50IHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBHT09HTEVfQVVUSF9DTElFTlRfSUQgPSBpbXBvcnQubWV0YS5lbnY/LlZJVEVfR09PR0xFX0FVVEhfQ0xJRU5UX0lEIHx8ICcxNjcyOTA5MDIxMDQtbTMxdjFsaW1vOXFqZWM5czdmOXI5azlsdHU0bjI1YjMuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20nO1xuXG4vKipcbiAqIEdvb2dsZSBPQXV0aCBSZWRpcmVjdCBVUklcbiAqIGNocm9tZS5pZGVudGl0eS5sYXVuY2hXZWJBdXRoRmxvd1x1QzVEMFx1QzExQyBcdUMwQUNcdUM2QTlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJlZGlyZWN0IFVSSVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R29vZ2xlUmVkaXJlY3RVUkkoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGBodHRwczovLyR7Y2hyb21lLnJ1bnRpbWUuaWR9LmNocm9taXVtYXBwLm9yZy9gO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tDb25maWddIEZhaWxlZCB0byBnZXQgY2hyb21lLnJ1bnRpbWUuaWQ6JywgZXJyb3IpO1xuICAgIHJldHVybiAnaHR0cHM6Ly91bmtub3duLmNocm9taXVtYXBwLm9yZy8nO1xuICB9XG59XG4iLCAiLyoqXG4gKiBTdXBhYmFzZSBDbGllbnQgZm9yIERhaWx5IFNjcnVtIEV4dGVuc2lvblxuICpcbiAqIFx1Qzc3OFx1Qzk5RCBcdUFEMDBcdUI5QUM6XG4gKiAtIFx1Qzc3NFx1QkE1NFx1Qzc3Qy9cdUJFNDRcdUJDMDBcdUJDODhcdUQ2MzggXHVCODVDXHVBREY4XHVDNzc4XG4gKiAtIEdvb2dsZSBPQXV0aCB2aWEgY2hyb21lLmlkZW50aXR5XG4gKiAtIFx1QzEzOFx1QzE1OCBcdUFEMDBcdUI5QUMgKGNocm9tZS5zdG9yYWdlLmxvY2FsXHVDNUQwIEpXVCBcdUM4MDBcdUM3QTUpXG4gKiAtIFx1Qzc3OFx1Qzk5RCBcdUMwQzFcdUQwREMgXHVCQ0MwXHVBQ0JEIFx1QjlBQ1x1QzJBNFx1QjEwOFxuICpcbiAqIEBzZWUgZG9jcy9yZXNlYXJjaC5tZCA0LjFcdUM4MDhcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgU1VQQUJBU0VfVVJMLCBTVVBBQkFTRV9BTk9OX0tFWSwgR09PR0xFX0FVVEhfQ0xJRU5UX0lELCBnZXRHb29nbGVSZWRpcmVjdFVSSSB9IGZyb20gJy4vY29uZmlnLmpzJztcblxuLyoqXG4gKiBTdXBhYmFzZSBcdUQwNzRcdUI3N0NcdUM3NzRcdUM1QjhcdUQyQjggXHVDNzc4XHVDMkE0XHVEMTM0XHVDMkE0XG4gKiBAdHlwZSB7aW1wb3J0KCdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnKS5TdXBhYmFzZUNsaWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KFNVUEFCQVNFX1VSTCwgU1VQQUJBU0VfQU5PTl9LRVksIHtcbiAgYXV0aDoge1xuICAgIC8vIGNocm9tZS5zdG9yYWdlLmxvY2FsXHVDNzQ0IFx1QzEzOFx1QzE1OCBcdUMyQTRcdUQxQTBcdUI5QUNcdUM5QzBcdUI4NUMgXHVDMEFDXHVDNkE5XG4gICAgc3RvcmFnZToge1xuICAgICAgZ2V0SXRlbTogYXN5bmMgKGtleSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoW2tleV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0W2tleV0gfHwgbnVsbDtcbiAgICAgIH0sXG4gICAgICBzZXRJdGVtOiBhc3luYyAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoeyBba2V5XTogdmFsdWUgfSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlSXRlbTogYXN5bmMgKGtleSkgPT4ge1xuICAgICAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5yZW1vdmUoW2tleV0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gXHVDNzkwXHVCM0Q5IFx1RDFBMFx1RDA3MCBcdUFDMzFcdUMyRTAgXHVENjVDXHVDMTMxXHVENjU0XG4gICAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgICAvLyBcdUMxMzhcdUMxNTggXHVDNjAxXHVDMThEXHVDMTMxIChcdUJFMENcdUI3N0NcdUM2QjBcdUM4MDAgXHVDN0FDXHVDMkRDXHVDNzkxIFx1RDZDNFx1QzVEMFx1QjNDNCBcdUM3MjBcdUM5QzApXG4gICAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gICAgLy8gXHVCODVDXHVDRUVDIFx1QzJBNFx1RDFBMFx1QjlBQ1x1QzlDMCBcdUFDMTBcdUM5QzAgKFx1QjJFNFx1Qjk3OCBcdUQwRURcdUM1RDBcdUMxMUMgXHVCODVDXHVBREY4XHVDNzc4IFx1QzBDMVx1RDBEQyBcdUIzRDlcdUFFMzBcdUQ2NTQpXG4gICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiBmYWxzZVxuICB9XG59KTtcblxuLyoqXG4gKiBcdUM3NzRcdUJBNTRcdUM3N0MvXHVCRTQ0XHVCQzAwXHVCQzg4XHVENjM4IFx1Qjg1Q1x1QURGOFx1Qzc3OFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbCAtIFx1QzBBQ1x1QzZBOVx1Qzc5MCBcdUM3NzRcdUJBNTRcdUM3N0NcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFx1QkU0NFx1QkMwMFx1QkM4OFx1RDYzOFxuICogQHRocm93cyB7RXJyb3J9IFx1Qjg1Q1x1QURGOFx1Qzc3OCBcdUMyRTRcdUQzMjggXHVDMkRDXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7c2Vzc2lvbjogb2JqZWN0LCB1c2VyOiBvYmplY3R9Pn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25JbihlbWFpbCwgcGFzc3dvcmQpIHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQoe1xuICAgIGVtYWlsLFxuICAgIHBhc3N3b3JkXG4gIH0pO1xuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdXBhYmFzZV0gU2lnbiBpbiBmYWlsZWQ6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBjaHJvbWUuc3RvcmFnZVx1QzVEMCBcdUM3NzhcdUM5OUQgXHVDODE1XHVCQ0Y0IFx1QzgwMFx1QzdBNSAoYmFja2dyb3VuZC5qc1x1QzVEMFx1QzExQyBcdUMwQUNcdUM2QTkpXG4gIGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7XG4gICAgYXV0aFRva2VuOiBkYXRhLnNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgIHJlZnJlc2hUb2tlbjogZGF0YS5zZXNzaW9uLnJlZnJlc2hfdG9rZW4sXG4gICAgdXNlcklkOiBkYXRhLnVzZXIuaWQsXG4gICAgaXNMb2dnZWRJbjogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBcdUM3NzRcdUJBNTRcdUM3N0MvXHVCRTQ0XHVCQzAwXHVCQzg4XHVENjM4IFx1RDY4Q1x1QzZEMFx1QUMwMFx1Qzc4NVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbCAtIFx1QzBBQ1x1QzZBOVx1Qzc5MCBcdUM3NzRcdUJBNTRcdUM3N0NcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFx1QkU0NFx1QkMwMFx1QkM4OFx1RDYzOFxuICogQHRocm93cyB7RXJyb3J9IFx1RDY4Q1x1QzZEMFx1QUMwMFx1Qzc4NSBcdUMyRTRcdUQzMjggXHVDMkRDXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7c2Vzc2lvbjogb2JqZWN0fG51bGwsIHVzZXI6IG9iamVjdH0+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnblVwKGVtYWlsLCBwYXNzd29yZCkge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25VcCh7XG4gICAgZW1haWwsXG4gICAgcGFzc3dvcmRcbiAgfSk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1cGFiYXNlXSBTaWduIHVwIGZhaWxlZDonLCBlcnJvci5tZXNzYWdlKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIFx1Qzc3NFx1QkE1NFx1Qzc3QyBcdUM3NzhcdUM5OURcdUM3NzQgXHVENTQ0XHVDNjk0XHVENTVDIFx1QUNCRFx1QzZCMCBzZXNzaW9uXHVDNzQwIG51bGxcbiAgLy8gXHVDNzc4XHVDOTlEXHVDNzc0IFx1RDU0NFx1QzY5NCBcdUM1QzZcdUM3M0NcdUJBNzQgXHVCQzE0XHVCODVDIHNlc3Npb24gXHVDMEREXHVDMTMxXHVCNDI4XG4gIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAvLyBjaHJvbWUuc3RvcmFnZVx1QzVEMCBcdUM3NzhcdUM5OUQgXHVDODE1XHVCQ0Y0IFx1QzgwMFx1QzdBNVxuICAgIGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7XG4gICAgICBhdXRoVG9rZW46IGRhdGEuc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICByZWZyZXNoVG9rZW46IGRhdGEuc2Vzc2lvbi5yZWZyZXNoX3Rva2VuLFxuICAgICAgdXNlcklkOiBkYXRhLnVzZXIuaWQsXG4gICAgICBpc0xvZ2dlZEluOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBHb29nbGUgT0F1dGggXHVCODVDXHVBREY4XHVDNzc4XG4gKlxuICogY2hyb21lLmlkZW50aXR5LmxhdW5jaFdlYkF1dGhGbG93XHVCOTdDIFx1QzBBQ1x1QzZBOVx1RDU1OFx1QzVFQ1xuICogR29vZ2xlIE9BdXRoIFx1Qzc3OFx1Qzk5RCBcdUQ2QzQgU3VwYWJhc2Ugc2lnbkluV2l0aElkVG9rZW5cdUM3M0NcdUI4NUMgXHVDMTM4XHVDMTU4IFx1QzBERFx1QzEzMVxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBPQXV0aCBcdUQ1MENcdUI4NUNcdUM2QjAgXHVDMkU0XHVEMzI4IFx1QjYxMFx1QjI5NCBcdUI4NUNcdUFERjhcdUM3NzggXHVDMkU0XHVEMzI4IFx1QzJEQ1xuICogQHJldHVybnMge1Byb21pc2U8e3Nlc3Npb246IG9iamVjdCwgdXNlcjogb2JqZWN0fT59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoR29vZ2xlKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIDEuIEdvb2dsZSBPQXV0aCBVUkwgXHVCRTRDXHVCNERDXG4gICAgY29uc3QgYXV0aFVybCA9IGJ1aWxkR29vZ2xlT0F1dGhVUkwoKTtcblxuICAgIC8vIDIuIGNocm9tZS5pZGVudGl0eVx1Qjg1QyBPQXV0aCBcdUQ1MENcdUI4NUNcdUM2QjAgXHVDMkRDXHVDNzkxXG4gICAgY2hyb21lLmlkZW50aXR5LmxhdW5jaFdlYkF1dGhGbG93KFxuICAgICAge1xuICAgICAgICB1cmw6IGF1dGhVcmwsXG4gICAgICAgIGludGVyYWN0aXZlOiB0cnVlXG4gICAgICB9LFxuICAgICAgYXN5bmMgKHJlZGlyZWN0VXJsKSA9PiB7XG4gICAgICAgIC8vIDMuIFx1QzVEMFx1QjdFQyBcdUNDQjRcdUQwNkNcbiAgICAgICAgaWYgKGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdXBhYmFzZV0gT0F1dGggZmxvdyBlcnJvcjonLCBjaHJvbWUucnVudGltZS5sYXN0RXJyb3IpO1xuICAgICAgICAgIHJldHVybiByZWplY3QoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVkaXJlY3RVcmwpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm8gcmVkaXJlY3QgVVJMIHJlY2VpdmVkJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyA0LiBSZWRpcmVjdCBVUkxcdUM1RDBcdUMxMUMgSUQgdG9rZW4gXHVDRDk0XHVDRDlDXG4gICAgICAgICAgY29uc3QgaWRUb2tlbiA9IGV4dHJhY3RUb2tlbkZyb21VcmwocmVkaXJlY3RVcmwpO1xuXG4gICAgICAgICAgLy8gNS4gU3VwYWJhc2Ugc2lnbkluV2l0aElkVG9rZW5cbiAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhJZFRva2VuKHtcbiAgICAgICAgICAgIHByb3ZpZGVyOiAnZ29vZ2xlJyxcbiAgICAgICAgICAgIHRva2VuOiBpZFRva2VuXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdXBhYmFzZV0gR29vZ2xlIHNpZ24gaW4gZmFpbGVkOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNi4gY2hyb21lLnN0b3JhZ2VcdUM1RDAgXHVDNzc4XHVDOTlEIFx1QzgxNVx1QkNGNCBcdUM4MDBcdUM3QTVcbiAgICAgICAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoe1xuICAgICAgICAgICAgYXV0aFRva2VuOiBkYXRhLnNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgcmVmcmVzaFRva2VuOiBkYXRhLnNlc3Npb24ucmVmcmVzaF90b2tlbixcbiAgICAgICAgICAgIHVzZXJJZDogZGF0YS51c2VyLmlkLFxuICAgICAgICAgICAgaXNMb2dnZWRJbjogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1N1cGFiYXNlXSBHb29nbGUgc2lnbiBpbiBlcnJvcjonLCBlcnIpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG59XG5cbi8qKlxuICogXHVCODVDXHVBREY4XHVDNTQ0XHVDNkMzXG4gKlxuICogU3VwYWJhc2UgXHVDMTM4XHVDMTU4IFx1Qzg4NVx1QjhDQyBcdUJDMEYgY2hyb21lLnN0b3JhZ2UgXHVEMDc0XHVCOUFDXHVDNUI0XG4gKlxuICogQHRocm93cyB7RXJyb3J9IFx1Qjg1Q1x1QURGOFx1QzU0NFx1QzZDMyBcdUMyRTRcdUQzMjggXHVDMkRDXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25PdXQoKSB7XG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbk91dCgpO1xuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdXBhYmFzZV0gU2lnbiBvdXQgZmFpbGVkOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gY2hyb21lLnN0b3JhZ2VcdUM1RDBcdUMxMUMgXHVDNzc4XHVDOTlEIFx1QzgxNVx1QkNGNCBcdUM4MUNcdUFDNzBcbiAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwucmVtb3ZlKFtcbiAgICAnYXV0aFRva2VuJyxcbiAgICAncmVmcmVzaFRva2VuJyxcbiAgICAndXNlcklkJyxcbiAgICAnaXNMb2dnZWRJbidcbiAgXSk7XG5cbn1cblxuLyoqXG4gKiBcdUQ2MDRcdUM3QUMgXHVDMTM4XHVDMTU4IFx1QkMxOFx1RDY1OFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHtzZXNzaW9uOiBvYmplY3R8bnVsbCwgdXNlcjogb2JqZWN0fG51bGx9Pn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNlc3Npb24oKSB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpO1xuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdXBhYmFzZV0gR2V0IHNlc3Npb24gZmFpbGVkOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzZXNzaW9uOiBkYXRhLnNlc3Npb24sXG4gICAgdXNlcjogZGF0YS5zZXNzaW9uPy51c2VyIHx8IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBcdUM3NzhcdUM5OUQgXHVDMEMxXHVEMERDIFx1QkNDMFx1QUNCRCBcdUI5QUNcdUMyQTRcdUIxMDhcbiAqXG4gKiBcdUMwQUNcdUM2QTkgXHVDNjA4OlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgeyBkYXRhIH0gPSBvbkF1dGhTdGF0ZUNoYW5nZSgoZXZlbnQsIHNlc3Npb24pID0+IHtcbiAqIH0pO1xuICogLy8gXHVBRDZDXHVCM0M1IFx1RDU3NFx1QzgxQzogZGF0YS5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7KGV2ZW50OiBzdHJpbmcsIHNlc3Npb246IG9iamVjdHxudWxsKSA9PiB2b2lkfSBjYWxsYmFja1xuICogQHJldHVybnMge3tkYXRhOiB7c3Vic2NyaXB0aW9uOiBvYmplY3R9fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uQXV0aFN0YXRlQ2hhbmdlKGNhbGxiYWNrKSB7XG4gIHJldHVybiBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKChldmVudCwgc2Vzc2lvbikgPT4ge1xuXG4gICAgLy8gY2hyb21lLnN0b3JhZ2UgXHVCM0Q5XHVBRTMwXHVENjU0XG4gICAgaWYgKGV2ZW50ID09PSAnU0lHTkVEX0lOJyAmJiBzZXNzaW9uKSB7XG4gICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoe1xuICAgICAgICBhdXRoVG9rZW46IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICByZWZyZXNoVG9rZW46IHNlc3Npb24ucmVmcmVzaF90b2tlbixcbiAgICAgICAgdXNlcklkOiBzZXNzaW9uLnVzZXIuaWQsXG4gICAgICAgIGlzTG9nZ2VkSW46IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdTSUdORURfT1VUJykge1xuICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwucmVtb3ZlKFtcbiAgICAgICAgJ2F1dGhUb2tlbicsXG4gICAgICAgICdyZWZyZXNoVG9rZW4nLFxuICAgICAgICAndXNlcklkJyxcbiAgICAgICAgJ2lzTG9nZ2VkSW4nXG4gICAgICBdKTtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhldmVudCwgc2Vzc2lvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdvb2dsZSBPQXV0aCBVUkwgXHVCRTRDXHVCNERDXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkR29vZ2xlT0F1dGhVUkwoKSB7XG4gIGlmICghR09PR0xFX0FVVEhfQ0xJRU5UX0lEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHT09HTEVfQVVUSF9DTElFTlRfSUQgaXMgbm90IGNvbmZpZ3VyZWQnKTtcbiAgfVxuXG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgIGNsaWVudF9pZDogR09PR0xFX0FVVEhfQ0xJRU5UX0lELFxuICAgIHJlZGlyZWN0X3VyaTogZ2V0R29vZ2xlUmVkaXJlY3RVUkkoKSxcbiAgICByZXNwb25zZV90eXBlOiAnaWRfdG9rZW4nLFxuICAgIHNjb3BlOiAnb3BlbmlkIGVtYWlsIHByb2ZpbGUnLFxuICAgIC8vIFN1cGFiYXNlXHVCMjk0IGlkX3Rva2VuXHVDNzQ0IFx1QzBBQ1x1QzZBOVxuICAgIG5vbmNlOiBjcnlwdG8ucmFuZG9tVVVJRCgpXG4gIH0pO1xuXG4gIHJldHVybiBgaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tL28vb2F1dGgyL3YyL2F1dGg/JHtwYXJhbXMudG9TdHJpbmcoKX1gO1xufVxuXG4vKipcbiAqIFJlZGlyZWN0IFVSTFx1QzVEMFx1QzExQyBJRCB0b2tlbiBcdUNEOTRcdUNEOUNcbiAqXG4gKiBHb29nbGUgT0F1dGggcmVkaXJlY3QgVVJMIFx1RDYxNVx1QzJERDpcbiAqIGh0dHBzOi8ve2V4dGVuc2lvbi1pZH0uY2hyb21pdW1hcHAub3JnLyNpZF90b2tlbj17dG9rZW59Ji4uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVkaXJlY3RVcmxcbiAqIEB0aHJvd3Mge0Vycm9yfSBcdUQxQTBcdUQwNzAgXHVDRDk0XHVDRDlDIFx1QzJFNFx1RDMyOCBcdUMyRENcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RUb2tlbkZyb21VcmwocmVkaXJlY3RVcmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlZGlyZWN0VXJsKTtcbiAgICAvLyBGcmFnbWVudFx1QzVEMFx1QzExQyBpZF90b2tlbiBcdUNEOTRcdUNEOUMgKCNpZF90b2tlbj14eHgpXG4gICAgY29uc3QgZnJhZ21lbnQgPSB1cmwuaGFzaC5zdWJzdHJpbmcoMSk7IC8vICMgXHVDODFDXHVBQzcwXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhmcmFnbWVudCk7XG4gICAgY29uc3QgaWRUb2tlbiA9IHBhcmFtcy5nZXQoJ2lkX3Rva2VuJyk7XG5cbiAgICBpZiAoIWlkVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaWRfdG9rZW4gbm90IGZvdW5kIGluIHJlZGlyZWN0IFVSTCcpO1xuICAgIH1cblxuICAgIHJldHVybiBpZFRva2VuO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3VwYWJhc2VdIEZhaWxlZCB0byBleHRyYWN0IHRva2VuIGZyb20gVVJMOicsIGVycik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZXh0cmFjdCB0b2tlbiBmcm9tIHJlZGlyZWN0IFVSTCcpO1xuICB9XG59XG4iLCAiLyoqXG4gKiBEYWlseSBTY3J1bSBWaWV3ZXJcbiAqIE1vZGVybiBVSSB3aXRoIE5vdGlvbi1zdHlsZSBkZXNpZ25cbiAqIFBoYXNlIDU6IFN5bmMgYnV0dG9uICsgQ29nbml0aXZlIEZsb3cgVUlcbiAqL1xuXG5pbXBvcnQgeyBnZXRTZXNzaW9uLCBzaWduT3V0IH0gZnJvbSAnLi9saWIvc3VwYWJhc2UtY2xpZW50LmpzJztcbmltcG9ydCB7IFNVUEFCQVNFX1VSTCB9IGZyb20gJy4vbGliL2NvbmZpZy5qcyc7XG5cbi8vIERPTSBFbGVtZW50c1xuY29uc3QgbG9hZGluZ1NjcmVlbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FkaW5nU2NyZWVuJyk7XG5jb25zdCBsb2FkaW5nU3VidGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FkaW5nU3VidGV4dCcpO1xuY29uc3QgcHJvZ3Jlc3NGaWxsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2dyZXNzRmlsbCcpO1xuXG5jb25zdCBzY3J1bUNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY3J1bUNvbnRhaW5lcicpO1xuY29uc3Qgc2NydW1EYXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjcnVtRGF0ZScpO1xuY29uc3Qgc2NydW1Db250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjcnVtQ29udGVudCcpO1xuXG5jb25zdCBlcnJvclNjcmVlbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcnJvclNjcmVlbicpO1xuY29uc3QgZXJyb3JUaXRsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcnJvclRpdGxlJyk7XG5jb25zdCBlcnJvck1lc3NhZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3JNZXNzYWdlJyk7XG5jb25zdCByZXRyeUJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXRyeUJ0bicpO1xuXG5jb25zdCBlbXB0eVNjcmVlbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlbXB0eVNjcmVlbicpO1xuY29uc3QgZW1wdHlNZXNzYWdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VtcHR5TWVzc2FnZScpO1xuY29uc3QgZ2VuZXJhdGVCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2VuZXJhdGVCdG4nKTtcblxuY29uc3QgZmxvYXRpbmdDb250cm9scyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmbG9hdGluZ0NvbnRyb2xzJyk7XG5jb25zdCBkYXRlUGlja2VyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RhdGVQaWNrZXInKTtcbmNvbnN0IHRvZGF5QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvZGF5QnRuJyk7XG5jb25zdCBnZW5lcmF0ZUJ0bk1haW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2VuZXJhdGVCdG5NYWluJyk7XG5jb25zdCBzeW5jQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bmNCdG4nKTtcbmNvbnN0IHN5bmNTdGF0dXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3luY1N0YXR1cycpO1xuY29uc3Qgc3luY1Byb2dyZXNzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bmNQcm9ncmVzcycpO1xuY29uc3Qgc3luY1Byb2dyZXNzRmlsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzeW5jUHJvZ3Jlc3NGaWxsJyk7XG5cbi8vIFN0YXRlXG5sZXQgY3VycmVudERhdGUgPSBudWxsO1xubGV0IHByb2dyZXNzID0gMDtcbmxldCBsb2FkaW5nSW50ZXJ2YWwgPSBudWxsO1xubGV0IHBlbmRpbmdDb3VudCA9IDA7XG5sZXQgaW5pdGlhbFBlbmRpbmdDb3VudCA9IDA7IC8vIEZvciBwcm9ncmVzcyBjYWxjdWxhdGlvblxubGV0IHByb2Nlc3NlZENvdW50ID0gMDsgLy8gVHJhY2sgcHJvY2Vzc2VkIGl0ZW1zXG5sZXQgaXNTeW5jaW5nID0gZmFsc2U7XG5sZXQgZXhwYW5kZWRGbG93cyA9IG5ldyBTZXQoKTsgLy8gVHJhY2sgZXhwYW5kZWQgY29nbml0aXZlIGZsb3cgcGFuZWxzXG5cbmNvbnN0IGxvYWRpbmdNZXNzYWdlcyA9IFtcbiAgICAnQW5hbHl6aW5nIHlvdXIgYWN0aXZpdGllcy4uLicsXG4gICAgJ1Byb2Nlc3NpbmcgY29tbWl0cyAmIFBScy4uLicsXG4gICAgJ1Jldmlld2luZyBjYWxlbmRhciBldmVudHMuLi4nLFxuICAgICdHYXRoZXJpbmcgaW5zaWdodHMuLi4nLFxuICAgICdQcmVwYXJpbmcgeW91ciBzY3J1bS4uLidcbl07XG5cbi8vIEluaXRpYWxpemVcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICBkYXRlUGlja2VyLnZhbHVlID0gdG9kYXk7XG4gICAgY3VycmVudERhdGUgPSB0b2RheTtcblxuICAgIHNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBhd2FpdCBsb2FkUmVwb3J0KGN1cnJlbnREYXRlKTtcbiAgICBhd2FpdCBjaGVja1BlbmRpbmdDb3VudChjdXJyZW50RGF0ZSk7XG59KTtcblxuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycygpIHtcbiAgICBkYXRlUGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGN1cnJlbnREYXRlID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgIGF3YWl0IGxvYWRSZXBvcnQoY3VycmVudERhdGUpO1xuICAgICAgICBhd2FpdCBjaGVja1BlbmRpbmdDb3VudChjdXJyZW50RGF0ZSk7XG4gICAgfSk7XG5cbiAgICB0b2RheUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICAgICAgZGF0ZVBpY2tlci52YWx1ZSA9IHRvZGF5O1xuICAgICAgICBjdXJyZW50RGF0ZSA9IHRvZGF5O1xuICAgICAgICBhd2FpdCBsb2FkUmVwb3J0KGN1cnJlbnREYXRlKTtcbiAgICAgICAgYXdhaXQgY2hlY2tQZW5kaW5nQ291bnQoY3VycmVudERhdGUpO1xuICAgIH0pO1xuXG4gICAgcmV0cnlCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBsb2FkUmVwb3J0KGN1cnJlbnREYXRlKSk7XG4gICAgZ2VuZXJhdGVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBnZW5lcmF0ZVJlcG9ydChjdXJyZW50RGF0ZSkpO1xuICAgIGdlbmVyYXRlQnRuTWFpbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IGdlbmVyYXRlUmVwb3J0KGN1cnJlbnREYXRlKSk7XG5cbiAgICAvLyBTeW5jIGJ1dHRvbiBldmVudCBsaXN0ZW5lclxuICAgIGlmIChzeW5jQnRuKSB7XG4gICAgICAgIHN5bmNCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBzeW5jRGF0YShjdXJyZW50RGF0ZSkpO1xuICAgIH1cbn1cblxuLy8gVmlldyBNYW5hZ2VtZW50XG5mdW5jdGlvbiBzaG93Vmlldyh2aWV3KSB7XG4gICAgLy8gXHVCQUE4XHVCNEUwIFx1QkRGMCBcdUMyMjhcdUFFMzBcdUFFMzBcbiAgICBsb2FkaW5nU2NyZWVuLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgIHNjcnVtQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTtcbiAgICBlcnJvclNjcmVlbi5jbGFzc0xpc3QucmVtb3ZlKCd2aXNpYmxlJyk7XG4gICAgZW1wdHlTY3JlZW4uY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpO1xuICAgIGZsb2F0aW5nQ29udHJvbHMuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpO1xuXG4gICAgc3dpdGNoICh2aWV3KSB7XG4gICAgICAgIGNhc2UgJ2xvYWRpbmcnOlxuICAgICAgICAgICAgbG9hZGluZ1NjcmVlbi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHN0YXJ0TG9hZGluZ0FuaW1hdGlvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JlcG9ydCc6XG4gICAgICAgICAgICBzY3J1bUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCd2aXNpYmxlJyk7XG4gICAgICAgICAgICBmbG9hdGluZ0NvbnRyb2xzLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICBlcnJvclNjcmVlbi5jbGFzc0xpc3QuYWRkKCd2aXNpYmxlJyk7XG4gICAgICAgICAgICBmbG9hdGluZ0NvbnRyb2xzLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlbXB0eSc6XG4gICAgICAgICAgICBlbXB0eVNjcmVlbi5jbGFzc0xpc3QuYWRkKCd2aXNpYmxlJyk7XG4gICAgICAgICAgICBmbG9hdGluZ0NvbnRyb2xzLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRMb2FkaW5nQW5pbWF0aW9uKCkge1xuICAgIHByb2dyZXNzID0gMDtcbiAgICBwcm9ncmVzc0ZpbGwuc3R5bGUud2lkdGggPSAnMCUnO1xuICAgIGxvYWRpbmdTdWJ0ZXh0LnRleHRDb250ZW50ID0gbG9hZGluZ01lc3NhZ2VzWzBdO1xuXG4gICAgaWYgKGxvYWRpbmdJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbChsb2FkaW5nSW50ZXJ2YWwpO1xuXG4gICAgbG9hZGluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBwcm9ncmVzcyArPSBNYXRoLnJhbmRvbSgpICogOCArIDI7XG4gICAgICAgIGlmIChwcm9ncmVzcyA+IDk1KSBwcm9ncmVzcyA9IDk1O1xuXG4gICAgICAgIHByb2dyZXNzRmlsbC5zdHlsZS53aWR0aCA9IHByb2dyZXNzICsgJyUnO1xuXG4gICAgICAgIGNvbnN0IG1zZ0luZGV4ID0gTWF0aC5taW4oTWF0aC5mbG9vcihwcm9ncmVzcyAvIDIwKSwgbG9hZGluZ01lc3NhZ2VzLmxlbmd0aCAtIDEpO1xuICAgICAgICBsb2FkaW5nU3VidGV4dC50ZXh0Q29udGVudCA9IGxvYWRpbmdNZXNzYWdlc1ttc2dJbmRleF07XG4gICAgfSwgNDAwKTtcbn1cblxuZnVuY3Rpb24gc3RvcExvYWRpbmdBbmltYXRpb24oKSB7XG4gICAgaWYgKGxvYWRpbmdJbnRlcnZhbCkge1xuICAgICAgICBjbGVhckludGVydmFsKGxvYWRpbmdJbnRlcnZhbCk7XG4gICAgICAgIGxvYWRpbmdJbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuICAgIHByb2dyZXNzRmlsbC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBsb2FkaW5nU3VidGV4dC50ZXh0Q29udGVudCA9ICdDb21wbGV0ZSEnO1xufVxuXG4vLyBBUEkgQ2FsbHNcbmFzeW5jIGZ1bmN0aW9uIGxvYWRSZXBvcnQoZGF0ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHNob3dWaWV3KCdsb2FkaW5nJyk7XG5cbiAgICAgICAgY29uc3QgeyBzZXNzaW9uIH0gPSBhd2FpdCBnZXRTZXNzaW9uKCk7XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgbG9nIGluIGZpcnN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXJsID0gYCR7U1VQQUJBU0VfVVJMfS9mdW5jdGlvbnMvdjEvZ2V0LXNjcnVtP2RhdGU9JHtkYXRlfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Nlc3Npb24uYWNjZXNzX3Rva2VufWAsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzdG9wTG9hZGluZ0FuaW1hdGlvbigpO1xuXG4gICAgICAgIC8vIFx1QzdBMFx1QzJEQyBcdUIzMDBcdUFFMzAgXHVENkM0IFx1RDY1NFx1QkE3NCBcdUM4MDRcdUQ2NTggKFx1Qjg1Q1x1QjUyOSBcdUM2NDRcdUI4Q0MgXHVDNTYwXHVCMkM4XHVCQTU0XHVDNzc0XHVDMTU4IFx1QkNGNFx1QzVFQ1x1QzhGQ1x1QUUzMClcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgZW1wdHlNZXNzYWdlLnRleHRDb250ZW50ID0gYCR7Zm9ybWF0RGF0ZShkYXRlKX1cdUM1RDAgXHVDMjE4XHVDOUQxXHVCNDFDIFx1QjM3MFx1Qzc3NFx1RDEzMFx1QUMwMCBcdUM1QzZcdUMyQjVcdUIyQzhcdUIyRTQuYDtcbiAgICAgICAgICAgIHNob3dWaWV3KCdlbXB0eScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IGVycm9yOiAnVW5rbm93biBlcnJvcicgfSkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyci5lcnJvciB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcyB8fCAhcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmb3JtYXQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJSZXBvcnQocmVzdWx0LmRhdGEsIGRhdGUpO1xuICAgICAgICBzaG93VmlldygncmVwb3J0Jyk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzdG9wTG9hZGluZ0FuaW1hdGlvbigpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWV3ZXJdIExvYWQgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgc2hvd0Vycm9yKCdcdUJEODhcdUI3RUNcdUM2MjRcdUFFMzAgXHVDMkU0XHVEMzI4JywgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxufVxuXG4vLyBDaGVjayBwZW5kaW5nIGNvdW50IGZvciBzeW5jIGJ1dHRvblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tQZW5kaW5nQ291bnQoZGF0ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgc2Vzc2lvbiB9ID0gYXdhaXQgZ2V0U2Vzc2lvbigpO1xuICAgICAgICBpZiAoIXNlc3Npb24pIHJldHVybjtcblxuICAgICAgICBjb25zdCB0aW1lem9uZSA9IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZSB8fCAnQXNpYS9TZW91bCc7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke1NVUEFCQVNFX1VSTH0vZnVuY3Rpb25zL3YxL3BlbmRpbmctY291bnQ/ZGF0ZT0ke2RhdGV9JnRpbWV6b25lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRpbWV6b25lKX1gO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Nlc3Npb24uYWNjZXNzX3Rva2VufWAsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tTeW5jXSBGYWlsZWQgdG8gY2hlY2sgcGVuZGluZyBjb3VudCcpO1xuICAgICAgICAgICAgdXBkYXRlU3luY1VJKDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHBlbmRpbmdDb3VudCA9IHJlc3VsdC5wZW5kaW5nX2NvdW50IHx8IDA7XG4gICAgICAgICAgICB1cGRhdGVTeW5jVUkocGVuZGluZ0NvdW50LCByZXN1bHQubm9ybWFsaXplZF9jb3VudCk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3luY10gQ2hlY2sgcGVuZGluZyBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICB1cGRhdGVTeW5jVUkoMCk7XG4gICAgfVxufVxuXG4vLyBVcGRhdGUgc3luYyBidXR0b24gVUlcbmZ1bmN0aW9uIHVwZGF0ZVN5bmNVSShwZW5kaW5nLCBub3JtYWxpemVkID0gMCkge1xuICAgIGlmICghc3luY0J0biB8fCAhc3luY1N0YXR1cykgcmV0dXJuO1xuXG4gICAgLy8gVXBkYXRlIGJ1dHRvbiBzdGF0ZSBiYXNlZCBvbiBwZW5kaW5nIGNvdW50IGFuZCBzeW5jaW5nIHN0YXR1c1xuICAgIGlmIChpc1N5bmNpbmcpIHtcbiAgICAgICAgc3luY0J0bi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHN5bmNCdG4uY2xhc3NMaXN0LmFkZCgnc3luY2luZycpO1xuICAgICAgICBzeW5jU3RhdHVzLnRleHRDb250ZW50ID0gJ1x1QjNEOVx1QUUzMFx1RDY1NCBcdUM5MTEuLi4nO1xuICAgICAgICBzeW5jQnRuLnRpdGxlID0gJ1x1QjNEOVx1QUUzMFx1RDY1NCBcdUM5QzRcdUQ1ODkgXHVDOTExLi4uJztcblxuICAgICAgICAvLyBTaG93IHByb2dyZXNzIGJhclxuICAgICAgICBpZiAoc3luY1Byb2dyZXNzKSB7XG4gICAgICAgICAgICBzeW5jUHJvZ3Jlc3MuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nID4gMCkge1xuICAgICAgICBzeW5jQnRuLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHN5bmNCdG4uY2xhc3NMaXN0LnJlbW92ZSgnc3luY2luZycpO1xuICAgICAgICBzeW5jU3RhdHVzLnRleHRDb250ZW50ID0gYCR7cGVuZGluZ31cdUFDMUMgXHVCMzAwXHVBRTMwYDtcbiAgICAgICAgc3luY0J0bi50aXRsZSA9IGAke3BlbmRpbmd9XHVBQzFDXHVDNzU4IFx1QkJGOFx1Q0M5OFx1QjlBQyBcdUIzNzBcdUM3NzRcdUQxMzBcdUFDMDAgXHVDNzg4XHVDMkI1XHVCMkM4XHVCMkU0LiBcdUQwNzRcdUI5QURcdUQ1NThcdUM1RUMgXHVCM0Q5XHVBRTMwXHVENjU0XHVENTU4XHVDMTM4XHVDNjk0LmA7XG5cbiAgICAgICAgLy8gSGlkZSBwcm9ncmVzcyBiYXIgd2hlbiBub3Qgc3luY2luZ1xuICAgICAgICBpZiAoc3luY1Byb2dyZXNzKSB7XG4gICAgICAgICAgICBzeW5jUHJvZ3Jlc3MuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IHByb2dyZXNzIGZpbGxcbiAgICAgICAgaWYgKHN5bmNQcm9ncmVzc0ZpbGwpIHtcbiAgICAgICAgICAgIHN5bmNQcm9ncmVzc0ZpbGwuc3R5bGUud2lkdGggPSAnMCUnO1xuICAgICAgICAgICAgc3luY1Byb2dyZXNzRmlsbC5jbGFzc0xpc3QucmVtb3ZlKCdjb21wbGV0ZScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gcGVuZGluZyBkYXRhIC0gZGlzYWJsZSBidXR0b25cbiAgICAgICAgc3luY0J0bi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHN5bmNCdG4uY2xhc3NMaXN0LnJlbW92ZSgnc3luY2luZycpO1xuICAgICAgICBzeW5jU3RhdHVzLnRleHRDb250ZW50ID0gJ1x1QjNEOVx1QUUzMFx1RDY1NCBcdUM2NDRcdUI4Q0MnO1xuICAgICAgICBzeW5jQnRuLnRpdGxlID0gJ1x1Q0M5OFx1QjlBQ1x1RDU2MCBcdUIzNzBcdUM3NzRcdUQxMzBcdUFDMDAgXHVDNUM2XHVDMkI1XHVCMkM4XHVCMkU0Lic7XG5cbiAgICAgICAgLy8gSGlkZSBwcm9ncmVzcyBiYXJcbiAgICAgICAgaWYgKHN5bmNQcm9ncmVzcykge1xuICAgICAgICAgICAgc3luY1Byb2dyZXNzLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gVXBkYXRlIHN5bmMgcHJvZ3Jlc3MgYmFyXG5mdW5jdGlvbiB1cGRhdGVTeW5jUHJvZ3Jlc3MocHJvY2Vzc2VkLCB0b3RhbCkge1xuICAgIGlmICghc3luY1Byb2dyZXNzRmlsbCB8fCB0b3RhbCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgY29uc3QgcGVyY2VudCA9IE1hdGgubWluKDEwMCwgTWF0aC5yb3VuZCgocHJvY2Vzc2VkIC8gdG90YWwpICogMTAwKSk7XG4gICAgc3luY1Byb2dyZXNzRmlsbC5zdHlsZS53aWR0aCA9IGAke3BlcmNlbnR9JWA7XG5cbiAgICBpZiAocGVyY2VudCA+PSAxMDApIHtcbiAgICAgICAgc3luY1Byb2dyZXNzRmlsbC5jbGFzc0xpc3QuYWRkKCdjb21wbGV0ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN5bmNQcm9ncmVzc0ZpbGwuY2xhc3NMaXN0LnJlbW92ZSgnY29tcGxldGUnKTtcbiAgICB9XG59XG5cbi8vIFN5bmMgZGF0YSAoY2FsbCBkYXRhLW5vcm1hbGl6ZSlcbmFzeW5jIGZ1bmN0aW9uIHN5bmNEYXRhKGRhdGUsIGlzSW5pdGlhbENhbGwgPSB0cnVlKSB7XG4gICAgaWYgKGlzU3luY2luZyAmJiBpc0luaXRpYWxDYWxsKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBJbml0aWFsaXplIG9uIGZpcnN0IGNhbGxcbiAgICAgICAgaWYgKGlzSW5pdGlhbENhbGwpIHtcbiAgICAgICAgICAgIGlzU3luY2luZyA9IHRydWU7XG4gICAgICAgICAgICBpbml0aWFsUGVuZGluZ0NvdW50ID0gcGVuZGluZ0NvdW50O1xuICAgICAgICAgICAgcHJvY2Vzc2VkQ291bnQgPSAwO1xuICAgICAgICAgICAgdXBkYXRlU3luY1VJKHBlbmRpbmdDb3VudCk7XG4gICAgICAgICAgICB1cGRhdGVTeW5jUHJvZ3Jlc3MoMCwgaW5pdGlhbFBlbmRpbmdDb3VudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHNlc3Npb24gfSA9IGF3YWl0IGdldFNlc3Npb24oKTtcbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBsb2cgaW4gZmlyc3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aW1lem9uZSA9IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZSB8fCAnQXNpYS9TZW91bCc7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke1NVUEFCQVNFX1VSTH0vZnVuY3Rpb25zL3YxL2RhdGEtbm9ybWFsaXplYDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Nlc3Npb24uYWNjZXNzX3Rva2VufWAsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgYmF0Y2hfc2l6ZTogMjAsIGRhdGUsIHRpbWV6b25lIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBlcnJvcjogJ1Vua25vd24gZXJyb3InIH0pKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIuZXJyb3IgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbU3luY10gUmVzdWx0OicsIHJlc3VsdCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHByb2dyZXNzXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUaGlzQmF0Y2ggPSByZXN1bHQubm9ybWFsaXplZCB8fCAwO1xuICAgICAgICBwcm9jZXNzZWRDb3VudCArPSBub3JtYWxpemVkVGhpc0JhdGNoO1xuICAgICAgICB1cGRhdGVTeW5jUHJvZ3Jlc3MocHJvY2Vzc2VkQ291bnQsIGluaXRpYWxQZW5kaW5nQ291bnQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgdGV4dCB3aXRoIHByb2dyZXNzXG4gICAgICAgIGlmIChzeW5jU3RhdHVzKSB7XG4gICAgICAgICAgICBzeW5jU3RhdHVzLnRleHRDb250ZW50ID0gYCR7cHJvY2Vzc2VkQ291bnR9LyR7aW5pdGlhbFBlbmRpbmdDb3VudH0gXHVDQzk4XHVCOUFDIFx1QzkxMS4uLmA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZS1jaGVjayBwZW5kaW5nIGNvdW50XG4gICAgICAgIGF3YWl0IGNoZWNrUGVuZGluZ0NvdW50KGRhdGUpO1xuXG4gICAgICAgIC8vIElmIG1vcmUgcGVuZGluZyBhbmQgd2UgYWN0dWFsbHkgcHJvY2Vzc2VkIHNvbWV0aGluZywgY29udGludWUgc3luY1xuICAgICAgICBpZiAocGVuZGluZ0NvdW50ID4gMCAmJiBub3JtYWxpemVkVGhpc0JhdGNoID4gMCkge1xuICAgICAgICAgICAgLy8gU21hbGwgZGVsYXkgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIHNlcnZlclxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICAgICAgYXdhaXQgc3luY0RhdGEoZGF0ZSwgZmFsc2UpOyAvLyBSZWN1cnNpdmUgY2FsbCB3aXRoIGlzSW5pdGlhbENhbGwgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU3luYyBjb21wbGV0ZVxuICAgICAgICAgICAgZmluaXNoU3luYygpO1xuICAgICAgICB9XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3luY10gRmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgaWYgKHN5bmNTdGF0dXMpIHtcbiAgICAgICAgICAgIHN5bmNTdGF0dXMudGV4dENvbnRlbnQgPSAnXHVCM0Q5XHVBRTMwXHVENjU0IFx1QzJFNFx1RDMyOCc7XG4gICAgICAgIH1cbiAgICAgICAgZmluaXNoU3luYyh0cnVlKTtcbiAgICB9XG59XG5cbi8vIEZpbmlzaCBzeW5jIGFuZCB1cGRhdGUgVUlcbmZ1bmN0aW9uIGZpbmlzaFN5bmMoaXNFcnJvciA9IGZhbHNlKSB7XG4gICAgaXNTeW5jaW5nID0gZmFsc2U7XG5cbiAgICBpZiAoIWlzRXJyb3IpIHtcbiAgICAgICAgLy8gU2hvdyAxMDAlIHByb2dyZXNzIGJyaWVmbHlcbiAgICAgICAgdXBkYXRlU3luY1Byb2dyZXNzKGluaXRpYWxQZW5kaW5nQ291bnQsIGluaXRpYWxQZW5kaW5nQ291bnQpO1xuXG4gICAgICAgIGlmIChzeW5jU3RhdHVzKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzc2VkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3luY1N0YXR1cy50ZXh0Q29udGVudCA9IGAke3Byb2Nlc3NlZENvdW50fVx1QUMxQyBcdUM2NDRcdUI4Q0MhYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3luY1N0YXR1cy50ZXh0Q29udGVudCA9ICdcdUNDOThcdUI5QUNcdUQ1NjAgXHVCMzcwXHVDNzc0XHVEMTMwIFx1QzVDNlx1Qzc0Qyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIaWRlIHByb2dyZXNzIGJhciBhZnRlciBkZWxheVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVN5bmNVSShwZW5kaW5nQ291bnQpO1xuICAgICAgICB9LCAyMDAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVTeW5jVUkocGVuZGluZ0NvdW50KTtcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUmVwb3J0KGRhdGUpIHtcbiAgICB0cnkge1xuICAgICAgICBnZW5lcmF0ZUJ0bi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGdlbmVyYXRlQnRuTWFpbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHNob3dWaWV3KCdsb2FkaW5nJyk7XG5cbiAgICAgICAgY29uc3QgeyBzZXNzaW9uIH0gPSBhd2FpdCBnZXRTZXNzaW9uKCk7XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgbG9nIGluIGZpcnN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZXpvbmUgPSBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmUgfHwgJ0FzaWEvU2VvdWwnO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHtTVVBBQkFTRV9VUkx9L2Z1bmN0aW9ucy92MS9nZW5lcmF0ZS1zY3J1bWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtzZXNzaW9uLmFjY2Vzc190b2tlbn1gLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRhcmdldF9kYXRlOiBkYXRlLCB0aW1lem9uZSB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZXJyb3I6ICdVbmtub3duIGVycm9yJyB9KSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyLmVycm9yIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yIHx8ICdHZW5lcmF0aW9uIGZhaWxlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IGxvYWRSZXBvcnQoZGF0ZSk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzdG9wTG9hZGluZ0FuaW1hdGlvbigpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWV3ZXJdIEdlbmVyYXRlIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgIHNob3dFcnJvcignXHVDMEREXHVDMTMxIFx1QzJFNFx1RDMyOCcsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIGdlbmVyYXRlQnRuLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIGdlbmVyYXRlQnRuTWFpbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2hvd0Vycm9yKHRpdGxlLCBtZXNzYWdlKSB7XG4gICAgZXJyb3JUaXRsZS50ZXh0Q29udGVudCA9IHRpdGxlO1xuICAgIGVycm9yTWVzc2FnZS50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgc2hvd1ZpZXcoJ2Vycm9yJyk7XG59XG5cbi8vIFJlbmRlcmluZ1xuZnVuY3Rpb24gcmVuZGVyUmVwb3J0KHJlcG9ydCwgZGF0ZSkge1xuICAgIHNjcnVtRGF0ZS50ZXh0Q29udGVudCA9IGZvcm1hdERhdGUoZGF0ZSk7XG4gICAgc2NydW1Db250ZW50LmlubmVySFRNTCA9ICcnO1xuXG4gICAgLy8gU3VwcG9ydCBib3RoIG5ldyBmb3JtYXQgKGZsYXQpIGFuZCBsZWdhY3kgZm9ybWF0IChuZXN0ZWQpXG4gICAgY29uc3Qgc3RydWN0dXJlZCA9IHJlcG9ydC5jb3JlX2FnZW5kYXMgPyByZXBvcnQgOiAgLy8gTmV3IGZvcm1hdDogY29yZV9hZ2VuZGFzIGF0IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0LnNvdXJjZV9jaXRhdGlvbnM/LnN0cnVjdHVyZWRfb3V0cHV0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgIChyZXBvcnQuY29nbml0aXZlX3JlYXNvbmluZz8uY29yZV9hZ2VuZGFzID8gcmVwb3J0LmNvZ25pdGl2ZV9yZWFzb25pbmcgOiBudWxsKTtcblxuICAgIGlmIChzdHJ1Y3R1cmVkICYmIHN0cnVjdHVyZWQuY29yZV9hZ2VuZGFzKSB7XG4gICAgICAgIHJlbmRlclN0cnVjdHVyZWRSZXBvcnQoc3RydWN0dXJlZCk7XG4gICAgfSBlbHNlIGlmIChyZXBvcnQuY29nbml0aXZlX3JlYXNvbmluZz8uY29udGVudCkge1xuICAgICAgICByZW5kZXJNYXJrZG93blJlcG9ydChyZXBvcnQuY29nbml0aXZlX3JlYXNvbmluZy5jb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKHJlcG9ydC5yYXdfc3VtbWFyeSB8fCByZXBvcnQuc3VtbWFyeSkge1xuICAgICAgICByZW5kZXJNYXJrZG93blJlcG9ydChyZXBvcnQucmF3X3N1bW1hcnkgfHwgcmVwb3J0LnN1bW1hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcnVtQ29udGVudC5pbm5lckhUTUwgPSAnPHAgY2xhc3M9XCJlbXB0eS1jb250ZW50XCI+XHVCMEI0XHVDNkE5XHVDNzc0IFx1QzVDNlx1QzJCNVx1QjJDOFx1QjJFNC48L3A+JztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN0cnVjdHVyZWRSZXBvcnQoc3RydWN0dXJlZCkge1xuICAgIGNvbnN0IGljb25zID0gWydcdUQ4M0RcdURDQ0InLCAnXHVEODNDXHVERkFGJywgJ1x1RDgzRFx1RENBMScsICdcdUQ4M0RcdURDQ0EnLCAnXHVEODNEXHVERDI3J107XG5cbiAgICBzdHJ1Y3R1cmVkLmNvcmVfYWdlbmRhcy5mb3JFYWNoKChhZ2VuZGEsIGkpID0+IHtcbiAgICAgICAgY29uc3QgaWNvbiA9IGljb25zW2kgJSBpY29ucy5sZW5ndGhdO1xuICAgICAgICBjb25zdCBhZ2VuZGFJZCA9IGBhZ2VuZGEtJHtpfWA7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHNlY3Rpb24gd2l0aCB0YXNrcyAobmV3IHR3by1jb2x1bW4gbGF5b3V0KVxuICAgICAgICBjb25zdCBzZWN0aW9uID0gY3JlYXRlU2VjdGlvbihhZ2VuZGEudGl0bGUsIGljb24sIGFnZW5kYS50YXNrcywgYWdlbmRhSWQsIGFnZW5kYS5jb2duaXRpdmVfZmxvdyk7XG5cbiAgICAgICAgc2NydW1Db250ZW50LmFwcGVuZENoaWxkKHNlY3Rpb24pO1xuXG4gICAgICAgIGlmIChpIDwgc3RydWN0dXJlZC5jb3JlX2FnZW5kYXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc2NydW1Db250ZW50LmFwcGVuZENoaWxkKGNyZWF0ZURpdmlkZXIoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFN1bW1hcnkgc2VjdGlvbiAobmV3IGZvcm1hdClcbiAgICBpZiAoc3RydWN0dXJlZC5zdW1tYXJ5KSB7XG4gICAgICAgIHNjcnVtQ29udGVudC5hcHBlbmRDaGlsZChjcmVhdGVEaXZpZGVyKCkpO1xuICAgICAgICBjb25zdCBzdW1tYXJ5U2VjdGlvbiA9IGNyZWF0ZVNlY3Rpb24oJ1x1QzY5NFx1QzU3RCcsICdcdUQ4M0RcdURDREQnLCBbc3RydWN0dXJlZC5zdW1tYXJ5XSk7XG4gICAgICAgIHNjcnVtQ29udGVudC5hcHBlbmRDaGlsZChzdW1tYXJ5U2VjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHN0cnVjdHVyZWQuc3RhbmRhbG9uZV90YXNrcyAmJiBzdHJ1Y3R1cmVkLnN0YW5kYWxvbmVfdGFza3MubGVuZ3RoID4gMCkge1xuICAgICAgICBzY3J1bUNvbnRlbnQuYXBwZW5kQ2hpbGQoY3JlYXRlRGl2aWRlcigpKTtcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IGNyZWF0ZVNlY3Rpb24oJ1x1QUUzMFx1RDBDMCBcdUQ2NUNcdUIzRDknLCAnXHVEODNEXHVEQ0REJyxcbiAgICAgICAgICAgIHN0cnVjdHVyZWQuc3RhbmRhbG9uZV90YXNrcy5tYXAodCA9PiB0LnRpdGxlICsgKHQuc3VtbWFyeSA/ICc6ICcgKyB0LnN1bW1hcnkgOiAnJykpXG4gICAgICAgICk7XG4gICAgICAgIHNjcnVtQ29udGVudC5hcHBlbmRDaGlsZChzZWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoc3RydWN0dXJlZC5kYXRhX2dhcHMgJiYgc3RydWN0dXJlZC5kYXRhX2dhcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBzY3J1bUNvbnRlbnQuYXBwZW5kQ2hpbGQoY3JlYXRlRGl2aWRlcigpKTtcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IGNyZWF0ZVNlY3Rpb24oJ1x1QjM3MFx1Qzc3NFx1RDEzMCBcdUIyMDRcdUI3N0QnLCAnXHUyNkEwXHVGRTBGJywgc3RydWN0dXJlZC5kYXRhX2dhcHMpO1xuICAgICAgICBzY3J1bUNvbnRlbnQuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHN0cnVjdHVyZWQudW5yZXNvbHZlZCAmJiBzdHJ1Y3R1cmVkLnVucmVzb2x2ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICBzY3J1bUNvbnRlbnQuYXBwZW5kQ2hpbGQoY3JlYXRlRGl2aWRlcigpKTtcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IGNyZWF0ZVNlY3Rpb24oJ1x1QkJGOFx1RDU3NFx1QUNCMCBcdUQ1NkRcdUJBQTknLCAnXHUyNzUzJywgc3RydWN0dXJlZC51bnJlc29sdmVkKTtcbiAgICAgICAgc2NydW1Db250ZW50LmFwcGVuZENoaWxkKHNlY3Rpb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTWFya2Rvd25SZXBvcnQoY29udGVudCkge1xuICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJykuZmlsdGVyKGwgPT4gbC50cmltKCkpO1xuICAgIGNvbnN0IHNlY3Rpb24gPSBjcmVhdGVTZWN0aW9uKCdSZXBvcnQnLCAnXHVEODNEXHVEQ0M0JywgbGluZXMpO1xuICAgIHNjcnVtQ29udGVudC5hcHBlbmRDaGlsZChzZWN0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VjdGlvbih0aXRsZSwgaWNvbiwgdGFza3MsIGFnZW5kYUlkID0gbnVsbCwgY29nbml0aXZlRmxvdyA9IG51bGwpIHtcbiAgICBjb25zdCBzZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2VjdGlvbi5jbGFzc05hbWUgPSAnc2NydW0tc2VjdGlvbic7XG5cbiAgICAvLyBDaGVjayBpZiBjb2duaXRpdmUgZmxvdyBpcyBhdmFpbGFibGVcbiAgICBjb25zdCBoYXNDb2duaXRpdmVGbG93ID0gY29nbml0aXZlRmxvdyAmJiBjb2duaXRpdmVGbG93LnBvaW50cyAmJiBjb2duaXRpdmVGbG93LnBvaW50cy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGlzRXhwYW5kZWQgPSBleHBhbmRlZEZsb3dzLmhhcyhhZ2VuZGFJZCk7XG5cbiAgICAvLyBCdWlsZCBoZWFkZXIgSFRNTCB3aXRoIG9wdGlvbmFsIENvZ25pdGl2ZSBGbG93IGJ1dHRvblxuICAgIGxldCBoZWFkZXJIdG1sID0gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1oZWFkZXJcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2VjdGlvbi1pY29uXCI+JHtpY29ufTwvc3Bhbj5cbiAgICAgICAgICAgIDxoMiBjbGFzcz1cInNlY3Rpb24tdGl0bGVcIj4ke2VzY2FwZUh0bWwodGl0bGUpfTwvaDI+XG4gICAgYDtcblxuICAgIC8vIEFkZCBDb2duaXRpdmUgRmxvdyBidXR0b24gaWYgYXZhaWxhYmxlXG4gICAgaWYgKGhhc0NvZ25pdGl2ZUZsb3cpIHtcbiAgICAgICAgaGVhZGVySHRtbCArPSBgXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiY29nbml0aXZlLWZsb3ctYnRuICR7aXNFeHBhbmRlZCA/ICdhY3RpdmUnIDogJyd9XCIgZGF0YS1hZ2VuZGEtaWQ9XCIke2FnZW5kYUlkfVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY2YtaWNvblwiPlx1RDgzRVx1RERFMDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNmLXRleHRcIj5Db2duaXRpdmUgRmxvdzwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICBgO1xuICAgIH1cblxuICAgIGhlYWRlckh0bWwgKz0gYDwvZGl2PmA7XG4gICAgc2VjdGlvbi5pbm5lckhUTUwgPSBoZWFkZXJIdG1sO1xuXG4gICAgLy8gQ3JlYXRlIG1haW4gY29udGVudCB3cmFwcGVyIChmb3Igc2lkZS1ieS1zaWRlIGxheW91dCB3aXRoIGNvZ25pdGl2ZSBmbG93KVxuICAgIGNvbnN0IGNvbnRlbnRXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGVudFdyYXBwZXIuY2xhc3NOYW1lID0gJ3NlY3Rpb24tY29udGVudC13cmFwcGVyJyArIChpc0V4cGFuZGVkID8gJyBleHBhbmRlZCcgOiAnJyk7XG4gICAgc2VjdGlvbi5hcHBlbmRDaGlsZChjb250ZW50V3JhcHBlcik7XG5cbiAgICAvLyBBZGQgdGFza3MgY29udGVudCAobGVmdCBzaWRlKVxuICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250ZW50LmNsYXNzTmFtZSA9ICdzZWN0aW9uLWNvbnRlbnQnO1xuICAgIGNvbnRlbnRXcmFwcGVyLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGFza3MgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyAobmV3IGZvcm1hdCkgb3Igc3RyaW5ncyAobGVnYWN5KVxuICAgIGNvbnN0IGlzTmV3Rm9ybWF0ID0gdGFza3MubGVuZ3RoID4gMCAmJiB0eXBlb2YgdGFza3NbMF0gPT09ICdvYmplY3QnICYmIHRhc2tzWzBdICE9PSBudWxsO1xuXG4gICAgaWYgKHRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBlbXB0eSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlbXB0eS5jbGFzc05hbWUgPSAnc2NydW0taXRlbSc7XG4gICAgICAgIGVtcHR5LnRleHRDb250ZW50ID0gJ1x1RDU2RFx1QkFBOSBcdUM1QzZcdUM3NEMnO1xuICAgICAgICBlbXB0eS5zdHlsZS5jb2xvciA9ICd2YXIoLS10ZXh0LXRlcnRpYXJ5KSc7XG4gICAgICAgIGVtcHR5LnN0eWxlLmZvbnRTdHlsZSA9ICdpdGFsaWMnO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVtcHR5KTtcbiAgICB9IGVsc2UgaWYgKGlzTmV3Rm9ybWF0KSB7XG4gICAgICAgIC8vIE5ldyBmb3JtYXQ6IHR3by1jb2x1bW4gbGF5b3V0IChmYWN0IHwgcmVhc29uaW5nKVxuICAgICAgICB0YXNrcy5mb3JFYWNoKCh0YXNrLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICByb3cuY2xhc3NOYW1lID0gJ3Rhc2stcm93JztcbiAgICAgICAgICAgIHJvdy5zdHlsZS5hbmltYXRpb25EZWxheSA9IChpbmRleCAqIDAuMDgpICsgJ3MnO1xuXG4gICAgICAgICAgICAvLyBGYWN0IGNvbHVtblxuICAgICAgICAgICAgY29uc3QgZmFjdERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZmFjdERpdi5jbGFzc05hbWUgPSAndGFzay1mYWN0JztcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydGFuY2UgPSB0YXNrLmltcG9ydGFuY2UgPT09ICdoaWdoJyA/ICdcdTJCNTAgJyA6ICcnO1xuICAgICAgICAgICAgZmFjdERpdi50ZXh0Q29udGVudCA9IGltcG9ydGFuY2UgKyAodGFzay5mYWN0IHx8IHRhc2sudGl0bGUgfHwgJycpO1xuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGZhY3REaXYpO1xuXG4gICAgICAgICAgICAvLyBSZWFzb25pbmcgY29sdW1uXG4gICAgICAgICAgICBjb25zdCByZWFzb25pbmdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHJlYXNvbmluZ0Rpdi5jbGFzc05hbWUgPSAndGFzay1yZWFzb25pbmcnO1xuICAgICAgICAgICAgcmVhc29uaW5nRGl2LnRleHRDb250ZW50ID0gdGFzay5yZWFzb25pbmcgfHwgdGFzay5zdW1tYXJ5Py5qb2luKCcsICcpIHx8ICcnO1xuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHJlYXNvbmluZ0Rpdik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTGVnYWN5IGZvcm1hdDogc2ltcGxlIGxpc3RcbiAgICAgICAgdGFza3MuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICdzY3J1bS1pdGVtJztcbiAgICAgICAgICAgIGRpdi50ZXh0Q29udGVudCA9IGl0ZW07XG4gICAgICAgICAgICBkaXYuc3R5bGUuYW5pbWF0aW9uRGVsYXkgPSAoaW5kZXggKiAwLjA4KSArICdzJztcbiAgICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIENvZ25pdGl2ZSBGbG93IHBhbmVsIGlmIGF2YWlsYWJsZSAocmlnaHQgc2lkZSlcbiAgICBpZiAoaGFzQ29nbml0aXZlRmxvdykge1xuICAgICAgICBjb25zdCBmbG93UGFuZWwgPSBjcmVhdGVDb2duaXRpdmVGbG93UGFuZWwoY29nbml0aXZlRmxvdywgYWdlbmRhSWQpO1xuICAgICAgICBjb250ZW50V3JhcHBlci5hcHBlbmRDaGlsZChmbG93UGFuZWwpO1xuXG4gICAgICAgIC8vIEFkZCBjbGljayBoYW5kbGVyIGZvciB0b2dnbGUgYnV0dG9uXG4gICAgICAgIGNvbnN0IGJ0biA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvcignLmNvZ25pdGl2ZS1mbG93LWJ0bicpO1xuICAgICAgICBpZiAoYnRuKSB7XG4gICAgICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlQ29nbml0aXZlRmxvdyhhZ2VuZGFJZCwgYnRuLCBmbG93UGFuZWwsIGNvbnRlbnRXcmFwcGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb247XG59XG5cbi8vIENyZWF0ZSBDb2duaXRpdmUgRmxvdyBwYW5lbFxuZnVuY3Rpb24gY3JlYXRlQ29nbml0aXZlRmxvd1BhbmVsKGZsb3csIGFnZW5kYUlkKSB7XG4gICAgY29uc3QgcGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwYW5lbC5jbGFzc05hbWUgPSAnY29nbml0aXZlLWZsb3ctcGFuZWwnO1xuICAgIHBhbmVsLmlkID0gYGNmLXBhbmVsLSR7YWdlbmRhSWR9YDtcblxuICAgIC8vIENoZWNrIGlmIHNob3VsZCBiZSBpbml0aWFsbHkgZXhwYW5kZWRcbiAgICBpZiAoZXhwYW5kZWRGbG93cy5oYXMoYWdlbmRhSWQpKSB7XG4gICAgICAgIHBhbmVsLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICB9XG5cbiAgICAvLyBGbG93IGRpYWdyYW06IGRvbWFpbjEgXHUyNTAwXHUyNTAwXHUyMTkyIGRvbWFpbjIgXHUyNTAwXHUyNTAwXHUyMTkyIGRvbWFpbjNcbiAgICBsZXQgZGlhZ3JhbUh0bWwgPSAnJztcbiAgICBpZiAoZmxvdy5mbG93X2RpYWdyYW0gJiYgZmxvdy5mbG93X2RpYWdyYW0ubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBmbG93QXJyb3dzID0gZmxvdy5mbG93X2RpYWdyYW0ubWFwKGRvbWFpbiA9PlxuICAgICAgICAgICAgYDxzcGFuIGNsYXNzPVwiZmxvdy1kb21haW5cIj4ke2VzY2FwZUh0bWwoZG9tYWluKX08L3NwYW4+YFxuICAgICAgICApLmpvaW4oJzxzcGFuIGNsYXNzPVwiZmxvdy1hcnJvd1wiPlx1MjE5Mjwvc3Bhbj4nKTtcbiAgICAgICAgZGlhZ3JhbUh0bWwgPSBgPGRpdiBjbGFzcz1cImZsb3ctZGlhZ3JhbVwiPiR7Zmxvd0Fycm93c308L2Rpdj5gO1xuICAgIH1cblxuICAgIC8vIFBvaW50cyBsaXN0XG4gICAgbGV0IHBvaW50c0h0bWwgPSAnJztcbiAgICBpZiAoZmxvdy5wb2ludHMgJiYgZmxvdy5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICBwb2ludHNIdG1sID0gZmxvdy5wb2ludHMubWFwKHBvaW50ID0+IHtcbiAgICAgICAgICAgIGxldCBwb2ludENvbnRlbnQgPSBgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZsb3ctcG9pbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBvaW50LW1haW5cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicG9pbnQtZG9tYWluXCI+WyR7ZXNjYXBlSHRtbChwb2ludC5kb21haW4pfV08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInBvaW50LXRob3VnaHRcIj4ke2VzY2FwZUh0bWwocG9pbnQudGhvdWdodF9wcm9jZXNzKX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgYDtcblxuICAgICAgICAgICAgaWYgKHBvaW50Lmluc2lnaHQpIHtcbiAgICAgICAgICAgICAgICBwb2ludENvbnRlbnQgKz0gYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicG9pbnQtaW5zaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnNpZ2h0LWljb25cIj5cdUQ4M0RcdURDQTE8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImluc2lnaHQtdGV4dFwiPiR7ZXNjYXBlSHRtbChwb2ludC5pbnNpZ2h0KX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvaW50Q29udGVudCArPSAnPC9kaXY+JztcbiAgICAgICAgICAgIHJldHVybiBwb2ludENvbnRlbnQ7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cblxuICAgIHBhbmVsLmlubmVySFRNTCA9IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImNmLWhlYWRlclwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjZi10aXRsZS1pY29uXCI+XHVEODNFXHVEREUwPC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjZi10aXRsZVwiPkNvZ25pdGl2ZSBGbG93PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgJHtkaWFncmFtSHRtbH1cbiAgICAgICAgPGRpdiBjbGFzcz1cImZsb3ctcG9pbnRzXCI+JHtwb2ludHNIdG1sfTwvZGl2PlxuICAgIGA7XG5cbiAgICByZXR1cm4gcGFuZWw7XG59XG5cbi8vIFRvZ2dsZSBDb2duaXRpdmUgRmxvdyBwYW5lbCAoc2lkZSBwYW5lbClcbmZ1bmN0aW9uIHRvZ2dsZUNvZ25pdGl2ZUZsb3coYWdlbmRhSWQsIGJ0biwgcGFuZWwsIGNvbnRlbnRXcmFwcGVyKSB7XG4gICAgY29uc3QgaXNFeHBhbmRlZCA9IGV4cGFuZGVkRmxvd3MuaGFzKGFnZW5kYUlkKTtcblxuICAgIGlmIChpc0V4cGFuZGVkKSB7XG4gICAgICAgIGV4cGFuZGVkRmxvd3MuZGVsZXRlKGFnZW5kYUlkKTtcbiAgICAgICAgcGFuZWwuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpO1xuICAgICAgICBidG4uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIGlmIChjb250ZW50V3JhcHBlcikgY29udGVudFdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnZXhwYW5kZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBleHBhbmRlZEZsb3dzLmFkZChhZ2VuZGFJZCk7XG4gICAgICAgIHBhbmVsLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgYnRuLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICBpZiAoY29udGVudFdyYXBwZXIpIGNvbnRlbnRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2V4cGFuZGVkJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEaXZpZGVyKCkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5jbGFzc05hbWUgPSAnZGl2aWRlcic7XG4gICAgcmV0dXJuIGRpdjtcbn1cblxuLy8gVXRpbGl0aWVzXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGVTdHIpIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0ciArICdUMDA6MDA6MDAnKTtcbiAgICByZXR1cm4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ2tvLUtSJywge1xuICAgICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgICAgIG1vbnRoOiAnbG9uZycsXG4gICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICB3ZWVrZGF5OiAnbG9uZydcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHRtbCh0ZXh0KSB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn0iXSwKICAibWFwcGluZ3MiOiAiO0FBMENPLFNBQVMsT0FBTyxHQUFHLEdBQUc7QUFDM0IsTUFBSSxJQUFJLENBQUM7QUFDVCxXQUFTLEtBQUssRUFBRyxLQUFJLE9BQU8sVUFBVSxlQUFlLEtBQUssR0FBRyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsSUFBSTtBQUM5RSxNQUFFLENBQUMsSUFBSSxFQUFFLENB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LElBQ3BDLE1BQU07QUFBQSxJQUNOLE9BQU87QUFBQSxJQUNQLEtBQUs7QUFBQSxJQUNMLFNBQVM7QUFBQSxFQUNiLENBQUM7QUFDTDtBQUVBLFNBQVMsV0FBVyxNQUFNO0FBQ3RCLFFBQU0sTUFBTSxTQUFTLGNBQWMsS0FBSztBQUN4QyxNQUFJLGNBQWM7QUFDbEIsU0FBTyxJQUFJO0FBQ2Y7IiwKICAibmFtZXMiOiBbIkZ1bmN0aW9uUmVnaW9uIiwgImNvdW50OiBudW1iZXIgfCBudWxsIiwgInJlcyIsICJ0aGlzIiwgImZldGNoIiwgImhlYWQiLCAiUG9zdGdyZXN0Q2xpZW50IiwgImdldCIsICJtZXRob2Q6ICdIRUFEJyB8ICdHRVQnIHwgJ1BPU1QnIiwgImJvZHk6IHVua25vd24gfCB1bmRlZmluZWQiLCAiZXJyb3JNZXNzYWdlIiwgIlNPQ0tFVF9TVEFURVMiLCAiQ0hBTk5FTF9TVEFURVMiLCAiQ0hBTk5FTF9FVkVOVFMiLCAiVFJBTlNQT1JUUyIsICJDT05ORUNUSU9OX1NUQVRFIiwgIlBvc3RncmVzVHlwZXMiLCAiUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyIsICJSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCIsICJSRUFMVElNRV9MSVNURU5fVFlQRVMiLCAiUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyIsICJwb3N0Z3Jlc19jaGFuZ2VzIiwgIl9hIiwgImVycm9yTWVzc2FnZSIsICJfYiIsICJ0eXBlIiwgIm5vb3AiLCAiZXJyb3JNZXNzYWdlIiwgIl9hIiwgIm5hbWVzcGFjZVRvUGF0aCIsICJyZXNvbHZlRmV0Y2giLCAicmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+IiwgInBhcmFtczogeyBbazogc3RyaW5nXTogYW55IH0iLCAiZmV0Y2giLCAidGhpcyIsICJkb3dubG9hZEZuOiAoKSA9PiBQcm9taXNlPFJlc3BvbnNlPiIsICJzaG91bGRUaHJvd09uRXJyb3I6IGJvb2xlYW4iLCAiREVGQVVMVF9GSUxFX09QVElPTlM6IEZpbGVPcHRpb25zIiwgImhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4iLCAiX3F1ZXJ5U3RyaW5nOiBzdHJpbmdbXSIsICJwYXJhbXM6IHN0cmluZ1tdIiwgInZlcnNpb24iLCAicGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IiwgInZlcnNpb24iLCAiREVGQVVMVF9IRUFERVJTIiwgInZlcnNpb24iLCAicmVzb2x2ZUZldGNoIiwgIl9nZXRFcnJvck1lc3NhZ2UiLCAiaGFuZGxlRXJyb3IiLCAiX2dldFJlcXVlc3RQYXJhbXMiLCAiX2hhbmRsZVJlcXVlc3QiLCAiZmV0Y2giLCAicmVzb2x2ZUZldGNoIiwgInZlcnNpb24iLCAiZmFjdG9yIiwgIkRFRkFVTFRfSEVBREVSUyIsICJyZXNvbHZlRmV0Y2giLCAidmVyc2lvbiIsICJyZXN1bHQiLCAiZXhwaXJlc0F0IiwgImVycm9yIiwgImRhdGEiLCAiX2EiLCAicGF5bG9hZCIsICJjdXJyZW50TGV2ZWwiLCAibmV4dExldmVsIiwgInZlcmlmaWVkRmFjdG9ycyIsICJjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzIiwgInZlcnNpb24iLCAiREVGQVVMVF9IRUFERVJTIiwgIkRFRkFVTFRfQVVUSF9PUFRJT05TOiBTdXBhYmFzZUF1dGhDbGllbnRPcHRpb25zIiwgIkRFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUzogUmVhbHRpbWVDbGllbnRPcHRpb25zIiwgInJlc29sdmVGZXRjaCIsICJmZXRjaCIsICJfb2JqZWN0U3ByZWFkMiIsICJERUZBVUxUX0RCX09QVElPTlMiLCAiREVGQVVMVF9BVVRIX09QVElPTlMiLCAiREVGQVVMVF9SRUFMVElNRV9PUFRJT05TIiwgIkRFRkFVTFRfR0xPQkFMX09QVElPTlMiLCAicmVzdWx0OiBSZXF1aXJlZDxTdXBhYmFzZUNsaWVudE9wdGlvbnM8U2NoZW1hTmFtZT4+IiwgInN1cGFiYXNlVXJsOiBzdHJpbmciLCAic3VwYWJhc2VLZXk6IHN0cmluZyIsICJTdXBhYmFzZVN0b3JhZ2VDbGllbnQiLCAidGhpcyJdCn0K
